/*!--------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
!(function () {
  try {
    var e =
        "undefined" != typeof window
          ? window
          : "undefined" != typeof global
            ? global
            : "undefined" != typeof self
              ? self
              : {},
      n = new e.Error().stack
    n &&
      ((e._sentryDebugIds = e._sentryDebugIds || {}),
      (e._sentryDebugIds[n] = "1d7f60fd-c040-547c-970e-c3471ba696a3"))
  } catch (e) {}
})()
var n7 = function (i, t) {
  return (
    (n7 =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (e, s) {
          e.__proto__ = s
        }) ||
      function (e, s) {
        for (var r in s)
          Object.prototype.hasOwnProperty.call(s, r) && (e[r] = s[r])
      }),
    n7(i, t)
  )
}
export function __extends(i, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError(
      "Class extends value " + String(t) + " is not a constructor or null",
    )
  n7(i, t)
  function e() {
    this.constructor = i
  }
  i.prototype =
    t === null ? Object.create(t) : ((e.prototype = t.prototype), new e())
}
export var __assign = function () {
  return (
    (__assign =
      Object.assign ||
      function (t) {
        for (var e, s = 1, r = arguments.length; s < r; s++) {
          e = arguments[s]
          for (var a in e)
            Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a])
        }
        return t
      }),
    __assign.apply(this, arguments)
  )
}
export function __rest(i, t) {
  var e = {}
  for (var s in i)
    Object.prototype.hasOwnProperty.call(i, s) &&
      t.indexOf(s) < 0 &&
      (e[s] = i[s])
  if (i != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, s = Object.getOwnPropertySymbols(i); r < s.length; r++)
      t.indexOf(s[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(i, s[r]) &&
        (e[s[r]] = i[s[r]])
  return e
}
export function __decorate(i, t, e, s) {
  var r = arguments.length,
    a =
      r < 3 ? t : s === null ? (s = Object.getOwnPropertyDescriptor(t, e)) : s,
    o
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    a = Reflect.decorate(i, t, e, s)
  else
    for (var c = i.length - 1; c >= 0; c--)
      (o = i[c]) && (a = (r < 3 ? o(a) : r > 3 ? o(t, e, a) : o(t, e)) || a)
  return r > 3 && a && Object.defineProperty(t, e, a), a
}
export function __param(i, t) {
  return function (e, s) {
    t(e, s, i)
  }
}
export function __esDecorate(i, t, e, s, r, a) {
  function o(E) {
    if (E !== void 0 && typeof E != "function")
      throw new TypeError("Function expected")
    return E
  }
  for (
    var c = s.kind,
      l = c === "getter" ? "get" : c === "setter" ? "set" : "value",
      u = !t && i ? (s.static ? i : i.prototype) : null,
      d = t || (u ? Object.getOwnPropertyDescriptor(u, s.name) : {}),
      m,
      f = !1,
      p = e.length - 1;
    p >= 0;
    p--
  ) {
    var v = {}
    for (var b in s) v[b] = b === "access" ? {} : s[b]
    for (var b in s.access) v.access[b] = s.access[b]
    v.addInitializer = function (E) {
      if (f)
        throw new TypeError(
          "Cannot add initializers after decoration has completed",
        )
      a.push(o(E || null))
    }
    var k = (0, e[p])(c === "accessor" ? { get: d.get, set: d.set } : d[l], v)
    if (c === "accessor") {
      if (k === void 0) continue
      if (k === null || typeof k != "object")
        throw new TypeError("Object expected")
      ;(m = o(k.get)) && (d.get = m),
        (m = o(k.set)) && (d.set = m),
        (m = o(k.init)) && r.unshift(m)
    } else (m = o(k)) && (c === "field" ? r.unshift(m) : (d[l] = m))
  }
  u && Object.defineProperty(u, s.name, d), (f = !0)
}
export function __runInitializers(i, t, e) {
  for (var s = arguments.length > 2, r = 0; r < t.length; r++)
    e = s ? t[r].call(i, e) : t[r].call(i)
  return s ? e : void 0
}
export function __propKey(i) {
  return typeof i == "symbol" ? i : "".concat(i)
}
export function __setFunctionName(i, t, e) {
  return (
    typeof t == "symbol" &&
      (t = t.description ? "[".concat(t.description, "]") : ""),
    Object.defineProperty(i, "name", {
      configurable: !0,
      value: e ? "".concat(e, " ", t) : t,
    })
  )
}
export function __metadata(i, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(i, t)
}
export function __awaiter(i, t, e, s) {
  function r(a) {
    return a instanceof e
      ? a
      : new e(function (o) {
          o(a)
        })
  }
  return new (e || (e = Promise))(function (a, o) {
    function c(d) {
      try {
        u(s.next(d))
      } catch (m) {
        o(m)
      }
    }
    function l(d) {
      try {
        u(s.throw(d))
      } catch (m) {
        o(m)
      }
    }
    function u(d) {
      d.done ? a(d.value) : r(d.value).then(c, l)
    }
    u((s = s.apply(i, t || [])).next())
  })
}
export function __generator(i, t) {
  var e = {
      label: 0,
      sent: function () {
        if (a[0] & 1) throw a[1]
        return a[1]
      },
      trys: [],
      ops: [],
    },
    s,
    r,
    a,
    o
  return (
    (o = { next: c(0), throw: c(1), return: c(2) }),
    typeof Symbol == "function" &&
      (o[Symbol.iterator] = function () {
        return this
      }),
    o
  )
  function c(u) {
    return function (d) {
      return l([u, d])
    }
  }
  function l(u) {
    if (s) throw new TypeError("Generator is already executing.")
    for (; o && ((o = 0), u[0] && (e = 0)), e; )
      try {
        if (
          ((s = 1),
          r &&
            (a =
              u[0] & 2
                ? r.return
                : u[0]
                  ? r.throw || ((a = r.return) && a.call(r), 0)
                  : r.next) &&
            !(a = a.call(r, u[1])).done)
        )
          return a
        switch (((r = 0), a && (u = [u[0] & 2, a.value]), u[0])) {
          case 0:
          case 1:
            a = u
            break
          case 4:
            return e.label++, { value: u[1], done: !1 }
          case 5:
            e.label++, (r = u[1]), (u = [0])
            continue
          case 7:
            ;(u = e.ops.pop()), e.trys.pop()
            continue
          default:
            if (
              ((a = e.trys),
              !(a = a.length > 0 && a[a.length - 1]) &&
                (u[0] === 6 || u[0] === 2))
            ) {
              e = 0
              continue
            }
            if (u[0] === 3 && (!a || (u[1] > a[0] && u[1] < a[3]))) {
              e.label = u[1]
              break
            }
            if (u[0] === 6 && e.label < a[1]) {
              ;(e.label = a[1]), (a = u)
              break
            }
            if (a && e.label < a[2]) {
              ;(e.label = a[2]), e.ops.push(u)
              break
            }
            a[2] && e.ops.pop(), e.trys.pop()
            continue
        }
        u = t.call(i, e)
      } catch (d) {
        ;(u = [6, d]), (r = 0)
      } finally {
        s = a = 0
      }
    if (u[0] & 5) throw u[1]
    return { value: u[0] ? u[1] : void 0, done: !0 }
  }
}
export var __createBinding = Object.create
  ? function (i, t, e, s) {
      s === void 0 && (s = e)
      var r = Object.getOwnPropertyDescriptor(t, e)
      ;(!r || ("get" in r ? !t.__esModule : r.writable || r.configurable)) &&
        (r = {
          enumerable: !0,
          get: function () {
            return t[e]
          },
        }),
        Object.defineProperty(i, s, r)
    }
  : function (i, t, e, s) {
      s === void 0 && (s = e), (i[s] = t[e])
    }
export function __exportStar(i, t) {
  for (var e in i)
    e !== "default" &&
      !Object.prototype.hasOwnProperty.call(t, e) &&
      __createBinding(t, i, e)
}
export function __values(i) {
  var t = typeof Symbol == "function" && Symbol.iterator,
    e = t && i[t],
    s = 0
  if (e) return e.call(i)
  if (i && typeof i.length == "number")
    return {
      next: function () {
        return (
          i && s >= i.length && (i = void 0), { value: i && i[s++], done: !i }
        )
      },
    }
  throw new TypeError(
    t ? "Object is not iterable." : "Symbol.iterator is not defined.",
  )
}
export function __read(i, t) {
  var e = typeof Symbol == "function" && i[Symbol.iterator]
  if (!e) return i
  var s = e.call(i),
    r,
    a = [],
    o
  try {
    for (; (t === void 0 || t-- > 0) && !(r = s.next()).done; ) a.push(r.value)
  } catch (c) {
    o = { error: c }
  } finally {
    try {
      r && !r.done && (e = s.return) && e.call(s)
    } finally {
      if (o) throw o.error
    }
  }
  return a
}
export function __spread() {
  for (var i = [], t = 0; t < arguments.length; t++)
    i = i.concat(__read(arguments[t]))
  return i
}
export function __spreadArrays() {
  for (var i = 0, t = 0, e = arguments.length; t < e; t++)
    i += arguments[t].length
  for (var s = Array(i), r = 0, t = 0; t < e; t++)
    for (var a = arguments[t], o = 0, c = a.length; o < c; o++, r++) s[r] = a[o]
  return s
}
export function __spreadArray(i, t, e) {
  if (e || arguments.length === 2)
    for (var s = 0, r = t.length, a; s < r; s++)
      (a || !(s in t)) &&
        (a || (a = Array.prototype.slice.call(t, 0, s)), (a[s] = t[s]))
  return i.concat(a || Array.prototype.slice.call(t))
}
export function __await(i) {
  return this instanceof __await ? ((this.v = i), this) : new __await(i)
}
export function __asyncGenerator(i, t, e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.")
  var s = e.apply(i, t || []),
    r,
    a = []
  return (
    (r = {}),
    c("next"),
    c("throw"),
    c("return", o),
    (r[Symbol.asyncIterator] = function () {
      return this
    }),
    r
  )
  function o(p) {
    return function (v) {
      return Promise.resolve(v).then(p, m)
    }
  }
  function c(p, v) {
    s[p] &&
      ((r[p] = function (b) {
        return new Promise(function (k, E) {
          a.push([p, b, k, E]) > 1 || l(p, b)
        })
      }),
      v && (r[p] = v(r[p])))
  }
  function l(p, v) {
    try {
      u(s[p](v))
    } catch (b) {
      f(a[0][3], b)
    }
  }
  function u(p) {
    p.value instanceof __await
      ? Promise.resolve(p.value.v).then(d, m)
      : f(a[0][2], p)
  }
  function d(p) {
    l("next", p)
  }
  function m(p) {
    l("throw", p)
  }
  function f(p, v) {
    p(v), a.shift(), a.length && l(a[0][0], a[0][1])
  }
}
export function __asyncDelegator(i) {
  var t, e
  return (
    (t = {}),
    s("next"),
    s("throw", function (r) {
      throw r
    }),
    s("return"),
    (t[Symbol.iterator] = function () {
      return this
    }),
    t
  )
  function s(r, a) {
    t[r] = i[r]
      ? function (o) {
          return (e = !e) ? { value: __await(i[r](o)), done: !1 } : a ? a(o) : o
        }
      : a
  }
}
export function __asyncValues(i) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.")
  var t = i[Symbol.asyncIterator],
    e
  return t
    ? t.call(i)
    : ((i = typeof __values == "function" ? __values(i) : i[Symbol.iterator]()),
      (e = {}),
      s("next"),
      s("throw"),
      s("return"),
      (e[Symbol.asyncIterator] = function () {
        return this
      }),
      e)
  function s(a) {
    e[a] =
      i[a] &&
      function (o) {
        return new Promise(function (c, l) {
          ;(o = i[a](o)), r(c, l, o.done, o.value)
        })
      }
  }
  function r(a, o, c, l) {
    Promise.resolve(l).then(function (u) {
      a({ value: u, done: c })
    }, o)
  }
}
export function __makeTemplateObject(i, t) {
  return (
    Object.defineProperty
      ? Object.defineProperty(i, "raw", { value: t })
      : (i.raw = t),
    i
  )
}
var cht = Object.create
  ? function (i, t) {
      Object.defineProperty(i, "default", { enumerable: !0, value: t })
    }
  : function (i, t) {
      i.default = t
    }
export function __importStar(i) {
  if (i && i.__esModule) return i
  var t = {}
  if (i != null)
    for (var e in i)
      e !== "default" &&
        Object.prototype.hasOwnProperty.call(i, e) &&
        __createBinding(t, i, e)
  return cht(t, i), t
}
export function __importDefault(i) {
  return i && i.__esModule ? i : { default: i }
}
export function __classPrivateFieldGet(i, t, e, s) {
  if (e === "a" && !s)
    throw new TypeError("Private accessor was defined without a getter")
  if (typeof t == "function" ? i !== t || !s : !t.has(i))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it",
    )
  return e === "m" ? s : e === "a" ? s.call(i) : s ? s.value : t.get(i)
}
export function __classPrivateFieldSet(i, t, e, s, r) {
  if (s === "m") throw new TypeError("Private method is not writable")
  if (s === "a" && !r)
    throw new TypeError("Private accessor was defined without a setter")
  if (typeof t == "function" ? i !== t || !r : !t.has(i))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it",
    )
  return s === "a" ? r.call(i, e) : r ? (r.value = e) : t.set(i, e), e
}
export function __classPrivateFieldIn(i, t) {
  if (t === null || (typeof t != "object" && typeof t != "function"))
    throw new TypeError("Cannot use 'in' operator on non-object")
  return typeof i == "function" ? t === i : i.has(t)
}
export function __addDisposableResource(i, t, e) {
  if (t != null) {
    if (typeof t != "object" && typeof t != "function")
      throw new TypeError("Object expected.")
    var s, r
    if (e) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.")
      s = t[Symbol.asyncDispose]
    }
    if (s === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.")
      ;(s = t[Symbol.dispose]), e && (r = s)
    }
    if (typeof s != "function") throw new TypeError("Object not disposable.")
    r &&
      (s = function () {
        try {
          r.call(this)
        } catch (a) {
          return Promise.reject(a)
        }
      }),
      i.stack.push({ value: t, dispose: s, async: e })
  } else e && i.stack.push({ async: !0 })
  return t
}
var lht =
  typeof SuppressedError == "function"
    ? SuppressedError
    : function (i, t, e) {
        var s = new Error(e)
        return (
          (s.name = "SuppressedError"), (s.error = i), (s.suppressed = t), s
        )
      }
export function __disposeResources(i) {
  function t(s) {
    ;(i.error = i.hasError
      ? new lht(s, i.error, "An error was suppressed during disposal.")
      : s),
      (i.hasError = !0)
  }
  function e() {
    for (; i.stack.length; ) {
      var s = i.stack.pop()
      try {
        var r = s.dispose && s.dispose.call(s.value)
        if (s.async)
          return Promise.resolve(r).then(e, function (a) {
            return t(a), e()
          })
      } catch (a) {
        t(a)
      }
    }
    if (i.hasError) throw i.error
  }
  return e()
}
export default {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
}
var uht = Object.create,
  a7 = Object.defineProperty,
  hht = Object.getOwnPropertyDescriptor,
  PV = Object.getOwnPropertyNames,
  dht = Object.getPrototypeOf,
  mht = Object.prototype.hasOwnProperty,
  fht = (i, t) =>
    function () {
      return t || (0, i[PV(i)[0]])((t = { exports: {} }).exports, t), t.exports
    },
  pht = (i, t) => {
    for (var e in t) a7(i, e, { get: t[e], enumerable: !0 })
  },
  ght = (i, t, e, s) => {
    if ((t && typeof t == "object") || typeof t == "function")
      for (let r of PV(t))
        !mht.call(i, r) &&
          r !== e &&
          a7(i, r, {
            get: () => t[r],
            enumerable: !(s = hht(t, r)) || s.enumerable,
          })
    return i
  },
  $V = (i, t, e) => (
    (e = i != null ? uht(dht(i)) : {}),
    ght(
      t || !i || !i.__esModule
        ? a7(e, "default", { value: i, enumerable: !0 })
        : e,
      i,
    )
  ),
  xV = fht({
    "node_modules/minimist/index.js"(i, t) {
      t.exports = function (a, o) {
        o || (o = {})
        var c = { bools: {}, strings: {}, unknownFn: null }
        typeof o.unknown == "function" && (c.unknownFn = o.unknown),
          typeof o.boolean == "boolean" && o.boolean
            ? (c.allBools = !0)
            : []
                .concat(o.boolean)
                .filter(Boolean)
                .forEach(function (M) {
                  c.bools[M] = !0
                })
        var l = {}
        Object.keys(o.alias || {}).forEach(function (M) {
          ;(l[M] = [].concat(o.alias[M])),
            l[M].forEach(function (rt) {
              l[rt] = [M].concat(
                l[M].filter(function (Jt) {
                  return rt !== Jt
                }),
              )
            })
        }),
          []
            .concat(o.string)
            .filter(Boolean)
            .forEach(function (M) {
              ;(c.strings[M] = !0), l[M] && (c.strings[l[M]] = !0)
            })
        var u = o.default || {},
          d = { _: [] }
        Object.keys(c.bools).forEach(function (M) {
          p(M, u[M] === void 0 ? !1 : u[M])
        })
        var m = []
        a.indexOf("--") !== -1 &&
          ((m = a.slice(a.indexOf("--") + 1)),
          (a = a.slice(0, a.indexOf("--"))))
        function f(M, rt) {
          return (
            (c.allBools && /^--[^=]+$/.test(rt)) ||
            c.strings[M] ||
            c.bools[M] ||
            l[M]
          )
        }
        function p(M, rt, Jt) {
          if (!(Jt && c.unknownFn && !f(M, Jt) && c.unknownFn(Jt) === !1)) {
            var ct = !c.strings[M] && s(rt) ? Number(rt) : rt
            v(d, M.split("."), ct),
              (l[M] || []).forEach(function (me) {
                v(d, me.split("."), ct)
              })
          }
        }
        function v(M, rt, Jt) {
          for (var ct = M, me = 0; me < rt.length - 1; me++) {
            var j = rt[me]
            if (r(ct, j)) return
            ct[j] === void 0 && (ct[j] = {}),
              (ct[j] === Object.prototype ||
                ct[j] === Number.prototype ||
                ct[j] === String.prototype) &&
                (ct[j] = {}),
              ct[j] === Array.prototype && (ct[j] = []),
              (ct = ct[j])
          }
          var j = rt[rt.length - 1]
          r(ct, j) ||
            ((ct === Object.prototype ||
              ct === Number.prototype ||
              ct === String.prototype) &&
              (ct = {}),
            ct === Array.prototype && (ct = []),
            ct[j] === void 0 || c.bools[j] || typeof ct[j] == "boolean"
              ? (ct[j] = Jt)
              : Array.isArray(ct[j])
                ? ct[j].push(Jt)
                : (ct[j] = [ct[j], Jt]))
        }
        function b(M) {
          return l[M].some(function (rt) {
            return c.bools[rt]
          })
        }
        for (var k = 0; k < a.length; k++) {
          var E = a[k]
          if (/^--.+=/.test(E)) {
            var P = E.match(/^--([^=]+)=([\s\S]*)$/),
              C = P[1],
              R = P[2]
            c.bools[C] && (R = R !== "false"), p(C, R, E)
          } else if (/^--no-.+/.test(E)) {
            var C = E.match(/^--no-(.+)/)[1]
            p(C, !1, E)
          } else if (/^--.+/.test(E)) {
            var C = E.match(/^--(.+)/)[1],
              D = a[k + 1]
            D !== void 0 &&
            !/^-/.test(D) &&
            !c.bools[C] &&
            !c.allBools &&
            (!l[C] || !b(C))
              ? (p(C, D, E), k++)
              : /^(true|false)$/.test(D)
                ? (p(C, D === "true", E), k++)
                : p(C, c.strings[C] ? "" : !0, E)
          } else if (/^-[^-]+/.test(E)) {
            for (
              var V = E.slice(1, -1).split(""), tt = !1, Z = 0;
              Z < V.length;
              Z++
            ) {
              var D = E.slice(Z + 2)
              if (D === "-") {
                p(V[Z], D, E)
                continue
              }
              if (/[A-Za-z]/.test(V[Z]) && /=/.test(D)) {
                p(V[Z], D.split("=")[1], E), (tt = !0)
                break
              }
              if (/[A-Za-z]/.test(V[Z]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(D)) {
                p(V[Z], D, E), (tt = !0)
                break
              }
              if (V[Z + 1] && V[Z + 1].match(/\W/)) {
                p(V[Z], E.slice(Z + 2), E), (tt = !0)
                break
              } else p(V[Z], c.strings[V[Z]] ? "" : !0, E)
            }
            var C = E.slice(-1)[0]
            !tt &&
              C !== "-" &&
              (a[k + 1] &&
              !/^(-|--)[^-]/.test(a[k + 1]) &&
              !c.bools[C] &&
              (!l[C] || !b(C))
                ? (p(C, a[k + 1], E), k++)
                : a[k + 1] && /^(true|false)$/.test(a[k + 1])
                  ? (p(C, a[k + 1] === "true", E), k++)
                  : p(C, c.strings[C] ? "" : !0, E))
          } else if (
            ((!c.unknownFn || c.unknownFn(E) !== !1) &&
              d._.push(c.strings._ || !s(E) ? E : Number(E)),
            o.stopEarly)
          ) {
            d._.push.apply(d._, a.slice(k + 1))
            break
          }
        }
        return (
          Object.keys(u).forEach(function (M) {
            e(d, M.split(".")) ||
              (v(d, M.split("."), u[M]),
              (l[M] || []).forEach(function (rt) {
                v(d, rt.split("."), u[M])
              }))
          }),
          o["--"]
            ? ((d["--"] = new Array()),
              m.forEach(function (M) {
                d["--"].push(M)
              }))
            : m.forEach(function (M) {
                d._.push(M)
              }),
          d
        )
      }
      function e(a, o) {
        var c = a
        o.slice(0, -1).forEach(function (u) {
          c = c[u] || {}
        })
        var l = o[o.length - 1]
        return l in c
      }
      function s(a) {
        return typeof a == "number" || /^0x[0-9a-f]+$/i.test(a)
          ? !0
          : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(a)
      }
      function r(a, o) {
        return (
          (o === "constructor" && typeof a[o] == "function") ||
          o === "__proto__"
        )
      }
    },
  })
import * as rc from "@sentry/node"
var vht =
  "https://80ec2259ebfad12d8aa2afe6eb4f6dd5@metrics.cursor.sh/4508016051945472"
function ds() {
  return globalThis._CURSOR_SENTRY
}
function wht() {
  return {
    send: function (t) {
      const e = ds().buffer
      return e.length < 64 && e.push(t), Promise.resolve({ statusCode: 200 })
    },
    flush: function (t) {
      return Promise.resolve(!0)
    },
  }
}
function yht() {
  return {
    send: function (i) {
      return ds().enabled
        ? ds().transport.send(i)
        : Promise.resolve({ statusCode: 200 })
    },
    flush: function (i) {
      return ds().transport.flush(i)
    },
  }
}
function bht() {
  return function (i) {
    return i.attributes?.["sentry.sample_rate"] === void 0 ? 0 : 1
  }
}
function Tht() {
  return {
    defaultIntegrations: [],
    dsn: vht,
    parentSpanIsAlwaysRootSpan: !0,
    tracesSampler: bht(),
    transport: yht,
  }
}
globalThis._CURSOR_SENTRY === void 0 &&
  (globalThis._CURSOR_SENTRY = {
    buffer: [],
    enabled: !0,
    loggerSampleRate: 1,
    sentry: void 0,
    tracesSampleRate: 0.01,
    transport: wht(),
  })
var NV
function o7(i, t) {
  const e = Object.create(null)
  for (const s of i) {
    const r = t(s)
    let a = e[r]
    a || (a = e[r] = []), a.push(s)
  }
  return e
}
function kht(i, t) {
  const e = [],
    s = []
  for (const r of i) t.has(r) || e.push(r)
  for (const r of t) i.has(r) || s.push(r)
  return { removed: e, added: s }
}
var ljt = class {
    static {
      NV = Symbol.toStringTag
    }
    constructor(i, t) {
      ;(this.b = t), (this.a = new Map()), (this[NV] = "SetWithKey")
      for (const e of i) this.add(e)
    }
    get size() {
      return this.a.size
    }
    add(i) {
      const t = this.b(i)
      return this.a.set(t, i), this
    }
    delete(i) {
      return this.a.delete(this.b(i))
    }
    has(i) {
      return this.a.has(this.b(i))
    }
    *entries() {
      for (const i of this.a.values()) yield [i, i]
    }
    keys() {
      return this.values()
    }
    *values() {
      for (const i of this.a.values()) yield i
    }
    clear() {
      this.a.clear()
    }
    forEach(i, t) {
      this.a.forEach((e) => i.call(t, e, e, this))
    }
    [Symbol.iterator]() {
      return this.values()
    }
  },
  Sht = class {
    constructor() {
      ;(this.b = []),
        (this.a = function (i) {
          setTimeout(() => {
            throw i.stack
              ? xs.isErrorNoTelemetry(i)
                ? new xs(
                    i.message +
                      `

` +
                      i.stack,
                  )
                : new Error(
                    i.message +
                      `

` +
                      i.stack,
                  )
              : i
          }, 0)
        })
    }
    addListener(i) {
      return (
        this.b.push(i),
        () => {
          this.d(i)
        }
      )
    }
    c(i) {
      this.b.forEach((t) => {
        t(i)
      })
    }
    d(i) {
      this.b.splice(this.b.indexOf(i), 1)
    }
    setUnexpectedErrorHandler(i) {
      this.a = i
    }
    getUnexpectedErrorHandler() {
      return this.a
    }
    onUnexpectedError(i) {
      this.a(i), this.c(i)
    }
    onUnexpectedExternalError(i) {
      this.a(i)
    }
  },
  l_ = new Sht()
function c7(i) {
  l_.setUnexpectedErrorHandler(i)
}
function Eht(i) {
  if (!i || typeof i != "object") return !1
  const t = i
  return t.code === "EPIPE" && t.syscall?.toUpperCase() === "WRITE"
}
function u_(i) {
  l_.onUnexpectedError(i)
}
function $e(i) {
  Ms(i) || l_.onUnexpectedError(i)
}
function l7(i) {
  Ms(i) || l_.onUnexpectedExternalError(i)
}
function xu(i) {
  if (i instanceof Error) {
    const { name: t, message: e } = i,
      s = i.stacktrace || i.stack
    return {
      $isError: !0,
      name: t,
      message: e,
      stack: s,
      noTelemetry: xs.isErrorNoTelemetry(i),
    }
  }
  return i
}
function Iht(i) {
  let t
  return (
    i.noTelemetry ? (t = new xs()) : ((t = new Error()), (t.name = i.name)),
    (t.message = i.message),
    (t.stack = i.stack),
    t
  )
}
var h_ = "Canceled"
function Ms(i) {
  return i instanceof bi
    ? !0
    : i instanceof Error && i.name === h_ && i.message === h_
}
var bi = class extends Error {
  constructor() {
    super(h_), (this.name = this.message)
  }
}
function Nu() {
  const i = new Error(h_)
  return (i.name = i.message), i
}
function Lt(i) {
  return i ? new Error(`Illegal argument: ${i}`) : new Error("Illegal argument")
}
function u7(i) {
  return i ? new Error(`Illegal state: ${i}`) : new Error("Illegal state")
}
var Ba = class extends TypeError {
  constructor(i) {
    super(
      i
        ? `${i} is read-only and cannot be changed`
        : "Cannot change read-only property",
    )
  }
}
function CV(i) {
  return i
    ? i.message
      ? i.message
      : i.stack
        ? i.stack.split(`
`)[0]
        : String(i)
    : "Error"
}
var Pht = class extends Error {
    constructor(i) {
      super("NotImplemented"), i && (this.message = i)
    }
  },
  h7 = class extends Error {
    constructor(i) {
      super("NotSupported"), i && (this.message = i)
    }
  },
  xs = class Zj extends Error {
    constructor(t) {
      super(t), (this.name = "CodeExpectedError")
    }
    static fromError(t) {
      if (t instanceof Zj) return t
      const e = new Zj()
      return (e.message = t.message), (e.stack = t.stack), e
    }
    static isErrorNoTelemetry(t) {
      return t.name === "CodeExpectedError"
    }
  },
  nc = class Plt extends Error {
    constructor(t) {
      super(t || "An unexpected bug occurred."),
        Object.setPrototypeOf(this, Plt.prototype)
    }
  }
function d_(i, t) {
  const e = this
  let s = !1,
    r
  return function () {
    if (s) return r
    if (((s = !0), t))
      try {
        r = i.apply(e, arguments)
      } finally {
        t()
      }
    else r = i.apply(e, arguments)
    return r
  }
}
function $ht(i, t) {
  const e = xht(i, t)
  if (e !== -1) return i[e]
}
function xht(i, t, e = i.length - 1) {
  for (let s = e; s >= 0; s--) {
    const r = i[s]
    if (t(r)) return s
  }
  return -1
}
function Nht(i, t, e = 0, s = i.length) {
  let r = e,
    a = s
  for (; r < a; ) {
    const o = Math.floor((r + a) / 2)
    t(i[o]) ? (r = o + 1) : (a = o)
  }
  return r - 1
}
function Cht(i, t, e = 0, s = i.length) {
  let r = e,
    a = s
  for (; r < a; ) {
    const o = Math.floor((r + a) / 2)
    t(i[o]) ? (a = o) : (r = o + 1)
  }
  return r
}
var ujt = class $lt {
  static {
    this.assertInvariants = !1
  }
  constructor(t) {
    ;(this.e = t), (this.c = 0)
  }
  findLastMonotonous(t) {
    if ($lt.assertInvariants) {
      if (this.d) {
        for (const s of this.e)
          if (this.d(s) && !t(s))
            throw new Error(
              "MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.",
            )
      }
      this.d = t
    }
    const e = Nht(this.e, t, this.c)
    return (this.c = e + 1), e === -1 ? void 0 : this.e[e]
  }
}
function Er(i, t, e = (s, r) => s === r) {
  if (i === t) return !0
  if (!i || !t || i.length !== t.length) return !1
  for (let s = 0, r = i.length; s < r; s++) if (!e(i[s], t[s])) return !1
  return !0
}
function Jht(i, t) {
  const e = []
  let s
  for (const r of i.slice(0).sort(t))
    !s || t(s[0], r) !== 0 ? ((s = [r]), e.push(s)) : s.push(r)
  return e
}
function JV(i, t, e) {
  const s = []
  function r(c, l, u) {
    if (l === 0 && u.length === 0) return
    const d = s[s.length - 1]
    d && d.start + d.deleteCount === c
      ? ((d.deleteCount += l), d.toInsert.push(...u))
      : s.push({ start: c, deleteCount: l, toInsert: u })
  }
  let a = 0,
    o = 0
  for (;;) {
    if (a === i.length) {
      r(a, 0, t.slice(o))
      break
    }
    if (o === t.length) {
      r(a, i.length - a, [])
      break
    }
    const c = i[a],
      l = t[o],
      u = e(c, l)
    u === 0
      ? ((a += 1), (o += 1))
      : u < 0
        ? (r(a, 1, []), (a += 1))
        : u > 0 && (r(a, 0, [l]), (o += 1))
  }
  return s
}
function Lht(i, t, e) {
  const s = JV(i, t, e),
    r = [],
    a = []
  for (const o of s)
    r.push(...i.slice(o.start, o.start + o.deleteCount)), a.push(...o.toInsert)
  return { removed: r, added: a }
}
function Rht(i, t, e, s, r) {
  return e === 0
    ? Promise.resolve([])
    : new Promise((a, o) => {
        ;(async () => {
          const c = i.length,
            l = i.slice(0, e).sort(t)
          for (
            let u = e, d = Math.min(e + s, c);
            u < c;
            u = d, d = Math.min(d + s, c)
          ) {
            if (
              (u > e && (await new Promise((m) => setTimeout(m))),
              r && r.isCancellationRequested)
            )
              throw new bi()
            Dht(i, t, l, u, d)
          }
          return l
        })().then(a, o)
      })
}
function Dht(i, t, e, s, r) {
  for (const a = e.length; s < r; s++) {
    const o = i[s]
    if (t(o, e[a - 1]) < 0) {
      e.pop()
      const c = Cht(e, (l) => t(o, l) < 0)
      e.splice(c, 0, o)
    }
  }
}
function Ue(i) {
  return i.filter((t) => !!t)
}
function Fht(i) {
  let t = 0
  for (let e = 0; e < i.length; e++) i[e] && ((i[t] = i[e]), (t += 1))
  i.length = t
}
function d7(i) {
  return !Array.isArray(i) || i.length === 0
}
function Cu(i) {
  return Array.isArray(i) && i.length > 0
}
function ac(i, t = (e) => e) {
  const e = new Set()
  return i.filter((s) => {
    const r = t(s)
    return e.has(r) ? !1 : (e.add(r), !0)
  })
}
function LV(i, t) {
  return i.push(t), () => Aht(i, t)
}
function Aht(i, t) {
  const e = i.indexOf(t)
  if (e > -1) return i.splice(e, 1), t
}
function RV(i, t) {
  let e
  if (typeof t == "number") {
    let s = t
    e = () => {
      const r = Math.sin(s++) * 179426549
      return r - Math.floor(r)
    }
  } else e = Math.random
  for (let s = i.length - 1; s > 0; s -= 1) {
    const r = Math.floor(e() * (s + 1)),
      a = i[s]
    ;(i[s] = i[r]), (i[r] = a)
  }
}
function m_(i, t) {
  return Array.isArray(i) ? i.map(t) : t(i)
}
function Ir(i) {
  return Array.isArray(i) ? i : [i]
}
var m7
;(function (i) {
  function t(a) {
    return a < 0
  }
  i.isLessThan = t
  function e(a) {
    return a <= 0
  }
  i.isLessThanOrEqual = e
  function s(a) {
    return a > 0
  }
  i.isGreaterThan = s
  function r(a) {
    return a === 0
  }
  ;(i.isNeitherLessOrGreaterThan = r),
    (i.greaterThan = 1),
    (i.lessThan = -1),
    (i.neitherLessOrGreaterThan = 0)
})(m7 || (m7 = {}))
function _ht(i, t) {
  return (e, s) => t(i(e), i(s))
}
var Oht = (i, t) => i - t,
  hjt = class B3 {
    static {
      this.empty = new B3((t) => {})
    }
    constructor(t) {
      this.iterate = t
    }
    forEach(t) {
      this.iterate((e) => (t(e), !0))
    }
    toArray() {
      const t = []
      return this.iterate((e) => (t.push(e), !0)), t
    }
    filter(t) {
      return new B3((e) => this.iterate((s) => (t(s) ? e(s) : !0)))
    }
    map(t) {
      return new B3((e) => this.iterate((s) => e(t(s))))
    }
    some(t) {
      let e = !1
      return this.iterate((s) => ((e = t(s)), !e)), e
    }
    findFirst(t) {
      let e
      return this.iterate((s) => (t(s) ? ((e = s), !1) : !0)), e
    }
    findLast(t) {
      let e
      return this.iterate((s) => (t(s) && (e = s), !0)), e
    }
    findLastMaxBy(t) {
      let e,
        s = !0
      return (
        this.iterate(
          (r) => ((s || m7.isGreaterThan(t(r, e))) && ((s = !1), (e = r)), !0),
        ),
        e
      )
    }
  },
  DV,
  FV,
  AV
function Bht(i, t, e) {
  let s = i.get(t)
  return s === void 0 && ((s = e), i.set(t, s)), s
}
var qht = class {
  constructor(i, t) {
    ;(this.uri = i), (this.value = t)
  }
}
function Uht(i) {
  return Array.isArray(i)
}
var oi = class Qf {
    static {
      this.c = (t) => t.toString()
    }
    constructor(t, e) {
      if (((this[DV] = "ResourceMap"), t instanceof Qf))
        (this.d = new Map(t.d)), (this.e = e ?? Qf.c)
      else if (Uht(t)) {
        ;(this.d = new Map()), (this.e = e ?? Qf.c)
        for (const [s, r] of t) this.set(s, r)
      } else (this.d = new Map()), (this.e = t ?? Qf.c)
    }
    set(t, e) {
      return this.d.set(this.e(t), new qht(t, e)), this
    }
    get(t) {
      return this.d.get(this.e(t))?.value
    }
    has(t) {
      return this.d.has(this.e(t))
    }
    get size() {
      return this.d.size
    }
    clear() {
      this.d.clear()
    }
    delete(t) {
      return this.d.delete(this.e(t))
    }
    forEach(t, e) {
      typeof e < "u" && (t = t.bind(e))
      for (const [s, r] of this.d) t(r.value, r.uri, this)
    }
    *values() {
      for (const t of this.d.values()) yield t.value
    }
    *keys() {
      for (const t of this.d.values()) yield t.uri
    }
    *entries() {
      for (const t of this.d.values()) yield [t.uri, t.value]
    }
    *[((DV = Symbol.toStringTag), Symbol.iterator)]() {
      for (const [, t] of this.d) yield [t.uri, t.value]
    }
  },
  _V = class {
    constructor(i, t) {
      ;(this[FV] = "ResourceSet"),
        !i || typeof i == "function"
          ? (this.c = new oi(i))
          : ((this.c = new oi(t)), i.forEach(this.add, this))
    }
    get size() {
      return this.c.size
    }
    add(i) {
      return this.c.set(i, i), this
    }
    clear() {
      this.c.clear()
    }
    delete(i) {
      return this.c.delete(i)
    }
    forEach(i, t) {
      this.c.forEach((e, s) => i.call(t, s, s, this))
    }
    has(i) {
      return this.c.has(i)
    }
    entries() {
      return this.c.entries()
    }
    keys() {
      return this.c.keys()
    }
    values() {
      return this.c.keys()
    }
    [((FV = Symbol.toStringTag), Symbol.iterator)]() {
      return this.keys()
    }
  },
  OV
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.AsOld = 1)] = "AsOld"),
    (i[(i.AsNew = 2)] = "AsNew")
})(OV || (OV = {}))
var Mht = class {
    constructor() {
      ;(this[AV] = "LinkedMap"),
        (this.c = new Map()),
        (this.d = void 0),
        (this.e = void 0),
        (this.f = 0),
        (this.g = 0)
    }
    clear() {
      this.c.clear(),
        (this.d = void 0),
        (this.e = void 0),
        (this.f = 0),
        this.g++
    }
    isEmpty() {
      return !this.d && !this.e
    }
    get size() {
      return this.f
    }
    get first() {
      return this.d?.value
    }
    get last() {
      return this.e?.value
    }
    has(i) {
      return this.c.has(i)
    }
    get(i, t = 0) {
      const e = this.c.get(i)
      if (e) return t !== 0 && this.m(e, t), e.value
    }
    set(i, t, e = 0) {
      let s = this.c.get(i)
      if (s) (s.value = t), e !== 0 && this.m(s, e)
      else {
        switch (
          ((s = { key: i, value: t, next: void 0, previous: void 0 }), e)
        ) {
          case 0:
            this.k(s)
            break
          case 1:
            this.j(s)
            break
          case 2:
            this.k(s)
            break
          default:
            this.k(s)
            break
        }
        this.c.set(i, s), this.f++
      }
      return this
    }
    delete(i) {
      return !!this.remove(i)
    }
    remove(i) {
      const t = this.c.get(i)
      if (t) return this.c.delete(i), this.l(t), this.f--, t.value
    }
    shift() {
      if (!this.d && !this.e) return
      if (!this.d || !this.e) throw new Error("Invalid list")
      const i = this.d
      return this.c.delete(i.key), this.l(i), this.f--, i.value
    }
    forEach(i, t) {
      const e = this.g
      let s = this.d
      for (; s; ) {
        if (
          (t ? i.bind(t)(s.value, s.key, this) : i(s.value, s.key, this),
          this.g !== e)
        )
          throw new Error("LinkedMap got modified during iteration.")
        s = s.next
      }
    }
    keys() {
      const i = this,
        t = this.g
      let e = this.d
      const s = {
        [Symbol.iterator]() {
          return s
        },
        next() {
          if (i.g !== t)
            throw new Error("LinkedMap got modified during iteration.")
          if (e) {
            const r = { value: e.key, done: !1 }
            return (e = e.next), r
          } else return { value: void 0, done: !0 }
        },
      }
      return s
    }
    values() {
      const i = this,
        t = this.g
      let e = this.d
      const s = {
        [Symbol.iterator]() {
          return s
        },
        next() {
          if (i.g !== t)
            throw new Error("LinkedMap got modified during iteration.")
          if (e) {
            const r = { value: e.value, done: !1 }
            return (e = e.next), r
          } else return { value: void 0, done: !0 }
        },
      }
      return s
    }
    entries() {
      const i = this,
        t = this.g
      let e = this.d
      const s = {
        [Symbol.iterator]() {
          return s
        },
        next() {
          if (i.g !== t)
            throw new Error("LinkedMap got modified during iteration.")
          if (e) {
            const r = { value: [e.key, e.value], done: !1 }
            return (e = e.next), r
          } else return { value: void 0, done: !0 }
        },
      }
      return s
    }
    [((AV = Symbol.toStringTag), Symbol.iterator)]() {
      return this.entries()
    }
    h(i) {
      if (i >= this.size) return
      if (i === 0) {
        this.clear()
        return
      }
      let t = this.d,
        e = this.size
      for (; t && e > i; ) this.c.delete(t.key), (t = t.next), e--
      ;(this.d = t), (this.f = e), t && (t.previous = void 0), this.g++
    }
    i(i) {
      if (i >= this.size) return
      if (i === 0) {
        this.clear()
        return
      }
      let t = this.e,
        e = this.size
      for (; t && e > i; ) this.c.delete(t.key), (t = t.previous), e--
      ;(this.e = t), (this.f = e), t && (t.next = void 0), this.g++
    }
    j(i) {
      if (!this.d && !this.e) this.e = i
      else if (this.d) (i.next = this.d), (this.d.previous = i)
      else throw new Error("Invalid list")
      ;(this.d = i), this.g++
    }
    k(i) {
      if (!this.d && !this.e) this.d = i
      else if (this.e) (i.previous = this.e), (this.e.next = i)
      else throw new Error("Invalid list")
      ;(this.e = i), this.g++
    }
    l(i) {
      if (i === this.d && i === this.e) (this.d = void 0), (this.e = void 0)
      else if (i === this.d) {
        if (!i.next) throw new Error("Invalid list")
        ;(i.next.previous = void 0), (this.d = i.next)
      } else if (i === this.e) {
        if (!i.previous) throw new Error("Invalid list")
        ;(i.previous.next = void 0), (this.e = i.previous)
      } else {
        const t = i.next,
          e = i.previous
        if (!t || !e) throw new Error("Invalid list")
        ;(t.previous = e), (e.next = t)
      }
      ;(i.next = void 0), (i.previous = void 0), this.g++
    }
    m(i, t) {
      if (!this.d || !this.e) throw new Error("Invalid list")
      if (!(t !== 1 && t !== 2)) {
        if (t === 1) {
          if (i === this.d) return
          const e = i.next,
            s = i.previous
          i === this.e
            ? ((s.next = void 0), (this.e = s))
            : ((e.previous = s), (s.next = e)),
            (i.previous = void 0),
            (i.next = this.d),
            (this.d.previous = i),
            (this.d = i),
            this.g++
        } else if (t === 2) {
          if (i === this.e) return
          const e = i.next,
            s = i.previous
          i === this.d
            ? ((e.previous = void 0), (this.d = e))
            : ((e.previous = s), (s.next = e)),
            (i.next = void 0),
            (i.previous = this.e),
            (this.e.next = i),
            (this.e = i),
            this.g++
        }
      }
    }
    toJSON() {
      const i = []
      return (
        this.forEach((t, e) => {
          i.push([e, t])
        }),
        i
      )
    }
    fromJSON(i) {
      this.clear()
      for (const [t, e] of i) this.set(t, e)
    }
  },
  Hht = class extends Mht {
    constructor(i, t = 1) {
      super(), (this.n = i), (this.o = Math.min(Math.max(0, t), 1))
    }
    get limit() {
      return this.n
    }
    set limit(i) {
      ;(this.n = i), this.p()
    }
    get ratio() {
      return this.o
    }
    set ratio(i) {
      ;(this.o = Math.min(Math.max(0, i), 1)), this.p()
    }
    get(i, t = 2) {
      return super.get(i, t)
    }
    peek(i) {
      return super.get(i, 0)
    }
    set(i, t) {
      return super.set(i, t, 2), this
    }
    p() {
      this.size > this.n && this.q(Math.round(this.n * this.o))
    }
  },
  Ju = class extends Hht {
    constructor(i, t = 1) {
      super(i, t)
    }
    q(i) {
      this.h(i)
    }
    set(i, t) {
      return super.set(i, t), this.p(), this
    }
  },
  BV = class {
    constructor() {
      this.c = new Map()
    }
    add(i, t) {
      let e = this.c.get(i)
      e || ((e = new Set()), this.c.set(i, e)), e.add(t)
    }
    delete(i, t) {
      const e = this.c.get(i)
      e && (e.delete(t), e.size === 0 && this.c.delete(i))
    }
    forEach(i, t) {
      const e = this.c.get(i)
      e && e.forEach(t)
    }
    get(i) {
      const t = this.c.get(i)
      return t || new Set()
    }
  },
  ms
;(function (i) {
  function t(R) {
    return R && typeof R == "object" && typeof R[Symbol.iterator] == "function"
  }
  i.is = t
  const e = Object.freeze([])
  function s() {
    return e
  }
  i.empty = s
  function* r(R) {
    yield R
  }
  i.single = r
  function a(R) {
    return t(R) ? R : r(R)
  }
  i.wrap = a
  function o(R) {
    return R || e
  }
  i.from = o
  function* c(R) {
    for (let D = R.length - 1; D >= 0; D--) yield R[D]
  }
  i.reverse = c
  function l(R) {
    return !R || R[Symbol.iterator]().next().done === !0
  }
  i.isEmpty = l
  function u(R) {
    return R[Symbol.iterator]().next().value
  }
  i.first = u
  function d(R, D) {
    let V = 0
    for (const tt of R) if (D(tt, V++)) return !0
    return !1
  }
  i.some = d
  function m(R, D) {
    for (const V of R) if (D(V)) return V
  }
  i.find = m
  function* f(R, D) {
    for (const V of R) D(V) && (yield V)
  }
  i.filter = f
  function* p(R, D) {
    let V = 0
    for (const tt of R) yield D(tt, V++)
  }
  i.map = p
  function* v(R, D) {
    let V = 0
    for (const tt of R) yield* D(tt, V++)
  }
  i.flatMap = v
  function* b(...R) {
    for (const D of R) yield* D
  }
  i.concat = b
  function k(R, D, V) {
    let tt = V
    for (const Z of R) tt = D(tt, Z)
    return tt
  }
  i.reduce = k
  function* E(R, D, V = R.length) {
    for (
      D < -R.length && (D = 0),
        D < 0 && (D += R.length),
        V < 0 ? (V += R.length) : V > R.length && (V = R.length);
      D < V;
      D++
    )
      yield R[D]
  }
  i.slice = E
  function P(R, D = Number.POSITIVE_INFINITY) {
    const V = []
    if (D === 0) return [V, R]
    const tt = R[Symbol.iterator]()
    for (let Z = 0; Z < D; Z++) {
      const M = tt.next()
      if (M.done) return [V, i.empty()]
      V.push(M.value)
    }
    return [
      V,
      {
        [Symbol.iterator]() {
          return tt
        },
      },
    ]
  }
  i.consume = P
  async function C(R) {
    const D = []
    for await (const V of R) D.push(V)
    return Promise.resolve(D)
  }
  i.asyncToArray = C
})(ms || (ms = {}))
var Wht = !1,
  oc = null,
  djt = class xlt {
    constructor() {
      this.b = new Map()
    }
    static {
      this.a = 0
    }
    c(t) {
      let e = this.b.get(t)
      return (
        e ||
          ((e = {
            parent: null,
            source: null,
            isSingleton: !1,
            value: t,
            idx: xlt.a++,
          }),
          this.b.set(t, e)),
        e
      )
    }
    trackDisposable(t) {
      const e = this.c(t)
      e.source || (e.source = new Error().stack)
    }
    setParent(t, e) {
      const s = this.c(t)
      s.parent = e
    }
    markAsDisposed(t) {
      this.b.delete(t)
    }
    markAsSingleton(t) {
      this.c(t).isSingleton = !0
    }
    f(t, e) {
      const s = e.get(t)
      if (s) return s
      const r = t.parent ? this.f(this.c(t.parent), e) : t
      return e.set(t, r), r
    }
    getTrackedDisposables() {
      const t = new Map()
      return [...this.b.entries()]
        .filter(([, s]) => s.source !== null && !this.f(s, t).isSingleton)
        .flatMap(([s]) => s)
    }
    computeLeakingDisposables(t = 10, e) {
      let s
      if (e) s = e
      else {
        const l = new Map(),
          u = [...this.b.values()].filter(
            (m) => m.source !== null && !this.f(m, l).isSingleton,
          )
        if (u.length === 0) return
        const d = new Set(u.map((m) => m.value))
        if (
          ((s = u.filter((m) => !(m.parent && d.has(m.parent)))),
          s.length === 0)
        )
          throw new Error("There are cyclic diposable chains!")
      }
      if (!s) return
      function r(l) {
        function u(m, f) {
          for (
            ;
            m.length > 0 &&
            f.some((p) => (typeof p == "string" ? p === m[0] : m[0].match(p)));

          )
            m.shift()
        }
        const d = l.source
          .split(
            `
`,
          )
          .map((m) => m.trim().replace("at ", ""))
          .filter((m) => m !== "")
        return (
          u(d, [
            "Error",
            /^trackDisposable \(.*\)$/,
            /^DisposableTracker.trackDisposable \(.*\)$/,
          ]),
          d.reverse()
        )
      }
      const a = new BV()
      for (const l of s) {
        const u = r(l)
        for (let d = 0; d <= u.length; d++)
          a.add(
            u.slice(0, d).join(`
`),
            l,
          )
      }
      s.sort(_ht((l) => l.idx, Oht))
      let o = "",
        c = 0
      for (const l of s.slice(0, t)) {
        c++
        const u = r(l),
          d = []
        for (let m = 0; m < u.length; m++) {
          let f = u[m]
          f = `(shared with ${
            a.get(
              u.slice(0, m + 1).join(`
`),
            ).size
          }/${s.length} leaks) at ${f}`
          const v = a.get(
              u.slice(0, m).join(`
`),
            ),
            b = o7(
              [...v].map((k) => r(k)[m]),
              (k) => k,
            )
          delete b[u[m]]
          for (const [k, E] of Object.entries(b))
            d.unshift(
              `    - stacktraces of ${E.length} other leaks continue with ${k}`,
            )
          d.unshift(f)
        }
        o += `


==================== Leaking disposable ${c}/${s.length}: ${l.value.constructor.name} ====================
${d.join(`
`)}
============================================================

`
      }
      return (
        s.length > t &&
          (o += `


... and ${s.length - t} more leaking disposables

`),
        { leaks: s, details: o }
      )
    }
  }
function jht(i) {
  oc = i
}
if (Wht) {
  const i = "__is_disposable_tracked__"
  jht(
    new (class {
      trackDisposable(t) {
        const e = new Error("Potentially leaked disposable").stack
        setTimeout(() => {
          t[i] || console.log(e)
        }, 3e3)
      }
      setParent(t, e) {
        if (t && t !== at.None)
          try {
            t[i] = !0
          } catch {}
      }
      markAsDisposed(t) {
        if (t && t !== at.None)
          try {
            t[i] = !0
          } catch {}
      }
      markAsSingleton(t) {}
    })(),
  )
}
function cc(i) {
  return oc?.trackDisposable(i), i
}
function lc(i) {
  oc?.markAsDisposed(i)
}
function Lu(i, t) {
  oc?.setParent(i, t)
}
function Vht(i, t) {
  if (oc) for (const e of i) oc.setParent(e, t)
}
function Ght(i) {
  return (
    typeof i == "object" &&
    i !== null &&
    typeof i.dispose == "function" &&
    i.dispose.length === 0
  )
}
function Hs(i) {
  if (ms.is(i)) {
    const t = []
    for (const e of i)
      if (e)
        try {
          e.dispose()
        } catch (s) {
          t.push(s)
        }
    if (t.length === 1) throw t[0]
    if (t.length > 1)
      throw new AggregateError(t, "Encountered errors while disposing of store")
    return Array.isArray(i) ? [] : i
  } else if (i) return i.dispose(), i
}
function qV(...i) {
  const t = et(() => Hs(i))
  return Vht(i, t), t
}
function et(i) {
  const t = cc({
    dispose: d_(() => {
      lc(t), i()
    }),
  })
  return t
}
var gt = class Nlt {
    static {
      this.DISABLE_DISPOSED_WARNING = !1
    }
    constructor() {
      ;(this.f = new Set()), (this.g = !1), cc(this)
    }
    dispose() {
      this.g || (lc(this), (this.g = !0), this.clear())
    }
    get isDisposed() {
      return this.g
    }
    clear() {
      if (this.f.size !== 0)
        try {
          Hs(this.f)
        } finally {
          this.f.clear()
        }
    }
    add(t) {
      if (!t) return t
      if (t === this) throw new Error("Cannot register a disposable on itself!")
      return (
        Lu(t, this),
        this.g
          ? Nlt.DISABLE_DISPOSED_WARNING ||
            console.warn(
              new Error(
                "Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!",
              ).stack,
            )
          : this.f.add(t),
        t
      )
    }
    delete(t) {
      if (t) {
        if (t === this)
          throw new Error("Cannot dispose a disposable on itself!")
        this.f.delete(t), t.dispose()
      }
    }
    deleteAndLeak(t) {
      t && this.f.has(t) && (this.f.delete(t), Lu(t, null))
    }
  },
  at = class {
    static {
      this.None = Object.freeze({ dispose() {} })
    }
    constructor() {
      ;(this.B = new gt()), cc(this), Lu(this.B, this)
    }
    dispose() {
      lc(this), this.B.dispose()
    }
    D(i) {
      if (i === this) throw new Error("Cannot register a disposable on itself!")
      return this.B.add(i)
    }
  },
  zr = class {
    constructor() {
      ;(this.b = !1), cc(this)
    }
    get value() {
      return this.b ? void 0 : this.a
    }
    set value(i) {
      this.b ||
        i === this.a ||
        (this.a?.dispose(), i && Lu(i, this), (this.a = i))
    }
    clear() {
      this.value = void 0
    }
    dispose() {
      ;(this.b = !0), lc(this), this.a?.dispose(), (this.a = void 0)
    }
    clearAndLeak() {
      const i = this.a
      return (this.a = void 0), i && Lu(i, null), i
    }
  },
  f_ = class {
    constructor() {
      ;(this.a = new Map()), (this.b = !1), cc(this)
    }
    dispose() {
      lc(this), (this.b = !0), this.clearAndDisposeAll()
    }
    clearAndDisposeAll() {
      if (this.a.size)
        try {
          Hs(this.a.values())
        } finally {
          this.a.clear()
        }
    }
    has(i) {
      return this.a.has(i)
    }
    get size() {
      return this.a.size
    }
    get(i) {
      return this.a.get(i)
    }
    set(i, t, e = !1) {
      this.b &&
        console.warn(
          new Error(
            "Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!",
          ).stack,
        ),
        e || this.a.get(i)?.dispose(),
        this.a.set(i, t)
    }
    deleteAndDispose(i) {
      this.a.get(i)?.dispose(), this.a.delete(i)
    }
    deleteAndLeak(i) {
      const t = this.a.get(i)
      return this.a.delete(i), t
    }
    keys() {
      return this.a.keys()
    }
    values() {
      return this.a.values()
    }
    [Symbol.iterator]() {
      return this.a[Symbol.iterator]()
    }
  },
  Me = class q3 {
    static {
      this.Undefined = new q3(void 0)
    }
    constructor(t) {
      ;(this.element = t),
        (this.next = q3.Undefined),
        (this.prev = q3.Undefined)
    }
  },
  Ru = class {
    constructor() {
      ;(this.a = Me.Undefined), (this.b = Me.Undefined), (this.c = 0)
    }
    get size() {
      return this.c
    }
    get first() {
      return this.a
    }
    isEmpty() {
      return this.a === Me.Undefined
    }
    clear() {
      let i = this.a
      for (; i !== Me.Undefined; ) {
        const t = i.next
        ;(i.prev = Me.Undefined), (i.next = Me.Undefined), (i = t)
      }
      ;(this.a = Me.Undefined), (this.b = Me.Undefined), (this.c = 0)
    }
    unshift(i) {
      return this.d(i, !1)
    }
    push(i) {
      return this.d(i, !0)
    }
    d(i, t) {
      const e = new Me(i)
      if (this.a === Me.Undefined) (this.a = e), (this.b = e)
      else if (t) {
        const r = this.b
        ;(this.b = e), (e.prev = r), (r.next = e)
      } else {
        const r = this.a
        ;(this.a = e), (e.next = r), (r.prev = e)
      }
      this.c += 1
      let s = !1
      return () => {
        s || ((s = !0), this.e(e))
      }
    }
    shift() {
      if (this.a !== Me.Undefined) {
        const i = this.a.element
        return this.e(this.a), i
      }
    }
    pop() {
      if (this.b !== Me.Undefined) {
        const i = this.b.element
        return this.e(this.b), i
      }
    }
    remove(i) {
      this.e(i)
    }
    e(i) {
      if (i.prev !== Me.Undefined && i.next !== Me.Undefined) {
        const t = i.prev
        ;(t.next = i.next), (i.next.prev = t)
      } else
        i.prev === Me.Undefined && i.next === Me.Undefined
          ? ((this.a = Me.Undefined), (this.b = Me.Undefined))
          : i.next === Me.Undefined
            ? ((this.b = this.b.prev), (this.b.next = Me.Undefined))
            : i.prev === Me.Undefined &&
              ((this.a = this.a.next), (this.a.prev = Me.Undefined))
      this.c -= 1
    }
    *[Symbol.iterator]() {
      let i = this.a
      for (; i !== Me.Undefined; ) yield i.element, (i = i.next)
    }
  },
  zht =
    globalThis.performance && typeof globalThis.performance.now == "function",
  ss = class Clt {
    static create(t) {
      return new Clt(t)
    }
    constructor(t) {
      ;(this.c =
        zht && t === !1
          ? Date.now
          : globalThis.performance.now.bind(globalThis.performance)),
        (this.a = this.c()),
        (this.b = -1)
    }
    stop() {
      this.b = this.c()
    }
    reset() {
      ;(this.a = this.c()), (this.b = -1)
    }
    elapsed() {
      return this.b !== -1 ? this.b - this.a : this.c() - this.a
    }
  },
  Yht = !1,
  UV = !1,
  Qht = !1,
  Qt
;(function (i) {
  i.None = () => at.None
  function t(j) {
    if (Qht) {
      const { onDidAddListener: z } = j,
        ot = f7.create()
      let it = 0
      j.onDidAddListener = () => {
        ++it === 2 &&
          (console.warn(
            "snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here",
          ),
          ot.print()),
          z?.()
      }
    }
  }
  function e(j, z) {
    return p(j, () => {}, 0, void 0, !0, void 0, z)
  }
  i.defer = e
  function s(j) {
    return (z, ot = null, it) => {
      let nt = !1,
        $t
      return (
        ($t = j(
          (Bt) => {
            if (!nt) return $t ? $t.dispose() : (nt = !0), z.call(ot, Bt)
          },
          null,
          it,
        )),
        nt && $t.dispose(),
        $t
      )
    }
  }
  i.once = s
  function r(j, z) {
    return i.once(i.filter(j, z))
  }
  i.onceIf = r
  function a(j, z, ot) {
    return m((it, nt = null, $t) => j((Bt) => it.call(nt, z(Bt)), null, $t), ot)
  }
  i.map = a
  function o(j, z, ot) {
    return m(
      (it, nt = null, $t) =>
        j(
          (Bt) => {
            z(Bt), it.call(nt, Bt)
          },
          null,
          $t,
        ),
      ot,
    )
  }
  i.forEach = o
  function c(j, z, ot) {
    return m(
      (it, nt = null, $t) => j((Bt) => z(Bt) && it.call(nt, Bt), null, $t),
      ot,
    )
  }
  i.filter = c
  function l(j) {
    return j
  }
  i.signal = l
  function u(...j) {
    return (z, ot = null, it) => {
      const nt = qV(...j.map(($t) => $t((Bt) => z.call(ot, Bt))))
      return f(nt, it)
    }
  }
  i.any = u
  function d(j, z, ot, it) {
    let nt = ot
    return a(j, ($t) => ((nt = z(nt, $t)), nt), it)
  }
  i.reduce = d
  function m(j, z) {
    let ot
    const it = {
      onWillAddFirstListener() {
        ot = j(nt.fire, nt)
      },
      onDidRemoveLastListener() {
        ot?.dispose()
      },
    }
    z || t(it)
    const nt = new J(it)
    return z?.add(nt), nt.event
  }
  function f(j, z) {
    return z instanceof Array ? z.push(j) : z && z.add(j), j
  }
  function p(j, z, ot = 100, it = !1, nt = !1, $t, Bt) {
    let xt,
      oe,
      mi,
      Ce = 0,
      wi
    const Ri = {
      leakWarningThreshold: $t,
      onWillAddFirstListener() {
        xt = j((Vr) => {
          Ce++,
            (oe = z(oe, Vr)),
            it && !mi && (ye.fire(oe), (oe = void 0)),
            (wi = () => {
              const ec = oe
              ;(oe = void 0),
                (mi = void 0),
                (!it || Ce > 1) && ye.fire(ec),
                (Ce = 0)
            }),
            typeof ot == "number"
              ? (clearTimeout(mi), (mi = setTimeout(wi, ot)))
              : mi === void 0 && ((mi = 0), queueMicrotask(wi))
        })
      },
      onWillRemoveListener() {
        nt && Ce > 0 && wi?.()
      },
      onDidRemoveLastListener() {
        ;(wi = void 0), xt.dispose()
      },
    }
    Bt || t(Ri)
    const ye = new J(Ri)
    return Bt?.add(ye), ye.event
  }
  i.debounce = p
  function v(j, z = 0, ot) {
    return i.debounce(
      j,
      (it, nt) => (it ? (it.push(nt), it) : [nt]),
      z,
      void 0,
      !0,
      void 0,
      ot,
    )
  }
  i.accumulate = v
  function b(j, z = (it, nt) => it === nt, ot) {
    let it = !0,
      nt
    return c(
      j,
      ($t) => {
        const Bt = it || !z($t, nt)
        return (it = !1), (nt = $t), Bt
      },
      ot,
    )
  }
  i.latch = b
  function k(j, z, ot) {
    return [i.filter(j, z, ot), i.filter(j, (it) => !z(it), ot)]
  }
  i.split = k
  function E(j, z = !1, ot = [], it) {
    let nt = ot.slice(),
      $t = j((oe) => {
        nt ? nt.push(oe) : xt.fire(oe)
      })
    it && it.add($t)
    const Bt = () => {
        nt?.forEach((oe) => xt.fire(oe)), (nt = null)
      },
      xt = new J({
        onWillAddFirstListener() {
          $t || (($t = j((oe) => xt.fire(oe))), it && it.add($t))
        },
        onDidAddFirstListener() {
          nt && (z ? setTimeout(Bt) : Bt())
        },
        onDidRemoveLastListener() {
          $t && $t.dispose(), ($t = null)
        },
      })
    return it && it.add(xt), xt.event
  }
  i.buffer = E
  function P(j, z) {
    return (it, nt, $t) => {
      const Bt = z(new R())
      return j(
        function (xt) {
          const oe = Bt.evaluate(xt)
          oe !== C && it.call(nt, oe)
        },
        void 0,
        $t,
      )
    }
  }
  i.chain = P
  const C = Symbol("HaltChainable")
  class R {
    constructor() {
      this.f = []
    }
    map(z) {
      return this.f.push(z), this
    }
    forEach(z) {
      return this.f.push((ot) => (z(ot), ot)), this
    }
    filter(z) {
      return this.f.push((ot) => (z(ot) ? ot : C)), this
    }
    reduce(z, ot) {
      let it = ot
      return this.f.push((nt) => ((it = z(it, nt)), it)), this
    }
    latch(z = (ot, it) => ot === it) {
      let ot = !0,
        it
      return (
        this.f.push((nt) => {
          const $t = ot || !z(nt, it)
          return (ot = !1), (it = nt), $t ? nt : C
        }),
        this
      )
    }
    evaluate(z) {
      for (const ot of this.f) if (((z = ot(z)), z === C)) break
      return z
    }
  }
  function D(j, z, ot = (it) => it) {
    const it = (...xt) => Bt.fire(ot(...xt)),
      nt = () => j.on(z, it),
      $t = () => j.removeListener(z, it),
      Bt = new J({ onWillAddFirstListener: nt, onDidRemoveLastListener: $t })
    return Bt.event
  }
  i.fromNodeEventEmitter = D
  function V(j, z, ot = (it) => it) {
    const it = (...xt) => Bt.fire(ot(...xt)),
      nt = () => j.addEventListener(z, it),
      $t = () => j.removeEventListener(z, it),
      Bt = new J({ onWillAddFirstListener: nt, onDidRemoveLastListener: $t })
    return Bt.event
  }
  i.fromDOMEventEmitter = V
  function tt(j) {
    return new Promise((z) => s(j)(z))
  }
  i.toPromise = tt
  function Z(j) {
    const z = new J()
    return (
      j
        .then(
          (ot) => {
            z.fire(ot)
          },
          () => {
            z.fire(void 0)
          },
        )
        .finally(() => {
          z.dispose()
        }),
      z.event
    )
  }
  i.fromPromise = Z
  function M(j, z) {
    return j((ot) => z.fire(ot))
  }
  i.forward = M
  function rt(j, z, ot) {
    return z(ot), j((it) => z(it))
  }
  i.runAndSubscribe = rt
  class Jt {
    constructor(z, ot) {
      ;(this._observable = z), (this.f = 0), (this.g = !1)
      const it = {
        onWillAddFirstListener: () => {
          z.addObserver(this), this._observable.reportChanges()
        },
        onDidRemoveLastListener: () => {
          z.removeObserver(this)
        },
      }
      ot || t(it), (this.emitter = new J(it)), ot && ot.add(this.emitter)
    }
    beginUpdate(z) {
      this.f++
    }
    handlePossibleChange(z) {}
    handleChange(z, ot) {
      this.g = !0
    }
    endUpdate(z) {
      this.f--,
        this.f === 0 &&
          (this._observable.reportChanges(),
          this.g && ((this.g = !1), this.emitter.fire(this._observable.get())))
    }
  }
  function ct(j, z) {
    return new Jt(j, z).emitter.event
  }
  i.fromObservable = ct
  function me(j) {
    return (z, ot, it) => {
      let nt = 0,
        $t = !1
      const Bt = {
        beginUpdate() {
          nt++
        },
        endUpdate() {
          nt--, nt === 0 && (j.reportChanges(), $t && (($t = !1), z.call(ot)))
        },
        handlePossibleChange() {},
        handleChange() {
          $t = !0
        },
      }
      j.addObserver(Bt), j.reportChanges()
      const xt = {
        dispose() {
          j.removeObserver(Bt)
        },
      }
      return (
        it instanceof gt ? it.add(xt) : Array.isArray(it) && it.push(xt), xt
      )
    }
  }
  i.fromObservableLight = me
})(Qt || (Qt = {}))
var Xht = class tV {
    static {
      this.all = new Set()
    }
    static {
      this.f = 0
    }
    constructor(t) {
      ;(this.listenerCount = 0),
        (this.invocationCount = 0),
        (this.elapsedOverall = 0),
        (this.durations = []),
        (this.name = `${t}_${tV.f++}`),
        tV.all.add(this)
    }
    start(t) {
      ;(this.g = new ss()), (this.listenerCount = t)
    }
    stop() {
      if (this.g) {
        const t = this.g.elapsed()
        this.durations.push(t),
          (this.elapsedOverall += t),
          (this.invocationCount += 1),
          (this.g = void 0)
      }
    }
  },
  MV = -1,
  Kht = class Jlt {
    static {
      this.f = 1
    }
    constructor(t, e, s = (Jlt.f++).toString(16).padStart(3, "0")) {
      ;(this.j = t), (this.threshold = e), (this.name = s), (this.h = 0)
    }
    dispose() {
      this.g?.clear()
    }
    check(t, e) {
      const s = this.threshold
      if (s <= 0 || e < s) return
      this.g || (this.g = new Map())
      const r = this.g.get(t.value) || 0
      if ((this.g.set(t.value, r + 1), (this.h -= 1), this.h <= 0)) {
        this.h = s * 0.5
        const [a, o] = this.getMostFrequentStack(),
          c = `[${this.name}] potential listener LEAK detected, having ${e} listeners already. MOST frequent listener (${o}):`
        console.warn(c), console.warn(a)
        const l = new Zht(c, a)
        this.j(l)
      }
      return () => {
        const a = this.g.get(t.value) || 0
        this.g.set(t.value, a - 1)
      }
    }
    getMostFrequentStack() {
      if (!this.g) return
      let t,
        e = 0
      for (const [s, r] of this.g) (!t || e < r) && ((t = [s, r]), (e = r))
      return t
    }
  },
  f7 = class Llt {
    static create() {
      const t = new Error()
      return new Llt(t.stack ?? "")
    }
    constructor(t) {
      this.value = t
    }
    print() {
      console.warn(
        this.value
          .split(
            `
`,
          )
          .slice(2).join(`
`),
      )
    }
  },
  Zht = class extends Error {
    constructor(i, t) {
      super(i), (this.name = "ListenerLeakError"), (this.stack = t)
    }
  },
  tdt = class extends Error {
    constructor(i, t) {
      super(i), (this.name = "ListenerRefusalError"), (this.stack = t)
    }
  },
  edt = 0,
  p_ = class {
    constructor(i) {
      ;(this.value = i), (this.id = edt++)
    }
  },
  idt = 2,
  HV = (i, t) => {
    if (i instanceof p_) t(i)
    else
      for (let e = 0; e < i.length; e++) {
        const s = i[e]
        s && t(s)
      }
  },
  g_
if (Yht) {
  const i = []
  setInterval(() => {
    i.length !== 0 &&
      (console.warn(
        "[LEAKING LISTENERS] GC'ed these listeners that were NOT yet disposed:",
      ),
      console.warn(
        i.join(`
`),
      ),
      (i.length = 0))
  }, 3e3),
    (g_ = new FinalizationRegistry((t) => {
      typeof t == "string" && i.push(t)
    }))
}
var J = class {
    constructor(i) {
      ;(this.z = 0),
        (this.f = i),
        (this.g =
          MV > 0 || this.f?.leakWarningThreshold
            ? new Kht(
                i?.onListenerError ?? $e,
                this.f?.leakWarningThreshold ?? MV,
              )
            : void 0),
        (this.j = this.f?._profName ? new Xht(this.f._profName) : void 0),
        (this.w = this.f?.deliveryQueue)
    }
    dispose() {
      if (!this.m) {
        if (
          ((this.m = !0), this.w?.current === this && this.w.reset(), this.u)
        ) {
          if (UV) {
            const i = this.u
            queueMicrotask(() => {
              HV(i, (t) => t.stack?.print())
            })
          }
          ;(this.u = void 0), (this.z = 0)
        }
        this.f?.onDidRemoveLastListener?.(), this.g?.dispose()
      }
    }
    get event() {
      return (
        (this.q ??= (i, t, e) => {
          if (this.g && this.z > this.g.threshold ** 2) {
            const c = `[${this.g.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this.z} vs ${this.g.threshold})`
            console.warn(c)
            const l = this.g.getMostFrequentStack() ?? ["UNKNOWN stack", -1],
              u = new tdt(
                `${c}. HINT: Stack shows most frequent listener (${l[1]}-times)`,
                l[0],
              )
            return (this.f?.onListenerError || $e)(u), at.None
          }
          if (this.m) return at.None
          t && (i = i.bind(t))
          const s = new p_(i)
          let r, a
          this.g &&
            this.z >= Math.ceil(this.g.threshold * 0.2) &&
            ((s.stack = f7.create()), (r = this.g.check(s.stack, this.z + 1))),
            UV && (s.stack = a ?? f7.create()),
            this.u
              ? this.u instanceof p_
                ? ((this.w ??= new sdt()), (this.u = [this.u, s]))
                : this.u.push(s)
              : (this.f?.onWillAddFirstListener?.(this),
                (this.u = s),
                this.f?.onDidAddFirstListener?.(this)),
            this.f?.onDidAddListener?.(this),
            this.z++
          const o = et(() => {
            g_?.unregister(o), r?.(), this.A(s)
          })
          if (
            (e instanceof gt ? e.add(o) : Array.isArray(e) && e.push(o), g_)
          ) {
            const c = new Error().stack
                .split(
                  `
`,
                )
                .slice(2, 3)
                .join(
                  `
`,
                )
                .trim(),
              l = /(file:|vscode-file:\/\/vscode-app)?(\/[^:]*:\d+:\d+)/.exec(c)
            g_.register(o, l?.[2] ?? c, o)
          }
          return o
        }),
        this.q
      )
    }
    A(i) {
      if ((this.f?.onWillRemoveListener?.(this), !this.u)) return
      if (this.z === 1) {
        ;(this.u = void 0),
          this.f?.onDidRemoveLastListener?.(this),
          (this.z = 0)
        return
      }
      const t = this.u,
        e = t.indexOf(i)
      if (e === -1)
        throw (
          (console.log("disposed?", this.m),
          console.log("size?", this.z),
          console.log("arr?", JSON.stringify(this.u)),
          new Error("Attempted to dispose unknown listener"))
        )
      this.z--, (t[e] = void 0)
      const s = this.w.current === this
      if (this.z * idt <= t.length) {
        let r = 0
        for (let a = 0; a < t.length; a++)
          t[a]
            ? (t[r++] = t[a])
            : s && r < this.w.end && (this.w.end--, r < this.w.i && this.w.i--)
        t.length = r
      }
    }
    B(i, t) {
      if (!i) return
      const e = this.f?.onListenerError || $e
      if (!e) {
        i.value(t)
        return
      }
      try {
        i.value(t)
      } catch (s) {
        e(s)
      }
    }
    C(i) {
      const t = i.current.u
      for (; i.i < i.end; ) this.B(t[i.i++], i.value)
      i.reset()
    }
    fire(i) {
      if (
        (this.w?.current && (this.C(this.w), this.j?.stop()),
        this.j?.start(this.z),
        this.u)
      )
        if (this.u instanceof p_) this.B(this.u, i)
        else {
          const t = this.w
          t.enqueue(this, i, this.u.length), this.C(t)
        }
      this.j?.stop()
    }
    hasListeners() {
      return this.z > 0
    }
  },
  sdt = class {
    constructor() {
      ;(this.i = -1), (this.end = 0)
    }
    enqueue(i, t, e) {
      ;(this.i = 0), (this.end = e), (this.current = i), (this.value = t)
    }
    reset() {
      ;(this.i = this.end), (this.current = void 0), (this.value = void 0)
    }
  },
  Du = class extends J {
    async fireAsync(i, t, e) {
      if (this.u)
        for (
          this.h || (this.h = new Ru()),
            HV(this.u, (s) => this.h.push([s.value, i]));
          this.h.size > 0 && !t.isCancellationRequested;

        ) {
          const [s, r] = this.h.shift(),
            a = [],
            o = {
              ...r,
              token: t,
              waitUntil: (c) => {
                if (Object.isFrozen(a))
                  throw new Error("waitUntil can NOT be called asynchronous")
                e && (c = e(c, s)), a.push(c)
              },
            }
          try {
            s(o)
          } catch (c) {
            $e(c)
            continue
          }
          Object.freeze(a),
            await Promise.allSettled(a).then((c) => {
              for (const l of c) l.status === "rejected" && $e(l.reason)
            })
        }
    }
  },
  Fu = class extends J {
    get isPaused() {
      return this.h !== 0
    }
    constructor(i) {
      super(i), (this.h = 0), (this.s = new Ru()), (this.t = i?.merge)
    }
    pause() {
      this.h++
    }
    resume() {
      if (this.h !== 0 && --this.h === 0)
        if (this.t) {
          if (this.s.size > 0) {
            const i = Array.from(this.s)
            this.s.clear(), super.fire(this.t(i))
          }
        } else for (; !this.h && this.s.size !== 0; ) super.fire(this.s.shift())
    }
    fire(i) {
      this.z && (this.h !== 0 ? this.s.push(i) : super.fire(i))
    }
  },
  rdt = class extends Fu {
    constructor(i) {
      super(i), (this.k = i.delay ?? 100)
    }
    fire(i) {
      this.o ||
        (this.pause(),
        (this.o = setTimeout(() => {
          ;(this.o = void 0), this.resume()
        }, this.k))),
        super.fire(i)
    }
  },
  ndt = class {
    constructor() {
      ;(this.f = !1),
        (this.g = Qt.None),
        (this.h = at.None),
        (this.j = new J({
          onDidAddFirstListener: () => {
            ;(this.f = !0), (this.h = this.g(this.j.fire, this.j))
          },
          onDidRemoveLastListener: () => {
            ;(this.f = !1), this.h.dispose()
          },
        })),
        (this.event = this.j.event)
    }
    set input(i) {
      ;(this.g = i),
        this.f && (this.h.dispose(), (this.h = i(this.j.fire, this.j)))
    }
    dispose() {
      this.h.dispose(), this.j.dispose()
    }
  },
  WV = Object.freeze(function (i, t) {
    const e = setTimeout(i.bind(t), 0)
    return {
      dispose() {
        clearTimeout(e)
      },
    }
  }),
  ce
;(function (i) {
  function t(e) {
    return e === i.None || e === i.Cancelled || e instanceof v_
      ? !0
      : !e || typeof e != "object"
        ? !1
        : typeof e.isCancellationRequested == "boolean" &&
          typeof e.onCancellationRequested == "function"
  }
  ;(i.isCancellationToken = t),
    (i.None = Object.freeze({
      isCancellationRequested: !1,
      onCancellationRequested: Qt.None,
    })),
    (i.Cancelled = Object.freeze({
      isCancellationRequested: !0,
      onCancellationRequested: WV,
    }))
})(ce || (ce = {}))
var v_ = class {
    constructor() {
      ;(this.a = !1), (this.b = null)
    }
    cancel() {
      this.a || ((this.a = !0), this.b && (this.b.fire(void 0), this.dispose()))
    }
    get isCancellationRequested() {
      return this.a
    }
    get onCancellationRequested() {
      return this.a ? WV : (this.b || (this.b = new J()), this.b.event)
    }
    dispose() {
      this.b && (this.b.dispose(), (this.b = null))
    }
  },
  fe = class {
    constructor(i) {
      ;(this.f = void 0),
        (this.g = void 0),
        (this.g = i && i.onCancellationRequested(this.cancel, this))
    }
    get token() {
      return this.f || (this.f = new v_()), this.f
    }
    cancel() {
      this.f ? this.f instanceof v_ && this.f.cancel() : (this.f = ce.Cancelled)
    }
    dispose(i = !1) {
      i && this.cancel(),
        this.g?.dispose(),
        this.f ? this.f instanceof v_ && this.f.dispose() : (this.f = ce.None)
    }
  }
function adt() {
  return globalThis._VSCODE_NLS_MESSAGES
}
function jV() {
  return globalThis._VSCODE_NLS_LANGUAGE
}
var odt =
  jV() === "pseudo" ||
  (typeof document < "u" &&
    document.location &&
    typeof document.location.hash == "string" &&
    document.location.hash.indexOf("pseudo=true") >= 0)
function w_(i, t) {
  let e
  return (
    t.length === 0
      ? (e = i)
      : (e = i.replace(/\{(\d+)\}/g, (s, r) => {
          const a = r[0],
            o = t[a]
          let c = s
          return (
            typeof o == "string"
              ? (c = o)
              : (typeof o == "number" ||
                  typeof o == "boolean" ||
                  o === void 0 ||
                  o === null) &&
                (c = String(o)),
            c
          )
        })),
    odt && (e = "\uFF3B" + e.replace(/[aouei]/g, "$&$&") + "\uFF3D"),
    e
  )
}
function g(i, t, ...e) {
  return w_(typeof i == "number" ? VV(i, t) : t, e)
}
function VV(i, t) {
  const e = adt()?.[i]
  if (typeof e != "string") {
    if (typeof t == "string") return t
    throw new Error(`!!! NLS MISSING: ${i} !!!`)
  }
  return e
}
function p7(i, t, ...e) {
  let s
  typeof i == "number" ? (s = VV(i, t)) : (s = t)
  const r = w_(s, e)
  return { value: r, original: t === s ? r : w_(t, e) }
}
var qn = "en",
  Au = !1,
  _u = !1,
  Ou = !1,
  cdt = !1,
  GV = !1,
  g7 = !1,
  ldt = !1,
  zV = !1,
  YV = !1,
  udt = !1,
  y_ = void 0,
  b_ = qn,
  QV = qn,
  hdt = void 0,
  Yr = void 0,
  Qr = globalThis,
  fs = void 0
typeof Qr.vscode < "u" && typeof Qr.vscode.process < "u"
  ? (fs = Qr.vscode.process)
  : typeof process < "u" &&
    typeof process?.versions?.node == "string" &&
    (fs = process)
var XV = typeof fs?.versions?.electron == "string",
  ddt = XV && fs?.type === "renderer"
if (typeof fs == "object") {
  ;(Au = fs.platform === "win32"),
    (_u = fs.platform === "darwin"),
    (Ou = fs.platform === "linux"),
    (cdt = Ou && !!fs.env.SNAP && !!fs.env.SNAP_REVISION),
    (ldt = XV),
    (YV = !!fs.env.CI || !!fs.env.BUILD_ARTIFACTSTAGINGDIRECTORY),
    (y_ = qn),
    (b_ = qn)
  const i = fs.env.VSCODE_NLS_CONFIG
  if (i)
    try {
      const t = JSON.parse(i)
      ;(y_ = t.userLocale),
        (QV = t.osLocale),
        (b_ = t.resolvedLanguage || qn),
        (hdt = t.languagePack?.translationsConfigFile)
    } catch {}
  GV = !0
} else
  typeof navigator == "object" && !ddt
    ? ((Yr = navigator.userAgent),
      (Au = Yr.indexOf("Windows") >= 0),
      (_u = Yr.indexOf("Macintosh") >= 0),
      (zV =
        (Yr.indexOf("Macintosh") >= 0 ||
          Yr.indexOf("iPad") >= 0 ||
          Yr.indexOf("iPhone") >= 0) &&
        !!navigator.maxTouchPoints &&
        navigator.maxTouchPoints > 0),
      (Ou = Yr.indexOf("Linux") >= 0),
      (udt = Yr?.indexOf("Mobi") >= 0),
      (g7 = !0),
      (b_ = jV() || qn),
      (y_ = navigator.language.toLowerCase()),
      (QV = y_))
    : console.error("Unable to resolve platform.")
var KV
;(function (i) {
  ;(i[(i.Web = 0)] = "Web"),
    (i[(i.Mac = 1)] = "Mac"),
    (i[(i.Linux = 2)] = "Linux"),
    (i[(i.Windows = 3)] = "Windows")
})(KV || (KV = {}))
function mdt(i) {
  switch (i) {
    case 0:
      return "Web"
    case 1:
      return "Mac"
    case 2:
      return "Linux"
    case 3:
      return "Windows"
  }
}
var T_ = 0
_u ? (T_ = 1) : Au ? (T_ = 3) : Ou && (T_ = 2)
var ie = Au,
  Ke = _u,
  De = Ou,
  ZV = GV,
  v7 = g7,
  fdt = g7 && typeof Qr.importScripts == "function",
  pdt = fdt ? Qr.origin : void 0,
  qa = YV,
  gdt = T_,
  Pr = Yr,
  Un = b_,
  tG
;(function (i) {
  function t() {
    return Un
  }
  i.value = t
  function e() {
    return Un.length === 2
      ? Un === "en"
      : Un.length >= 3
        ? Un[0] === "e" && Un[1] === "n" && Un[2] === "-"
        : !1
  }
  i.isDefaultVariant = e
  function s() {
    return Un === "en"
  }
  i.isDefault = s
})(tG || (tG = {}))
var vdt = typeof Qr.postMessage == "function" && !Qr.importScripts,
  eG = (() => {
    if (vdt) {
      const i = []
      Qr.addEventListener("message", (e) => {
        if (e.data && e.data.vscodeScheduleAsyncWork)
          for (let s = 0, r = i.length; s < r; s++) {
            const a = i[s]
            if (a.id === e.data.vscodeScheduleAsyncWork) {
              i.splice(s, 1), a.callback()
              return
            }
          }
      })
      let t = 0
      return (e) => {
        const s = ++t
        i.push({ id: s, callback: e }),
          Qr.postMessage({ vscodeScheduleAsyncWork: s }, "*")
      }
    }
    return (i) => setTimeout(i)
  })(),
  iG
;(function (i) {
  ;(i[(i.Windows = 1)] = "Windows"),
    (i[(i.Macintosh = 2)] = "Macintosh"),
    (i[(i.Linux = 3)] = "Linux")
})(iG || (iG = {}))
var w7 = _u || zV ? 2 : Au ? 1 : 3,
  sG = !0,
  rG = !1
function nG() {
  if (!rG) {
    rG = !0
    const i = new Uint8Array(2)
    ;(i[0] = 1), (i[1] = 2), (sG = new Uint16Array(i.buffer)[0] === 513)
  }
  return sG
}
var y7 = !!(Pr && Pr.indexOf("Chrome") >= 0),
  wdt = !!(Pr && Pr.indexOf("Firefox") >= 0),
  ydt = !!(!y7 && Pr && Pr.indexOf("Safari") >= 0),
  aG = !!(Pr && Pr.indexOf("Edg/") >= 0),
  mjt = !!(Pr && Pr.indexOf("Android") >= 0),
  Ua,
  b7 = globalThis.vscode
if (typeof b7 < "u" && typeof b7.process < "u") {
  const i = b7.process
  Ua = {
    get platform() {
      return i.platform
    },
    get arch() {
      return i.arch
    },
    get env() {
      return i.env
    },
    cwd() {
      return i.cwd()
    },
  }
} else
  typeof process < "u" && typeof process?.versions?.node == "string"
    ? (Ua = {
        get platform() {
          return process.platform
        },
        get arch() {
          return process.arch
        },
        get env() {
          return process.env
        },
        cwd() {
          return process.env.VSCODE_CWD || process.cwd()
        },
      })
    : (Ua = {
        get platform() {
          return ie ? "win32" : Ke ? "darwin" : "linux"
        },
        get arch() {},
        get env() {
          return {}
        },
        cwd() {
          return "/"
        },
      })
var Ma = Ua.cwd,
  Mn = Ua.env,
  bdt = Ua.platform,
  fjt = Ua.arch,
  Tdt = 65,
  kdt = 97,
  Sdt = 90,
  Edt = 122,
  Hn = 46,
  Ti = 47,
  rs = 92,
  Wn = 58,
  Idt = 63,
  oG = class extends Error {
    constructor(i, t, e) {
      let s
      typeof t == "string" && t.indexOf("not ") === 0
        ? ((s = "must not be"), (t = t.replace(/^not /, "")))
        : (s = "must be")
      const r = i.indexOf(".") !== -1 ? "property" : "argument"
      let a = `The "${i}" ${r} ${s} of type ${t}`
      ;(a += `. Received type ${typeof e}`),
        super(a),
        (this.code = "ERR_INVALID_ARG_TYPE")
    }
  }
function Pdt(i, t) {
  if (i === null || typeof i != "object") throw new oG(t, "Object", i)
}
function je(i, t) {
  if (typeof i != "string") throw new oG(t, "string", i)
}
var ns = bdt === "win32"
function qt(i) {
  return i === Ti || i === rs
}
function T7(i) {
  return i === Ti
}
function jn(i) {
  return (i >= Tdt && i <= Sdt) || (i >= kdt && i <= Edt)
}
function k_(i, t, e, s) {
  let r = "",
    a = 0,
    o = -1,
    c = 0,
    l = 0
  for (let u = 0; u <= i.length; ++u) {
    if (u < i.length) l = i.charCodeAt(u)
    else {
      if (s(l)) break
      l = Ti
    }
    if (s(l)) {
      if (!(o === u - 1 || c === 1))
        if (c === 2) {
          if (
            r.length < 2 ||
            a !== 2 ||
            r.charCodeAt(r.length - 1) !== Hn ||
            r.charCodeAt(r.length - 2) !== Hn
          ) {
            if (r.length > 2) {
              const d = r.lastIndexOf(e)
              d === -1
                ? ((r = ""), (a = 0))
                : ((r = r.slice(0, d)), (a = r.length - 1 - r.lastIndexOf(e))),
                (o = u),
                (c = 0)
              continue
            } else if (r.length !== 0) {
              ;(r = ""), (a = 0), (o = u), (c = 0)
              continue
            }
          }
          t && ((r += r.length > 0 ? `${e}..` : ".."), (a = 2))
        } else
          r.length > 0
            ? (r += `${e}${i.slice(o + 1, u)}`)
            : (r = i.slice(o + 1, u)),
            (a = u - o - 1)
      ;(o = u), (c = 0)
    } else l === Hn && c !== -1 ? ++c : (c = -1)
  }
  return r
}
function $dt(i) {
  return i ? `${i[0] === "." ? "" : "."}${i}` : ""
}
function cG(i, t) {
  Pdt(t, "pathObject")
  const e = t.dir || t.root,
    s = t.base || `${t.name || ""}${$dt(t.ext)}`
  return e ? (e === t.root ? `${e}${s}` : `${e}${i}${s}`) : s
}
var Ve = {
    resolve(...i) {
      let t = "",
        e = "",
        s = !1
      for (let r = i.length - 1; r >= -1; r--) {
        let a
        if (r >= 0) {
          if (((a = i[r]), je(a, `paths[${r}]`), a.length === 0)) continue
        } else
          t.length === 0
            ? (a = Ma())
            : ((a = Mn[`=${t}`] || Ma()),
              (a === void 0 ||
                (a.slice(0, 2).toLowerCase() !== t.toLowerCase() &&
                  a.charCodeAt(2) === rs)) &&
                (a = `${t}\\`))
        const o = a.length
        let c = 0,
          l = "",
          u = !1
        const d = a.charCodeAt(0)
        if (o === 1) qt(d) && ((c = 1), (u = !0))
        else if (qt(d))
          if (((u = !0), qt(a.charCodeAt(1)))) {
            let m = 2,
              f = m
            for (; m < o && !qt(a.charCodeAt(m)); ) m++
            if (m < o && m !== f) {
              const p = a.slice(f, m)
              for (f = m; m < o && qt(a.charCodeAt(m)); ) m++
              if (m < o && m !== f) {
                for (f = m; m < o && !qt(a.charCodeAt(m)); ) m++
                ;(m === o || m !== f) &&
                  ((l = `\\\\${p}\\${a.slice(f, m)}`), (c = m))
              }
            }
          } else c = 1
        else
          jn(d) &&
            a.charCodeAt(1) === Wn &&
            ((l = a.slice(0, 2)),
            (c = 2),
            o > 2 && qt(a.charCodeAt(2)) && ((u = !0), (c = 3)))
        if (l.length > 0)
          if (t.length > 0) {
            if (l.toLowerCase() !== t.toLowerCase()) continue
          } else t = l
        if (s) {
          if (t.length > 0) break
        } else if (((e = `${a.slice(c)}\\${e}`), (s = u), u && t.length > 0))
          break
      }
      return (e = k_(e, !s, "\\", qt)), s ? `${t}\\${e}` : `${t}${e}` || "."
    },
    normalize(i) {
      je(i, "path")
      const t = i.length
      if (t === 0) return "."
      let e = 0,
        s,
        r = !1
      const a = i.charCodeAt(0)
      if (t === 1) return T7(a) ? "\\" : i
      if (qt(a))
        if (((r = !0), qt(i.charCodeAt(1)))) {
          let c = 2,
            l = c
          for (; c < t && !qt(i.charCodeAt(c)); ) c++
          if (c < t && c !== l) {
            const u = i.slice(l, c)
            for (l = c; c < t && qt(i.charCodeAt(c)); ) c++
            if (c < t && c !== l) {
              for (l = c; c < t && !qt(i.charCodeAt(c)); ) c++
              if (c === t) return `\\\\${u}\\${i.slice(l)}\\`
              c !== l && ((s = `\\\\${u}\\${i.slice(l, c)}`), (e = c))
            }
          }
        } else e = 1
      else
        jn(a) &&
          i.charCodeAt(1) === Wn &&
          ((s = i.slice(0, 2)),
          (e = 2),
          t > 2 && qt(i.charCodeAt(2)) && ((r = !0), (e = 3)))
      let o = e < t ? k_(i.slice(e), !r, "\\", qt) : ""
      return (
        o.length === 0 && !r && (o = "."),
        o.length > 0 && qt(i.charCodeAt(t - 1)) && (o += "\\"),
        s === void 0 ? (r ? `\\${o}` : o) : r ? `${s}\\${o}` : `${s}${o}`
      )
    },
    isAbsolute(i) {
      je(i, "path")
      const t = i.length
      if (t === 0) return !1
      const e = i.charCodeAt(0)
      return (
        qt(e) ||
        (t > 2 && jn(e) && i.charCodeAt(1) === Wn && qt(i.charCodeAt(2)))
      )
    },
    join(...i) {
      if (i.length === 0) return "."
      let t, e
      for (let a = 0; a < i.length; ++a) {
        const o = i[a]
        je(o, "path"),
          o.length > 0 && (t === void 0 ? (t = e = o) : (t += `\\${o}`))
      }
      if (t === void 0) return "."
      let s = !0,
        r = 0
      if (typeof e == "string" && qt(e.charCodeAt(0))) {
        ++r
        const a = e.length
        a > 1 &&
          qt(e.charCodeAt(1)) &&
          (++r, a > 2 && (qt(e.charCodeAt(2)) ? ++r : (s = !1)))
      }
      if (s) {
        for (; r < t.length && qt(t.charCodeAt(r)); ) r++
        r >= 2 && (t = `\\${t.slice(r)}`)
      }
      return Ve.normalize(t)
    },
    relative(i, t) {
      if ((je(i, "from"), je(t, "to"), i === t)) return ""
      const e = Ve.resolve(i),
        s = Ve.resolve(t)
      if (e === s || ((i = e.toLowerCase()), (t = s.toLowerCase()), i === t))
        return ""
      let r = 0
      for (; r < i.length && i.charCodeAt(r) === rs; ) r++
      let a = i.length
      for (; a - 1 > r && i.charCodeAt(a - 1) === rs; ) a--
      const o = a - r
      let c = 0
      for (; c < t.length && t.charCodeAt(c) === rs; ) c++
      let l = t.length
      for (; l - 1 > c && t.charCodeAt(l - 1) === rs; ) l--
      const u = l - c,
        d = o < u ? o : u
      let m = -1,
        f = 0
      for (; f < d; f++) {
        const v = i.charCodeAt(r + f)
        if (v !== t.charCodeAt(c + f)) break
        v === rs && (m = f)
      }
      if (f !== d) {
        if (m === -1) return s
      } else {
        if (u > d) {
          if (t.charCodeAt(c + f) === rs) return s.slice(c + f + 1)
          if (f === 2) return s.slice(c + f)
        }
        o > d && (i.charCodeAt(r + f) === rs ? (m = f) : f === 2 && (m = 3)),
          m === -1 && (m = 0)
      }
      let p = ""
      for (f = r + m + 1; f <= a; ++f)
        (f === a || i.charCodeAt(f) === rs) &&
          (p += p.length === 0 ? ".." : "\\..")
      return (
        (c += m),
        p.length > 0
          ? `${p}${s.slice(c, l)}`
          : (s.charCodeAt(c) === rs && ++c, s.slice(c, l))
      )
    },
    toNamespacedPath(i) {
      if (typeof i != "string" || i.length === 0) return i
      const t = Ve.resolve(i)
      if (t.length <= 2) return i
      if (t.charCodeAt(0) === rs) {
        if (t.charCodeAt(1) === rs) {
          const e = t.charCodeAt(2)
          if (e !== Idt && e !== Hn) return `\\\\?\\UNC\\${t.slice(2)}`
        }
      } else if (
        jn(t.charCodeAt(0)) &&
        t.charCodeAt(1) === Wn &&
        t.charCodeAt(2) === rs
      )
        return `\\\\?\\${t}`
      return i
    },
    dirname(i) {
      je(i, "path")
      const t = i.length
      if (t === 0) return "."
      let e = -1,
        s = 0
      const r = i.charCodeAt(0)
      if (t === 1) return qt(r) ? i : "."
      if (qt(r)) {
        if (((e = s = 1), qt(i.charCodeAt(1)))) {
          let c = 2,
            l = c
          for (; c < t && !qt(i.charCodeAt(c)); ) c++
          if (c < t && c !== l) {
            for (l = c; c < t && qt(i.charCodeAt(c)); ) c++
            if (c < t && c !== l) {
              for (l = c; c < t && !qt(i.charCodeAt(c)); ) c++
              if (c === t) return i
              c !== l && (e = s = c + 1)
            }
          }
        }
      } else
        jn(r) &&
          i.charCodeAt(1) === Wn &&
          ((e = t > 2 && qt(i.charCodeAt(2)) ? 3 : 2), (s = e))
      let a = -1,
        o = !0
      for (let c = t - 1; c >= s; --c)
        if (qt(i.charCodeAt(c))) {
          if (!o) {
            a = c
            break
          }
        } else o = !1
      if (a === -1) {
        if (e === -1) return "."
        a = e
      }
      return i.slice(0, a)
    },
    basename(i, t) {
      t !== void 0 && je(t, "suffix"), je(i, "path")
      let e = 0,
        s = -1,
        r = !0,
        a
      if (
        (i.length >= 2 &&
          jn(i.charCodeAt(0)) &&
          i.charCodeAt(1) === Wn &&
          (e = 2),
        t !== void 0 && t.length > 0 && t.length <= i.length)
      ) {
        if (t === i) return ""
        let o = t.length - 1,
          c = -1
        for (a = i.length - 1; a >= e; --a) {
          const l = i.charCodeAt(a)
          if (qt(l)) {
            if (!r) {
              e = a + 1
              break
            }
          } else
            c === -1 && ((r = !1), (c = a + 1)),
              o >= 0 &&
                (l === t.charCodeAt(o)
                  ? --o === -1 && (s = a)
                  : ((o = -1), (s = c)))
        }
        return e === s ? (s = c) : s === -1 && (s = i.length), i.slice(e, s)
      }
      for (a = i.length - 1; a >= e; --a)
        if (qt(i.charCodeAt(a))) {
          if (!r) {
            e = a + 1
            break
          }
        } else s === -1 && ((r = !1), (s = a + 1))
      return s === -1 ? "" : i.slice(e, s)
    },
    extname(i) {
      je(i, "path")
      let t = 0,
        e = -1,
        s = 0,
        r = -1,
        a = !0,
        o = 0
      i.length >= 2 &&
        i.charCodeAt(1) === Wn &&
        jn(i.charCodeAt(0)) &&
        (t = s = 2)
      for (let c = i.length - 1; c >= t; --c) {
        const l = i.charCodeAt(c)
        if (qt(l)) {
          if (!a) {
            s = c + 1
            break
          }
          continue
        }
        r === -1 && ((a = !1), (r = c + 1)),
          l === Hn
            ? e === -1
              ? (e = c)
              : o !== 1 && (o = 1)
            : e !== -1 && (o = -1)
      }
      return e === -1 ||
        r === -1 ||
        o === 0 ||
        (o === 1 && e === r - 1 && e === s + 1)
        ? ""
        : i.slice(e, r)
    },
    format: cG.bind(null, "\\"),
    parse(i) {
      je(i, "path")
      const t = { root: "", dir: "", base: "", ext: "", name: "" }
      if (i.length === 0) return t
      const e = i.length
      let s = 0,
        r = i.charCodeAt(0)
      if (e === 1)
        return qt(r) ? ((t.root = t.dir = i), t) : ((t.base = t.name = i), t)
      if (qt(r)) {
        if (((s = 1), qt(i.charCodeAt(1)))) {
          let m = 2,
            f = m
          for (; m < e && !qt(i.charCodeAt(m)); ) m++
          if (m < e && m !== f) {
            for (f = m; m < e && qt(i.charCodeAt(m)); ) m++
            if (m < e && m !== f) {
              for (f = m; m < e && !qt(i.charCodeAt(m)); ) m++
              m === e ? (s = m) : m !== f && (s = m + 1)
            }
          }
        }
      } else if (jn(r) && i.charCodeAt(1) === Wn) {
        if (e <= 2) return (t.root = t.dir = i), t
        if (((s = 2), qt(i.charCodeAt(2)))) {
          if (e === 3) return (t.root = t.dir = i), t
          s = 3
        }
      }
      s > 0 && (t.root = i.slice(0, s))
      let a = -1,
        o = s,
        c = -1,
        l = !0,
        u = i.length - 1,
        d = 0
      for (; u >= s; --u) {
        if (((r = i.charCodeAt(u)), qt(r))) {
          if (!l) {
            o = u + 1
            break
          }
          continue
        }
        c === -1 && ((l = !1), (c = u + 1)),
          r === Hn
            ? a === -1
              ? (a = u)
              : d !== 1 && (d = 1)
            : a !== -1 && (d = -1)
      }
      return (
        c !== -1 &&
          (a === -1 || d === 0 || (d === 1 && a === c - 1 && a === o + 1)
            ? (t.base = t.name = i.slice(o, c))
            : ((t.name = i.slice(o, a)),
              (t.base = i.slice(o, c)),
              (t.ext = i.slice(a, c)))),
        o > 0 && o !== s ? (t.dir = i.slice(0, o - 1)) : (t.dir = t.root),
        t
      )
    },
    sep: "\\",
    delimiter: ";",
    win32: null,
    posix: null,
  },
  xdt = (() => {
    if (ns) {
      const i = /\\/g
      return () => {
        const t = Ma().replace(i, "/")
        return t.slice(t.indexOf("/"))
      }
    }
    return () => Ma()
  })(),
  Wt = {
    resolve(...i) {
      let t = "",
        e = !1
      for (let s = i.length - 1; s >= -1 && !e; s--) {
        const r = s >= 0 ? i[s] : xdt()
        je(r, `paths[${s}]`),
          r.length !== 0 && ((t = `${r}/${t}`), (e = r.charCodeAt(0) === Ti))
      }
      return (t = k_(t, !e, "/", T7)), e ? `/${t}` : t.length > 0 ? t : "."
    },
    normalize(i) {
      if ((je(i, "path"), i.length === 0)) return "."
      const t = i.charCodeAt(0) === Ti,
        e = i.charCodeAt(i.length - 1) === Ti
      return (
        (i = k_(i, !t, "/", T7)),
        i.length === 0
          ? t
            ? "/"
            : e
              ? "./"
              : "."
          : (e && (i += "/"), t ? `/${i}` : i)
      )
    },
    isAbsolute(i) {
      return je(i, "path"), i.length > 0 && i.charCodeAt(0) === Ti
    },
    join(...i) {
      if (i.length === 0) return "."
      let t
      for (let e = 0; e < i.length; ++e) {
        const s = i[e]
        je(s, "path"), s.length > 0 && (t === void 0 ? (t = s) : (t += `/${s}`))
      }
      return t === void 0 ? "." : Wt.normalize(t)
    },
    relative(i, t) {
      if (
        (je(i, "from"),
        je(t, "to"),
        i === t || ((i = Wt.resolve(i)), (t = Wt.resolve(t)), i === t))
      )
        return ""
      const e = 1,
        s = i.length,
        r = s - e,
        a = 1,
        o = t.length - a,
        c = r < o ? r : o
      let l = -1,
        u = 0
      for (; u < c; u++) {
        const m = i.charCodeAt(e + u)
        if (m !== t.charCodeAt(a + u)) break
        m === Ti && (l = u)
      }
      if (u === c)
        if (o > c) {
          if (t.charCodeAt(a + u) === Ti) return t.slice(a + u + 1)
          if (u === 0) return t.slice(a + u)
        } else
          r > c && (i.charCodeAt(e + u) === Ti ? (l = u) : u === 0 && (l = 0))
      let d = ""
      for (u = e + l + 1; u <= s; ++u)
        (u === s || i.charCodeAt(u) === Ti) &&
          (d += d.length === 0 ? ".." : "/..")
      return `${d}${t.slice(a + l)}`
    },
    toNamespacedPath(i) {
      return i
    },
    dirname(i) {
      if ((je(i, "path"), i.length === 0)) return "."
      const t = i.charCodeAt(0) === Ti
      let e = -1,
        s = !0
      for (let r = i.length - 1; r >= 1; --r)
        if (i.charCodeAt(r) === Ti) {
          if (!s) {
            e = r
            break
          }
        } else s = !1
      return e === -1 ? (t ? "/" : ".") : t && e === 1 ? "//" : i.slice(0, e)
    },
    basename(i, t) {
      t !== void 0 && je(t, "ext"), je(i, "path")
      let e = 0,
        s = -1,
        r = !0,
        a
      if (t !== void 0 && t.length > 0 && t.length <= i.length) {
        if (t === i) return ""
        let o = t.length - 1,
          c = -1
        for (a = i.length - 1; a >= 0; --a) {
          const l = i.charCodeAt(a)
          if (l === Ti) {
            if (!r) {
              e = a + 1
              break
            }
          } else
            c === -1 && ((r = !1), (c = a + 1)),
              o >= 0 &&
                (l === t.charCodeAt(o)
                  ? --o === -1 && (s = a)
                  : ((o = -1), (s = c)))
        }
        return e === s ? (s = c) : s === -1 && (s = i.length), i.slice(e, s)
      }
      for (a = i.length - 1; a >= 0; --a)
        if (i.charCodeAt(a) === Ti) {
          if (!r) {
            e = a + 1
            break
          }
        } else s === -1 && ((r = !1), (s = a + 1))
      return s === -1 ? "" : i.slice(e, s)
    },
    extname(i) {
      je(i, "path")
      let t = -1,
        e = 0,
        s = -1,
        r = !0,
        a = 0
      for (let o = i.length - 1; o >= 0; --o) {
        const c = i.charCodeAt(o)
        if (c === Ti) {
          if (!r) {
            e = o + 1
            break
          }
          continue
        }
        s === -1 && ((r = !1), (s = o + 1)),
          c === Hn
            ? t === -1
              ? (t = o)
              : a !== 1 && (a = 1)
            : t !== -1 && (a = -1)
      }
      return t === -1 ||
        s === -1 ||
        a === 0 ||
        (a === 1 && t === s - 1 && t === e + 1)
        ? ""
        : i.slice(t, s)
    },
    format: cG.bind(null, "/"),
    parse(i) {
      je(i, "path")
      const t = { root: "", dir: "", base: "", ext: "", name: "" }
      if (i.length === 0) return t
      const e = i.charCodeAt(0) === Ti
      let s
      e ? ((t.root = "/"), (s = 1)) : (s = 0)
      let r = -1,
        a = 0,
        o = -1,
        c = !0,
        l = i.length - 1,
        u = 0
      for (; l >= s; --l) {
        const d = i.charCodeAt(l)
        if (d === Ti) {
          if (!c) {
            a = l + 1
            break
          }
          continue
        }
        o === -1 && ((c = !1), (o = l + 1)),
          d === Hn
            ? r === -1
              ? (r = l)
              : u !== 1 && (u = 1)
            : r !== -1 && (u = -1)
      }
      if (o !== -1) {
        const d = a === 0 && e ? 1 : a
        r === -1 || u === 0 || (u === 1 && r === o - 1 && r === a + 1)
          ? (t.base = t.name = i.slice(d, o))
          : ((t.name = i.slice(d, r)),
            (t.base = i.slice(d, o)),
            (t.ext = i.slice(r, o)))
      }
      return a > 0 ? (t.dir = i.slice(0, a - 1)) : e && (t.dir = "/"), t
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null,
  }
;(Wt.win32 = Ve.win32 = Ve), (Wt.posix = Ve.posix = Wt)
var Xr = ns ? Ve.normalize : Wt.normalize,
  $r = ns ? Ve.isAbsolute : Wt.isAbsolute,
  se = ns ? Ve.join : Wt.join,
  Ndt = ns ? Ve.resolve : Wt.resolve,
  uc = ns ? Ve.relative : Wt.relative,
  Ui = ns ? Ve.dirname : Wt.dirname,
  ke = ns ? Ve.basename : Wt.basename,
  S_ = ns ? Ve.extname : Wt.extname,
  pjt = ns ? Ve.format : Wt.format,
  gjt = ns ? Ve.parse : Wt.parse,
  vjt = ns ? Ve.toNamespacedPath : Wt.toNamespacedPath,
  xe = ns ? Ve.sep : Wt.sep,
  lG = ns ? Ve.delimiter : Wt.delimiter
function Cdt(i) {
  return i
}
var Jdt = class {
    constructor(i, t) {
      ;(this.a = void 0),
        (this.b = void 0),
        typeof i == "function"
          ? ((this.c = i), (this.d = Cdt))
          : ((this.c = t), (this.d = i.getCacheKey))
    }
    get(i) {
      const t = this.d(i)
      return this.b !== t && ((this.b = t), (this.a = this.c(i))), this.a
    }
  },
  as = class {
    constructor(i) {
      ;(this.d = i), (this.a = !1)
    }
    get hasValue() {
      return this.a
    }
    get value() {
      if (!this.a)
        try {
          this.b = this.d()
        } catch (i) {
          this.c = i
        } finally {
          this.a = !0
        }
      if (this.c) throw this.c
      return this.b
    }
    get rawValue() {
      return this.b
    }
  }
function E_(i) {
  return !i || typeof i != "string" ? !0 : i.trim().length === 0
}
var Ldt = /{([^}]+)}/g
function uG(i, t) {
  return Object.keys(t).length === 0 ? i : i.replace(Ldt, (e, s) => t[s] ?? e)
}
function Vn(i) {
  return i.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&")
}
function Rdt(i, t) {
  let e = 0,
    s = i.indexOf(t)
  for (; s !== -1; ) e++, (s = i.indexOf(t, s + t.length))
  return e
}
function Ddt(i, t) {
  if (!i || !t) return i
  const e = t.length
  if (e === 0 || i.length === 0) return i
  let s = 0
  for (; i.indexOf(t, s) === s; ) s = s + e
  return i.substring(s)
}
function Gn(i, t) {
  if (!i || !t) return i
  const e = t.length,
    s = i.length
  if (e === 0 || s === 0) return i
  let r = s,
    a = -1
  for (; (a = i.lastIndexOf(t, r - 1)), !(a === -1 || a + e !== r); ) {
    if (a === 0) return ""
    r = a
  }
  return i.substring(0, r)
}
function Fdt(i) {
  return i.replace(/\*/g, "")
}
function hG(i, t, e = {}) {
  if (!i) throw new Error("Cannot create regex from empty string")
  t || (i = Vn(i)),
    e.wholeWord &&
      (/\B/.test(i.charAt(0)) || (i = "\\b" + i),
      /\B/.test(i.charAt(i.length - 1)) || (i = i + "\\b"))
  let s = ""
  return (
    e.global && (s += "g"),
    e.matchCase || (s += "i"),
    e.multiline && (s += "m"),
    e.unicode && (s += "u"),
    new RegExp(i, s)
  )
}
function dG(i) {
  return i.source === "^" ||
    i.source === "^$" ||
    i.source === "$" ||
    i.source === "^\\s*$"
    ? !1
    : !!(i.exec("") && i.lastIndex === 0)
}
function mG(i) {
  return i.split(/\r\n|\r|\n/)
}
function k7(i) {
  for (let t = 0, e = i.length; t < e; t++) {
    const s = i.charCodeAt(t)
    if (s !== 32 && s !== 9) return t
  }
  return -1
}
function Adt(i, t = i.length - 1) {
  for (let e = t; e >= 0; e--) {
    const s = i.charCodeAt(e)
    if (s !== 32 && s !== 9) return e
  }
  return -1
}
function _dt(i, t, e) {
  const s = []
  let r = 0
  for (const a of i.matchAll(t)) {
    if ((s.push(i.slice(r, a.index)), a.index === void 0))
      throw new Error("match.index should be defined")
    ;(r = a.index + a[0].length),
      s.push(e(a[0], ...a.slice(1), a.index, i, a.groups))
  }
  return s.push(i.slice(r)), Promise.all(s).then((a) => a.join(""))
}
function Ha(i, t) {
  return i < t ? -1 : i > t ? 1 : 0
}
function S7(i, t, e = 0, s = i.length, r = 0, a = t.length) {
  for (; e < s && r < a; e++, r++) {
    const l = i.charCodeAt(e),
      u = t.charCodeAt(r)
    if (l < u) return -1
    if (l > u) return 1
  }
  const o = s - e,
    c = a - r
  return o < c ? -1 : o > c ? 1 : 0
}
function fG(i, t) {
  return Bu(i, t, 0, i.length, 0, t.length)
}
function Bu(i, t, e = 0, s = i.length, r = 0, a = t.length) {
  for (; e < s && r < a; e++, r++) {
    let l = i.charCodeAt(e),
      u = t.charCodeAt(r)
    if (l === u) continue
    if (l >= 128 || u >= 128)
      return S7(i.toLowerCase(), t.toLowerCase(), e, s, r, a)
    pG(l) && (l -= 32), pG(u) && (u -= 32)
    const d = l - u
    if (d !== 0) return d
  }
  const o = s - e,
    c = a - r
  return o < c ? -1 : o > c ? 1 : 0
}
function pG(i) {
  return i >= 97 && i <= 122
}
function gG(i) {
  return i >= 65 && i <= 90
}
function Ws(i, t) {
  return i.length === t.length && Bu(i, t) === 0
}
function I_(i, t) {
  const e = t.length
  return t.length > i.length ? !1 : Bu(i, t, 0, e) === 0
}
function Odt(i, t) {
  const e = Math.min(i.length, t.length)
  let s
  for (s = 0; s < e; s++) if (i.charCodeAt(s) !== t.charCodeAt(s)) return s
  return e
}
function P_(i) {
  return 55296 <= i && i <= 56319
}
function $_(i) {
  return 56320 <= i && i <= 57343
}
function E7(i, t) {
  return ((i - 55296) << 10) + (t - 56320) + 65536
}
function vG(i, t, e) {
  const s = i.charCodeAt(e)
  if (P_(s) && e + 1 < t) {
    const r = i.charCodeAt(e + 1)
    if ($_(r)) return E7(s, r)
  }
  return s
}
function Bdt(i, t) {
  const e = i.charCodeAt(t - 1)
  if ($_(e) && t > 1) {
    const s = i.charCodeAt(t - 2)
    if (P_(s)) return E7(s, e)
  }
  return e
}
var qdt = class {
    get offset() {
      return this.e
    }
    constructor(i, t = 0) {
      ;(this.c = i), (this.d = i.length), (this.e = t)
    }
    setOffset(i) {
      this.e = i
    }
    prevCodePoint() {
      const i = Bdt(this.c, this.e)
      return (this.e -= i >= 65536 ? 2 : 1), i
    }
    nextCodePoint() {
      const i = vG(this.c, this.d, this.e)
      return (this.e += i >= 65536 ? 2 : 1), i
    }
    eol() {
      return this.e >= this.d
    }
  },
  Udt = class {
    get offset() {
      return this.c.offset
    }
    constructor(i, t = 0) {
      this.c = new qdt(i, t)
    }
    nextGraphemeLength() {
      const i = EG.getInstance(),
        t = this.c,
        e = t.offset
      let s = i.getGraphemeBreakType(t.nextCodePoint())
      for (; !t.eol(); ) {
        const r = t.offset,
          a = i.getGraphemeBreakType(t.nextCodePoint())
        if (kG(s, a)) {
          t.setOffset(r)
          break
        }
        s = a
      }
      return t.offset - e
    }
    prevGraphemeLength() {
      const i = EG.getInstance(),
        t = this.c,
        e = t.offset
      let s = i.getGraphemeBreakType(t.prevCodePoint())
      for (; t.offset > 0; ) {
        const r = t.offset,
          a = i.getGraphemeBreakType(t.prevCodePoint())
        if (kG(a, s)) {
          t.setOffset(r)
          break
        }
        s = a
      }
      return e - t.offset
    }
    eol() {
      return this.c.eol()
    }
  }
function wG(i, t) {
  return new Udt(i, t).nextGraphemeLength()
}
var I7 = void 0
function Mdt() {
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/
}
function yG(i) {
  return I7 || (I7 = Mdt()), I7.test(i)
}
var Hdt = /^[\t\n\r\x20-\x7E]*$/
function Wdt(i) {
  return Hdt.test(i)
}
var jdt = /[\u2028\u2029]/
function bG(i) {
  return jdt.test(i)
}
var Vdt = "\uFEFF"
function Gdt(i) {
  return !!(i && i.length > 0 && i.charCodeAt(0) === 65279)
}
function zdt(i, t) {
  if (!i || !t || i.length < t.length) return !1
  const e = t.length,
    s = i.toLowerCase()
  let r = 0,
    a = -1
  for (; r < e; ) {
    const o = s.indexOf(t[r], a + 1)
    if (o < 0) return !1
    ;(a = o), r++
  }
  return !0
}
function TG(i, t = !1) {
  return i ? (t && (i = i.replace(/\\./g, "")), i.toLowerCase() !== i) : !1
}
function Ydt(i) {
  return i.charAt(0).toUpperCase() + i.slice(1)
}
function Qdt(i, t = 1) {
  if (t === 0) return ""
  let e = -1
  do
    (e = i.indexOf(
      `
`,
      e + 1,
    )),
      t--
  while (t > 0 && e >= 0)
  return e === -1 ? i : (i[e - 1] === "\r" && e--, i.substr(0, e))
}
function kG(i, t) {
  return i === 0
    ? t !== 5 && t !== 7
    : i === 2 && t === 3
      ? !1
      : i === 4 || i === 2 || i === 3 || t === 4 || t === 2 || t === 3
        ? !0
        : !(
            (i === 8 && (t === 8 || t === 9 || t === 11 || t === 12)) ||
            ((i === 11 || i === 9) && (t === 9 || t === 10)) ||
            ((i === 12 || i === 10) && t === 10) ||
            t === 5 ||
            t === 13 ||
            t === 7 ||
            i === 1 ||
            (i === 13 && t === 14) ||
            (i === 6 && t === 6)
          )
}
var SG
;(function (i) {
  ;(i[(i.Other = 0)] = "Other"),
    (i[(i.Prepend = 1)] = "Prepend"),
    (i[(i.CR = 2)] = "CR"),
    (i[(i.LF = 3)] = "LF"),
    (i[(i.Control = 4)] = "Control"),
    (i[(i.Extend = 5)] = "Extend"),
    (i[(i.Regional_Indicator = 6)] = "Regional_Indicator"),
    (i[(i.SpacingMark = 7)] = "SpacingMark"),
    (i[(i.L = 8)] = "L"),
    (i[(i.V = 9)] = "V"),
    (i[(i.T = 10)] = "T"),
    (i[(i.LV = 11)] = "LV"),
    (i[(i.LVT = 12)] = "LVT"),
    (i[(i.ZWJ = 13)] = "ZWJ"),
    (i[(i.Extended_Pictographic = 14)] = "Extended_Pictographic")
})(SG || (SG = {}))
var EG = class Xf {
  static {
    this.c = null
  }
  static getInstance() {
    return Xf.c || (Xf.c = new Xf()), Xf.c
  }
  constructor() {
    this.d = Xdt()
  }
  getGraphemeBreakType(t) {
    if (t < 32) return t === 10 ? 3 : t === 13 ? 2 : 4
    if (t < 127) return 0
    const e = this.d,
      s = e.length / 3
    let r = 1
    for (; r <= s; )
      if (t < e[3 * r]) r = 2 * r
      else if (t > e[3 * r + 1]) r = 2 * r + 1
      else return e[3 * r + 2]
    return 0
  }
}
function Xdt() {
  return JSON.parse(
    "[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]",
  )
}
var IG
;(function (i) {
  ;(i[(i.zwj = 8205)] = "zwj"),
    (i[(i.emojiVariantSelector = 65039)] = "emojiVariantSelector"),
    (i[(i.enclosingKeyCap = 8419)] = "enclosingKeyCap")
})(IG || (IG = {}))
var wjt = class Kf {
    static {
      this.c = new as(() =>
        JSON.parse(
          '{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}',
        ),
      )
    }
    static {
      this.d = new Jdt({ getCacheKey: JSON.stringify }, (t) => {
        function e(d) {
          const m = new Map()
          for (let f = 0; f < d.length; f += 2) m.set(d[f], d[f + 1])
          return m
        }
        function s(d, m) {
          const f = new Map(d)
          for (const [p, v] of m) f.set(p, v)
          return f
        }
        function r(d, m) {
          if (!d) return m
          const f = new Map()
          for (const [p, v] of d) m.has(p) && f.set(p, v)
          return f
        }
        const a = this.c.value
        let o = t.filter((d) => !d.startsWith("_") && d in a)
        o.length === 0 && (o = ["_default"])
        let c
        for (const d of o) {
          const m = e(a[d])
          c = r(c, m)
        }
        const l = e(a._common),
          u = s(l, c)
        return new Kf(u)
      })
    }
    static getInstance(t) {
      return Kf.d.get(Array.from(t))
    }
    static {
      this.e = new as(() =>
        Object.keys(Kf.c.value).filter((t) => !t.startsWith("_")),
      )
    }
    static getLocales() {
      return Kf.e.value
    }
    constructor(t) {
      this.f = t
    }
    isAmbiguous(t) {
      return this.f.has(t)
    }
    containsAmbiguousCharacter(t) {
      for (let e = 0; e < t.length; e++) {
        const s = t.codePointAt(e)
        if (typeof s == "number" && this.isAmbiguous(s)) return !0
      }
      return !1
    }
    getPrimaryConfusable(t) {
      return this.f.get(t)
    }
    getConfusableCodePoints() {
      return new Set(this.f.keys())
    }
  },
  yjt = class Zf {
    static c() {
      return JSON.parse(
        "[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]",
      )
    }
    static {
      this.d = void 0
    }
    static e() {
      return this.d || (this.d = new Set(Zf.c())), this.d
    }
    static isInvisibleCharacter(t) {
      return Zf.e().has(t)
    }
    static containsInvisibleCharacter(t) {
      for (let e = 0; e < t.length; e++) {
        const s = t.codePointAt(e)
        if (typeof s == "number" && Zf.isInvisibleCharacter(s)) return !0
      }
      return !1
    }
    static get codePoints() {
      return Zf.e()
    }
  }
function _t(i) {
  return typeof i == "string"
}
function Kdt(i) {
  return Array.isArray(i) && i.every((t) => _t(t))
}
function Je(i) {
  return (
    typeof i == "object" &&
    i !== null &&
    !Array.isArray(i) &&
    !(i instanceof RegExp) &&
    !(i instanceof Date)
  )
}
function Zdt(i) {
  const t = Object.getPrototypeOf(Uint8Array)
  return typeof i == "object" && i instanceof t
}
function ps(i) {
  return typeof i == "number" && !isNaN(i)
}
function PG(i) {
  return i === !0 || i === !1
}
function qu(i) {
  return typeof i > "u"
}
function Wa(i) {
  return !Fe(i)
}
function Fe(i) {
  return qu(i) || i === null
}
function $G(i, t) {
  if (!i)
    throw new Error(t ? `Unexpected type, expected '${t}'` : "Unexpected type")
}
function hc(i) {
  if (Fe(i)) throw new Error("Assertion Failed: argument is undefined or null")
  return i
}
var tmt = Object.prototype.hasOwnProperty
function xG(i) {
  if (!Je(i)) return !1
  for (const t in i) if (tmt.call(i, t)) return !1
  return !0
}
function emt(i) {
  return typeof i == "function"
}
function imt(i, t) {
  if (_t(t)) {
    if (typeof i !== t)
      throw new Error(`argument does not match constraint: typeof ${t}`)
  } else if (emt(t)) {
    try {
      if (i instanceof t) return
    } catch {}
    if (
      (!Fe(i) && i.constructor === t) ||
      (t.length === 1 && t.call(void 0, i) === !0)
    )
      return
    throw new Error(
      "argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true",
    )
  }
}
function zn(i) {
  return i === 47 || i === 92
}
function NG(i) {
  return i.replace(/[\\/]/g, Wt.sep)
}
function smt(i) {
  return (
    i.indexOf("/") === -1 && (i = NG(i)),
    /^[a-zA-Z]:(\/|$)/.test(i) && (i = "/" + i),
    i
  )
}
function P7(i, t = Wt.sep) {
  if (!i) return ""
  const e = i.length,
    s = i.charCodeAt(0)
  if (zn(s)) {
    if (zn(i.charCodeAt(1)) && !zn(i.charCodeAt(2))) {
      let a = 3
      const o = a
      for (; a < e && !zn(i.charCodeAt(a)); a++);
      if (o !== a && !zn(i.charCodeAt(a + 1))) {
        for (a += 1; a < e; a++)
          if (zn(i.charCodeAt(a))) return i.slice(0, a + 1).replace(/[\\/]/g, t)
      }
    }
    return t
  } else if (CG(s) && i.charCodeAt(1) === 58)
    return zn(i.charCodeAt(2)) ? i.slice(0, 2) + t : i.slice(0, 2)
  let r = i.indexOf("://")
  if (r !== -1) {
    for (r += 3; r < e; r++) if (zn(i.charCodeAt(r))) return i.slice(0, r + 1)
  }
  return ""
}
var rmt = /[\\/:\*\?"<>\|]/g,
  nmt = /[/]/g,
  amt = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i
function omt(i, t = ie) {
  const e = t ? rmt : nmt
  return !(
    !i ||
    i.length === 0 ||
    /^\s+$/.test(i) ||
    ((e.lastIndex = 0), e.test(i)) ||
    (t && amt.test(i)) ||
    i === "." ||
    i === ".." ||
    (t && i[i.length - 1] === ".") ||
    (t && i.length !== i.trim().length) ||
    i.length > 255
  )
}
function $7(i, t, e) {
  const s = i === t
  return !e || s ? s : !i || !t ? !1 : Ws(i, t)
}
function ja(i, t, e, s = xe) {
  if (i === t) return !0
  if (!i || !t || t.length > i.length) return !1
  if (e) {
    if (!I_(i, t)) return !1
    if (t.length === i.length) return !0
    let a = t.length
    return t.charAt(t.length - 1) === s && a--, i.charAt(a) === s
  }
  return t.charAt(t.length - 1) !== s && (t += s), i.indexOf(t) === 0
}
function CG(i) {
  return (i >= 65 && i <= 90) || (i >= 97 && i <= 122)
}
function cmt(i) {
  return (
    ie
      ? ((i = Gn(i, xe)), i.endsWith(":") && (i += xe))
      : ((i = Gn(i, xe)), i || (i = xe)),
    i
  )
}
function JG(i) {
  const t = Xr(i)
  return ie
    ? i.length > 3
      ? !1
      : x7(t) && (i.length === 2 || t.charCodeAt(2) === 92)
    : t === Wt.sep
}
function x7(i, t = ie) {
  return t ? CG(i.charCodeAt(0)) && i.charCodeAt(1) === 58 : !1
}
function LG(i, t = ie) {
  return x7(i, t) ? i[0] : void 0
}
var lmt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  umt = "BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789"
function hmt(i, t, e = 8) {
  let s = ""
  for (let a = 0; a < e; a++) {
    let o
    a === 0 && ie && !t && (e === 3 || e === 4) ? (o = umt) : (o = lmt),
      (s += o.charAt(Math.floor(Math.random() * o.length)))
  }
  let r
  return t ? (r = `${t}-${s}`) : (r = s), i ? se(i, r) : r
}
var dmt = /^\w[\w\d+.-]*$/,
  mmt = /^\//,
  fmt = /^\/\//
function pmt(i, t) {
  if (!i.scheme && t)
    throw new Error(
      `[UriError]: Scheme is missing: {scheme: "", authority: "${i.authority}", path: "${i.path}", query: "${i.query}", fragment: "${i.fragment}"}`,
    )
  if (i.scheme && !dmt.test(i.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.")
  if (i.path) {
    if (i.authority) {
      if (!mmt.test(i.path))
        throw new Error(
          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character',
        )
    } else if (fmt.test(i.path))
      throw new Error(
        '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")',
      )
  }
}
function gmt(i, t) {
  return !i && !t ? "file" : i
}
function vmt(i, t) {
  switch (i) {
    case "https":
    case "http":
    case "file":
      t ? t[0] !== js && (t = js + t) : (t = js)
      break
  }
  return t
}
var Se = "",
  js = "/",
  wmt = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
  S = class U3 {
    static isUri(t) {
      return t instanceof U3
        ? !0
        : t
          ? typeof t.authority == "string" &&
            typeof t.fragment == "string" &&
            typeof t.path == "string" &&
            typeof t.query == "string" &&
            typeof t.scheme == "string" &&
            typeof t.fsPath == "string" &&
            typeof t.with == "function" &&
            typeof t.toString == "function"
          : !1
    }
    constructor(t, e, s, r, a, o = !1) {
      typeof t == "object"
        ? ((this.scheme = t.scheme || Se),
          (this.authority = t.authority || Se),
          (this.path = t.path || Se),
          (this.query = t.query || Se),
          (this.fragment = t.fragment || Se))
        : ((this.scheme = gmt(t, o)),
          (this.authority = e || Se),
          (this.path = vmt(this.scheme, s || Se)),
          (this.query = r || Se),
          (this.fragment = a || Se),
          pmt(this, o))
    }
    get fsPath() {
      return x_(this, !1)
    }
    with(t) {
      if (!t) return this
      let { scheme: e, authority: s, path: r, query: a, fragment: o } = t
      return (
        e === void 0 ? (e = this.scheme) : e === null && (e = Se),
        s === void 0 ? (s = this.authority) : s === null && (s = Se),
        r === void 0 ? (r = this.path) : r === null && (r = Se),
        a === void 0 ? (a = this.query) : a === null && (a = Se),
        o === void 0 ? (o = this.fragment) : o === null && (o = Se),
        e === this.scheme &&
        s === this.authority &&
        r === this.path &&
        a === this.query &&
        o === this.fragment
          ? this
          : new dc(e, s, r, a, o)
      )
    }
    static parse(t, e = !1) {
      const s = wmt.exec(t)
      return s
        ? new dc(
            s[2] || Se,
            N_(s[4] || Se),
            N_(s[5] || Se),
            N_(s[7] || Se),
            N_(s[9] || Se),
            e,
          )
        : new dc(Se, Se, Se, Se, Se)
    }
    static file(t) {
      let e = Se
      if ((ie && (t = t.replace(/\\/g, js)), t[0] === js && t[1] === js)) {
        const s = t.indexOf(js, 2)
        s === -1
          ? ((e = t.substring(2)), (t = js))
          : ((e = t.substring(2, s)), (t = t.substring(s) || js))
      }
      return new dc("file", e, t, Se, Se)
    }
    static from(t, e) {
      return new dc(t.scheme, t.authority, t.path, t.query, t.fragment, e)
    }
    static joinPath(t, ...e) {
      if (!t.path)
        throw new Error("[UriError]: cannot call joinPath on URI without path")
      let s
      return (
        ie && t.scheme === "file"
          ? (s = U3.file(Ve.join(x_(t, !0), ...e)).path)
          : (s = Wt.join(t.path, ...e)),
        t.with({ path: s })
      )
    }
    toString(t = !1) {
      return N7(this, t)
    }
    toJSON() {
      return this
    }
    static revive(t) {
      if (t) {
        if (t instanceof U3) return t
        {
          const e = new dc(t)
          return (
            (e._formatted = t.external ?? null),
            (e._fsPath = t._sep === DG ? (t.fsPath ?? null) : null),
            e
          )
        }
      } else return t
    }
    [Symbol.for("debug.description")]() {
      return `URI(${this.toString()})`
    }
  }
function RG(i) {
  return !i || typeof i != "object"
    ? !1
    : typeof i.scheme == "string" &&
        (typeof i.authority == "string" || typeof i.authority > "u") &&
        (typeof i.path == "string" || typeof i.path > "u") &&
        (typeof i.query == "string" || typeof i.query > "u") &&
        (typeof i.fragment == "string" || typeof i.fragment > "u")
}
var DG = ie ? 1 : void 0,
  dc = class extends S {
    constructor() {
      super(...arguments), (this._formatted = null), (this._fsPath = null)
    }
    get fsPath() {
      return this._fsPath || (this._fsPath = x_(this, !1)), this._fsPath
    }
    toString(i = !1) {
      return i
        ? N7(this, !0)
        : (this._formatted || (this._formatted = N7(this, !1)), this._formatted)
    }
    toJSON() {
      const i = { $mid: 1 }
      return (
        this._fsPath && ((i.fsPath = this._fsPath), (i._sep = DG)),
        this._formatted && (i.external = this._formatted),
        this.path && (i.path = this.path),
        this.scheme && (i.scheme = this.scheme),
        this.authority && (i.authority = this.authority),
        this.query && (i.query = this.query),
        this.fragment && (i.fragment = this.fragment),
        i
      )
    }
  },
  FG = {
    58: "%3A",
    47: "%2F",
    63: "%3F",
    35: "%23",
    91: "%5B",
    93: "%5D",
    64: "%40",
    33: "%21",
    36: "%24",
    38: "%26",
    39: "%27",
    40: "%28",
    41: "%29",
    42: "%2A",
    43: "%2B",
    44: "%2C",
    59: "%3B",
    61: "%3D",
    32: "%20",
  }
function AG(i, t, e) {
  let s,
    r = -1
  for (let a = 0; a < i.length; a++) {
    const o = i.charCodeAt(a)
    if (
      (o >= 97 && o <= 122) ||
      (o >= 65 && o <= 90) ||
      (o >= 48 && o <= 57) ||
      o === 45 ||
      o === 46 ||
      o === 95 ||
      o === 126 ||
      (t && o === 47) ||
      (e && o === 91) ||
      (e && o === 93) ||
      (e && o === 58)
    )
      r !== -1 && ((s += encodeURIComponent(i.substring(r, a))), (r = -1)),
        s !== void 0 && (s += i.charAt(a))
    else {
      s === void 0 && (s = i.substr(0, a))
      const c = FG[o]
      c !== void 0
        ? (r !== -1 && ((s += encodeURIComponent(i.substring(r, a))), (r = -1)),
          (s += c))
        : r === -1 && (r = a)
    }
  }
  return (
    r !== -1 && (s += encodeURIComponent(i.substring(r))), s !== void 0 ? s : i
  )
}
function ymt(i) {
  let t
  for (let e = 0; e < i.length; e++) {
    const s = i.charCodeAt(e)
    s === 35 || s === 63
      ? (t === void 0 && (t = i.substr(0, e)), (t += FG[s]))
      : t !== void 0 && (t += i[e])
  }
  return t !== void 0 ? t : i
}
function x_(i, t) {
  let e
  return (
    i.authority && i.path.length > 1 && i.scheme === "file"
      ? (e = `//${i.authority}${i.path}`)
      : i.path.charCodeAt(0) === 47 &&
          ((i.path.charCodeAt(1) >= 65 && i.path.charCodeAt(1) <= 90) ||
            (i.path.charCodeAt(1) >= 97 && i.path.charCodeAt(1) <= 122)) &&
          i.path.charCodeAt(2) === 58
        ? t
          ? (e = i.path.substr(1))
          : (e = i.path[1].toLowerCase() + i.path.substr(2))
        : (e = i.path),
    ie && (e = e.replace(/\//g, "\\")),
    e
  )
}
function N7(i, t) {
  const e = t ? ymt : AG
  let s = "",
    { scheme: r, authority: a, path: o, query: c, fragment: l } = i
  if (
    (r && ((s += r), (s += ":")),
    (a || r === "file") && ((s += js), (s += js)),
    a)
  ) {
    let u = a.indexOf("@")
    if (u !== -1) {
      const d = a.substr(0, u)
      ;(a = a.substr(u + 1)),
        (u = d.lastIndexOf(":")),
        u === -1
          ? (s += e(d, !1, !1))
          : ((s += e(d.substr(0, u), !1, !1)),
            (s += ":"),
            (s += e(d.substr(u + 1), !1, !0))),
        (s += "@")
    }
    ;(a = a.toLowerCase()),
      (u = a.lastIndexOf(":")),
      u === -1
        ? (s += e(a, !1, !0))
        : ((s += e(a.substr(0, u), !1, !0)), (s += a.substr(u)))
  }
  if (o) {
    if (o.length >= 3 && o.charCodeAt(0) === 47 && o.charCodeAt(2) === 58) {
      const u = o.charCodeAt(1)
      u >= 65 &&
        u <= 90 &&
        (o = `/${String.fromCharCode(u + 32)}:${o.substr(3)}`)
    } else if (o.length >= 2 && o.charCodeAt(1) === 58) {
      const u = o.charCodeAt(0)
      u >= 65 &&
        u <= 90 &&
        (o = `${String.fromCharCode(u + 32)}:${o.substr(2)}`)
    }
    s += e(o, !0, !1)
  }
  return (
    c && ((s += "?"), (s += e(c, !1, !1))),
    l && ((s += "#"), (s += t ? l : AG(l, !1, !1))),
    s
  )
}
function _G(i) {
  try {
    return decodeURIComponent(i)
  } catch {
    return i.length > 3 ? i.substr(0, 3) + _G(i.substr(3)) : i
  }
}
var OG = /(%[0-9A-Za-z][0-9A-Za-z])+/g
function N_(i) {
  return i.match(OG) ? i.replace(OG, (t) => _G(t)) : i
}
var G
;(function (i) {
  ;(i.inMemory = "inmemory"),
    (i.vscode = "vscode"),
    (i.internal = "private"),
    (i.walkThrough = "walkThrough"),
    (i.walkThroughSnippet = "walkThroughSnippet"),
    (i.http = "http"),
    (i.https = "https"),
    (i.file = "file"),
    (i.mailto = "mailto"),
    (i.untitled = "untitled"),
    (i.data = "data"),
    (i.command = "command"),
    (i.vscodeRemote = "vscode-remote"),
    (i.vscodeRemoteResource = "vscode-remote-resource"),
    (i.vscodeManagedRemoteResource = "vscode-managed-remote-resource"),
    (i.vscodeUserData = "vscode-userdata"),
    (i.vscodeCustomEditor = "vscode-custom-editor"),
    (i.vscodeNotebook = "vscode-notebook"),
    (i.vscodeNotebookCell = "vscode-notebook-cell"),
    (i.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata"),
    (i.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff"),
    (i.vscodeNotebookCellOutput = "vscode-notebook-cell-output"),
    (i.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff"),
    (i.vscodeNotebookMetadata = "vscode-notebook-metadata"),
    (i.vscodeInteractiveInput = "vscode-interactive-input"),
    (i.vscodeSettings = "vscode-settings"),
    (i.vscodeWorkspaceTrust = "vscode-workspace-trust"),
    (i.vscodeTerminal = "vscode-terminal"),
    (i.vscodeChatCodeBlock = "vscode-chat-code-block"),
    (i.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block"),
    (i.vscodeChatSesssion = "vscode-chat-editor"),
    (i.webviewPanel = "webview-panel"),
    (i.vscodeWebview = "vscode-webview"),
    (i.extension = "extension"),
    (i.aiChat = "cursor.aichat"),
    (i.notepad = "cursor.notepad"),
    (i.contextObject = "cursor.context-object"),
    (i.composer = "cursor.composer"),
    (i.aiSettings = "cursor.aisettings"),
    (i.tinderDiffEditor = "cursor.tinderdiffeditor"),
    (i.aiReader = "cursor.aireader"),
    (i.vscodeFileResource = "vscode-file"),
    (i.tmp = "tmp"),
    (i.vsls = "vsls"),
    (i.vscodeSourceControl = "vscode-scm"),
    (i.commentsInput = "comment"),
    (i.codeSetting = "code-setting"),
    (i.cursorDev = "cursor-dev"),
    (i.outputChannel = "output"),
    (i.accessibleView = "accessible-view"),
    (i.bugbot = "cursor.bugbot")
})(G || (G = {}))
function C7(i, t) {
  return S.isUri(i) ? Ws(i.scheme, t) : I_(i, t + ":")
}
function bmt(i, ...t) {
  return t.some((e) => C7(i, e))
}
var Tmt = "tkn",
  kmt = class {
    constructor() {
      ;(this.a = Object.create(null)),
        (this.b = Object.create(null)),
        (this.c = Object.create(null)),
        (this.d = "http"),
        (this.e = null),
        (this.f = "/")
    }
    setPreferredWebSchema(i) {
      this.d = i
    }
    setDelegate(i) {
      this.e = i
    }
    setServerRootPath(i, t) {
      this.f = Smt(i, t)
    }
    getServerRootPath() {
      return this.f
    }
    get g() {
      return Wt.join(this.f, G.vscodeRemoteResource)
    }
    set(i, t, e) {
      ;(this.a[i] = t), (this.b[i] = e)
    }
    setConnectionToken(i, t) {
      this.c[i] = t
    }
    getPreferredWebSchema() {
      return this.d
    }
    rewrite(i) {
      if (this.e)
        try {
          return this.e(i)
        } catch (o) {
          return $e(o), i
        }
      const t = i.authority
      let e = this.a[t]
      e && e.indexOf(":") !== -1 && e.indexOf("[") === -1 && (e = `[${e}]`)
      const s = this.b[t],
        r = this.c[t]
      let a = `path=${encodeURIComponent(i.path)}`
      return (
        typeof r == "string" && (a += `&${Tmt}=${encodeURIComponent(r)}`),
        S.from({
          scheme: v7 ? this.d : G.vscodeRemoteResource,
          authority: `${e}:${s}`,
          path: this.g,
          query: a,
        })
      )
    }
  },
  BG = new kmt()
function Smt(i, t) {
  return Wt.join(t ?? "/", `${i.quality ?? "oss"}-${i.commit ?? "dev"}`)
}
var qG = "vscode-app",
  Emt = class M3 {
    static {
      this.a = qG
    }
    asBrowserUri(t) {
      const e = this.b(t)
      return this.uriToBrowserUri(e)
    }
    uriToBrowserUri(t) {
      return t.scheme === G.vscodeRemote
        ? BG.rewrite(t)
        : t.scheme === G.file &&
            (ZV || pdt === `${G.vscodeFileResource}://${M3.a}`)
          ? t.with({
              scheme: G.vscodeFileResource,
              authority: t.authority || M3.a,
              query: null,
              fragment: null,
            })
          : t
    }
    asFileUri(t) {
      const e = this.b(t)
      return this.uriToFileUri(e)
    }
    uriToFileUri(t) {
      return t.scheme === G.vscodeFileResource
        ? t.with({
            scheme: G.file,
            authority: t.authority !== M3.a ? t.authority : null,
            query: null,
            fragment: null,
          })
        : t
    }
    b(t, e) {
      if (S.isUri(t)) return t
      if (globalThis._VSCODE_FILE_ROOT) {
        const s = globalThis._VSCODE_FILE_ROOT
        if (/^\w[\w\d+.-]*:\/\//.test(s)) return S.joinPath(S.parse(s, !0), t)
        const r = se(s, t)
        return S.file(r)
      }
      return S.parse(e.toUrl(t))
    }
  },
  UG = new Emt(),
  MG
;(function (i) {
  const t = new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    [
      "3",
      {
        "Cross-Origin-Opener-Policy": "same-origin",
        "Cross-Origin-Embedder-Policy": "require-corp",
      },
    ],
  ])
  i.CoopAndCoep = Object.freeze(t.get("3"))
  const e = "vscode-coi"
  function s(a) {
    let o
    typeof a == "string"
      ? (o = new URL(a).searchParams)
      : a instanceof URL
        ? (o = a.searchParams)
        : S.isUri(a) && (o = new URL(a.toString(!0)).searchParams)
    const c = o?.get(e)
    if (c) return t.get(c)
  }
  i.getHeadersFromQuery = s
  function r(a, o, c) {
    if (!globalThis.crossOriginIsolated) return
    const l = o && c ? "3" : c ? "2" : "1"
    a instanceof URLSearchParams ? a.set(e, l) : (a[e] = l)
  }
  i.addSearchParam = r
})(MG || (MG = {}))
function Vs(i) {
  return x_(i, !0)
}
var Uu = class {
    constructor(i) {
      this.a = i
    }
    compare(i, t, e = !1) {
      return i === t
        ? 0
        : Ha(this.getComparisonKey(i, e), this.getComparisonKey(t, e))
    }
    isEqual(i, t, e = !1) {
      return i === t
        ? !0
        : !i || !t
          ? !1
          : this.getComparisonKey(i, e) === this.getComparisonKey(t, e)
    }
    getComparisonKey(i, t = !1) {
      return i
        .with({
          path: this.a(i) ? i.path.toLowerCase() : void 0,
          fragment: t ? null : void 0,
        })
        .toString()
    }
    ignorePathCasing(i) {
      return this.a(i)
    }
    isEqualOrParent(i, t, e = !1) {
      if (i.scheme === t.scheme) {
        if (i.scheme === G.file)
          return (
            ja(Vs(i), Vs(t), this.a(i)) &&
            i.query === t.query &&
            (e || i.fragment === t.fragment)
          )
        if (jG(i.authority, t.authority))
          return (
            ja(i.path, t.path, this.a(i), "/") &&
            i.query === t.query &&
            (e || i.fragment === t.fragment)
          )
      }
      return !1
    }
    joinPath(i, ...t) {
      return S.joinPath(i, ...t)
    }
    basenameOrAuthority(i) {
      return xr(i) || i.authority
    }
    basename(i) {
      return Wt.basename(i.path)
    }
    extname(i) {
      return Wt.extname(i.path)
    }
    dirname(i) {
      if (i.path.length === 0) return i
      let t
      return (
        i.scheme === G.file
          ? (t = S.file(Ui(Vs(i))).path)
          : ((t = Wt.dirname(i.path)),
            i.authority &&
              t.length &&
              t.charCodeAt(0) !== 47 &&
              (console.error(
                `dirname("${i.toString})) resulted in a relative path`,
              ),
              (t = "/"))),
        i.with({ path: t })
      )
    }
    normalizePath(i) {
      if (!i.path.length) return i
      let t
      return (
        i.scheme === G.file
          ? (t = S.file(Xr(Vs(i))).path)
          : (t = Wt.normalize(i.path)),
        i.with({ path: t })
      )
    }
    relativePath(i, t) {
      if (i.scheme !== t.scheme || !jG(i.authority, t.authority)) return
      if (i.scheme === G.file) {
        const r = uc(Vs(i), Vs(t))
        return ie ? NG(r) : r
      }
      let e = i.path || "/"
      const s = t.path || "/"
      if (this.a(i)) {
        let r = 0
        for (
          const a = Math.min(e.length, s.length);
          r < a &&
          !(
            e.charCodeAt(r) !== s.charCodeAt(r) &&
            e.charAt(r).toLowerCase() !== s.charAt(r).toLowerCase()
          );
          r++
        );
        e = s.substr(0, r) + e.substr(r)
      }
      return Wt.relative(e, s)
    }
    resolvePath(i, t) {
      if (i.scheme === G.file) {
        const e = S.file(Ndt(Vs(i), t))
        return i.with({ authority: e.authority, path: e.path })
      }
      return (t = smt(t)), i.with({ path: Wt.resolve(i.path, t) })
    }
    isAbsolutePath(i) {
      return !!i.path && i.path[0] === "/"
    }
    isEqualAuthority(i, t) {
      return i === t || (i !== void 0 && t !== void 0 && Ws(i, t))
    }
    hasTrailingPathSeparator(i, t = xe) {
      if (i.scheme === G.file) {
        const e = Vs(i)
        return e.length > P7(e).length && e[e.length - 1] === t
      } else {
        const e = i.path
        return (
          e.length > 1 &&
          e.charCodeAt(e.length - 1) === 47 &&
          !/^[a-zA-Z]:(\/$|\\$)/.test(i.fsPath)
        )
      }
    }
    removeTrailingPathSeparator(i, t = xe) {
      return VG(i, t)
        ? i.with({ path: i.path.substr(0, i.path.length - 1) })
        : i
    }
    addTrailingPathSeparator(i, t = xe) {
      let e = !1
      if (i.scheme === G.file) {
        const s = Vs(i)
        e = s !== void 0 && s.length === P7(s).length && s[s.length - 1] === t
      } else {
        t = "/"
        const s = i.path
        e = s.length === 1 && s.charCodeAt(s.length - 1) === 47
      }
      return !e && !VG(i, t) ? i.with({ path: i.path + "/" }) : i
    }
  },
  Xt = new Uu(() => !1),
  J7 = new Uu((i) => (i.scheme === G.file ? !De : !0)),
  Imt = new Uu((i) => !0),
  HG = Xt.isEqual.bind(Xt),
  bjt = Xt.isEqualOrParent.bind(Xt),
  Tjt = Xt.getComparisonKey.bind(Xt),
  L7 = Xt.basenameOrAuthority.bind(Xt),
  xr = Xt.basename.bind(Xt),
  Pmt = Xt.extname.bind(Xt),
  C_ = Xt.dirname.bind(Xt),
  He = Xt.joinPath.bind(Xt),
  kjt = Xt.normalizePath.bind(Xt),
  WG = Xt.relativePath.bind(Xt),
  Sjt = Xt.resolvePath.bind(Xt),
  $mt = Xt.isAbsolutePath.bind(Xt),
  jG = Xt.isEqualAuthority.bind(Xt),
  VG = Xt.hasTrailingPathSeparator.bind(Xt),
  Ejt = Xt.removeTrailingPathSeparator.bind(Xt),
  Ijt = Xt.addTrailingPathSeparator.bind(Xt),
  GG
;(function (i) {
  ;(i.META_DATA_LABEL = "label"),
    (i.META_DATA_DESCRIPTION = "description"),
    (i.META_DATA_SIZE = "size"),
    (i.META_DATA_MIME = "mime")
  function t(e) {
    const s = new Map()
    e.path
      .substring(e.path.indexOf(";") + 1, e.path.lastIndexOf(";"))
      .split(";")
      .forEach((o) => {
        const [c, l] = o.split(":")
        c && l && s.set(c, l)
      })
    const a = e.path.substring(0, e.path.indexOf(";"))
    return a && s.set(i.META_DATA_MIME, a), s
  }
  i.parseMetaData = t
})(GG || (GG = {}))
var xmt = Symbol("MicrotaskDelay")
function Kr(i) {
  return !!i && typeof i.then == "function"
}
function Zr(i) {
  const t = new fe(),
    e = i(t.token),
    s = new Promise((r, a) => {
      const o = t.token.onCancellationRequested(() => {
        o.dispose(), a(new bi())
      })
      Promise.resolve(e).then(
        (c) => {
          o.dispose(), t.dispose(), r(c)
        },
        (c) => {
          o.dispose(), t.dispose(), a(c)
        },
      )
    })
  return new (class {
    cancel() {
      t.cancel(), t.dispose()
    }
    then(r, a) {
      return s.then(r, a)
    }
    catch(r) {
      return this.then(void 0, r)
    }
    finally(r) {
      return s.finally(r)
    }
  })()
}
function zG(i, t, e) {
  return new Promise((s, r) => {
    const a = t.onCancellationRequested(() => {
      a.dispose(), s(e)
    })
    i.then(s, r).finally(() => a.dispose())
  })
}
function Nmt(i, t) {
  return new Promise((e, s) => {
    const r = t.onCancellationRequested(() => {
      r.dispose(), s(new bi())
    })
    i.then(e, s).finally(() => r.dispose())
  })
}
function Ci(i) {
  return new Promise((t, e) => {
    const s = i()
    Kr(s) ? s.then(t, e) : t(s)
  })
}
function YG() {
  let i, t
  return {
    promise: new Promise((s, r) => {
      ;(i = s), (t = r)
    }),
    resolve: i,
    reject: t,
  }
}
var Cmt = class {
    constructor() {
      ;(this.f = !1), (this.a = null), (this.b = null), (this.d = null)
    }
    queue(i) {
      if (this.f) return Promise.reject(new Error("Throttler is disposed"))
      if (this.a) {
        if (((this.d = i), !this.b)) {
          const t = () => {
            if (((this.b = null), this.f)) return
            const e = this.queue(this.d)
            return (this.d = null), e
          }
          this.b = new Promise((e) => {
            this.a.then(t, t).then(e)
          })
        }
        return new Promise((t, e) => {
          this.b.then(t, e)
        })
      }
      return (
        (this.a = i()),
        new Promise((t, e) => {
          this.a.then(
            (s) => {
              ;(this.a = null), t(s)
            },
            (s) => {
              ;(this.a = null), e(s)
            },
          )
        })
      )
    }
    dispose() {
      this.f = !0
    }
  },
  Jmt = (i, t) => {
    let e = !0
    const s = setTimeout(() => {
      ;(e = !1), t()
    }, i)
    return {
      isTriggered: () => e,
      dispose: () => {
        clearTimeout(s), (e = !1)
      },
    }
  },
  Lmt = (i) => {
    let t = !0
    return (
      queueMicrotask(() => {
        t && ((t = !1), i())
      }),
      {
        isTriggered: () => t,
        dispose: () => {
          t = !1
        },
      }
    )
  },
  QG = class {
    constructor(i) {
      ;(this.defaultDelay = i),
        (this.a = null),
        (this.b = null),
        (this.d = null),
        (this.f = null),
        (this.g = null)
    }
    trigger(i, t = this.defaultDelay) {
      ;(this.g = i),
        this.h(),
        this.b ||
          (this.b = new Promise((s, r) => {
            ;(this.d = s), (this.f = r)
          }).then(() => {
            if (((this.b = null), (this.d = null), this.g)) {
              const s = this.g
              return (this.g = null), s()
            }
          }))
      const e = () => {
        ;(this.a = null), this.d?.(null)
      }
      return (this.a = t === xmt ? Lmt(e) : Jmt(t, e)), this.b
    }
    isTriggered() {
      return !!this.a?.isTriggered()
    }
    cancel() {
      this.h(), this.b && (this.f?.(new bi()), (this.b = null))
    }
    h() {
      this.a?.dispose(), (this.a = null)
    }
    dispose() {
      this.cancel()
    }
  },
  J_ = class {
    constructor(i) {
      ;(this.a = new QG(i)), (this.b = new Cmt())
    }
    trigger(i, t) {
      return this.a.trigger(() => this.b.queue(i), t)
    }
    isTriggered() {
      return this.a.isTriggered()
    }
    cancel() {
      this.a.cancel()
    }
    dispose() {
      this.a.dispose(), this.b.dispose()
    }
  },
  Ns = class {
    constructor() {
      ;(this.a = !1),
        (this.b = new Promise((i, t) => {
          this.d = i
        }))
    }
    isOpen() {
      return this.a
    }
    open() {
      ;(this.a = !0), this.d(!0)
    }
    wait() {
      return this.b
    }
  }
function Fi(i, t) {
  return t
    ? new Promise((e, s) => {
        const r = setTimeout(() => {
            a.dispose(), e()
          }, i),
          a = t.onCancellationRequested(() => {
            clearTimeout(r), a.dispose(), s(new bi())
          })
      })
    : Zr((e) => Fi(i, e))
}
function XG(i, t = 0, e) {
  const s = setTimeout(() => {
      i(), e && r.dispose()
    }, t),
    r = et(() => {
      clearTimeout(s), e?.deleteAndLeak(r)
    })
  return e?.add(r), r
}
function Rmt(i, t = (s) => !!s, e = null) {
  if (i.length === 0) return Promise.resolve(e)
  let s = i.length
  const r = () => {
    s = -1
    for (const a of i) a.cancel?.()
  }
  return new Promise((a, o) => {
    for (const c of i)
      c.then((l) => {
        --s >= 0 && t(l) ? (r(), a(l)) : s === 0 && a(e)
      }).catch((l) => {
        --s >= 0 && (r(), o(l))
      })
  })
}
var Dmt = class {
    constructor(i) {
      ;(this.a = 0),
        (this.b = !1),
        (this.f = i),
        (this.g = []),
        (this.d = 0),
        (this.h = new J())
    }
    whenIdle() {
      return this.size > 0 ? Qt.toPromise(this.onDrained) : Promise.resolve()
    }
    get onDrained() {
      return this.h.event
    }
    get size() {
      return this.a
    }
    queue(i) {
      if (this.b) throw new Error("Object has been disposed")
      return (
        this.a++,
        new Promise((t, e) => {
          this.g.push({ factory: i, c: t, e }), this.j()
        })
      )
    }
    j() {
      for (; this.g.length && this.d < this.f; ) {
        const i = this.g.shift()
        this.d++
        const t = i.factory()
        t.then(i.c, i.e),
          t.then(
            () => this.k(),
            () => this.k(),
          )
      }
    }
    k() {
      this.b ||
        (this.d--,
        --this.a === 0 && this.h.fire(),
        this.g.length > 0 && this.j())
    }
    clear() {
      if (this.b) throw new Error("Object has been disposed")
      ;(this.g.length = 0), (this.a = this.d)
    }
    dispose() {
      ;(this.b = !0), (this.g.length = 0), (this.a = 0), this.h.dispose()
    }
  },
  Fmt = class extends Dmt {
    constructor() {
      super(1)
    }
  },
  KG = class {
    constructor() {
      ;(this.a = new Map()),
        (this.b = new Set()),
        (this.d = void 0),
        (this.f = 0)
    }
    async whenDrained() {
      if (this.g()) return
      const i = new Yn()
      return this.b.add(i), i.p
    }
    g() {
      for (const [, i] of this.a) if (i.size > 0) return !1
      return !0
    }
    queueSize(i, t = Xt) {
      const e = t.getComparisonKey(i)
      return this.a.get(e)?.size ?? 0
    }
    queueFor(i, t, e = Xt) {
      const s = e.getComparisonKey(i)
      let r = this.a.get(s)
      if (!r) {
        r = new Fmt()
        const a = this.f++,
          o = Qt.once(r.onDrained)(() => {
            r?.dispose(),
              this.a.delete(s),
              this.h(),
              this.d?.deleteAndDispose(a),
              this.d?.size === 0 && (this.d.dispose(), (this.d = void 0))
          })
        this.d || (this.d = new f_()), this.d.set(a, o), this.a.set(s, r)
      }
      return r.queue(t)
    }
    h() {
      this.g() && this.j()
    }
    j() {
      for (const i of this.b) i.complete()
      this.b.clear()
    }
    dispose() {
      for (const [, i] of this.a) i.dispose()
      this.a.clear(), this.j(), this.d?.dispose()
    }
  },
  ZG = class {
    constructor() {
      ;(this.d = void 0), (this.f = !1)
    }
    cancel() {
      this.d?.dispose(), (this.d = void 0)
    }
    cancelAndSet(i, t, e = globalThis) {
      if (this.f)
        throw new nc("Calling 'cancelAndSet' on a disposed IntervalTimer")
      this.cancel()
      const s = e.setInterval(() => {
        i()
      }, t)
      this.d = et(() => {
        e.clearInterval(s), (this.d = void 0)
      })
    }
    dispose() {
      this.cancel(), (this.f = !0)
    }
  },
  tn = class {
    constructor(i, t) {
      ;(this.b = -1), (this.a = i), (this.d = t), (this.f = this.g.bind(this))
    }
    dispose() {
      this.cancel(), (this.a = null)
    }
    cancel() {
      this.isScheduled() && (clearTimeout(this.b), (this.b = -1))
    }
    schedule(i = this.d) {
      this.cancel(), (this.b = setTimeout(this.f, i))
    }
    get delay() {
      return this.d
    }
    set delay(i) {
      this.d = i
    }
    isScheduled() {
      return this.b !== -1
    }
    flush() {
      this.isScheduled() && (this.cancel(), this.h())
    }
    g() {
      ;(this.b = -1), this.a && this.h()
    }
    h() {
      this.a?.()
    }
  },
  tz = class {
    constructor(i, t) {
      t % 1e3 !== 0 &&
        console.warn(
          `ProcessTimeRunOnceScheduler resolution is 1s, ${t}ms is not a multiple of 1000ms.`,
        ),
        (this.a = i),
        (this.b = t),
        (this.d = 0),
        (this.f = -1),
        (this.g = this.h.bind(this))
    }
    dispose() {
      this.cancel(), (this.a = null)
    }
    cancel() {
      this.isScheduled() && (clearInterval(this.f), (this.f = -1))
    }
    schedule(i = this.b) {
      i % 1e3 !== 0 &&
        console.warn(
          `ProcessTimeRunOnceScheduler resolution is 1s, ${i}ms is not a multiple of 1000ms.`,
        ),
        this.cancel(),
        (this.d = Math.ceil(i / 1e3)),
        (this.f = setInterval(this.g, 1e3))
    }
    isScheduled() {
      return this.f !== -1
    }
    h() {
      this.d--,
        !(this.d > 0) && (clearInterval(this.f), (this.f = -1), this.a?.())
    }
  },
  Amt = class extends tn {
    constructor(i, t) {
      super(i, t), (this.j = [])
    }
    work(i) {
      this.j.push(i), this.isScheduled() || this.schedule()
    }
    h() {
      const i = this.j
      ;(this.j = []), this.a?.(i)
    }
    dispose() {
      ;(this.j = []), super.dispose()
    }
  },
  _mt = class extends at {
    constructor(i, t) {
      super(),
        (this.h = i),
        (this.j = t),
        (this.a = []),
        (this.b = this.D(new zr())),
        (this.f = !1),
        (this.g = 0)
    }
    get pending() {
      return this.a.length
    }
    work(i) {
      if (this.f) return !1
      if (typeof this.h.maxBufferedWork == "number") {
        if (this.b.value) {
          if (this.pending + i.length > this.h.maxBufferedWork) return !1
        } else if (
          this.pending + i.length - this.h.maxWorkChunkSize >
          this.h.maxBufferedWork
        )
          return !1
      }
      for (const e of i) this.a.push(e)
      const t = Date.now() - this.g
      return (
        !this.b.value &&
        (!this.h.waitThrottleDelayBetweenWorkUnits || t >= this.h.throttleDelay)
          ? this.m()
          : !this.b.value &&
            this.h.waitThrottleDelayBetweenWorkUnits &&
            this.q(Math.max(this.h.throttleDelay - t, 0)),
        !0
      )
    }
    m() {
      ;(this.g = Date.now()),
        this.j(this.a.splice(0, this.h.maxWorkChunkSize)),
        this.a.length > 0 && this.q()
    }
    q(i = this.h.throttleDelay) {
      ;(this.b.value = new tn(() => {
        this.b.clear(), this.m()
      }, i)),
        this.b.value.schedule()
    }
    dispose() {
      super.dispose(), (this.f = !0)
    }
  },
  ez,
  L_
;(function () {
  typeof globalThis.requestIdleCallback != "function" ||
  typeof globalThis.cancelIdleCallback != "function"
    ? (L_ = (i, t, e) => {
        eG(() => {
          if (s) return
          const r = Date.now() + 15
          t(
            Object.freeze({
              didTimeout: !0,
              timeRemaining() {
                return Math.max(0, r - Date.now())
              },
            }),
          )
        })
        let s = !1
        return {
          dispose() {
            s || (s = !0)
          },
        }
      })
    : (L_ = (i, t, e) => {
        const s = i.requestIdleCallback(
          t,
          typeof e == "number" ? { timeout: e } : void 0,
        )
        let r = !1
        return {
          dispose() {
            r || ((r = !0), i.cancelIdleCallback(s))
          },
        }
      }),
    (ez = (i, t) => L_(globalThis, i, t))
})()
var Omt = class {
    constructor(i, t) {
      ;(this.g = !1),
        (this.d = () => {
          try {
            this.j = t()
          } catch (e) {
            this.l = e
          } finally {
            this.g = !0
          }
        }),
        (this.f = L_(i, () => this.d()))
    }
    dispose() {
      this.f.dispose()
    }
    get value() {
      if ((this.g || (this.f.dispose(), this.d()), this.l)) throw this.l
      return this.j
    }
    get isInitialized() {
      return this.g
    }
  },
  Bmt = class extends Omt {
    constructor(i) {
      super(globalThis, i)
    }
  }
async function qmt(i, t, e) {
  let s
  for (let r = 0; r < e; r++)
    try {
      return await i()
    } catch (a) {
      ;(s = a), await Fi(t)
    }
  throw s
}
var iz
;(function (i) {
  ;(i[(i.Resolved = 0)] = "Resolved"), (i[(i.Rejected = 1)] = "Rejected")
})(iz || (iz = {}))
var Yn = class {
    get isRejected() {
      return this.d?.outcome === 1
    }
    get isResolved() {
      return this.d?.outcome === 0
    }
    get isSettled() {
      return !!this.d
    }
    get value() {
      return this.d?.outcome === 0 ? this.d?.value : void 0
    }
    constructor() {
      this.p = new Promise((i, t) => {
        ;(this.a = i), (this.b = t)
      })
    }
    complete(i) {
      return new Promise((t) => {
        this.a(i), (this.d = { outcome: 0, value: i }), t()
      })
    }
    error(i) {
      return new Promise((t) => {
        this.b(i), (this.d = { outcome: 1, value: i }), t()
      })
    }
    cancel() {
      return this.error(new bi())
    }
  },
  Qn
;(function (i) {
  async function t(s) {
    let r
    const a = await Promise.all(
      s.map((o) =>
        o.then(
          (c) => c,
          (c) => {
            r || (r = c)
          },
        ),
      ),
    )
    if (typeof r < "u") throw r
    return a
  }
  i.settled = t
  function e(s) {
    return new Promise(async (r, a) => {
      try {
        await s(r, a)
      } catch (o) {
        a(o)
      }
    })
  }
  i.withAsyncBody = e
})(Qn || (Qn = {}))
var sz
;(function (i) {
  ;(i[(i.Initial = 0)] = "Initial"),
    (i[(i.DoneOK = 1)] = "DoneOK"),
    (i[(i.DoneError = 2)] = "DoneError")
})(sz || (sz = {}))
var Mu = class Es {
    static fromArray(t) {
      return new Es((e) => {
        e.emitMany(t)
      })
    }
    static fromPromise(t) {
      return new Es(async (e) => {
        e.emitMany(await t)
      })
    }
    static fromPromisesResolveOrder(t) {
      return new Es(async (e) => {
        await Promise.all(t.map(async (s) => e.emitOne(await s)))
      })
    }
    static merge(t) {
      return new Es(async (e) => {
        await Promise.all(
          t.map(async (s) => {
            for await (const r of s) e.emitOne(r)
          }),
        )
      })
    }
    static {
      this.EMPTY = Es.fromArray([])
    }
    constructor(t, e) {
      ;(this.a = 0),
        (this.b = []),
        (this.d = null),
        (this.f = e),
        (this.g = new J()),
        queueMicrotask(async () => {
          const s = {
            emitOne: (r) => this.h(r),
            emitMany: (r) => this.j(r),
            reject: (r) => this.l(r),
          }
          try {
            await Promise.resolve(t(s)), this.k()
          } catch (r) {
            this.l(r)
          } finally {
            ;(s.emitOne = void 0), (s.emitMany = void 0), (s.reject = void 0)
          }
        })
    }
    [Symbol.asyncIterator]() {
      let t = 0
      return {
        next: async () => {
          do {
            if (this.a === 2) throw this.d
            if (t < this.b.length) return { done: !1, value: this.b[t++] }
            if (this.a === 1) return { done: !0, value: void 0 }
            await Qt.toPromise(this.g.event)
          } while (!0)
        },
        return: async () => (this.f?.(), { done: !0, value: void 0 }),
      }
    }
    static map(t, e) {
      return new Es(async (s) => {
        for await (const r of t) s.emitOne(e(r))
      })
    }
    map(t) {
      return Es.map(this, t)
    }
    static filter(t, e) {
      return new Es(async (s) => {
        for await (const r of t) e(r) && s.emitOne(r)
      })
    }
    filter(t) {
      return Es.filter(this, t)
    }
    static coalesce(t) {
      return Es.filter(t, (e) => !!e)
    }
    coalesce() {
      return Es.coalesce(this)
    }
    static async toPromise(t) {
      const e = []
      for await (const s of t) e.push(s)
      return e
    }
    toPromise() {
      return Es.toPromise(this)
    }
    h(t) {
      this.a === 0 && (this.b.push(t), this.g.fire())
    }
    j(t) {
      this.a === 0 && ((this.b = this.b.concat(t)), this.g.fire())
    }
    k() {
      this.a === 0 && ((this.a = 1), this.g.fire())
    }
    l(t) {
      this.a === 0 && ((this.a = 2), (this.d = t), this.g.fire())
    }
  },
  R7 = class {
    constructor(i) {
      ;(this.a = new Yn()),
        (this.b = new Mu((s) => {
          if (t) {
            s.reject(t)
            return
          }
          return (
            e && s.emitMany(e),
            (this.d = (r) => s.reject(r)),
            (this.f = (r) => s.emitOne(r)),
            this.a.p
          )
        }, i))
      let t, e
      ;(this.f = (s) => {
        e || (e = []), e.push(s)
      }),
        (this.d = (s) => {
          t || (t = s)
        })
    }
    get asyncIterable() {
      return this.b
    }
    resolve() {
      this.a.complete()
    }
    reject(i) {
      this.d(i), this.a.complete()
    }
    emitOne(i) {
      this.f(i)
    }
  },
  rz = Object.prototype.toString
function mc(i) {
  switch (rz.call(i)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return !0
    default:
      return Va(i, Error)
  }
}
function D7(i, t) {
  return rz.call(i) === `[object ${t}]`
}
function Hu(i) {
  return D7(i, "String")
}
function Wu(i) {
  return D7(i, "Object")
}
function Umt(i) {
  return typeof Event < "u" && Va(i, Event)
}
function Mmt(i) {
  return typeof Element < "u" && Va(i, Element)
}
function Hmt(i) {
  return D7(i, "RegExp")
}
function F7(i) {
  return !!(i && i.then && typeof i.then == "function")
}
function Wmt(i) {
  return (
    Wu(i) &&
    "nativeEvent" in i &&
    "preventDefault" in i &&
    "stopPropagation" in i
  )
}
function Va(i, t) {
  try {
    return i instanceof t
  } catch {
    return !1
  }
}
function nz(i) {
  return !!(typeof i == "object" && i !== null && (i.__isVue || i._isVue))
}
function A7(i, t = 0) {
  return typeof i != "string" || t === 0 || i.length <= t
    ? i
    : `${i.slice(0, t)}...`
}
function az(i, t) {
  if (!Array.isArray(i)) return ""
  const e = []
  for (let s = 0; s < i.length; s++) {
    const r = i[s]
    try {
      nz(r) ? e.push("[VueViewModel]") : e.push(String(r))
    } catch {
      e.push("[value cannot be serialized]")
    }
  }
  return e.join(t)
}
function jmt(i, t, e = !1) {
  return Hu(i)
    ? Hmt(t)
      ? t.test(i)
      : Hu(t)
        ? e
          ? i === t
          : i.includes(t)
        : !1
    : !1
}
function R_(i, t = [], e = !1) {
  return t.some((s) => jmt(i, s, e))
}
function Vmt(i, t, e = 250, s, r, a, o) {
  if (
    !a.exception ||
    !a.exception.values ||
    !o ||
    !Va(o.originalException, Error)
  )
    return
  const c =
    a.exception.values.length > 0
      ? a.exception.values[a.exception.values.length - 1]
      : void 0
  c &&
    (a.exception.values = Gmt(
      _7(i, t, r, o.originalException, s, a.exception.values, c, 0),
      e,
    ))
}
function _7(i, t, e, s, r, a, o, c) {
  if (a.length >= e + 1) return a
  let l = [...a]
  if (Va(s[r], Error)) {
    oz(o, c)
    const u = i(t, s[r]),
      d = l.length
    cz(u, r, d, c), (l = _7(i, t, e, s[r], r, [u, ...l], u, d))
  }
  return (
    Array.isArray(s.errors) &&
      s.errors.forEach((u, d) => {
        if (Va(u, Error)) {
          oz(o, c)
          const m = i(t, u),
            f = l.length
          cz(m, `errors[${d}]`, f, c), (l = _7(i, t, e, u, r, [m, ...l], m, f))
        }
      }),
    l
  )
}
function oz(i, t) {
  ;(i.mechanism = i.mechanism || { type: "generic", handled: !0 }),
    (i.mechanism = {
      ...i.mechanism,
      ...(i.type === "AggregateError" && { is_exception_group: !0 }),
      exception_id: t,
    })
}
function cz(i, t, e, s) {
  ;(i.mechanism = i.mechanism || { type: "generic", handled: !0 }),
    (i.mechanism = {
      ...i.mechanism,
      type: "chained",
      source: t,
      exception_id: e,
      parent_id: s,
    })
}
function Gmt(i, t) {
  return i.map((e) => (e.value && (e.value = A7(e.value, t)), e))
}
var ju = "8.35.0-cursor",
  ci = globalThis
function O7(i, t, e) {
  const s = e || ci,
    r = (s.__SENTRY__ = s.__SENTRY__ || {}),
    a = (r[ju] = r[ju] || {})
  return a[i] || (a[i] = t())
}
var zmt = ci,
  Ymt = 80
function Qmt(i, t = {}) {
  if (!i) return "<unknown>"
  try {
    let e = i
    const s = 5,
      r = []
    let a = 0,
      o = 0
    const c = " > ",
      l = c.length
    let u
    const d = Array.isArray(t) ? t : t.keyAttrs,
      m = (!Array.isArray(t) && t.maxStringLength) || Ymt
    for (
      ;
      e &&
      a++ < s &&
      ((u = Xmt(e, d)),
      !(u === "html" || (a > 1 && o + r.length * l + u.length >= m)));

    )
      r.push(u), (o += u.length), (e = e.parentNode)
    return r.reverse().join(c)
  } catch {
    return "<unknown>"
  }
}
function Xmt(i, t) {
  const e = i,
    s = []
  if (!e || !e.tagName) return ""
  if (zmt.HTMLElement && e instanceof HTMLElement && e.dataset) {
    if (e.dataset.sentryComponent) return e.dataset.sentryComponent
    if (e.dataset.sentryElement) return e.dataset.sentryElement
  }
  s.push(e.tagName.toLowerCase())
  const r =
    t && t.length
      ? t.filter((o) => e.getAttribute(o)).map((o) => [o, e.getAttribute(o)])
      : null
  if (r && r.length)
    r.forEach((o) => {
      s.push(`[${o[0]}="${o[1]}"]`)
    })
  else {
    e.id && s.push(`#${e.id}`)
    const o = e.className
    if (o && Hu(o)) {
      const c = o.split(/\s+/)
      for (const l of c) s.push(`.${l}`)
    }
  }
  const a = ["aria-label", "type", "name", "title", "alt"]
  for (const o of a) {
    const c = e.getAttribute(o)
    c && s.push(`[${o}="${c}"]`)
  }
  return s.join("")
}
var B7 = !1,
  Kmt = "Sentry Logger ",
  D_ = ["debug", "info", "warn", "error", "log", "assert", "trace"],
  F_ = {}
function lz(i) {
  if (!("console" in ci)) return i()
  const t = ci.console,
    e = {},
    s = Object.keys(F_)
  s.forEach((r) => {
    const a = F_[r]
    ;(e[r] = t[r]), (t[r] = a)
  })
  try {
    return i()
  } finally {
    s.forEach((r) => {
      t[r] = e[r]
    })
  }
}
function Zmt() {
  let i = !1
  const t = {
    enable: () => {
      i = !0
    },
    disable: () => {
      i = !1
    },
    isEnabled: () => i,
  }
  return (
    B7
      ? D_.forEach((e) => {
          t[e] = (...s) => {
            i &&
              lz(() => {
                ci.console[e](`${Kmt}[${e}]:`, ...s)
              })
          }
        })
      : D_.forEach((e) => {
          t[e] = () => {}
        }),
    t
  )
}
var Ee = O7("logger", Zmt)
function tft(i, t = !1) {
  const {
    host: e,
    path: s,
    pass: r,
    port: a,
    projectId: o,
    protocol: c,
    publicKey: l,
  } = i
  return `${c}://${l}${t && r ? `:${r}` : ""}@${e}${a ? `:${a}` : ""}/${s && `${s}/`}${o}`
}
var uz = class extends Error {
  constructor(i, t = "warn") {
    super(i),
      (this.message = i),
      (this.name = new.target.prototype.constructor.name),
      Object.setPrototypeOf(this, new.target.prototype),
      (this.logLevel = t)
  }
}
function eft(i, t, e) {
  if (!(t in i)) return
  const s = i[t],
    r = e(s)
  typeof r == "function" && ift(r, s), (i[t] = r)
}
function Xn(i, t, e) {
  try {
    Object.defineProperty(i, t, { value: e, writable: !0, configurable: !0 })
  } catch {
    B7 && Ee.log(`Failed to add non-enumerable property "${t}" to object`, i)
  }
}
function ift(i, t) {
  try {
    const e = t.prototype || {}
    ;(i.prototype = t.prototype = e), Xn(i, "__sentry_original__", t)
  } catch {}
}
function sft(i) {
  return i.__sentry_original__
}
function rft(i) {
  if (mc(i))
    return { message: i.message, name: i.name, stack: i.stack, ...dz(i) }
  if (Umt(i)) {
    const t = {
      type: i.type,
      target: hz(i.target),
      currentTarget: hz(i.currentTarget),
      ...dz(i),
    }
    return (
      typeof CustomEvent < "u" && Va(i, CustomEvent) && (t.detail = i.detail), t
    )
  } else return i
}
function hz(i) {
  try {
    return Mmt(i) ? Qmt(i) : Object.prototype.toString.call(i)
  } catch {
    return "<unknown>"
  }
}
function dz(i) {
  if (typeof i == "object" && i !== null) {
    const t = {}
    for (const e in i)
      Object.prototype.hasOwnProperty.call(i, e) && (t[e] = i[e])
    return t
  } else return {}
}
function fc(i) {
  return q7(i, new Map())
}
function q7(i, t) {
  if (nft(i)) {
    const e = t.get(i)
    if (e !== void 0) return e
    const s = {}
    t.set(i, s)
    for (const r of Object.getOwnPropertyNames(i))
      typeof i[r] < "u" && (s[r] = q7(i[r], t))
    return s
  }
  if (Array.isArray(i)) {
    const e = t.get(i)
    if (e !== void 0) return e
    const s = []
    return (
      t.set(i, s),
      i.forEach((r) => {
        s.push(q7(r, t))
      }),
      s
    )
  }
  return i
}
function nft(i) {
  if (!Wu(i)) return !1
  try {
    const t = Object.getPrototypeOf(i).constructor.name
    return !t || t === "Object"
  } catch {
    return !0
  }
}
var U7 = "<anonymous>"
function mz(i) {
  try {
    return !i || typeof i != "function" ? U7 : i.name || U7
  } catch {
    return U7
  }
}
function M7(i) {
  const t = i.exception
  if (t) {
    const e = []
    try {
      return (
        t.values.forEach((s) => {
          s.stacktrace.frames && e.push(...s.stacktrace.frames)
        }),
        e
      )
    } catch {
      return
    }
  }
}
var A_ = {},
  fz = {}
function aft(i, t) {
  ;(A_[i] = A_[i] || []), A_[i].push(t)
}
function oft(i, t) {
  fz[i] || (t(), (fz[i] = !0))
}
function cft(i, t) {
  const e = i && A_[i]
  if (e)
    for (const s of e)
      try {
        s(t)
      } catch (r) {
        B7 &&
          Ee.error(
            `Error while triggering instrumentation handler.
Type: ${i}
Name: ${mz(s)}
Error:`,
            r,
          )
      }
}
function lft(i) {
  const t = "console"
  aft(t, i), oft(t, uft)
}
function uft() {
  "console" in ci &&
    D_.forEach(function (i) {
      i in ci.console &&
        eft(ci.console, i, function (t) {
          return (
            (F_[i] = t),
            function (...e) {
              cft("console", { args: e, level: i })
              const r = F_[i]
              r && r.apply(ci.console, e)
            }
          )
        })
    })
}
var pz = 1e3
function gz() {
  return Date.now() / pz
}
function hft() {
  const { performance: i } = ci
  if (!i || !i.now) return gz
  const t = Date.now() - i.now(),
    e = i.timeOrigin == null ? t : i.timeOrigin
  return () => (e + i.now()) / pz
}
var pc = hft(),
  __,
  Pjt = (() => {
    const { performance: i } = ci
    if (!i || !i.now) {
      __ = "none"
      return
    }
    const t = 3600 * 1e3,
      e = i.now(),
      s = Date.now(),
      r = i.timeOrigin ? Math.abs(i.timeOrigin + e - s) : t,
      a = r < t,
      o = i.timing && i.timing.navigationStart,
      l = typeof o == "number" ? Math.abs(o + e - s) : t,
      u = l < t
    return a || u
      ? r <= l
        ? ((__ = "timeOrigin"), i.timeOrigin)
        : ((__ = "navigationStart"), o)
      : ((__ = "dateNow"), s)
  })()
function dft() {
  const i = typeof WeakSet == "function",
    t = i ? new WeakSet() : []
  function e(r) {
    if (i) return t.has(r) ? !0 : (t.add(r), !1)
    for (let a = 0; a < t.length; a++) if (t[a] === r) return !0
    return t.push(r), !1
  }
  function s(r) {
    if (i) t.delete(r)
    else
      for (let a = 0; a < t.length; a++)
        if (t[a] === r) {
          t.splice(a, 1)
          break
        }
  }
  return [e, s]
}
function Gs() {
  const i = ci,
    t = i.crypto || i.msCrypto
  let e = () => Math.random() * 16
  try {
    if (t && t.randomUUID) return t.randomUUID().replace(/-/g, "")
    t &&
      t.getRandomValues &&
      (e = () => {
        const s = new Uint8Array(1)
        return t.getRandomValues(s), s[0]
      })
  } catch {}
  return ("10000000100040008000" + 1e11).replace(/[018]/g, (s) =>
    (s ^ ((e() & 15) >> (s / 4))).toString(16),
  )
}
function vz(i) {
  return i.exception && i.exception.values ? i.exception.values[0] : void 0
}
function Ga(i) {
  const { message: t, event_id: e } = i
  if (t) return t
  const s = vz(i)
  return s
    ? s.type && s.value
      ? `${s.type}: ${s.value}`
      : s.type || s.value || e || "<unknown>"
    : e || "<unknown>"
}
function mft(i, t) {
  const e = vz(i)
  if (!e) return
  const s = { type: "generic", handled: !0 },
    r = e.mechanism
  if (((e.mechanism = { ...s, ...r, ...t }), t && "data" in t)) {
    const a = { ...(r && r.data), ...t.data }
    e.mechanism.data = a
  }
}
function wz(i, t = 100, e = 1 / 0) {
  try {
    return H7("", i, t, e)
  } catch (s) {
    return { ERROR: `**non-serializable** (${s})` }
  }
}
function H7(i, t, e = 1 / 0, s = 1 / 0, r = dft()) {
  const [a, o] = r
  if (
    t == null ||
    ["boolean", "string"].includes(typeof t) ||
    (typeof t == "number" && Number.isFinite(t))
  )
    return t
  const c = fft(i, t)
  if (!c.startsWith("[object ")) return c
  if (t.__sentry_skip_normalization__) return t
  const l =
    typeof t.__sentry_override_normalization_depth__ == "number"
      ? t.__sentry_override_normalization_depth__
      : e
  if (l === 0) return c.replace("object ", "")
  if (a(t)) return "[Circular ~]"
  const u = t
  if (u && typeof u.toJSON == "function")
    try {
      const p = u.toJSON()
      return H7("", p, l - 1, s, r)
    } catch {}
  const d = Array.isArray(t) ? [] : {}
  let m = 0
  const f = rft(t)
  for (const p in f) {
    if (!Object.prototype.hasOwnProperty.call(f, p)) continue
    if (m >= s) {
      d[p] = "[MaxProperties ~]"
      break
    }
    const v = f[p]
    ;(d[p] = H7(p, v, l - 1, s, r)), m++
  }
  return o(t), d
}
function fft(i, t) {
  try {
    if (i === "domain" && t && typeof t == "object" && t._events)
      return "[Domain]"
    if (i === "domainEmitter") return "[DomainEmitter]"
    if (typeof global < "u" && t === global) return "[Global]"
    if (typeof window < "u" && t === window) return "[Window]"
    if (typeof document < "u" && t === document) return "[Document]"
    if (nz(t)) return "[VueViewModel]"
    if (Wmt(t)) return "[SyntheticEvent]"
    if (typeof t == "number" && !Number.isFinite(t)) return `[${t}]`
    if (typeof t == "function") return `[Function: ${mz(t)}]`
    if (typeof t == "symbol") return `[${String(t)}]`
    if (typeof t == "bigint") return `[BigInt: ${String(t)}]`
    const e = pft(t)
    return /^HTML(\w*)Element$/.test(e)
      ? `[HTMLElement: ${e}]`
      : `[object ${e}]`
  } catch (e) {
    return `**non-serializable** (${e})`
  }
}
function pft(i) {
  const t = Object.getPrototypeOf(i)
  return t ? t.constructor.name : "null prototype"
}
function gft(i, t) {
  let e = 0
  for (let s = i.length - 1; s >= 0; s--) {
    const r = i[s]
    r === "."
      ? i.splice(s, 1)
      : r === ".."
        ? (i.splice(s, 1), e++)
        : e && (i.splice(s, 1), e--)
  }
  if (t) for (; e--; e) i.unshift("..")
  return i
}
var vft =
  /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/
function wft(i) {
  const t = i.length > 1024 ? `<truncated>${i.slice(-1024)}` : i,
    e = vft.exec(t)
  return e ? e.slice(1) : []
}
function yz(...i) {
  let t = "",
    e = !1
  for (let s = i.length - 1; s >= -1 && !e; s--) {
    const r = s >= 0 ? i[s] : "/"
    r && ((t = `${r}/${t}`), (e = r.charAt(0) === "/"))
  }
  return (
    (t = gft(
      t.split("/").filter((s) => !!s),
      !e,
    ).join("/")),
    (e ? "/" : "") + t || "."
  )
}
function bz(i) {
  let t = 0
  for (; t < i.length && i[t] === ""; t++);
  let e = i.length - 1
  for (; e >= 0 && i[e] === ""; e--);
  return t > e ? [] : i.slice(t, e - t + 1)
}
function yft(i, t) {
  ;(i = yz(i).slice(1)), (t = yz(t).slice(1))
  const e = bz(i.split("/")),
    s = bz(t.split("/")),
    r = Math.min(e.length, s.length)
  let a = r
  for (let c = 0; c < r; c++)
    if (e[c] !== s[c]) {
      a = c
      break
    }
  let o = []
  for (let c = a; c < e.length; c++) o.push("..")
  return (o = o.concat(s.slice(a))), o.join("/")
}
function bft(i, t) {
  let e = wft(i)[2] || ""
  return (
    t && e.slice(t.length * -1) === t && (e = e.slice(0, e.length - t.length)),
    e
  )
}
var Tz
;(function (i) {
  ;(i[(i.PENDING = 0)] = "PENDING"),
    (i[(i.RESOLVED = 1)] = "RESOLVED"),
    (i[(i.REJECTED = 2)] = "REJECTED")
})(Tz || (Tz = {}))
function Tft(i) {
  return new W7((t) => {
    t(i)
  })
}
function kft(i) {
  return new W7((t, e) => {
    e(i)
  })
}
var W7 = class eV {
  constructor(t) {
    ;(this._resolve = (e) => {
      this._setResult(1, e)
    }),
      (this._reject = (e) => {
        this._setResult(2, e)
      }),
      (this._setResult = (e, s) => {
        if (this._state === 0) {
          if (F7(s)) {
            s.then(this._resolve, this._reject)
            return
          }
          ;(this._state = e), (this._value = s), this._executeHandlers()
        }
      }),
      (this._executeHandlers = () => {
        if (this._state === 0) return
        const e = this._handlers.slice()
        ;(this._handlers = []),
          e.forEach((s) => {
            s[0] ||
              (this._state === 1 && s[1](this._value),
              this._state === 2 && s[2](this._value),
              (s[0] = !0))
          })
      }),
      (this._state = 0),
      (this._handlers = [])
    try {
      t(this._resolve, this._reject)
    } catch (e) {
      this._reject(e)
    }
  }
  then(t, e) {
    return new eV((s, r) => {
      this._handlers.push([
        !1,
        (a) => {
          if (!t) s(a)
          else
            try {
              s(t(a))
            } catch (o) {
              r(o)
            }
        },
        (a) => {
          if (!e) r(a)
          else
            try {
              s(e(a))
            } catch (o) {
              r(o)
            }
        },
      ]),
        this._executeHandlers()
    })
  }
  catch(t) {
    return this.then((e) => e, t)
  }
  finally(t) {
    return new eV((e, s) => {
      let r, a
      return this.then(
        (o) => {
          ;(a = !1), (r = o), t && t()
        },
        (o) => {
          ;(a = !0), (r = o), t && t()
        },
      ).then(() => {
        if (a) {
          s(r)
          return
        }
        e(r)
      })
    })
  }
}
function Sft(i) {
  const t = []
  function e() {
    return i === void 0 || t.length < i
  }
  function s(o) {
    return t.splice(t.indexOf(o), 1)[0] || Promise.resolve(void 0)
  }
  function r(o) {
    if (!e())
      return kft(new uz("Not adding Promise because buffer limit was reached."))
    const c = o()
    return (
      t.indexOf(c) === -1 && t.push(c),
      c.then(() => s(c)).then(null, () => s(c).then(null, () => {})),
      c
    )
  }
  function a(o) {
    return new W7((c, l) => {
      let u = t.length
      if (!u) return c(!0)
      const d = setTimeout(() => {
        o && o > 0 && c(!1)
      }, o)
      t.forEach((m) => {
        Tft(m).then(() => {
          --u || (clearTimeout(d), c(!0))
        }, l)
      })
    })
  }
  return { $: t, add: r, drain: a }
}
function Eft(i) {
  const t = {}
  let e = 0
  for (; e < i.length; ) {
    const s = i.indexOf("=", e)
    if (s === -1) break
    let r = i.indexOf(";", e)
    if (r === -1) r = i.length
    else if (r < s) {
      e = i.lastIndexOf(";", s - 1) + 1
      continue
    }
    const a = i.slice(e, s).trim()
    if (t[a] === void 0) {
      let o = i.slice(s + 1, r).trim()
      o.charCodeAt(0) === 34 && (o = o.slice(1, -1))
      try {
        t[a] = o.indexOf("%") !== -1 ? decodeURIComponent(o) : o
      } catch {
        t[a] = o
      }
    }
    e = r + 1
  }
  return t
}
function Ift(i) {
  return i.split(/[?#]/, 1)[0]
}
var kz = [
  "X-Client-IP",
  "X-Forwarded-For",
  "Fly-Client-IP",
  "CF-Connecting-IP",
  "Fastly-Client-Ip",
  "True-Client-Ip",
  "X-Real-IP",
  "X-Cluster-Client-IP",
  "X-Forwarded",
  "Forwarded-For",
  "Forwarded",
  "X-Vercel-Forwarded-For",
]
function Pft(i) {
  return (
    kz
      .map((r) => {
        const a = i[r],
          o = Array.isArray(a) ? a.join(";") : a
        return r === "Forwarded"
          ? $ft(o)
          : o && o.split(",").map((c) => c.trim())
      })
      .reduce((r, a) => (a ? r.concat(a) : r), [])
      .find((r) => r !== null && xft(r)) || null
  )
}
function $ft(i) {
  if (!i) return null
  for (const t of i.split(";")) if (t.startsWith("for=")) return t.slice(4)
  return null
}
function xft(i) {
  return /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/.test(
    i,
  )
}
var Nft = { ip: !1, request: !0, transaction: !0, user: !0 },
  Sz = ["cookies", "data", "headers", "method", "query_string", "url"],
  Cft = ["id", "username", "email"]
function Ez(i, t = {}) {
  const e = i.method && i.method.toUpperCase()
  let s = "",
    r = "url"
  t.customRoute || i.route
    ? ((s = t.customRoute || `${i.baseUrl || ""}${i.route && i.route.path}`),
      (r = "route"))
    : (i.originalUrl || i.url) && (s = Ift(i.originalUrl || i.url || ""))
  let a = ""
  return (
    t.method && e && (a += e),
    t.method && t.path && (a += " "),
    t.path && s && (a += s),
    [a, r]
  )
}
function Jft(i, t) {
  switch (t) {
    case "path":
      return Ez(i, { path: !0 })[0]
    case "handler":
      return (
        (i.route &&
          i.route.stack &&
          i.route.stack[0] &&
          i.route.stack[0].name) ||
        "<anonymous>"
      )
    case "methodPath":
    default: {
      const e = i._reconstructedRoute ? i._reconstructedRoute : void 0
      return Ez(i, { path: !0, method: !0, customRoute: e })[0]
    }
  }
}
function Lft(i, t) {
  const e = {}
  return (
    (Array.isArray(t) ? t : Cft).forEach((r) => {
      i && r in i && (e[r] = i[r])
    }),
    e
  )
}
function Rft(i, t = {}) {
  const { include: e = Sz } = t,
    s = {},
    r = i.headers || {},
    a = i.method,
    o = r.host || i.hostname || i.host || "<no host>",
    c =
      i.protocol === "https" || (i.socket && i.socket.encrypted)
        ? "https"
        : "http",
    l = i.originalUrl || i.url || "",
    u = l.startsWith(c) ? l : `${c}://${o}${l}`
  return (
    e.forEach((d) => {
      switch (d) {
        case "headers": {
          ;(s.headers = r),
            e.includes("cookies") || delete s.headers.cookie,
            e.includes("ip") ||
              kz.forEach((m) => {
                delete s.headers[m]
              })
          break
        }
        case "method": {
          s.method = a
          break
        }
        case "url": {
          s.url = u
          break
        }
        case "cookies": {
          s.cookies = i.cookies || (r.cookie && Eft(r.cookie)) || {}
          break
        }
        case "query_string": {
          s.query_string = Fft(i)
          break
        }
        case "data": {
          if (a === "GET" || a === "HEAD") break
          i.body !== void 0 &&
            (s.data = Hu(i.body) ? i.body : JSON.stringify(wz(i.body)))
          break
        }
        default:
          ;({}).hasOwnProperty.call(i, d) && (s[d] = i[d])
      }
    }),
    s
  )
}
function Dft(i, t, e) {
  const s = { ...Nft, ...(e && e.include) }
  if (s.request) {
    const r = Array.isArray(s.request) ? [...s.request] : [...Sz]
    s.ip && r.push("ip")
    const a = Rft(t, { include: r })
    i.request = { ...i.request, ...a }
  }
  if (s.user) {
    const r = t.user && Wu(t.user) ? Lft(t.user, s.user) : {}
    Object.keys(r).length && (i.user = { ...i.user, ...r })
  }
  if (s.ip) {
    const r =
      (t.headers && Pft(t.headers)) ||
      t.ip ||
      (t.socket && t.socket.remoteAddress)
    r && (i.user = { ...i.user, ip_address: r })
  }
  return (
    s.transaction &&
      !i.transaction &&
      i.type === "transaction" &&
      (i.transaction = Jft(t, s.transaction)),
    i
  )
}
function Fft(i) {
  let t = i.originalUrl || i.url || ""
  if (t) {
    t.startsWith("/") && (t = `http://dogs.are.great${t}`)
    try {
      const e = i.query || new URL(t).search.slice(1)
      return e.length ? e : void 0
    } catch {
      return
    }
  }
}
var Aft = ["fatal", "error", "warning", "log", "info", "debug"]
function _ft(i) {
  return i === "warn" ? "warning" : Aft.includes(i) ? i : "log"
}
var Oft = "sentry-",
  Bft = /^sentry-/
function qft(i) {
  const t = Uft(i)
  if (!t) return
  const e = Object.entries(t).reduce((s, [r, a]) => {
    if (r.match(Bft)) {
      const o = r.slice(Oft.length)
      s[o] = a
    }
    return s
  }, {})
  if (Object.keys(e).length > 0) return e
}
function Uft(i) {
  if (!(!i || (!Hu(i) && !Array.isArray(i))))
    return Array.isArray(i)
      ? i.reduce((t, e) => {
          const s = Iz(e)
          return (
            Object.entries(s).forEach(([r, a]) => {
              t[r] = a
            }),
            t
          )
        }, {})
      : Iz(i)
}
function Iz(i) {
  return i
    .split(",")
    .map((t) => t.split("=").map((e) => decodeURIComponent(e.trim())))
    .reduce((t, [e, s]) => (e && s && (t[e] = s), t), {})
}
var $jt = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$",
)
function Mft(i, t = []) {
  return [i, t]
}
function Pz(i, t) {
  const e = i[1]
  for (const s of e) {
    const r = s[0].type
    if (t(s, r)) return !0
  }
  return !1
}
function Hft(i) {
  return [{ type: "span" }, i]
}
var xjt = 60 * 1e3
function Wft(i, t) {
  return i(t.stack || "", 1)
}
function jft(i, t) {
  const e = { type: t.name || t.constructor.name, value: t.message },
    s = Wft(i, t)
  return s.length && (e.stacktrace = { frames: s }), e
}
function $z() {
  return { traceId: Gs(), spanId: Gs().substring(16) }
}
var Ge = !1
function gc() {
  return j7(ci), ci
}
function j7(i) {
  const t = (i.__SENTRY__ = i.__SENTRY__ || {})
  return (t.version = t.version || ju), (t[ju] = t[ju] || {})
}
function Vft(i, t = {}) {
  if (
    (t.user &&
      (!i.ipAddress && t.user.ip_address && (i.ipAddress = t.user.ip_address),
      !i.did &&
        !t.did &&
        (i.did = t.user.id || t.user.email || t.user.username)),
    (i.timestamp = t.timestamp || pc()),
    t.abnormal_mechanism && (i.abnormal_mechanism = t.abnormal_mechanism),
    t.ignoreDuration && (i.ignoreDuration = t.ignoreDuration),
    t.sid && (i.sid = t.sid.length === 32 ? t.sid : Gs()),
    t.init !== void 0 && (i.init = t.init),
    !i.did && t.did && (i.did = `${t.did}`),
    typeof t.started == "number" && (i.started = t.started),
    i.ignoreDuration)
  )
    i.duration = void 0
  else if (typeof t.duration == "number") i.duration = t.duration
  else {
    const e = i.timestamp - i.started
    i.duration = e >= 0 ? e : 0
  }
  t.release && (i.release = t.release),
    t.environment && (i.environment = t.environment),
    !i.ipAddress && t.ipAddress && (i.ipAddress = t.ipAddress),
    !i.userAgent && t.userAgent && (i.userAgent = t.userAgent),
    typeof t.errors == "number" && (i.errors = t.errors),
    t.status && (i.status = t.status)
}
var V7 = "_sentrySpan"
function O_(i, t) {
  t ? Xn(i, V7, t) : delete i[V7]
}
function B_(i) {
  return i[V7]
}
var Gft = 100,
  zft = class Rlt {
    constructor() {
      ;(this._notifyingListeners = !1),
        (this._scopeListeners = []),
        (this._eventProcessors = []),
        (this._breadcrumbs = []),
        (this._attachments = []),
        (this._user = {}),
        (this._tags = {}),
        (this._extra = {}),
        (this._contexts = {}),
        (this._sdkProcessingMetadata = {}),
        (this._propagationContext = $z())
    }
    clone() {
      const t = new Rlt()
      return (
        (t._breadcrumbs = [...this._breadcrumbs]),
        (t._tags = { ...this._tags }),
        (t._extra = { ...this._extra }),
        (t._contexts = { ...this._contexts }),
        (t._user = this._user),
        (t._level = this._level),
        (t._session = this._session),
        (t._transactionName = this._transactionName),
        (t._fingerprint = this._fingerprint),
        (t._eventProcessors = [...this._eventProcessors]),
        (t._requestSession = this._requestSession),
        (t._attachments = [...this._attachments]),
        (t._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }),
        (t._propagationContext = { ...this._propagationContext }),
        (t._client = this._client),
        (t._lastEventId = this._lastEventId),
        O_(t, B_(this)),
        t
      )
    }
    setClient(t) {
      this._client = t
    }
    setLastEventId(t) {
      this._lastEventId = t
    }
    getClient() {
      return this._client
    }
    lastEventId() {
      return this._lastEventId
    }
    addScopeListener(t) {
      this._scopeListeners.push(t)
    }
    addEventProcessor(t) {
      return this._eventProcessors.push(t), this
    }
    setUser(t) {
      return (
        (this._user = t || {
          email: void 0,
          id: void 0,
          ip_address: void 0,
          username: void 0,
        }),
        this._session && Vft(this._session, { user: t }),
        this._notifyScopeListeners(),
        this
      )
    }
    getUser() {
      return this._user
    }
    getRequestSession() {
      return this._requestSession
    }
    setRequestSession(t) {
      return (this._requestSession = t), this
    }
    setTags(t) {
      return (
        (this._tags = { ...this._tags, ...t }),
        this._notifyScopeListeners(),
        this
      )
    }
    setTag(t, e) {
      return (
        (this._tags = { ...this._tags, [t]: e }),
        this._notifyScopeListeners(),
        this
      )
    }
    setExtras(t) {
      return (
        (this._extra = { ...this._extra, ...t }),
        this._notifyScopeListeners(),
        this
      )
    }
    setExtra(t, e) {
      return (
        (this._extra = { ...this._extra, [t]: e }),
        this._notifyScopeListeners(),
        this
      )
    }
    setFingerprint(t) {
      return (this._fingerprint = t), this._notifyScopeListeners(), this
    }
    setLevel(t) {
      return (this._level = t), this._notifyScopeListeners(), this
    }
    setTransactionName(t) {
      return (this._transactionName = t), this._notifyScopeListeners(), this
    }
    setContext(t, e) {
      return (
        e === null ? delete this._contexts[t] : (this._contexts[t] = e),
        this._notifyScopeListeners(),
        this
      )
    }
    setSession(t) {
      return (
        t ? (this._session = t) : delete this._session,
        this._notifyScopeListeners(),
        this
      )
    }
    getSession() {
      return this._session
    }
    update(t) {
      if (!t) return this
      const e = typeof t == "function" ? t(this) : t,
        [s, r] =
          e instanceof vc
            ? [e.getScopeData(), e.getRequestSession()]
            : Wu(e)
              ? [t, t.requestSession]
              : [],
        {
          tags: a,
          extra: o,
          user: c,
          contexts: l,
          level: u,
          fingerprint: d = [],
          propagationContext: m,
        } = s || {}
      return (
        (this._tags = { ...this._tags, ...a }),
        (this._extra = { ...this._extra, ...o }),
        (this._contexts = { ...this._contexts, ...l }),
        c && Object.keys(c).length && (this._user = c),
        u && (this._level = u),
        d.length && (this._fingerprint = d),
        m && (this._propagationContext = m),
        r && (this._requestSession = r),
        this
      )
    }
    clear() {
      return (
        (this._breadcrumbs = []),
        (this._tags = {}),
        (this._extra = {}),
        (this._user = {}),
        (this._contexts = {}),
        (this._level = void 0),
        (this._transactionName = void 0),
        (this._fingerprint = void 0),
        (this._requestSession = void 0),
        (this._session = void 0),
        O_(this, void 0),
        (this._attachments = []),
        (this._propagationContext = $z()),
        this._notifyScopeListeners(),
        this
      )
    }
    addBreadcrumb(t, e) {
      const s = typeof e == "number" ? e : Gft
      if (s <= 0) return this
      const r = { timestamp: gz(), ...t },
        a = this._breadcrumbs
      return (
        a.push(r),
        (this._breadcrumbs = a.length > s ? a.slice(-s) : a),
        this._notifyScopeListeners(),
        this
      )
    }
    getLastBreadcrumb() {
      return this._breadcrumbs[this._breadcrumbs.length - 1]
    }
    clearBreadcrumbs() {
      return (this._breadcrumbs = []), this._notifyScopeListeners(), this
    }
    addAttachment(t) {
      return this._attachments.push(t), this
    }
    clearAttachments() {
      return (this._attachments = []), this
    }
    getScopeData() {
      return {
        breadcrumbs: this._breadcrumbs,
        attachments: this._attachments,
        contexts: this._contexts,
        tags: this._tags,
        extra: this._extra,
        user: this._user,
        level: this._level,
        fingerprint: this._fingerprint || [],
        eventProcessors: this._eventProcessors,
        propagationContext: this._propagationContext,
        sdkProcessingMetadata: this._sdkProcessingMetadata,
        transactionName: this._transactionName,
        span: B_(this),
      }
    }
    setSDKProcessingMetadata(t) {
      return (
        (this._sdkProcessingMetadata = {
          ...this._sdkProcessingMetadata,
          ...t,
        }),
        this
      )
    }
    setPropagationContext(t) {
      return (this._propagationContext = t), this
    }
    getPropagationContext() {
      return this._propagationContext
    }
    captureException(t, e) {
      const s = e && e.event_id ? e.event_id : Gs()
      if (!this._client)
        return (
          Ee.warn(
            "No client configured on scope - will not capture exception!",
          ),
          s
        )
      const r = new Error("Sentry syntheticException")
      return (
        this._client.captureException(
          t,
          { originalException: t, syntheticException: r, ...e, event_id: s },
          this,
        ),
        s
      )
    }
    captureMessage(t, e, s) {
      const r = s && s.event_id ? s.event_id : Gs()
      if (!this._client)
        return (
          Ee.warn("No client configured on scope - will not capture message!"),
          r
        )
      const a = new Error(t)
      return (
        this._client.captureMessage(
          t,
          e,
          { originalException: t, syntheticException: a, ...s, event_id: r },
          this,
        ),
        r
      )
    }
    captureEvent(t, e) {
      const s = e && e.event_id ? e.event_id : Gs()
      return this._client
        ? (this._client.captureEvent(t, { ...e, event_id: s }, this), s)
        : (Ee.warn("No client configured on scope - will not capture event!"),
          s)
    }
    _notifyScopeListeners() {
      this._notifyingListeners ||
        ((this._notifyingListeners = !0),
        this._scopeListeners.forEach((t) => {
          t(this)
        }),
        (this._notifyingListeners = !1))
    }
  },
  vc = zft
function Yft() {
  return O7("defaultCurrentScope", () => new vc())
}
function Qft() {
  return O7("defaultIsolationScope", () => new vc())
}
var Xft = class {
  constructor(i, t) {
    let e
    i ? (e = i) : (e = new vc())
    let s
    t ? (s = t) : (s = new vc()),
      (this._stack = [{ scope: e }]),
      (this._isolationScope = s)
  }
  withScope(i) {
    const t = this._pushScope()
    let e
    try {
      e = i(t)
    } catch (s) {
      throw (this._popScope(), s)
    }
    return F7(e)
      ? e.then(
          (s) => (this._popScope(), s),
          (s) => {
            throw (this._popScope(), s)
          },
        )
      : (this._popScope(), e)
  }
  getClient() {
    return this.getStackTop().client
  }
  getScope() {
    return this.getStackTop().scope
  }
  getIsolationScope() {
    return this._isolationScope
  }
  getStackTop() {
    return this._stack[this._stack.length - 1]
  }
  _pushScope() {
    const i = this.getScope().clone()
    return this._stack.push({ client: this.getClient(), scope: i }), i
  }
  _popScope() {
    return this._stack.length <= 1 ? !1 : !!this._stack.pop()
  }
}
function wc() {
  const i = gc(),
    t = j7(i)
  return (t.stack = t.stack || new Xft(Yft(), Qft()))
}
function Kft(i) {
  return wc().withScope(i)
}
function Zft(i, t) {
  const e = wc()
  return e.withScope(() => ((e.getStackTop().scope = i), t(i)))
}
function xz(i) {
  return wc().withScope(() => i(wc().getIsolationScope()))
}
function tpt() {
  return {
    withIsolationScope: xz,
    withScope: Kft,
    withSetScope: Zft,
    withSetIsolationScope: (i, t) => xz(t),
    getCurrentScope: () => wc().getScope(),
    getIsolationScope: () => wc().getIsolationScope(),
  }
}
function Vu(i) {
  const t = j7(i)
  return t.acs ? t.acs : tpt()
}
function zs() {
  const i = gc()
  return Vu(i).getCurrentScope()
}
function yc() {
  const i = gc()
  return Vu(i).getIsolationScope()
}
function G7(...i) {
  const t = gc(),
    e = Vu(t)
  if (i.length === 2) {
    const [s, r] = i
    return s ? e.withSetScope(s, r) : e.withScope(r)
  }
  return e.withScope(i[0])
}
function Nr() {
  return zs().getClient()
}
var ept = "_sentryMetrics"
function z7(i) {
  const t = i[ept]
  if (!t) return
  const e = {}
  for (const [, [s, r]] of t) (e[s] || (e[s] = [])).push(fc(r))
  return e
}
var Y7 = "sentry.source",
  Q7 = "sentry.sample_rate",
  X7 = "sentry.op",
  K7 = "sentry.origin",
  ipt = "sentry.measurement_unit",
  spt = "sentry.measurement_value",
  rpt = "sentry.profile_id",
  npt = "sentry.exclusive_time",
  apt = 0,
  opt = 1,
  Nz = 2,
  Cz = 0,
  Jz = 1
function cpt(i) {
  const { spanId: t, traceId: e } = i.spanContext(),
    { data: s, op: r, parent_span_id: a, status: o, origin: c } = Ys(i)
  return fc({
    parent_span_id: a,
    span_id: t,
    trace_id: e,
    data: s,
    op: r,
    status: o,
    origin: c,
  })
}
function bc(i) {
  return typeof i == "number"
    ? Lz(i)
    : Array.isArray(i)
      ? i[0] + i[1] / 1e9
      : i instanceof Date
        ? Lz(i.getTime())
        : pc()
}
function Lz(i) {
  return i > 9999999999 ? i / 1e3 : i
}
function Ys(i) {
  if (upt(i)) return i.getSpanJSON()
  try {
    const { spanId: t, traceId: e } = i.spanContext()
    if (lpt(i)) {
      const {
        attributes: s,
        startTime: r,
        name: a,
        endTime: o,
        parentSpanId: c,
        status: l,
      } = i
      return fc({
        span_id: t,
        trace_id: e,
        data: s,
        description: a,
        parent_span_id: c,
        start_timestamp: bc(r),
        timestamp: bc(o) || void 0,
        status: Rz(l),
        op: s[X7],
        origin: s[K7],
        _metrics_summary: z7(i),
      })
    }
    return { span_id: t, trace_id: e }
  } catch {
    return {}
  }
}
function lpt(i) {
  const t = i
  return (
    !!t.attributes && !!t.startTime && !!t.name && !!t.endTime && !!t.status
  )
}
function upt(i) {
  return typeof i.getSpanJSON == "function"
}
function Gu(i) {
  const { traceFlags: t } = i.spanContext()
  return t === Jz
}
function Rz(i) {
  if (!(!i || i.code === apt))
    return i.code === opt ? "ok" : i.message || "unknown_error"
}
var zu = "_sentryChildSpans",
  Z7 = "_sentryRootSpan"
function Dz(i, t) {
  const e = i[Z7] || i
  Xn(t, Z7, e), i[zu] ? i[zu].add(t) : Xn(i, zu, new Set([t]))
}
function hpt(i) {
  const t = new Set()
  function e(s) {
    if (!t.has(s) && Gu(s)) {
      t.add(s)
      const r = s[zu] ? Array.from(s[zu]) : []
      for (const a of r) e(a)
    }
  }
  return e(i), Array.from(t)
}
function Kn(i) {
  return i[Z7] || i
}
function dpt() {
  const i = gc(),
    t = Vu(i)
  return t.getActiveSpan ? t.getActiveSpan() : B_(zs())
}
function mpt() {
  const i = dpt(),
    t = i && Kn(i)
  if (t) {
    const e = "internal_error"
    Ge && Ee.log(`[Tracing] Root span: ${e} -> Global error occured`),
      t.setStatus({ code: Nz, message: e })
  }
}
mpt.tag = "sentry_tracingErrorCallback"
var Fz = "_sentryScope",
  Az = "_sentryIsolationScope"
function fpt(i, t, e) {
  i && (Xn(i, Az, e), Xn(i, Fz, t))
}
function _z(i) {
  return { scope: i[Fz], isolationScope: i[Az] }
}
function tq(i) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1
  const t = Nr(),
    e = i || (t && t.getOptions())
  return (
    !!e && (e.enableTracing || "tracesSampleRate" in e || "tracesSampler" in e)
  )
}
var eq = class {
  constructor(i = {}) {
    ;(this._traceId = i.traceId || Gs()),
      (this._spanId = i.spanId || Gs().substring(16))
  }
  spanContext() {
    return { spanId: this._spanId, traceId: this._traceId, traceFlags: Cz }
  }
  end(i) {}
  setAttribute(i, t) {
    return this
  }
  setAttributes(i) {
    return this
  }
  setStatus(i) {
    return this
  }
  updateName(i) {
    return this
  }
  isRecording() {
    return !1
  }
  addEvent(i, t, e) {
    return this
  }
  addLink(i) {
    return this
  }
  addLinks(i) {
    return this
  }
  recordException(i, t) {}
}
function ppt(i, t, e = () => {}) {
  let s
  try {
    s = i()
  } catch (r) {
    throw (t(r), e(), r)
  }
  return gpt(s, t, e)
}
function gpt(i, t, e) {
  return F7(i)
    ? i.then(
        (s) => (e(), s),
        (s) => {
          throw (t(s), e(), s)
        },
      )
    : (e(), i)
}
var vpt = "production",
  Oz = "_frozenDsc"
function Bz(i, t) {
  Xn(i, Oz, t)
}
function wpt(i, t) {
  const e = t.getOptions(),
    { publicKey: s } = t.getDsn() || {},
    r = fc({
      environment: e.environment || vpt,
      release: e.release,
      public_key: s,
      trace_id: i,
    })
  return t.emit("createDsc", r), r
}
function iq(i) {
  const t = Nr()
  if (!t) return {}
  const e = wpt(Ys(i).trace_id || "", t),
    s = Kn(i),
    r = s[Oz]
  if (r) return r
  const a = s.spanContext().traceState,
    o = a && a.get("sentry.dsc"),
    c = o && qft(o)
  if (c) return c
  const l = Ys(s),
    u = l.data || {},
    d = u[Q7]
  d != null && (e.sample_rate = `${d}`)
  const m = u[Y7],
    f = l.description
  return (
    m !== "url" && f && (e.transaction = f),
    tq() && (e.sampled = String(Gu(s))),
    t.emit("createDsc", e, s),
    e
  )
}
function ypt(i) {
  if (!Ge) return
  const {
      description: t = "< unknown name >",
      op: e = "< unknown op >",
      parent_span_id: s,
    } = Ys(i),
    { spanId: r } = i.spanContext(),
    a = Gu(i),
    o = Kn(i),
    c = o === i,
    l = `[Tracing] Starting ${a ? "sampled" : "unsampled"} ${c ? "root " : ""}span`,
    u = [`op: ${e}`, `name: ${t}`, `ID: ${r}`]
  if ((s && u.push(`parent ID: ${s}`), !c)) {
    const { op: d, description: m } = Ys(o)
    u.push(`root ID: ${o.spanContext().spanId}`),
      d && u.push(`root op: ${d}`),
      m && u.push(`root description: ${m}`)
  }
  Ee.log(`${l}
  ${u.join(`
  `)}`)
}
function bpt(i) {
  if (!Ge) return
  const { description: t = "< unknown name >", op: e = "< unknown op >" } =
      Ys(i),
    { spanId: s } = i.spanContext(),
    a = Kn(i) === i,
    o = `[Tracing] Finishing "${e}" ${a ? "root " : ""}span "${t}" with ID ${s}`
  Ee.log(o)
}
function Tpt(i) {
  if (typeof i == "boolean") return Number(i)
  const t = typeof i == "string" ? parseFloat(i) : i
  if (typeof t != "number" || isNaN(t) || t < 0 || t > 1) {
    Ge &&
      Ee.warn(
        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(i)} of type ${JSON.stringify(typeof i)}.`,
      )
    return
  }
  return t
}
function kpt(i, t) {
  if (!tq(i)) return [!1]
  let e
  typeof i.tracesSampler == "function"
    ? (e = i.tracesSampler(t))
    : t.parentSampled !== void 0
      ? (e = t.parentSampled)
      : typeof i.tracesSampleRate < "u"
        ? (e = i.tracesSampleRate)
        : (e = 1)
  const s = Tpt(e)
  return s === void 0
    ? (Ge &&
        Ee.warn(
          "[Tracing] Discarding transaction because of invalid sample rate.",
        ),
      [!1])
    : s
      ? Math.random() < s
        ? [!0, s]
        : (Ge &&
            Ee.log(
              `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(e)})`,
            ),
          [!1, s])
      : (Ge &&
          Ee.log(
            `[Tracing] Discarding transaction because ${typeof i.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`,
          ),
        [!1, s])
}
function Spt(i, t) {
  function e(d) {
    return !!d.trace_id && !!d.public_key
  }
  const s = iq(i[0]),
    r = t && t.getDsn(),
    a = t && t.getOptions().tunnel,
    o = {
      sent_at: new Date().toISOString(),
      ...(e(s) && { trace: s }),
      ...(!!a && r && { dsn: tft(r) }),
    },
    c = t && t.getOptions().beforeSendSpan,
    l = c ? (d) => c(Ys(d)) : (d) => Ys(d),
    u = []
  for (const d of i) {
    const m = l(d)
    m && u.push(Hft(m))
  }
  return Mft(o, u)
}
function qz(i) {
  if (!i || i.length === 0) return
  const t = {}
  return (
    i.forEach((e) => {
      const s = e.attributes || {},
        r = s[ipt],
        a = s[spt]
      typeof r == "string" &&
        typeof a == "number" &&
        (t[e.name] = { value: a, unit: r })
    }),
    t
  )
}
var Uz = 1e3,
  sq = class {
    constructor(i = {}) {
      ;(this._traceId = i.traceId || Gs()),
        (this._spanId = i.spanId || Gs().substring(16)),
        (this._startTime = i.startTimestamp || pc()),
        (this._attributes = {}),
        this.setAttributes({ [K7]: "manual", [X7]: i.op, ...i.attributes }),
        (this._name = i.name),
        i.parentSpanId && (this._parentSpanId = i.parentSpanId),
        "sampled" in i && (this._sampled = i.sampled),
        i.endTimestamp && (this._endTime = i.endTimestamp),
        (this._events = []),
        (this._isStandaloneSpan = i.isStandalone),
        this._endTime && this._onSpanEnded()
    }
    addLink(i) {
      return this
    }
    addLinks(i) {
      return this
    }
    recordException(i, t) {}
    spanContext() {
      const { _spanId: i, _traceId: t, _sampled: e } = this
      return { spanId: i, traceId: t, traceFlags: e ? Jz : Cz }
    }
    setAttribute(i, t) {
      return (
        t === void 0 ? delete this._attributes[i] : (this._attributes[i] = t),
        this
      )
    }
    setAttributes(i) {
      return Object.keys(i).forEach((t) => this.setAttribute(t, i[t])), this
    }
    updateStartTime(i) {
      this._startTime = bc(i)
    }
    setStatus(i) {
      return (this._status = i), this
    }
    updateName(i) {
      return (this._name = i), this
    }
    end(i) {
      this._endTime || ((this._endTime = bc(i)), bpt(this), this._onSpanEnded())
    }
    getSpanJSON() {
      return fc({
        data: this._attributes,
        description: this._name,
        op: this._attributes[X7],
        parent_span_id: this._parentSpanId,
        span_id: this._spanId,
        start_timestamp: this._startTime,
        status: Rz(this._status),
        timestamp: this._endTime,
        trace_id: this._traceId,
        origin: this._attributes[K7],
        _metrics_summary: z7(this),
        profile_id: this._attributes[rpt],
        exclusive_time: this._attributes[npt],
        measurements: qz(this._events),
        is_segment: (this._isStandaloneSpan && Kn(this) === this) || void 0,
        segment_id: this._isStandaloneSpan
          ? Kn(this).spanContext().spanId
          : void 0,
      })
    }
    isRecording() {
      return !this._endTime && !!this._sampled
    }
    addEvent(i, t, e) {
      Ge && Ee.log("[Tracing] Adding an event to span:", i)
      const s = Mz(t) ? t : e || pc(),
        r = Mz(t) ? {} : t || {},
        a = { name: i, time: bc(s), attributes: r }
      return this._events.push(a), this
    }
    isStandaloneSpan() {
      return !!this._isStandaloneSpan
    }
    _onSpanEnded() {
      const i = Nr()
      if (
        (i && i.emit("spanEnd", this),
        !(this._isStandaloneSpan || this === Kn(this)))
      )
        return
      if (this._isStandaloneSpan) {
        this._sampled
          ? Ipt(Spt([this], i))
          : (Ge &&
              Ee.log(
                "[Tracing] Discarding standalone span because its trace was not chosen to be sampled.",
              ),
            i && i.recordDroppedEvent("sample_rate", "span"))
        return
      }
      const e = this._convertSpanToTransaction()
      e && (_z(this).scope || zs()).captureEvent(e)
    }
    _convertSpanToTransaction() {
      if (!Hz(Ys(this))) return
      this._name ||
        (Ge &&
          Ee.warn(
            "Transaction has no name, falling back to `<unlabeled transaction>`.",
          ),
        (this._name = "<unlabeled transaction>"))
      const { scope: i, isolationScope: t } = _z(this),
        s = (i || zs()).getClient() || Nr()
      if (this._sampled !== !0) {
        Ge &&
          Ee.log(
            "[Tracing] Discarding transaction because its trace was not chosen to be sampled.",
          ),
          s && s.recordDroppedEvent("sample_rate", "transaction")
        return
      }
      const a = hpt(this)
          .filter((d) => d !== this && !Ept(d))
          .map((d) => Ys(d))
          .filter(Hz),
        o = this._attributes[Y7],
        c = {
          contexts: { trace: cpt(this) },
          spans:
            a.length > Uz
              ? a
                  .sort((d, m) => d.start_timestamp - m.start_timestamp)
                  .slice(0, Uz)
              : a,
          start_timestamp: this._startTime,
          timestamp: this._endTime,
          transaction: this._name,
          type: "transaction",
          sdkProcessingMetadata: {
            capturedSpanScope: i,
            capturedSpanIsolationScope: t,
            ...fc({ dynamicSamplingContext: iq(this) }),
          },
          _metrics_summary: z7(this),
          ...(o && { transaction_info: { source: o } }),
        },
        l = qz(this._events)
      return (
        l &&
          Object.keys(l).length &&
          (Ge &&
            Ee.log(
              "[Measurements] Adding measurements to transaction event",
              JSON.stringify(l, void 0, 2),
            ),
          (c.measurements = l)),
        c
      )
    }
  }
function Mz(i) {
  return (i && typeof i == "number") || i instanceof Date || Array.isArray(i)
}
function Hz(i) {
  return !!i.start_timestamp && !!i.timestamp && !!i.span_id && !!i.trace_id
}
function Ept(i) {
  return i instanceof sq && i.isStandaloneSpan()
}
function Ipt(i) {
  const t = Nr()
  if (!t) return
  const e = i[1]
  if (!e || e.length === 0) {
    t.recordDroppedEvent("before_send", "span")
    return
  }
  const s = t.getTransport()
  s &&
    s.send(i).then(null, (r) => {
      Ge && Ee.error("Error while sending span:", r)
    })
}
var Wz = "__SENTRY_SUPPRESS_TRACING__"
function Ppt(i, t) {
  const e = jz()
  if (e.startSpanManual) return e.startSpanManual(i, t)
  const s = Npt(i),
    { forceTransaction: r, parentSpan: a } = i
  return G7(i.scope, () =>
    Lpt(a)(() => {
      const c = zs(),
        l = Jpt(c),
        d =
          i.onlyIfParent && !l
            ? new eq()
            : xpt({
                parentSpan: l,
                spanArguments: s,
                forceTransaction: r,
                scope: c,
              })
      O_(c, d)
      function m() {
        d.end()
      }
      return ppt(
        () => t(d, m),
        () => {
          const { status: f } = Ys(d)
          d.isRecording() &&
            (!f || f === "ok") &&
            d.setStatus({ code: Nz, message: "internal_error" })
        },
      )
    }),
  )
}
function $pt(i, t) {
  const e = jz()
  return e.withActiveSpan
    ? e.withActiveSpan(i, t)
    : G7((s) => (O_(s, i || void 0), t(s)))
}
function xpt({
  parentSpan: i,
  spanArguments: t,
  forceTransaction: e,
  scope: s,
}) {
  if (!tq()) return new eq()
  const r = yc()
  let a
  if (i && !e) (a = Cpt(i, s, t)), Dz(i, a)
  else if (i) {
    const o = iq(i),
      { traceId: c, spanId: l } = i.spanContext(),
      u = Gu(i)
    ;(a = Vz({ traceId: c, parentSpanId: l, ...t }, s, u)), Bz(a, o)
  } else {
    const {
      traceId: o,
      dsc: c,
      parentSpanId: l,
      sampled: u,
    } = { ...r.getPropagationContext(), ...s.getPropagationContext() }
    ;(a = Vz({ traceId: o, parentSpanId: l, ...t }, s, u)), c && Bz(a, c)
  }
  return ypt(a), fpt(a, s, r), a
}
function Npt(i) {
  const e = { isStandalone: (i.experimental || {}).standalone, ...i }
  if (i.startTime) {
    const s = { ...e }
    return (s.startTimestamp = bc(i.startTime)), delete s.startTime, s
  }
  return e
}
function jz() {
  const i = gc()
  return Vu(i)
}
function Vz(i, t, e) {
  const s = Nr(),
    r = (s && s.getOptions()) || {},
    { name: a = "", attributes: o } = i,
    [c, l] = t.getScopeData().sdkProcessingMetadata[Wz]
      ? [!1]
      : kpt(r, {
          name: a,
          parentSampled: e,
          attributes: o,
          transactionContext: { name: a, parentSampled: e },
        }),
    u = new sq({
      ...i,
      attributes: { [Y7]: "custom", ...i.attributes },
      sampled: c,
    })
  return l !== void 0 && u.setAttribute(Q7, l), s && s.emit("spanStart", u), u
}
function Cpt(i, t, e) {
  const { spanId: s, traceId: r } = i.spanContext(),
    a = t.getScopeData().sdkProcessingMetadata[Wz] ? !1 : Gu(i),
    o = a
      ? new sq({ ...e, parentSpanId: s, traceId: r, sampled: a })
      : new eq({ traceId: r })
  Dz(i, o)
  const c = Nr()
  return (
    c && (c.emit("spanStart", o), e.endTimestamp && c.emit("spanEnd", o)), o
  )
}
function Jpt(i) {
  const t = B_(i)
  if (!t) return
  const e = Nr()
  return (e ? e.getOptions() : {}).parentSpanIsAlwaysRootSpan ? Kn(t) : t
}
function Lpt(i) {
  return i !== void 0 ? (t) => $pt(i, t) : (t) => t()
}
function Rpt(i) {
  if (i)
    return Dpt(i) ? { captureContext: i } : Apt(i) ? { captureContext: i } : i
}
function Dpt(i) {
  return i instanceof vc || typeof i == "function"
}
var Fpt = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext",
]
function Apt(i) {
  return Object.keys(i).some((t) => Fpt.includes(t))
}
function _pt(i, t) {
  return zs().captureException(i, Rpt(t))
}
function Gz(i, t) {
  const e = typeof t == "string" ? t : void 0,
    s = typeof t != "string" ? { captureContext: t } : void 0
  return zs().captureMessage(i, e, s)
}
function Njt(i) {
  return i
}
var zz,
  Opt = "FunctionToString",
  Yz = new WeakMap(),
  Bpt = () => ({
    name: Opt,
    setupOnce() {
      zz = Function.prototype.toString
      try {
        Function.prototype.toString = function (...i) {
          const t = sft(this),
            e = Yz.has(Nr()) && t !== void 0 ? t : this
          return zz.apply(e, i)
        }
      } catch {}
    },
    setup(i) {
      Yz.set(i, !0)
    },
  }),
  Cjt = Bpt,
  qpt = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/,
    "undefined is not an object (evaluating 'a.L')",
    `can't redefine non-configurable property "solana"`,
    "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
    "Can't find variable: _AutofillCallbackHandler",
  ],
  Upt = "InboundFilters",
  Mpt = (i = {}) => ({
    name: Upt,
    processEvent(t, e, s) {
      const r = s.getOptions(),
        a = Hpt(i, r)
      return Wpt(t, a) ? null : t
    },
  }),
  Jjt = Mpt
function Hpt(i = {}, t = {}) {
  return {
    allowUrls: [...(i.allowUrls || []), ...(t.allowUrls || [])],
    denyUrls: [...(i.denyUrls || []), ...(t.denyUrls || [])],
    ignoreErrors: [
      ...(i.ignoreErrors || []),
      ...(t.ignoreErrors || []),
      ...(i.disableErrorDefaults ? [] : qpt),
    ],
    ignoreTransactions: [
      ...(i.ignoreTransactions || []),
      ...(t.ignoreTransactions || []),
    ],
    ignoreInternal: i.ignoreInternal !== void 0 ? i.ignoreInternal : !0,
  }
}
function Wpt(i, t) {
  return t.ignoreInternal && Qpt(i)
    ? (Ge &&
        Ee.warn(`Event dropped due to being internal Sentry Error.
Event: ${Ga(i)}`),
      !0)
    : jpt(i, t.ignoreErrors)
      ? (Ge &&
          Ee.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Ga(i)}`),
        !0)
      : Kpt(i)
        ? (Ge &&
            Ee.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${Ga(i)}`),
          !0)
        : Vpt(i, t.ignoreTransactions)
          ? (Ge &&
              Ee.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Ga(i)}`),
            !0)
          : Gpt(i, t.denyUrls)
            ? (Ge &&
                Ee.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${Ga(i)}.
Url: ${q_(i)}`),
              !0)
            : zpt(i, t.allowUrls)
              ? !1
              : (Ge &&
                  Ee.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Ga(i)}.
Url: ${q_(i)}`),
                !0)
}
function jpt(i, t) {
  return i.type || !t || !t.length ? !1 : Ypt(i).some((e) => R_(e, t))
}
function Vpt(i, t) {
  if (i.type !== "transaction" || !t || !t.length) return !1
  const e = i.transaction
  return e ? R_(e, t) : !1
}
function Gpt(i, t) {
  if (!t || !t.length) return !1
  const e = q_(i)
  return e ? R_(e, t) : !1
}
function zpt(i, t) {
  if (!t || !t.length) return !0
  const e = q_(i)
  return e ? R_(e, t) : !0
}
function Ypt(i) {
  const t = []
  i.message && t.push(i.message)
  let e
  try {
    e = i.exception.values[i.exception.values.length - 1]
  } catch {}
  return (
    e &&
      e.value &&
      (t.push(e.value), e.type && t.push(`${e.type}: ${e.value}`)),
    t
  )
}
function Qpt(i) {
  try {
    return i.exception.values[0].type === "SentryError"
  } catch {}
  return !1
}
function Xpt(i = []) {
  for (let t = i.length - 1; t >= 0; t--) {
    const e = i[t]
    if (e && e.filename !== "<anonymous>" && e.filename !== "[native code]")
      return e.filename || null
  }
  return null
}
function q_(i) {
  try {
    let t
    try {
      t = i.exception.values[0].stacktrace.frames
    } catch {}
    return t ? Xpt(t) : null
  } catch {
    return Ge && Ee.error(`Cannot extract url for event ${Ga(i)}`), null
  }
}
function Kpt(i) {
  return i.type ||
    !i.exception ||
    !i.exception.values ||
    i.exception.values.length === 0
    ? !1
    : !i.message &&
        !i.exception.values.some(
          (t) => t.stacktrace || (t.type && t.type !== "Error") || t.value,
        )
}
var Zpt = "cause",
  tgt = 5,
  egt = "LinkedErrors",
  igt = (i = {}) => {
    const t = i.limit || tgt,
      e = i.key || Zpt
    return {
      name: egt,
      preprocessEvent(s, r, a) {
        const o = a.getOptions()
        Vmt(jft, o.stackParser, o.maxValueLength, e, t, s, r)
      },
    }
  },
  Ljt = igt,
  Qz = new Map(),
  Xz = new Set()
function sgt(i) {
  if (ci._sentryModuleMetadata)
    for (const t of Object.keys(ci._sentryModuleMetadata)) {
      const e = ci._sentryModuleMetadata[t]
      if (Xz.has(t)) continue
      Xz.add(t)
      const s = i(t)
      for (const r of s.reverse())
        if (r.filename) {
          Qz.set(r.filename, e)
          break
        }
    }
}
function rgt(i, t) {
  return sgt(i), Qz.get(t)
}
function Kz(i, t) {
  try {
    t.exception.values.forEach((e) => {
      if (e.stacktrace)
        for (const s of e.stacktrace.frames || []) {
          if (!s.filename || s.module_metadata) continue
          const r = rgt(i, s.filename)
          r && (s.module_metadata = r)
        }
    })
  } catch {}
}
function Zz(i) {
  try {
    i.exception.values.forEach((t) => {
      if (t.stacktrace)
        for (const e of t.stacktrace.frames || []) delete e.module_metadata
    })
  } catch {}
}
var Rjt = () => ({
    name: "ModuleMetadata",
    setup(i) {
      i.on("beforeEnvelope", (t) => {
        Pz(t, (e, s) => {
          if (s === "event") {
            const r = Array.isArray(e) ? e[1] : void 0
            r && (Zz(r), (e[1] = r))
          }
        })
      }),
        i.on("applyFrameMetadata", (t) => {
          if (t.type) return
          const e = i.getOptions().stackParser
          Kz(e, t)
        })
    },
  }),
  rq = {
    include: {
      cookies: !0,
      data: !0,
      headers: !0,
      ip: !1,
      query_string: !0,
      url: !0,
      user: { id: !0, username: !0, email: !0 },
    },
    transactionNamingScheme: "methodPath",
  },
  ngt = "RequestData",
  agt = (i = {}) => {
    const t = {
      ...rq,
      ...i,
      include: {
        ...rq.include,
        ...i.include,
        user:
          i.include && typeof i.include.user == "boolean"
            ? i.include.user
            : { ...rq.include.user, ...(i.include || {}).user },
      },
    }
    return {
      name: ngt,
      processEvent(e) {
        const { sdkProcessingMetadata: s = {} } = e,
          r = s.request
        if (!r) return e
        const a = ogt(t)
        return Dft(e, r, a)
      },
    }
  },
  Djt = agt
function ogt(i) {
  const {
      transactionNamingScheme: t,
      include: { ip: e, user: s, ...r },
    } = i,
    a = ["method"]
  for (const [c, l] of Object.entries(r)) l && a.push(c)
  let o
  if (s === void 0) o = !0
  else if (typeof s == "boolean") o = s
  else {
    const c = []
    for (const [l, u] of Object.entries(s)) u && c.push(l)
    o = c
  }
  return {
    include: {
      ip: e,
      user: o,
      request: a.length !== 0 ? a : void 0,
      transaction: t,
    },
  }
}
var cgt = "CaptureConsole",
  lgt = (i = {}) => {
    const t = i.levels || D_
    return {
      name: cgt,
      setup(e) {
        "console" in ci &&
          lft(({ args: s, level: r }) => {
            Nr() !== e || !t.includes(r) || ugt(s, r)
          })
      },
    }
  },
  Fjt = lgt
function ugt(i, t) {
  const e = { level: _ft(t), extra: { arguments: i } }
  G7((s) => {
    if (
      (s.addEventProcessor(
        (o) => (
          (o.logger = "console"), mft(o, { handled: !1, type: "console" }), o
        ),
      ),
      t === "assert")
    ) {
      if (!i[0]) {
        const o = `Assertion failed: ${az(i.slice(1), " ") || "console.assert"}`
        s.setExtra("arguments", i.slice(1)), Gz(o, e)
      }
      return
    }
    const r = i.find((o) => o instanceof Error)
    if (r) {
      _pt(r, e)
      return
    }
    const a = az(i, " ")
    Gz(a, e)
  })
}
var hgt = "Debug",
  dgt = (i = {}) => {
    const t = { debugger: !1, stringify: !1, ...i }
    return {
      name: hgt,
      setup(e) {
        e.on("beforeSendEvent", (s, r) => {
          if (t.debugger) debugger
          lz(() => {
            t.stringify
              ? (console.log(JSON.stringify(s, null, 2)),
                r &&
                  Object.keys(r).length &&
                  console.log(JSON.stringify(r, null, 2)))
              : (console.log(s), r && Object.keys(r).length && console.log(r))
          })
        })
      },
    }
  },
  Ajt = dgt,
  mgt = "Dedupe",
  fgt = () => {
    let i
    return {
      name: mgt,
      processEvent(t) {
        if (t.type) return t
        try {
          if (pgt(t, i))
            return (
              Ge &&
                Ee.warn(
                  "Event dropped due to being a duplicate of previously captured event.",
                ),
              null
            )
        } catch {}
        return (i = t)
      },
    }
  },
  _jt = fgt
function pgt(i, t) {
  return t ? !!(ggt(i, t) || vgt(i, t)) : !1
}
function ggt(i, t) {
  const e = i.message,
    s = t.message
  return !(
    (!e && !s) ||
    (e && !s) ||
    (!e && s) ||
    e !== s ||
    !eY(i, t) ||
    !tY(i, t)
  )
}
function vgt(i, t) {
  const e = iY(t),
    s = iY(i)
  return !(
    !e ||
    !s ||
    e.type !== s.type ||
    e.value !== s.value ||
    !eY(i, t) ||
    !tY(i, t)
  )
}
function tY(i, t) {
  let e = M7(i),
    s = M7(t)
  if (!e && !s) return !0
  if ((e && !s) || (!e && s) || ((e = e), (s = s), s.length !== e.length))
    return !1
  for (let r = 0; r < s.length; r++) {
    const a = s[r],
      o = e[r]
    if (
      a.filename !== o.filename ||
      a.lineno !== o.lineno ||
      a.colno !== o.colno ||
      a.function !== o.function
    )
      return !1
  }
  return !0
}
function eY(i, t) {
  let e = i.fingerprint,
    s = t.fingerprint
  if (!e && !s) return !0
  if ((e && !s) || (!e && s)) return !1
  ;(e = e), (s = s)
  try {
    return e.join("") === s.join("")
  } catch {
    return !1
  }
}
function iY(i) {
  return i.exception && i.exception.values && i.exception.values[0]
}
var wgt = "ExtraErrorData",
  ygt = (i = {}) => {
    const { depth: t = 3, captureErrorCause: e = !0 } = i
    return {
      name: wgt,
      processEvent(s, r, a) {
        const { maxValueLength: o = 250 } = a.getOptions()
        return bgt(s, r, t, e, o)
      },
    }
  },
  Ojt = ygt
function bgt(i, t = {}, e, s, r) {
  if (!t.originalException || !mc(t.originalException)) return i
  const a = t.originalException.name || t.originalException.constructor.name,
    o = Tgt(t.originalException, s, r)
  if (o) {
    const c = { ...i.contexts },
      l = wz(o, e)
    return (
      Wu(l) && (Xn(l, "__sentry_skip_normalization__", !0), (c[a] = l)),
      { ...i, contexts: c }
    )
  }
  return i
}
function Tgt(i, t, e) {
  try {
    const s = [
        "name",
        "message",
        "stack",
        "line",
        "column",
        "fileName",
        "lineNumber",
        "columnNumber",
        "toJSON",
      ],
      r = {}
    for (const a of Object.keys(i)) {
      if (s.indexOf(a) !== -1) continue
      const o = i[a]
      r[a] = mc(o) || typeof o == "string" ? A7(`${o}`, e) : o
    }
    if (
      (t &&
        i.cause !== void 0 &&
        (r.cause = mc(i.cause) ? i.cause.toString() : i.cause),
      typeof i.toJSON == "function")
    ) {
      const a = i.toJSON()
      for (const o of Object.keys(a)) {
        const c = a[o]
        r[o] = mc(c) ? c.toString() : c
      }
    }
    return r
  } catch (s) {
    Ge && Ee.error("Unable to extract extra data from the Error object:", s)
  }
  return null
}
var kgt = "RewriteFrames",
  Bjt = (i = {}) => {
    const t = i.root,
      e = i.prefix || "app:///",
      s = "window" in ci && ci.window !== void 0,
      r = i.iteratee || Sgt({ isBrowser: s, root: t, prefix: e })
    function a(c) {
      try {
        return {
          ...c,
          exception: {
            ...c.exception,
            values: c.exception.values.map((l) => ({
              ...l,
              ...(l.stacktrace && { stacktrace: o(l.stacktrace) }),
            })),
          },
        }
      } catch {
        return c
      }
    }
    function o(c) {
      return { ...c, frames: c && c.frames && c.frames.map((l) => r(l)) }
    }
    return {
      name: kgt,
      processEvent(c) {
        let l = c
        return c.exception && Array.isArray(c.exception.values) && (l = a(l)), l
      },
    }
  }
function Sgt({ isBrowser: i, root: t, prefix: e }) {
  return (s) => {
    if (!s.filename) return s
    const r =
        /^[a-zA-Z]:\\/.test(s.filename) ||
        (s.filename.includes("\\") && !s.filename.includes("/")),
      a = /^\//.test(s.filename)
    if (i) {
      if (t) {
        const o = s.filename
        o.indexOf(t) === 0 && (s.filename = o.replace(t, e))
      }
    } else if (r || a) {
      const o = r
          ? s.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/")
          : s.filename,
        c = t ? yft(t, o) : bft(o)
      s.filename = `${e}${c}`
    }
    return s
  }
}
var Egt = "SessionTiming",
  Igt = () => {
    const i = pc() * 1e3
    return {
      name: Egt,
      processEvent(t) {
        const e = pc() * 1e3
        return {
          ...t,
          extra: {
            ...t.extra,
            "session:start": i,
            "session:duration": e - i,
            "session:end": e,
          },
        }
      },
    }
  },
  qjt = Igt,
  Pgt = 10,
  $gt = "ZodErrors"
function xgt(i) {
  return mc(i) && i.name === "ZodError" && Array.isArray(i.errors)
}
function Ngt(i) {
  return {
    ...i,
    path: "path" in i && Array.isArray(i.path) ? i.path.join(".") : void 0,
    keys: "keys" in i ? JSON.stringify(i.keys) : void 0,
    unionErrors: "unionErrors" in i ? JSON.stringify(i.unionErrors) : void 0,
  }
}
function Cgt(i) {
  const t = new Set()
  for (const s of i.issues) s.path && s.path[0] && t.add(s.path[0])
  const e = Array.from(t)
  return `Failed to validate keys: ${A7(e.join(", "), 100)}`
}
function Jgt(i, t, e) {
  return !t.exception ||
    !t.exception.values ||
    !e ||
    !e.originalException ||
    !xgt(e.originalException) ||
    e.originalException.issues.length === 0
    ? t
    : {
        ...t,
        exception: {
          ...t.exception,
          values: [
            { ...t.exception.values[0], value: Cgt(e.originalException) },
            ...t.exception.values.slice(1),
          ],
        },
        extra: {
          ...t.extra,
          "zoderror.issues": e.originalException.errors.slice(0, i).map(Ngt),
        },
      }
}
var Lgt = (i = {}) => {
    const t = i.limit || Pgt
    return {
      name: $gt,
      processEvent(e, s) {
        return Jgt(t, e, s)
      },
    }
  },
  Ujt = Lgt,
  Mjt = (i) => ({
    name: "ThirdPartyErrorsFilter",
    setup(t) {
      t.on("beforeEnvelope", (e) => {
        Pz(e, (s, r) => {
          if (r === "event") {
            const a = Array.isArray(s) ? s[1] : void 0
            a && (Zz(a), (s[1] = a))
          }
        })
      }),
        t.on("applyFrameMetadata", (e) => {
          if (e.type) return
          const s = t.getOptions().stackParser
          Kz(s, e)
        })
    },
    processEvent(t) {
      const e = Rgt(t)
      if (e) {
        const s =
          i.behaviour === "drop-error-if-contains-third-party-frames" ||
          i.behaviour === "apply-tag-if-contains-third-party-frames"
            ? "some"
            : "every"
        if (e[s]((a) => !a.some((o) => i.filterKeys.includes(o)))) {
          if (
            i.behaviour === "drop-error-if-contains-third-party-frames" ||
            i.behaviour ===
              "drop-error-if-exclusively-contains-third-party-frames"
          )
            return null
          t.tags = { ...t.tags, third_party_code: !0 }
        }
      }
      return t
    },
  })
function Rgt(i) {
  const t = M7(i)
  if (t)
    return t
      .filter((e) => !!e.filename)
      .map((e) =>
        e.module_metadata
          ? Object.keys(e.module_metadata)
              .filter((s) => s.startsWith(sY))
              .map((s) => s.slice(sY.length))
          : [],
      )
}
var sY = "_sentryBundlerPluginAppKey:",
  Dgt = "c",
  Fgt = "g",
  Agt = "s",
  _gt = "d"
function Ogt(i) {
  let t = 0
  for (let e = 0; e < i.length; e++) {
    const s = i.charCodeAt(e)
    ;(t = (t << 5) - t + s), (t &= t)
  }
  return t >>> 0
}
var Bgt = class {
    constructor(i) {
      this._value = i
    }
    get weight() {
      return 1
    }
    add(i) {
      this._value += i
    }
    toString() {
      return `${this._value}`
    }
  },
  qgt = class {
    constructor(i) {
      ;(this._last = i),
        (this._min = i),
        (this._max = i),
        (this._sum = i),
        (this._count = 1)
    }
    get weight() {
      return 5
    }
    add(i) {
      ;(this._last = i),
        i < this._min && (this._min = i),
        i > this._max && (this._max = i),
        (this._sum += i),
        this._count++
    }
    toString() {
      return `${this._last}:${this._min}:${this._max}:${this._sum}:${this._count}`
    }
  },
  Ugt = class {
    constructor(i) {
      this._value = [i]
    }
    get weight() {
      return this._value.length
    }
    add(i) {
      this._value.push(i)
    }
    toString() {
      return this._value.join(":")
    }
  },
  Mgt = class {
    constructor(i) {
      ;(this.first = i), (this._value = new Set([i]))
    }
    get weight() {
      return this._value.size
    }
    add(i) {
      this._value.add(i)
    }
    toString() {
      return Array.from(this._value)
        .map((i) => (typeof i == "string" ? Ogt(i) : i))
        .join(":")
    }
  },
  Hjt = { [Dgt]: Bgt, [Fgt]: qgt, [_gt]: Ugt, [Agt]: Mgt }
typeof Symbol.dispose != "symbol" &&
  Object.defineProperty(Symbol, "dispose", { value: Symbol("Symbol.dispose") }),
  typeof Symbol.asyncDispose != "symbol" &&
    Object.defineProperty(Symbol, "asyncDispose", {
      value: Symbol("Symbol.asyncDispose"),
    })
var rY = "traceparent"
function nq() {
  return !ds().enabled
}
function nY(i) {
  if (nq()) return new oY(void 0)
  const t = ds().tracesSampleRate,
    e = { [Q7]: t }
  let s
  return (
    Math.random() < t &&
      Ppt({ name: i, attributes: e, parentSpan: null }, (r) => {
        ;(s = r), s.setAttributes(e)
      }),
    new oY(s)
  )
}
function aY(i, t) {
  const e = nY(i)
  try {
    const s = t(e)
    return Kr(s)
      ? Promise.resolve(s)
          .catch((r) => {
            throw (e.setError(), r)
          })
          .finally(() => {
            e.end()
          })
      : (e.end(), s)
  } catch (s) {
    throw (e.setError(), e.end(), s)
  }
}
function Hgt(i) {
  return function (t, e, s) {
    const r = s.value
    return (
      (s.value = function (...a) {
        return aY(i, () => r.apply(this, a))
      }),
      s
    )
  }
}
var oY = class {
  constructor(i) {
    ;(this.a = !1), (this.b = i)
  }
  end() {
    this.a || (this.b?.end(), (this.a = !0))
  }
  spanContext() {
    return this.b?.spanContext()
  }
  setAttribute(i, t) {
    this.b?.setAttribute(i, t)
  }
  setError(i) {
    this.b?.setStatus({ code: 2, message: i ?? "internal_error" })
  }
  [Symbol.dispose]() {
    this.end()
  }
}
function Wgt(i) {
  nq() || yc().addBreadcrumb(i)
}
function jgt(i) {
  nq() || Ms(i) || xs.isErrorNoTelemetry(i) || zs().captureException(i)
}
function cY(i) {
  const t = i?.spanContext(),
    e = t?.traceId ?? zs().getPropagationContext().traceId,
    s = t?.spanId ?? Gs().substring(16),
    r = t?.traceFlags === 1 ? "01" : "00"
  return `00-${e}-${s}-${r}`
}
function Vgt(i) {
  i === void 0 ||
    i === "" ||
    zs().setPropagationContext({ ...zs().getPropagationContext(), traceId: i })
}
function Ggt() {
  try {
    rc.init({
      ...Tht(),
      integrations: [
        rc.inboundFiltersIntegration(),
        rc.functionToStringIntegration(),
        rc.linkedErrorsIntegration(),
        rc.dedupeIntegration(),
      ],
    }),
      (ds().sentry = rc),
      Vgt(process.env.CURSOR_TRACE_ID)
  } catch (i) {
    console.error("Failed to initialize tracing in extension process", i)
  }
}
Ggt()
var zgt = $V(xV(), 1)
import * as Ygt from "net"
function lY(i, t) {
  return new Qgt(i, t)
}
var Qgt = class {
  constructor(i, t) {
    ;(this.e = i),
      (this.f = t),
      (this.a = { flowing: !1, ended: !1, destroyed: !1 }),
      (this.b = { data: [], error: [] }),
      (this.c = { data: [], error: [], end: [] }),
      (this.d = [])
  }
  pause() {
    this.a.destroyed || (this.a.flowing = !1)
  }
  resume() {
    this.a.destroyed ||
      this.a.flowing ||
      ((this.a.flowing = !0), this.j(), this.k(), this.l())
  }
  write(i) {
    if (!this.a.destroyed) {
      if (this.a.flowing) this.g(i)
      else if (
        (this.b.data.push(i),
        typeof this.f?.highWaterMark == "number" &&
          this.b.data.length > this.f.highWaterMark)
      )
        return new Promise((t) => this.d.push(t))
    }
  }
  error(i) {
    this.a.destroyed || (this.a.flowing ? this.h(i) : this.b.error.push(i))
  }
  end(i) {
    this.a.destroyed ||
      (typeof i < "u" && this.write(i),
      this.a.flowing ? (this.i(), this.destroy()) : (this.a.ended = !0))
  }
  g(i) {
    this.c.data.slice(0).forEach((t) => t(i))
  }
  h(i) {
    this.c.error.length === 0
      ? $e(i)
      : this.c.error.slice(0).forEach((t) => t(i))
  }
  i() {
    this.c.end.slice(0).forEach((i) => i())
  }
  on(i, t) {
    if (!this.a.destroyed)
      switch (i) {
        case "data":
          this.c.data.push(t), this.resume()
          break
        case "end":
          this.c.end.push(t), this.a.flowing && this.l() && this.destroy()
          break
        case "error":
          this.c.error.push(t), this.a.flowing && this.k()
          break
      }
  }
  removeListener(i, t) {
    if (this.a.destroyed) return
    let e
    switch (i) {
      case "data":
        e = this.c.data
        break
      case "end":
        e = this.c.end
        break
      case "error":
        e = this.c.error
        break
    }
    if (e) {
      const s = e.indexOf(t)
      s >= 0 && e.splice(s, 1)
    }
  }
  j() {
    if (this.b.data.length > 0) {
      const i = this.e(this.b.data)
      this.g(i), (this.b.data.length = 0)
      const t = [...this.d]
      ;(this.d.length = 0), t.forEach((e) => e())
    }
  }
  k() {
    if (this.c.error.length > 0) {
      for (const i of this.b.error) this.h(i)
      this.b.error.length = 0
    }
  }
  l() {
    return this.a.ended ? (this.i(), this.c.end.length > 0) : !1
  }
  destroy() {
    this.a.destroyed ||
      ((this.a.destroyed = !0),
      (this.a.ended = !0),
      (this.b.data.length = 0),
      (this.b.error.length = 0),
      (this.c.data.length = 0),
      (this.c.error.length = 0),
      (this.c.end.length = 0),
      (this.d.length = 0))
  }
}
function Xgt(i, t) {
  return new Promise((e, s) => {
    const r = []
    uY(i, {
      onData: (a) => {
        t && r.push(a)
      },
      onError: (a) => {
        t ? s(a) : e(void 0)
      },
      onEnd: () => {
        e(t ? t(r) : void 0)
      },
    })
  })
}
function uY(i, t, e) {
  i.on("error", (s) => {
    e?.isCancellationRequested || t.onError(s)
  }),
    i.on("end", () => {
      e?.isCancellationRequested || t.onEnd()
    }),
    i.on("data", (s) => {
      e?.isCancellationRequested || t.onData(s)
    })
}
function Kgt(i, t, e) {
  const s = lY(e)
  return (
    uY(i, {
      onData: (r) => s.write(t.data(r)),
      onError: (r) => s.error(t.error ? t.error(r) : r),
      onEnd: () => s.end(),
    }),
    s
  )
}
var U_ = typeof Buffer < "u",
  Zgt = new as(() => new Uint8Array(256)),
  aq,
  oq,
  Q = class Os {
    static alloc(t) {
      return U_ ? new Os(Buffer.allocUnsafe(t)) : new Os(new Uint8Array(t))
    }
    static wrap(t) {
      return (
        U_ &&
          !Buffer.isBuffer(t) &&
          (t = Buffer.from(t.buffer, t.byteOffset, t.byteLength)),
        new Os(t)
      )
    }
    static fromString(t, e) {
      return !(e?.dontUseNodeBuffer || !1) && U_
        ? new Os(Buffer.from(t))
        : (aq || (aq = new TextEncoder()), new Os(aq.encode(t)))
    }
    static fromByteArray(t) {
      const e = Os.alloc(t.length)
      for (let s = 0, r = t.length; s < r; s++) e.buffer[s] = t[s]
      return e
    }
    static concat(t, e) {
      if (typeof e > "u") {
        e = 0
        for (let a = 0, o = t.length; a < o; a++) e += t[a].byteLength
      }
      const s = Os.alloc(e)
      let r = 0
      for (let a = 0, o = t.length; a < o; a++) {
        const c = t[a]
        s.set(c, r), (r += c.byteLength)
      }
      return s
    }
    constructor(t) {
      ;(this.buffer = t), (this.byteLength = this.buffer.byteLength)
    }
    clone() {
      const t = Os.alloc(this.byteLength)
      return t.set(this), t
    }
    toString() {
      return U_
        ? this.buffer.toString()
        : (oq || (oq = new TextDecoder()), oq.decode(this.buffer))
    }
    slice(t, e) {
      return new Os(this.buffer.subarray(t, e))
    }
    set(t, e) {
      if (t instanceof Os) this.buffer.set(t.buffer, e)
      else if (t instanceof Uint8Array) this.buffer.set(t, e)
      else if (t instanceof ArrayBuffer) this.buffer.set(new Uint8Array(t), e)
      else if (ArrayBuffer.isView(t))
        this.buffer.set(new Uint8Array(t.buffer, t.byteOffset, t.byteLength), e)
      else throw new Error("Unknown argument 'array'")
    }
    readUInt32BE(t) {
      return M_(this.buffer, t)
    }
    writeUInt32BE(t, e) {
      H_(this.buffer, t, e)
    }
    readUInt32LE(t) {
      return svt(this.buffer, t)
    }
    writeUInt32LE(t, e) {
      rvt(this.buffer, t, e)
    }
    readUInt8(t) {
      return nvt(this.buffer, t)
    }
    writeUInt8(t, e) {
      avt(this.buffer, t, e)
    }
    indexOf(t, e = 0) {
      return tvt(this.buffer, t instanceof Os ? t.buffer : t, e)
    }
  }
function tvt(i, t, e = 0) {
  const s = t.byteLength,
    r = i.byteLength
  if (s === 0) return 0
  if (s === 1) return i.indexOf(t[0])
  if (s > r - e) return -1
  const a = Zgt.value
  a.fill(t.length)
  for (let u = 0; u < t.length; u++) a[t[u]] = t.length - u - 1
  let o = e + t.length - 1,
    c = o,
    l = -1
  for (; o < r; )
    if (i[o] === t[c]) {
      if (c === 0) {
        l = o
        break
      }
      o--, c--
    } else (o += Math.max(t.length - c, a[i[o]])), (c = t.length - 1)
  return l
}
function evt(i, t) {
  return ((i[t + 0] << 0) >>> 0) | ((i[t + 1] << 8) >>> 0)
}
function ivt(i, t, e) {
  ;(i[e + 0] = t & 255), (t = t >>> 8), (i[e + 1] = t & 255)
}
function M_(i, t) {
  return i[t] * 2 ** 24 + i[t + 1] * 2 ** 16 + i[t + 2] * 2 ** 8 + i[t + 3]
}
function H_(i, t, e) {
  ;(i[e + 3] = t),
    (t = t >>> 8),
    (i[e + 2] = t),
    (t = t >>> 8),
    (i[e + 1] = t),
    (t = t >>> 8),
    (i[e] = t)
}
function svt(i, t) {
  return (
    ((i[t + 0] << 0) >>> 0) |
    ((i[t + 1] << 8) >>> 0) |
    ((i[t + 2] << 16) >>> 0) |
    ((i[t + 3] << 24) >>> 0)
  )
}
function rvt(i, t, e) {
  ;(i[e + 0] = t & 255),
    (t = t >>> 8),
    (i[e + 1] = t & 255),
    (t = t >>> 8),
    (i[e + 2] = t & 255),
    (t = t >>> 8),
    (i[e + 3] = t & 255)
}
function nvt(i, t) {
  return i[t]
}
function avt(i, t, e) {
  i[e] = t
}
function ovt(i) {
  return Xgt(i, (t) => Q.concat(t))
}
function cvt(i) {
  return Kgt(
    i,
    { data: (t) => (typeof t == "string" ? Q.fromString(t) : Q.wrap(t)) },
    (t) => Q.concat(t),
  )
}
function W_(i) {
  let t = 0,
    e = 0,
    s = 0
  const r = new Uint8Array(Math.floor((i.length / 4) * 3)),
    a = (c) => {
      switch (e) {
        case 3:
          ;(r[s++] = t | c), (e = 0)
          break
        case 2:
          ;(r[s++] = t | (c >>> 2)), (t = c << 6), (e = 3)
          break
        case 1:
          ;(r[s++] = t | (c >>> 4)), (t = c << 4), (e = 2)
          break
        default:
          ;(t = c << 2), (e = 1)
      }
    }
  for (let c = 0; c < i.length; c++) {
    const l = i.charCodeAt(c)
    if (l >= 65 && l <= 90) a(l - 65)
    else if (l >= 97 && l <= 122) a(l - 97 + 26)
    else if (l >= 48 && l <= 57) a(l - 48 + 52)
    else if (l === 43 || l === 45) a(62)
    else if (l === 47 || l === 95) a(63)
    else {
      if (l === 61) break
      throw new SyntaxError(`Unexpected base64 character ${i[c]}`)
    }
  }
  const o = s
  for (; e > 0; ) a(0)
  return Q.wrap(r).slice(0, o)
}
var lvt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  uvt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
function Yu({ buffer: i }, t = !0, e = !1) {
  const s = e ? uvt : lvt
  let r = ""
  const a = i.byteLength % 3
  let o = 0
  for (; o < i.byteLength - a; o += 3) {
    const c = i[o + 0],
      l = i[o + 1],
      u = i[o + 2]
    ;(r += s[c >>> 2]),
      (r += s[((c << 4) | (l >>> 4)) & 63]),
      (r += s[((l << 2) | (u >>> 6)) & 63]),
      (r += s[u & 63])
  }
  if (a === 1) {
    const c = i[o + 0]
    ;(r += s[c >>> 2]), (r += s[(c << 4) & 63]), t && (r += "==")
  } else if (a === 2) {
    const c = i[o + 0],
      l = i[o + 1]
    ;(r += s[c >>> 2]),
      (r += s[((c << 4) | (l >>> 4)) & 63]),
      (r += s[(l << 2) & 63]),
      t && (r += "=")
  }
  return r
}
function cq(i) {
  const t = []
  typeof i == "number" && t.push("code/timeOrigin", i)
  function e(r, a) {
    t.push(r, a?.startTime ?? Date.now())
  }
  function s() {
    const r = []
    for (let a = 0; a < t.length; a += 2)
      r.push({ name: t[a], startTime: t[a + 1] })
    return r
  }
  return { mark: e, getMarks: s }
}
function hvt() {
  if (
    typeof performance == "object" &&
    typeof performance.mark == "function" &&
    !performance.nodeTiming
  )
    return typeof performance.timeOrigin != "number" && !performance.timing
      ? cq()
      : {
          mark(i, t) {
            performance.mark(i, t)
          },
          getMarks() {
            let i = performance.timeOrigin
            typeof i != "number" &&
              (i =
                performance.timing.navigationStart ||
                performance.timing.redirectStart ||
                performance.timing.fetchStart)
            const t = [{ name: "code/timeOrigin", startTime: Math.round(i) }]
            for (const e of performance.getEntriesByType("mark"))
              t.push({ name: e.name, startTime: Math.round(i + e.startTime) })
            return t
          },
        }
  if (typeof process == "object") {
    const i = performance?.timeOrigin
    return cq(i)
  } else return console.trace("perf-util loaded in UNKNOWN environment"), cq()
}
function dvt(i) {
  return (
    i.MonacoPerformanceMarks || (i.MonacoPerformanceMarks = hvt()),
    i.MonacoPerformanceMarks
  )
}
var hY = dvt(globalThis),
  Ae = hY.mark,
  mvt = hY.getMarks
import * as Qu from "fs"
var j_ = {}
pht(j_, {
  Promises: () => re,
  RimRafMode: () => za,
  SymlinkSupport: () => Mi,
  configureFlushOnWrite: () => hq,
  readdirSync: () => Tvt,
  rimrafSync: () => yvt,
  whenDeleted: () => Svt,
  writeFileSync: () => $vt,
})
import * as Gt from "fs"
import { tmpdir as fvt } from "os"
import { promisify as Xu } from "util"
var pvt = new Ju(1e4)
function V_(i) {
  return mY(i, "NFC", pvt)
}
var gvt = new Ju(1e4)
function dY(i) {
  return mY(i, "NFD", gvt)
}
var vvt = /[^\u0000-\u0080]/
function mY(i, t, e) {
  if (!i) return i
  const s = e.get(i)
  if (s) return s
  let r
  return vvt.test(i) ? (r = i.normalize(t)) : (r = i), e.set(i, r), r
}
var za
;(function (i) {
  ;(i[(i.UNLINK = 0)] = "UNLINK"), (i[(i.MOVE = 1)] = "MOVE")
})(za || (za = {}))
async function fY(i, t = za.UNLINK, e) {
  if (JG(i)) throw new Error("rimraf - will refuse to recursively delete root")
  return t === za.UNLINK ? lq(i) : wvt(i, e)
}
async function wvt(i, t = hmt(fvt())) {
  try {
    try {
      await Gt.promises.rename(i, t)
    } catch (e) {
      return e.code === "ENOENT" ? void 0 : lq(i)
    }
    lq(t).catch((e) => {})
  } catch (e) {
    if (e.code !== "ENOENT") throw e
  }
}
async function lq(i) {
  return Gt.promises.rm(i, { recursive: !0, force: !0, maxRetries: 3 })
}
function yvt(i) {
  if (JG(i)) throw new Error("rimraf - will refuse to recursively delete root")
  Gt.rmSync(i, { recursive: !0, force: !0, maxRetries: 3 })
}
async function G_(i, t) {
  return pY(await (t ? bvt(i) : Gt.promises.readdir(i)))
}
async function bvt(i) {
  try {
    return await Gt.promises.readdir(i, { withFileTypes: !0 })
  } catch (s) {
    console.warn("[node.js fs] readdir with filetypes failed with error: ", s)
  }
  const t = [],
    e = await G_(i)
  for (const s of e) {
    let r = !1,
      a = !1,
      o = !1
    try {
      const c = await Gt.promises.lstat(se(i, s))
      ;(r = c.isFile()), (a = c.isDirectory()), (o = c.isSymbolicLink())
    } catch (c) {
      console.warn(
        "[node.js fs] unexpected error from lstat after readdir: ",
        c,
      )
    }
    t.push({
      name: s,
      isFile: () => r,
      isDirectory: () => a,
      isSymbolicLink: () => o,
    })
  }
  return t
}
function Tvt(i) {
  return pY(Gt.readdirSync(i))
}
function pY(i) {
  return i.map((t) =>
    typeof t == "string"
      ? Ke
        ? V_(t)
        : t
      : ((t.name = Ke ? V_(t.name) : t.name), t),
  )
}
async function kvt(i) {
  const t = await G_(i),
    e = []
  for (const s of t) (await Mi.existsDirectory(se(i, s))) && e.push(s)
  return e
}
function Svt(i, t = 1e3) {
  return new Promise((e) => {
    let s = !1
    const r = setInterval(() => {
      s ||
        ((s = !0),
        Gt.access(i, (a) => {
          ;(s = !1), a && (clearInterval(r), e(void 0))
        }))
    }, t)
  })
}
var Mi
;(function (i) {
  async function t(r) {
    let a
    try {
      if (((a = await Gt.promises.lstat(r)), !a.isSymbolicLink()))
        return { stat: a }
    } catch {}
    try {
      return {
        stat: await Gt.promises.stat(r),
        symbolicLink: a?.isSymbolicLink() ? { dangling: !1 } : void 0,
      }
    } catch (o) {
      if (o.code === "ENOENT" && a)
        return { stat: a, symbolicLink: { dangling: !0 } }
      if (ie && o.code === "EACCES")
        try {
          return {
            stat: await Gt.promises.stat(await Gt.promises.readlink(r)),
            symbolicLink: { dangling: !1 },
          }
        } catch (c) {
          if (c.code === "ENOENT" && a)
            return { stat: a, symbolicLink: { dangling: !0 } }
          throw c
        }
      throw o
    }
  }
  i.stat = t
  async function e(r) {
    try {
      const { stat: a, symbolicLink: o } = await i.stat(r)
      return a.isFile() && o?.dangling !== !0
    } catch {}
    return !1
  }
  i.existsFile = e
  async function s(r) {
    try {
      const { stat: a, symbolicLink: o } = await i.stat(r)
      return a.isDirectory() && o?.dangling !== !0
    } catch {}
    return !1
  }
  i.existsDirectory = s
})(Mi || (Mi = {}))
var Evt = new KG()
function Ivt(i, t, e) {
  return Evt.queueFor(
    S.file(i),
    () => {
      const s = gY(e)
      return new Promise((r, a) => Pvt(i, t, s, (o) => (o ? a(o) : r())))
    },
    J7,
  )
}
var uq = !0
function hq(i) {
  uq = i
}
function Pvt(i, t, e, s) {
  if (!uq) return Gt.writeFile(i, t, { mode: e.mode, flag: e.flag }, s)
  Gt.open(i, e.flag, e.mode, (r, a) => {
    if (r) return s(r)
    Gt.writeFile(a, t, (o) => {
      if (o) return Gt.close(a, () => s(o))
      Gt.fdatasync(
        a,
        (c) => (
          c &&
            (console.warn(
              "[node.js fs] fdatasync is now disabled for this session because it failed: ",
              c,
            ),
            hq(!1)),
          Gt.close(a, (l) => s(l))
        ),
      )
    })
  })
}
function $vt(i, t, e) {
  const s = gY(e)
  if (!uq) return Gt.writeFileSync(i, t, { mode: s.mode, flag: s.flag })
  const r = Gt.openSync(i, s.flag, s.mode)
  try {
    Gt.writeFileSync(r, t)
    try {
      Gt.fdatasyncSync(r)
    } catch (a) {
      console.warn(
        "[node.js fs] fdatasyncSync is now disabled for this session because it failed: ",
        a,
      ),
        hq(!1)
    }
  } finally {
    Gt.closeSync(r)
  }
}
function gY(i) {
  return i
    ? {
        mode: typeof i.mode == "number" ? i.mode : 438,
        flag: typeof i.flag == "string" ? i.flag : "w",
      }
    : { mode: 438, flag: "w" }
}
async function xvt(i, t, e = 6e4) {
  if (i !== t)
    try {
      ie && typeof e == "number"
        ? await vY(i, t, Date.now(), e)
        : await Gt.promises.rename(i, t)
    } catch (s) {
      if (
        (i.toLowerCase() !== t.toLowerCase() && s.code === "EXDEV") ||
        i.endsWith(".")
      )
        await wY(i, t, { preserveSymlinks: !1 }), await fY(i, za.MOVE)
      else throw s
    }
}
async function vY(i, t, e, s, r = 0) {
  try {
    return await Gt.promises.rename(i, t)
  } catch (a) {
    if (a.code !== "EACCES" && a.code !== "EPERM" && a.code !== "EBUSY") throw a
    if (Date.now() - e >= s)
      throw (
        (console.error(
          `[node.js fs] rename failed after ${r} retries with error: ${a}`,
        ),
        a)
      )
    if (r === 0) {
      let o = !1
      try {
        const { stat: c } = await Mi.stat(t)
        c.isFile() || (o = !0)
      } catch {}
      if (o) throw a
    }
    return await Fi(Math.min(100, r * 10)), vY(i, t, e, s, r + 1)
  }
}
async function wY(i, t, e) {
  return bY(i, t, {
    root: { source: i, target: t },
    options: e,
    handledSourcePaths: new Set(),
  })
}
var yY = 511
async function bY(i, t, e) {
  if (e.handledSourcePaths.has(i)) return
  e.handledSourcePaths.add(i)
  const { stat: s, symbolicLink: r } = await Mi.stat(i)
  if (r) {
    if (e.options.preserveSymlinks)
      try {
        return await Jvt(i, t, e)
      } catch {}
    if (r.dangling) return
  }
  return s.isDirectory() ? Nvt(i, t, s.mode & yY, e) : Cvt(i, t, s.mode & yY)
}
async function Nvt(i, t, e, s) {
  await Gt.promises.mkdir(t, { recursive: !0, mode: e })
  const r = await G_(i)
  for (const a of r) await bY(se(i, a), se(t, a), s)
}
async function Cvt(i, t, e) {
  await Gt.promises.copyFile(i, t), await Gt.promises.chmod(t, e)
}
async function Jvt(i, t, e) {
  let s = await Gt.promises.readlink(i)
  ja(s, e.root.source, !De) &&
    (s = se(e.root.target, s.substr(e.root.source.length + 1))),
    await Gt.promises.symlink(s, t)
}
var re = new (class {
  get read() {
    return (i, t, e, s, r) =>
      new Promise((a, o) => {
        Gt.read(i, t, e, s, r, (c, l, u) =>
          c ? o(c) : a({ bytesRead: l, buffer: u }),
        )
      })
  }
  get write() {
    return (i, t, e, s, r) =>
      new Promise((a, o) => {
        Gt.write(i, t, e, s, r, (c, l, u) =>
          c ? o(c) : a({ bytesWritten: l, buffer: u }),
        )
      })
  }
  get fdatasync() {
    return Xu(Gt.fdatasync)
  }
  get open() {
    return Xu(Gt.open)
  }
  get close() {
    return Xu(Gt.close)
  }
  get realpath() {
    return Xu(Gt.realpath)
  }
  get ftruncate() {
    return Xu(Gt.ftruncate)
  }
  async exists(i) {
    try {
      return await Gt.promises.access(i), !0
    } catch {
      return !1
    }
  }
  get readdir() {
    return G_
  }
  get readDirsInDir() {
    return kvt
  }
  get writeFile() {
    return Ivt
  }
  get rm() {
    return fY
  }
  get rename() {
    return xvt
  }
  get copy() {
    return wY
  }
})()
async function dq(i, t) {
  if (De) return i
  const e = Ui(i)
  if (i === e) return i
  const s = (ke(i) || i).toLowerCase()
  try {
    if (t?.isCancellationRequested) return null
    const a = (await re.readdir(e)).filter((o) => o.toLowerCase() === s)
    if (a.length === 1) {
      const o = await dq(e, t)
      if (o) return se(o, a[0])
    } else if (a.length > 1) {
      const o = a.indexOf(s)
      if (o >= 0) {
        const c = await dq(e, t)
        if (c) return se(c, a[o])
      }
    }
  } catch {}
  return null
}
async function Lvt(i) {
  try {
    return await re.realpath(i)
  } catch {
    const e = TY(i)
    return await Qu.promises.access(e, Qu.constants.R_OK), e
  }
}
function Rvt(i) {
  try {
    return Qu.realpathSync(i)
  } catch {
    const e = TY(i)
    return Qu.accessSync(e, Qu.constants.R_OK), e
  }
}
function TY(i) {
  return Gn(Xr(i), xe)
}
function kY(i) {
  return (t, e, s) => {
    let r = null,
      a = null
    if (
      (typeof s.value == "function"
        ? ((r = "value"), (a = s.value))
        : typeof s.get == "function" && ((r = "get"), (a = s.get)),
      !a || typeof e == "symbol")
    )
      throw new Error("not supported")
    s[r] = i(a, e)
  }
}
function SY(i, t, e) {
  let s = null,
    r = null
  if (
    (typeof e.value == "function"
      ? ((s = "value"),
        (r = e.value),
        r.length !== 0 &&
          console.warn(
            "Memoize should only be used in functions with zero parameters",
          ))
      : typeof e.get == "function" && ((s = "get"), (r = e.get)),
    !r)
  )
    throw new Error("not supported")
  const a = `$memoize$${t}`
  e[s] = function (...o) {
    return (
      this.hasOwnProperty(a) ||
        Object.defineProperty(this, a, {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: r.apply(this, o),
        }),
      this[a]
    )
  }
}
function z_(i, t, e) {
  return kY((s, r) => {
    const a = `$debounce$${r}`,
      o = `$debounce$result$${r}`
    return function (...c) {
      this[o] || (this[o] = e ? e() : void 0),
        clearTimeout(this[a]),
        t && ((this[o] = t(this[o], ...c)), (c = [this[o]])),
        (this[a] = setTimeout(() => {
          s.apply(this, c), (this[o] = e ? e() : void 0)
        }, i))
    }
  })
}
function Dvt(i, t, e) {
  return kY((s, r) => {
    const a = `$throttle$timer$${r}`,
      o = `$throttle$result$${r}`,
      c = `$throttle$lastRun$${r}`,
      l = `$throttle$pending$${r}`
    return function (...u) {
      if (
        (this[o] || (this[o] = e ? e() : void 0),
        (this[c] === null || this[c] === void 0) &&
          (this[c] = -Number.MAX_VALUE),
        t && (this[o] = t(this[o], ...u)),
        this[l])
      )
        return
      const d = this[c] + i
      d <= Date.now()
        ? ((this[c] = Date.now()),
          s.apply(this, [this[o]]),
          (this[o] = e ? e() : void 0))
        : ((this[l] = !0),
          (this[a] = setTimeout(() => {
            ;(this[l] = !1),
              (this[c] = Date.now()),
              s.apply(this, [this[o]]),
              (this[o] = e ? e() : void 0)
          }, d - Date.now())))
    }
  })
}
function Fvt(i) {
  return JSON.stringify(i, Avt)
}
function EY(i) {
  let t = JSON.parse(i)
  return (t = ki(t)), t
}
function Avt(i, t) {
  return t instanceof RegExp ? { $mid: 2, source: t.source, flags: t.flags } : t
}
function ki(i, t = 0) {
  if (!i || t > 200) return i
  if (typeof i == "object") {
    switch (i.$mid) {
      case 1:
        return S.revive(i)
      case 2:
        return new RegExp(i.source, i.flags)
      case 17:
        return new Date(i.source)
    }
    if (i instanceof Q || i instanceof Uint8Array) return i
    if (Array.isArray(i))
      for (let e = 0; e < i.length; ++e) i[e] = ki(i[e], t + 1)
    else
      for (const e in i)
        Object.hasOwnProperty.call(i, e) && (i[e] = ki(i[e], t + 1))
  }
  return i
}
var IY
;(function (i) {
  ;(i[(i.Promise = 100)] = "Promise"),
    (i[(i.PromiseCancel = 101)] = "PromiseCancel"),
    (i[(i.EventListen = 102)] = "EventListen"),
    (i[(i.EventDispose = 103)] = "EventDispose")
})(IY || (IY = {}))
function PY(i) {
  switch (i) {
    case 100:
      return "req"
    case 101:
      return "cancel"
    case 102:
      return "subscribe"
    case 103:
      return "unsubscribe"
  }
}
var $Y
;(function (i) {
  ;(i[(i.Initialize = 200)] = "Initialize"),
    (i[(i.PromiseSuccess = 201)] = "PromiseSuccess"),
    (i[(i.PromiseError = 202)] = "PromiseError"),
    (i[(i.PromiseErrorObj = 203)] = "PromiseErrorObj"),
    (i[(i.EventFire = 204)] = "EventFire")
})($Y || ($Y = {}))
function xY(i) {
  switch (i) {
    case 200:
      return "init"
    case 201:
      return "reply:"
    case 202:
    case 203:
      return "replyErr:"
    case 204:
      return "event:"
  }
}
var Ya
;(function (i) {
  ;(i[(i.Uninitialized = 0)] = "Uninitialized"), (i[(i.Idle = 1)] = "Idle")
})(Ya || (Ya = {}))
function Tc(i) {
  let t = 0
  for (let e = 0; ; e += 7) {
    const s = i.read(1)
    if (((t |= (s.buffer[0] & 127) << e), !(s.buffer[0] & 128))) return t
  }
}
var _vt = Zn(0)
function kc(i, t) {
  if (t === 0) {
    i.write(_vt)
    return
  }
  let e = 0
  for (let r = t; r !== 0; r = r >>> 7) e++
  const s = Q.alloc(e)
  for (let r = 0; t !== 0; r++)
    (s.buffer[r] = t & 127), (t = t >>> 7), t > 0 && (s.buffer[r] |= 128)
  i.write(s)
}
var Ovt = class {
    constructor(i) {
      ;(this.b = i), (this.a = 0)
    }
    read(i) {
      const t = this.b.slice(this.a, this.a + i)
      return (this.a += t.byteLength), t
    }
  },
  Bvt = class {
    constructor() {
      this.a = []
    }
    get buffer() {
      return Q.concat(this.a)
    }
    write(i) {
      this.a.push(i)
    }
  },
  Ai
;(function (i) {
  ;(i[(i.Undefined = 0)] = "Undefined"),
    (i[(i.String = 1)] = "String"),
    (i[(i.Buffer = 2)] = "Buffer"),
    (i[(i.VSBuffer = 3)] = "VSBuffer"),
    (i[(i.Array = 4)] = "Array"),
    (i[(i.Object = 5)] = "Object"),
    (i[(i.Int = 6)] = "Int")
})(Ai || (Ai = {}))
function Zn(i) {
  const t = Q.alloc(1)
  return t.writeUInt8(i, 0), t
}
var Qa = {
    Undefined: Zn(Ai.Undefined),
    String: Zn(Ai.String),
    Buffer: Zn(Ai.Buffer),
    VSBuffer: Zn(Ai.VSBuffer),
    Array: Zn(Ai.Array),
    Object: Zn(Ai.Object),
    Uint: Zn(Ai.Int),
  },
  qvt = typeof Buffer < "u"
function mq(i, t) {
  if (typeof t > "u") i.write(Qa.Undefined)
  else if (typeof t == "string") {
    const e = Q.fromString(t)
    i.write(Qa.String), kc(i, e.byteLength), i.write(e)
  } else if (qvt && Buffer.isBuffer(t)) {
    const e = Q.wrap(t)
    i.write(Qa.Buffer), kc(i, e.byteLength), i.write(e)
  } else if (t instanceof Q)
    i.write(Qa.VSBuffer), kc(i, t.byteLength), i.write(t)
  else if (Array.isArray(t)) {
    i.write(Qa.Array), kc(i, t.length)
    for (const e of t) mq(i, e)
  } else if (typeof t == "number" && (t | 0) === t) i.write(Qa.Uint), kc(i, t)
  else {
    const e = Q.fromString(JSON.stringify(t))
    i.write(Qa.Object), kc(i, e.byteLength), i.write(e)
  }
}
function fq(i) {
  switch (i.read(1).readUInt8(0)) {
    case Ai.Undefined:
      return
    case Ai.String:
      return i.read(Tc(i)).toString()
    case Ai.Buffer:
      return i.read(Tc(i)).buffer
    case Ai.VSBuffer:
      return i.read(Tc(i))
    case Ai.Array: {
      const e = Tc(i),
        s = []
      for (let r = 0; r < e; r++) s.push(fq(i))
      return s
    }
    case Ai.Object:
      return JSON.parse(i.read(Tc(i)).toString())
    case Ai.Int:
      return Tc(i)
  }
}
var NY
;(function (i) {
  ;(i[(i.LocalSide = 0)] = "LocalSide"), (i[(i.OtherSide = 1)] = "OtherSide")
})(NY || (NY = {}))
var CY = class {
  constructor(i, t = null) {
    ;(this.l = i),
      (this.a = !1),
      (this.b = Ya.Uninitialized),
      (this.d = new Set()),
      (this.f = new Map()),
      (this.g = 0),
      (this.k = new J()),
      (this.onDidInitialize = this.k.event),
      (this.h = this.l.onMessage((e) => this.s(e))),
      (this.j = t)
  }
  getChannel(i) {
    const t = this
    return {
      call(e, s, r) {
        return t.a ? Promise.reject(new bi()) : t.m(i, e, s, r)
      },
      listen(e, s) {
        return t.a ? Qt.None : t.o(i, e, s)
      },
    }
  }
  m(i, t, e, s = ce.None) {
    const r = this.g++,
      o = { id: r, type: 100, channelName: i, name: t, arg: e }
    if (s.isCancellationRequested) return Promise.reject(new bi())
    let c, l
    return new Promise((d, m) => {
      if (s.isCancellationRequested) return m(new bi())
      const f = () => {
        const b = (k) => {
          switch (k.type) {
            case 201:
              this.f.delete(r), d(k.data)
              break
            case 202: {
              this.f.delete(r)
              const E = new Error(k.data.message)
              ;(E.stack = Array.isArray(k.data.stack)
                ? k.data.stack.join(`
`)
                : k.data.stack),
                (E.name = k.data.name),
                m(E)
              break
            }
            case 203:
              this.f.delete(r), m(k.data)
              break
          }
        }
        this.f.set(r, b), this.p(o)
      }
      let p = null
      this.b === Ya.Idle
        ? f()
        : ((p = Zr((b) => this.u())),
          p.then(() => {
            ;(p = null), f()
          }))
      const v = () => {
        p ? (p.cancel(), (p = null)) : this.p({ id: r, type: 101 }), m(new bi())
      }
      ;(c = s.onCancellationRequested(v)),
        (l = {
          dispose: d_(() => {
            v(), c.dispose()
          }),
        }),
        this.d.add(l)
    }).finally(() => {
      c.dispose(), this.d.delete(l)
    })
  }
  o(i, t, e) {
    const s = this.g++,
      a = { id: s, type: 102, channelName: i, name: t, arg: e }
    let o = null
    const c = new J({
        onWillAddFirstListener: () => {
          const u = () => {
            this.d.add(c), this.p(a)
          }
          this.b === Ya.Idle
            ? u()
            : ((o = Zr((d) => this.u())),
              o.then(() => {
                ;(o = null), u()
              }))
        },
        onDidRemoveLastListener: () => {
          o
            ? (o.cancel(), (o = null))
            : (this.d.delete(c), this.p({ id: s, type: 103 }))
        },
      }),
      l = (u) => c.fire(u.data)
    return this.f.set(s, l), c.event
  }
  p(i) {
    switch (i.type) {
      case 100:
      case 102: {
        const t = this.q([i.type, i.id, i.channelName, i.name], i.arg)
        this.j?.logOutgoing(
          t,
          i.id,
          0,
          `${PY(i.type)}: ${i.channelName}.${i.name}`,
          i.arg,
        )
        return
      }
      case 101:
      case 103: {
        const t = this.q([i.type, i.id])
        this.j?.logOutgoing(t, i.id, 0, PY(i.type))
        return
      }
    }
  }
  q(i, t = void 0) {
    const e = new Bvt()
    return mq(e, i), mq(e, t), this.r(e.buffer)
  }
  r(i) {
    try {
      return this.l.send(i), i.byteLength
    } catch {
      return 0
    }
  }
  s(i) {
    const t = new Ovt(i),
      e = fq(t),
      s = fq(t),
      r = e[0]
    switch (r) {
      case 200:
        return (
          this.j?.logIncoming(i.byteLength, 0, 0, xY(r)), this.t({ type: e[0] })
        )
      case 201:
      case 202:
      case 204:
      case 203:
        return (
          this.j?.logIncoming(i.byteLength, e[1], 0, xY(r), s),
          this.t({ type: e[0], id: e[1], data: s })
        )
    }
  }
  t(i) {
    if (i.type === 200) {
      ;(this.b = Ya.Idle), this.k.fire()
      return
    }
    this.f.get(i.id)?.(i)
  }
  get onDidInitializePromise() {
    return Qt.toPromise(this.onDidInitialize)
  }
  u() {
    return this.b === Ya.Idle ? Promise.resolve() : this.onDidInitializePromise
  }
  dispose() {
    ;(this.a = !0),
      this.h && (this.h.dispose(), (this.h = null)),
      Hs(this.d.values()),
      this.d.clear()
  }
}
__decorate([SY], CY.prototype, "onDidInitializePromise", null)
function Uvt(i) {
  let t = !1
  return {
    call(e, s, r) {
      return t
        ? i.call(e, s, r)
        : Fi(0)
            .then(() => (t = !0))
            .then(() => i.call(e, s, r))
    },
    listen(e, s) {
      if (t) return i.listen(e, s)
      const r = new ndt()
      return (
        Fi(0)
          .then(() => (t = !0))
          .then(() => (r.input = i.listen(e, s))),
        r.event
      )
    },
  }
}
var pq
;(function (i) {
  function t(a, o, c) {
    const l = a,
      u = c && c.disableMarshalling,
      d = new Map()
    for (const m in l) s(m) && d.set(m, Qt.buffer(l[m], !0, void 0, o))
    return new (class {
      listen(m, f, p) {
        const v = d.get(f)
        if (v) return v
        const b = l[f]
        if (typeof b == "function") {
          if (r(f)) return b.call(l, p)
          if (s(f)) return d.set(f, Qt.buffer(l[f], !0, void 0, o)), d.get(f)
        }
        throw new xs(`Event not found: ${f}`)
      }
      call(m, f, p) {
        const v = l[f]
        if (typeof v == "function") {
          if (!u && Array.isArray(p))
            for (let k = 0; k < p.length; k++) p[k] = ki(p[k])
          let b = v.apply(l, p)
          return b instanceof Promise || (b = Promise.resolve(b)), b
        }
        throw new xs(`Method not found: ${f}`)
      }
    })()
  }
  i.fromService = t
  function e(a, o) {
    const c = o && o.disableMarshalling
    return new Proxy(
      {},
      {
        get(l, u) {
          if (typeof u == "string")
            return o?.properties?.has(u)
              ? o.properties.get(u)
              : r(u)
                ? function (d) {
                    return a.listen(u, d)
                  }
                : s(u)
                  ? a.listen(u)
                  : async function (...d) {
                      let m
                      o && !Fe(o.context) ? (m = [o.context, ...d]) : (m = d)
                      const f = await a.call(u, m)
                      return c ? f : ki(f)
                    }
          throw new xs(`Property not found: ${String(u)}`)
        },
      },
    )
  }
  i.toService = e
  function s(a) {
    return a[0] === "o" && a[1] === "n" && gG(a.charCodeAt(2))
  }
  function r(a) {
    return /^onDynamic/.test(a) && gG(a.charCodeAt(9))
  }
})(pq || (pq = {}))
var JY
;(function (i) {
  ;(i.Created = "created"),
    (i.Read = "read"),
    (i.Write = "write"),
    (i.Open = "open"),
    (i.Error = "error"),
    (i.Close = "close"),
    (i.BrowserWebSocketBlobReceived = "browserWebSocketBlobReceived"),
    (i.NodeEndReceived = "nodeEndReceived"),
    (i.NodeEndSent = "nodeEndSent"),
    (i.NodeDrainBegin = "nodeDrainBegin"),
    (i.NodeDrainEnd = "nodeDrainEnd"),
    (i.zlibInflateError = "zlibInflateError"),
    (i.zlibInflateData = "zlibInflateData"),
    (i.zlibInflateInitialWrite = "zlibInflateInitialWrite"),
    (i.zlibInflateInitialFlushFired = "zlibInflateInitialFlushFired"),
    (i.zlibInflateWrite = "zlibInflateWrite"),
    (i.zlibInflateFlushFired = "zlibInflateFlushFired"),
    (i.zlibDeflateError = "zlibDeflateError"),
    (i.zlibDeflateData = "zlibDeflateData"),
    (i.zlibDeflateWrite = "zlibDeflateWrite"),
    (i.zlibDeflateFlushFired = "zlibDeflateFlushFired"),
    (i.WebSocketNodeSocketWrite = "webSocketNodeSocketWrite"),
    (i.WebSocketNodeSocketPeekedHeader = "webSocketNodeSocketPeekedHeader"),
    (i.WebSocketNodeSocketReadHeader = "webSocketNodeSocketReadHeader"),
    (i.WebSocketNodeSocketReadData = "webSocketNodeSocketReadData"),
    (i.WebSocketNodeSocketUnmaskedData = "webSocketNodeSocketUnmaskedData"),
    (i.WebSocketNodeSocketDrainBegin = "webSocketNodeSocketDrainBegin"),
    (i.WebSocketNodeSocketDrainEnd = "webSocketNodeSocketDrainEnd"),
    (i.ProtocolHeaderRead = "protocolHeaderRead"),
    (i.ProtocolMessageRead = "protocolMessageRead"),
    (i.ProtocolHeaderWrite = "protocolHeaderWrite"),
    (i.ProtocolMessageWrite = "protocolMessageWrite"),
    (i.ProtocolWrite = "protocolWrite")
})(JY || (JY = {}))
var Y_
;(function (i) {
  ;(i.enableDiagnostics = !1), (i.records = [])
  const t = new WeakMap()
  let e = 0
  function s(a, o) {
    if (!t.has(a)) {
      const c = String(++e)
      t.set(a, c)
    }
    return t.get(a)
  }
  function r(a, o, c, l) {
    if (!i.enableDiagnostics) return
    const u = s(a, o)
    if (
      l instanceof Q ||
      l instanceof Uint8Array ||
      l instanceof ArrayBuffer ||
      ArrayBuffer.isView(l)
    ) {
      const d = Q.alloc(l.byteLength)
      d.set(l),
        i.records.push({
          timestamp: Date.now(),
          id: u,
          label: o,
          type: c,
          buff: d,
        })
    } else
      i.records.push({
        timestamp: Date.now(),
        id: u,
        label: o,
        type: c,
        data: l,
      })
  }
  i.traceSocketEvent = r
})(Y_ || (Y_ = {}))
var LY
;(function (i) {
  ;(i[(i.NodeSocketCloseEvent = 0)] = "NodeSocketCloseEvent"),
    (i[(i.WebSocketCloseEvent = 1)] = "WebSocketCloseEvent")
})(LY || (LY = {}))
var gq = null
function ta() {
  return gq || (gq = Q.alloc(0)), gq
}
var RY = class {
    get byteLength() {
      return this.b
    }
    constructor() {
      ;(this.a = []), (this.b = 0)
    }
    acceptChunk(i) {
      this.a.push(i), (this.b += i.byteLength)
    }
    read(i) {
      return this.c(i, !0)
    }
    peek(i) {
      return this.c(i, !1)
    }
    c(i, t) {
      if (i === 0) return ta()
      if (i > this.b) throw new Error("Cannot read so many bytes!")
      if (this.a[0].byteLength === i) {
        const a = this.a[0]
        return t && (this.a.shift(), (this.b -= i)), a
      }
      if (this.a[0].byteLength > i) {
        const a = this.a[0].slice(0, i)
        return t && ((this.a[0] = this.a[0].slice(i)), (this.b -= i)), a
      }
      const e = Q.alloc(i)
      let s = 0,
        r = 0
      for (; i > 0; ) {
        const a = this.a[r]
        if (a.byteLength > i) {
          const o = a.slice(0, i)
          e.set(o, s),
            (s += i),
            t && ((this.a[r] = a.slice(i)), (this.b -= i)),
            (i -= i)
        } else
          e.set(a, s),
            (s += a.byteLength),
            t ? (this.a.shift(), (this.b -= a.byteLength)) : r++,
            (i -= a.byteLength)
      }
      return e
    }
  },
  DY
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Regular = 1)] = "Regular"),
    (i[(i.Control = 2)] = "Control"),
    (i[(i.Ack = 3)] = "Ack"),
    (i[(i.Disconnect = 5)] = "Disconnect"),
    (i[(i.ReplayRequest = 6)] = "ReplayRequest"),
    (i[(i.Pause = 7)] = "Pause"),
    (i[(i.Resume = 8)] = "Resume"),
    (i[(i.KeepAlive = 9)] = "KeepAlive")
})(DY || (DY = {}))
function FY(i) {
  switch (i) {
    case 0:
      return "None"
    case 1:
      return "Regular"
    case 2:
      return "Control"
    case 3:
      return "Ack"
    case 5:
      return "Disconnect"
    case 6:
      return "ReplayRequest"
    case 7:
      return "PauseWriting"
    case 8:
      return "ResumeWriting"
    case 9:
      return "KeepAlive"
  }
}
var AY
;(function (i) {
  ;(i[(i.HeaderLength = 13)] = "HeaderLength"),
    (i[(i.AcknowledgeTime = 2e3)] = "AcknowledgeTime"),
    (i[(i.TimeoutTime = 2e4)] = "TimeoutTime"),
    (i[(i.ReconnectionGraceTime = 108e5)] = "ReconnectionGraceTime"),
    (i[(i.ReconnectionShortGraceTime = 3e5)] = "ReconnectionShortGraceTime"),
    (i[(i.KeepAliveSendTime = 5e3)] = "KeepAliveSendTime")
})(AY || (AY = {}))
var Cr = class {
    constructor(i, t, e, s) {
      ;(this.type = i),
        (this.id = t),
        (this.ack = e),
        (this.data = s),
        (this.writtenTime = 0)
    }
    get size() {
      return this.data.byteLength
    }
  },
  _Y = class extends at {
    constructor(i) {
      super(),
        (this.f = this.D(new J())),
        (this.onMessage = this.f.event),
        (this.g = { readHead: !0, readLen: 13, messageType: 0, id: 0, ack: 0 }),
        (this.a = i),
        (this.b = !1),
        (this.c = new RY()),
        this.D(this.a.onData((t) => this.acceptChunk(t))),
        (this.lastReadTime = Date.now())
    }
    acceptChunk(i) {
      if (!(!i || i.byteLength === 0))
        for (
          this.lastReadTime = Date.now(), this.c.acceptChunk(i);
          this.c.byteLength >= this.g.readLen;

        ) {
          const t = this.c.read(this.g.readLen)
          if (this.g.readHead)
            (this.g.readHead = !1),
              (this.g.readLen = t.readUInt32BE(9)),
              (this.g.messageType = t.readUInt8(0)),
              (this.g.id = t.readUInt32BE(1)),
              (this.g.ack = t.readUInt32BE(5)),
              this.a.traceSocketEvent("protocolHeaderRead", {
                messageType: FY(this.g.messageType),
                id: this.g.id,
                ack: this.g.ack,
                messageSize: this.g.readLen,
              })
          else {
            const e = this.g.messageType,
              s = this.g.id,
              r = this.g.ack
            if (
              ((this.g.readHead = !0),
              (this.g.readLen = 13),
              (this.g.messageType = 0),
              (this.g.id = 0),
              (this.g.ack = 0),
              this.a.traceSocketEvent("protocolMessageRead", t),
              this.f.fire(new Cr(e, s, r, t)),
              this.b)
            )
              break
          }
        }
    }
    readEntireBuffer() {
      return this.c.read(this.c.byteLength)
    }
    dispose() {
      ;(this.b = !0), super.dispose()
    }
  },
  OY = class {
    constructor(i) {
      ;(this.k = null),
        (this.a = !1),
        (this.b = !1),
        (this.c = i),
        (this.d = []),
        (this.f = 0),
        (this.lastWriteTime = 0)
    }
    dispose() {
      try {
        this.flush()
      } catch {}
      this.a = !0
    }
    drain() {
      return this.flush(), this.c.drain()
    }
    flush() {
      this.m()
    }
    pause() {
      this.b = !0
    }
    resume() {
      ;(this.b = !1), this.l()
    }
    write(i) {
      if (this.a) return
      ;(i.writtenTime = Date.now()), (this.lastWriteTime = Date.now())
      const t = Q.alloc(13)
      t.writeUInt8(i.type, 0),
        t.writeUInt32BE(i.id, 1),
        t.writeUInt32BE(i.ack, 5),
        t.writeUInt32BE(i.data.byteLength, 9),
        this.c.traceSocketEvent("protocolHeaderWrite", {
          messageType: FY(i.type),
          id: i.id,
          ack: i.ack,
          messageSize: i.data.byteLength,
        }),
        this.c.traceSocketEvent("protocolMessageWrite", i.data),
        this.j(t, i.data)
    }
    g(i, t) {
      const e = this.f === 0
      return this.d.push(i, t), (this.f += i.byteLength + t.byteLength), e
    }
    h() {
      const i = Q.concat(this.d, this.f)
      return (this.d.length = 0), (this.f = 0), i
    }
    j(i, t) {
      this.g(i, t) && this.l()
    }
    l() {
      this.k ||
        (this.k = setTimeout(() => {
          ;(this.k = null), this.m()
        }))
    }
    m() {
      if (this.f === 0 || this.b) return
      const i = this.h()
      this.c.traceSocketEvent("protocolWrite", { byteLength: i.byteLength }),
        this.c.write(i)
    }
  },
  Xa = class {
    constructor() {
      ;(this.b = !1),
        (this.c = !1),
        (this.d = []),
        (this.a = new J({
          onWillAddFirstListener: () => {
            ;(this.b = !0), queueMicrotask(() => this.f())
          },
          onDidRemoveLastListener: () => {
            this.b = !1
          },
        })),
        (this.event = this.a.event)
    }
    f() {
      if (!this.c) {
        for (this.c = !0; this.b && this.d.length > 0; )
          this.a.fire(this.d.shift())
        this.c = !1
      }
    }
    fire(i) {
      this.b
        ? this.d.length > 0
          ? this.d.push(i)
          : this.a.fire(i)
        : this.d.push(i)
    }
    flushBuffer() {
      this.d = []
    }
  },
  Mvt = class {
    constructor(i) {
      ;(this.data = i), (this.next = null)
    }
  },
  Hvt = class {
    constructor() {
      ;(this.a = null), (this.b = null)
    }
    length() {
      let i = 0,
        t = this.a
      for (; t; ) (t = t.next), i++
      return i
    }
    peek() {
      return this.a ? this.a.data : null
    }
    toArray() {
      const i = []
      let t = 0,
        e = this.a
      for (; e; ) (i[t++] = e.data), (e = e.next)
      return i
    }
    pop() {
      if (this.a) {
        if (this.a === this.b) {
          ;(this.a = null), (this.b = null)
          return
        }
        this.a = this.a.next
      }
    }
    push(i) {
      const t = new Mvt(i)
      if (!this.a) {
        ;(this.a = t), (this.b = t)
        return
      }
      ;(this.b.next = t), (this.b = t)
    }
  },
  Wvt = class Wr {
    static {
      this.a = 10
    }
    static {
      this.b = null
    }
    static getInstance() {
      return Wr.b || (Wr.b = new Wr()), Wr.b
    }
    constructor() {
      this.c = []
      const t = Date.now()
      for (let e = 0; e < Wr.a; e++) this.c[e] = t - 1e3 * e
      setInterval(() => {
        for (let e = Wr.a; e >= 1; e--) this.c[e] = this.c[e - 1]
        this.c[0] = Date.now()
      }, 1e3)
    }
    d() {
      const t = Date.now(),
        e = (1 + Wr.a) * 1e3
      let s = 0
      for (let r = 0; r < Wr.a; r++) t - this.c[r] <= e && s++
      return 1 - s / Wr.a
    }
    hasHighLoad() {
      return this.d() >= 0.5
    }
  },
  vq = class {
    get unacknowledgedCount() {
      return this.d - this.f
    }
    constructor(i) {
      ;(this.v = new Xa()),
        (this.onControlMessage = this.v.event),
        (this.w = new Xa()),
        (this.onMessage = this.w.event),
        (this.x = new Xa()),
        (this.onDidDispose = this.x.event),
        (this.y = new Xa()),
        (this.onSocketClose = this.y.event),
        (this.z = new Xa()),
        (this.onSocketTimeout = this.z.event),
        (this.t = i.loadEstimator ?? Wvt.getInstance()),
        (this.u = i.sendKeepAlive ?? !0),
        (this.a = !1),
        (this.c = new Hvt()),
        (this.d = 0),
        (this.f = 0),
        (this.g = null),
        (this.h = 0),
        (this.j = 0),
        (this.k = 0),
        (this.l = null),
        (this.n = 0),
        (this.o = Date.now()),
        (this.s = new gt()),
        (this.p = i.socket),
        (this.q = this.s.add(new OY(this.p))),
        (this.r = this.s.add(new _Y(this.p))),
        this.s.add(this.r.onMessage((t) => this.A(t))),
        this.s.add(this.p.onClose((t) => this.y.fire(t))),
        i.initialChunk && this.r.acceptChunk(i.initialChunk),
        this.u
          ? (this.m = setInterval(() => {
              this.E()
            }, 5e3))
          : (this.m = null)
    }
    dispose() {
      this.g && (clearTimeout(this.g), (this.g = null)),
        this.l && (clearTimeout(this.l), (this.l = null)),
        this.m && (clearInterval(this.m), (this.m = null)),
        this.s.dispose()
    }
    drain() {
      return this.q.drain()
    }
    sendDisconnect() {
      if (!this.b) {
        this.b = !0
        const i = new Cr(5, 0, 0, ta())
        this.q.write(i), this.q.flush()
      }
    }
    sendPause() {
      const i = new Cr(7, 0, 0, ta())
      this.q.write(i)
    }
    sendResume() {
      const i = new Cr(8, 0, 0, ta())
      this.q.write(i)
    }
    pauseSocketWriting() {
      this.q.pause()
    }
    getSocket() {
      return this.p
    }
    getMillisSinceLastIncomingData() {
      return Date.now() - this.r.lastReadTime
    }
    beginAcceptReconnection(i, t) {
      ;(this.a = !0),
        this.s.dispose(),
        (this.s = new gt()),
        this.v.flushBuffer(),
        this.y.flushBuffer(),
        this.z.flushBuffer(),
        this.p.dispose(),
        (this.n = 0),
        (this.o = Date.now()),
        (this.p = i),
        (this.q = this.s.add(new OY(this.p))),
        (this.r = this.s.add(new _Y(this.p))),
        this.s.add(this.r.onMessage((e) => this.A(e))),
        this.s.add(this.p.onClose((e) => this.y.fire(e))),
        this.r.acceptChunk(t)
    }
    endAcceptReconnection() {
      ;(this.a = !1), (this.j = this.h)
      const i = new Cr(3, 0, this.j, ta())
      this.q.write(i)
      const t = this.c.toArray()
      for (let e = 0, s = t.length; e < s; e++) this.q.write(t[e])
      this.C()
    }
    acceptDisconnect() {
      this.x.fire()
    }
    A(i) {
      if (i.ack > this.f) {
        this.f = i.ack
        do {
          const t = this.c.peek()
          if (t && t.id <= i.ack) this.c.pop()
          else break
        } while (!0)
      }
      switch (i.type) {
        case 0:
          break
        case 1: {
          if (i.id > this.h)
            if (i.id !== this.h + 1) {
              const t = Date.now()
              t - this.n > 1e4 &&
                ((this.n = t), this.q.write(new Cr(6, 0, 0, ta())))
            } else
              (this.h = i.id),
                (this.k = Date.now()),
                this.B(),
                this.w.fire(i.data)
          break
        }
        case 2: {
          this.v.fire(i.data)
          break
        }
        case 3:
          break
        case 5: {
          this.x.fire()
          break
        }
        case 6: {
          const t = this.c.toArray()
          for (let e = 0, s = t.length; e < s; e++) this.q.write(t[e])
          this.C()
          break
        }
        case 7: {
          this.q.pause()
          break
        }
        case 8: {
          this.q.resume()
          break
        }
        case 9:
          break
      }
    }
    readEntireBuffer() {
      return this.r.readEntireBuffer()
    }
    flush() {
      this.q.flush()
    }
    send(i) {
      const t = ++this.d
      this.j = this.h
      const e = new Cr(1, t, this.j, i)
      this.c.push(e), this.a || (this.q.write(e), this.C())
    }
    sendControl(i) {
      const t = new Cr(2, 0, 0, i)
      this.q.write(t)
    }
    B() {
      if (this.h <= this.j || this.l) return
      const i = Date.now() - this.k
      if (i >= 2e3) {
        this.D()
        return
      }
      this.l = setTimeout(
        () => {
          ;(this.l = null), this.B()
        },
        2e3 - i + 5,
      )
    }
    C() {
      if (this.d <= this.f || this.g || this.a) return
      const i = this.c.peek(),
        t = Date.now() - i.writtenTime,
        e = Date.now() - this.r.lastReadTime,
        s = Date.now() - this.o
      if (t >= 2e4 && e >= 2e4 && s >= 2e4 && !this.t.hasHighLoad()) {
        ;(this.o = Date.now()),
          this.z.fire({
            unacknowledgedMsgCount: this.c.length(),
            timeSinceOldestUnacknowledgedMsg: t,
            timeSinceLastReceivedSomeData: e,
          })
        return
      }
      const r = Math.max(2e4 - t, 2e4 - e, 2e4 - s, 500)
      this.g = setTimeout(() => {
        ;(this.g = null), this.C()
      }, r)
    }
    D() {
      if (this.h <= this.j) return
      this.j = this.h
      const i = new Cr(3, 0, this.j, ta())
      this.q.write(i)
    }
    E() {
      this.j = this.h
      const i = new Cr(9, 0, this.j, ta())
      this.q.write(i)
    }
  }
import "crypto"
import "net"
import { tmpdir as jvt } from "os"
import { createDeflateRaw as Vvt, createInflateRaw as Gvt } from "zlib"
var Ze = (function () {
    if (typeof crypto == "object" && typeof crypto.randomUUID == "function")
      return crypto.randomUUID.bind(crypto)
    let i
    typeof crypto == "object" && typeof crypto.getRandomValues == "function"
      ? (i = crypto.getRandomValues.bind(crypto))
      : (i = function (s) {
          for (let r = 0; r < s.length; r++)
            s[r] = Math.floor(Math.random() * 256)
          return s
        })
    const t = new Uint8Array(16),
      e = []
    for (let s = 0; s < 256; s++) e.push(s.toString(16).padStart(2, "0"))
    return function () {
      i(t), (t[6] = (t[6] & 15) | 64), (t[8] = (t[8] & 63) | 128)
      let r = 0,
        a = ""
      return (
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += "-"),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += "-"),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += "-"),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += "-"),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        (a += e[t[r++]]),
        a
      )
    }
  })(),
  zvt = 3e4,
  Ku = class {
    traceSocketEvent(i, t) {
      Y_.traceSocketEvent(this.socket, this.debugLabel, i, t)
    }
    constructor(i, t = "") {
      ;(this.f = !0),
        (this.debugLabel = t),
        (this.socket = i),
        this.traceSocketEvent("created", { type: "NodeSocket" }),
        (this.a = (s) => {
          if (
            (this.traceSocketEvent("error", {
              code: s?.code,
              message: s?.message,
            }),
            s)
          ) {
            if (s.code === "EPIPE") return
            $e(s)
          }
        }),
        this.socket.on("error", this.a)
      let e
      ;(this.b = (s) => {
        this.traceSocketEvent("close", { hadError: s }),
          (this.f = !1),
          e && clearTimeout(e)
      }),
        this.socket.on("close", this.b),
        (this.d = () => {
          this.traceSocketEvent("nodeEndReceived"),
            (this.f = !1),
            (e = setTimeout(() => i.destroy(), zvt))
        }),
        this.socket.on("end", this.d)
    }
    dispose() {
      this.socket.off("error", this.a),
        this.socket.off("close", this.b),
        this.socket.off("end", this.d),
        this.socket.destroy()
    }
    onData(i) {
      const t = (e) => {
        this.traceSocketEvent("read", e), i(Q.wrap(e))
      }
      return (
        this.socket.on("data", t), { dispose: () => this.socket.off("data", t) }
      )
    }
    onClose(i) {
      const t = (e) => {
        i({ type: 0, hadError: e, error: void 0 })
      }
      return (
        this.socket.on("close", t),
        { dispose: () => this.socket.off("close", t) }
      )
    }
    onEnd(i) {
      const t = () => {
        i()
      }
      return (
        this.socket.on("end", t), { dispose: () => this.socket.off("end", t) }
      )
    }
    write(i) {
      if (!(this.socket.destroyed || !this.f))
        try {
          this.traceSocketEvent("write", i),
            this.socket.write(i.buffer, (t) => {
              if (t) {
                if (t.code === "EPIPE") return
                $e(t)
              }
            })
        } catch (t) {
          if (t.code === "EPIPE") return
          $e(t)
        }
    }
    end() {
      this.traceSocketEvent("nodeEndSent"), this.socket.end()
    }
    drain() {
      return (
        this.traceSocketEvent("nodeDrainBegin"),
        new Promise((i, t) => {
          if (this.socket.bufferSize === 0) {
            this.traceSocketEvent("nodeDrainEnd"), i()
            return
          }
          const e = () => {
            this.socket.off("close", e),
              this.socket.off("end", e),
              this.socket.off("error", e),
              this.socket.off("timeout", e),
              this.socket.off("drain", e),
              this.traceSocketEvent("nodeDrainEnd"),
              i()
          }
          this.socket.on("close", e),
            this.socket.on("end", e),
            this.socket.on("error", e),
            this.socket.on("timeout", e),
            this.socket.on("drain", e)
        })
      )
    }
  },
  BY
;(function (i) {
  ;(i[(i.MinHeaderByteSize = 2)] = "MinHeaderByteSize"),
    (i[(i.MaxWebSocketMessageLength = 262144)] = "MaxWebSocketMessageLength")
})(BY || (BY = {}))
var qY
;(function (i) {
  ;(i[(i.PeekHeader = 1)] = "PeekHeader"),
    (i[(i.ReadHeader = 2)] = "ReadHeader"),
    (i[(i.ReadBody = 3)] = "ReadBody"),
    (i[(i.Fin = 4)] = "Fin")
})(qY || (qY = {}))
var Yvt = class extends at {
    get permessageDeflate() {
      return this.a.permessageDeflate
    }
    get recordedInflateBytes() {
      return this.a.recordedInflateBytes
    }
    traceSocketEvent(i, t) {
      this.socket.traceSocketEvent(i, t)
    }
    constructor(i, t, e, s) {
      super(),
        (this.f = this.D(new J())),
        (this.g = this.D(new J())),
        (this.h = !1),
        (this.j = {
          state: 1,
          readLen: 2,
          fin: 0,
          compressed: !1,
          firstFrameOfMessage: !0,
          mask: 0,
          opcode: 0,
        }),
        (this.socket = i),
        this.traceSocketEvent("created", {
          type: "WebSocketNodeSocket",
          permessageDeflate: t,
          inflateBytesLength: e?.byteLength || 0,
          recordInflateBytes: s,
        }),
        (this.a = this.D(
          new Qvt(this, t, e, s, this.f, (r, a) => this.m(r, a)),
        )),
        this.D(
          this.a.onError((r) => {
            console.error(r),
              $e(r),
              this.g.fire({ type: 0, hadError: !0, error: r })
          }),
        ),
        (this.b = new RY()),
        this.D(this.socket.onData((r) => this.n(r))),
        this.D(
          this.socket.onClose(async (r) => {
            this.a.isProcessingReadQueue() &&
              (await Qt.toPromise(this.a.onDidFinishProcessingReadQueue)),
              this.g.fire(r)
          }),
        )
    }
    dispose() {
      this.a.isProcessingWriteQueue()
        ? this.D(
            this.a.onDidFinishProcessingWriteQueue(() => {
              this.dispose()
            }),
          )
        : (this.socket.dispose(), super.dispose())
    }
    onData(i) {
      return this.f.event(i)
    }
    onClose(i) {
      return this.g.event(i)
    }
    onEnd(i) {
      return this.socket.onEnd(i)
    }
    write(i) {
      let t = 0
      for (; t < i.byteLength; )
        this.a.writeMessage(i.slice(t, Math.min(t + 262144, i.byteLength)), {
          compressed: !0,
          opcode: 2,
        }),
          (t += 262144)
    }
    m(i, { compressed: t, opcode: e }) {
      if (this.h) return
      this.traceSocketEvent("webSocketNodeSocketWrite", i)
      let s = 2
      i.byteLength < 126
        ? (s += 0)
        : i.byteLength < 2 ** 16
          ? (s += 2)
          : (s += 8)
      const r = Q.alloc(s),
        a = t ? 64 : 0,
        o = e & 15
      if ((r.writeUInt8(128 | a | o, 0), i.byteLength < 126))
        r.writeUInt8(i.byteLength, 1)
      else if (i.byteLength < 2 ** 16) {
        r.writeUInt8(126, 1)
        let c = 1
        r.writeUInt8((i.byteLength >>> 8) & 255, ++c),
          r.writeUInt8((i.byteLength >>> 0) & 255, ++c)
      } else {
        r.writeUInt8(127, 1)
        let c = 1
        r.writeUInt8(0, ++c),
          r.writeUInt8(0, ++c),
          r.writeUInt8(0, ++c),
          r.writeUInt8(0, ++c),
          r.writeUInt8((i.byteLength >>> 24) & 255, ++c),
          r.writeUInt8((i.byteLength >>> 16) & 255, ++c),
          r.writeUInt8((i.byteLength >>> 8) & 255, ++c),
          r.writeUInt8((i.byteLength >>> 0) & 255, ++c)
      }
      this.socket.write(Q.concat([r, i]))
    }
    end() {
      ;(this.h = !0), this.socket.end()
    }
    n(i) {
      if (i.byteLength !== 0) {
        for (this.b.acceptChunk(i); this.b.byteLength >= this.j.readLen; )
          if (this.j.state === 1) {
            const t = this.b.peek(this.j.readLen),
              e = t.readUInt8(0),
              s = (e & 128) >>> 7,
              r = (e & 64) >>> 6,
              a = e & 15,
              o = t.readUInt8(1),
              c = (o & 128) >>> 7,
              l = o & 127
            ;(this.j.state = 2),
              (this.j.readLen =
                2 + (c ? 4 : 0) + (l === 126 ? 2 : 0) + (l === 127 ? 8 : 0)),
              (this.j.fin = s),
              this.j.firstFrameOfMessage && (this.j.compressed = !!r),
              (this.j.firstFrameOfMessage = !!s),
              (this.j.mask = 0),
              (this.j.opcode = a),
              this.traceSocketEvent("webSocketNodeSocketPeekedHeader", {
                headerSize: this.j.readLen,
                compressed: this.j.compressed,
                fin: this.j.fin,
                opcode: this.j.opcode,
              })
          } else if (this.j.state === 2) {
            const t = this.b.read(this.j.readLen),
              e = t.readUInt8(1),
              s = (e & 128) >>> 7
            let r = e & 127,
              a = 1
            r === 126
              ? (r = t.readUInt8(++a) * 2 ** 8 + t.readUInt8(++a))
              : r === 127 &&
                (r =
                  t.readUInt8(++a) * 0 +
                  t.readUInt8(++a) * 0 +
                  t.readUInt8(++a) * 0 +
                  t.readUInt8(++a) * 0 +
                  t.readUInt8(++a) * 2 ** 24 +
                  t.readUInt8(++a) * 2 ** 16 +
                  t.readUInt8(++a) * 2 ** 8 +
                  t.readUInt8(++a))
            let o = 0
            s &&
              (o =
                t.readUInt8(++a) * 2 ** 24 +
                t.readUInt8(++a) * 2 ** 16 +
                t.readUInt8(++a) * 2 ** 8 +
                t.readUInt8(++a)),
              (this.j.state = 3),
              (this.j.readLen = r),
              (this.j.mask = o),
              this.traceSocketEvent("webSocketNodeSocketPeekedHeader", {
                bodySize: this.j.readLen,
                compressed: this.j.compressed,
                fin: this.j.fin,
                mask: this.j.mask,
                opcode: this.j.opcode,
              })
          } else if (this.j.state === 3) {
            const t = this.b.read(this.j.readLen)
            this.traceSocketEvent("webSocketNodeSocketReadData", t),
              Zvt(t, this.j.mask),
              this.traceSocketEvent("webSocketNodeSocketUnmaskedData", t),
              (this.j.state = 1),
              (this.j.readLen = 2),
              (this.j.mask = 0),
              this.j.opcode <= 2
                ? this.a.acceptFrame(t, this.j.compressed, !!this.j.fin)
                : this.j.opcode === 9 &&
                  this.a.writeMessage(t, { compressed: !1, opcode: 10 })
          }
      }
    }
    async drain() {
      this.traceSocketEvent("webSocketNodeSocketDrainBegin"),
        this.a.isProcessingWriteQueue() &&
          (await Qt.toPromise(this.a.onDidFinishProcessingWriteQueue)),
        await this.socket.drain(),
        this.traceSocketEvent("webSocketNodeSocketDrainEnd")
    }
  },
  Qvt = class extends at {
    get permessageDeflate() {
      return !!(this.b && this.f)
    }
    get recordedInflateBytes() {
      return this.b ? this.b.recordedInflateBytes : Q.alloc(0)
    }
    constructor(i, t, e, s, r, a) {
      super(),
        (this.n = i),
        (this.q = r),
        (this.r = a),
        (this.a = this.D(new J())),
        (this.onError = this.a.event),
        (this.g = []),
        (this.h = []),
        (this.j = this.D(new J())),
        (this.onDidFinishProcessingReadQueue = this.j.event),
        (this.m = this.D(new J())),
        (this.onDidFinishProcessingWriteQueue = this.m.event),
        (this.s = !1),
        (this.w = !1),
        t
          ? ((this.b = this.D(new Xvt(this.n, s, e, { windowBits: 15 }))),
            (this.f = this.D(new Kvt(this.n, { windowBits: 15 }))),
            this.D(this.b.onError((o) => this.a.fire(o))),
            this.D(this.f.onError((o) => this.a.fire(o))))
          : ((this.b = null), (this.f = null))
    }
    writeMessage(i, t) {
      this.g.push({ data: i, options: t }), this.t()
    }
    async t() {
      if (!this.s) {
        for (this.s = !0; this.g.length > 0; ) {
          const { data: i, options: t } = this.g.shift()
          if (this.f && t.compressed) {
            const e = await this.u(this.f, i)
            this.r(e, t)
          } else this.r(i, { ...t, compressed: !1 })
        }
        ;(this.s = !1), this.m.fire()
      }
    }
    isProcessingWriteQueue() {
      return this.s
    }
    u(i, t) {
      return new Promise((e, s) => {
        i.write(t), i.flush((r) => e(r))
      })
    }
    acceptFrame(i, t, e) {
      this.h.push({ data: i, isCompressed: t, isLastFrameOfMessage: e }),
        this.y()
    }
    async y() {
      if (!this.w) {
        for (this.w = !0; this.h.length > 0; ) {
          const i = this.h.shift()
          if (this.b && i.isCompressed) {
            const t = await this.z(this.b, i.data, i.isLastFrameOfMessage)
            this.q.fire(t)
          } else this.q.fire(i.data)
        }
        ;(this.w = !1), this.j.fire()
      }
    }
    isProcessingReadQueue() {
      return this.w
    }
    z(i, t, e) {
      return new Promise((s, r) => {
        i.write(t),
          e && i.write(Q.fromByteArray([0, 0, 255, 255])),
          i.flush((a) => s(a))
      })
    }
  },
  Xvt = class extends at {
    get recordedInflateBytes() {
      return this.j ? Q.concat(this.f) : Q.alloc(0)
    }
    constructor(i, t, e, s) {
      super(),
        (this.h = i),
        (this.j = t),
        (this.a = this.D(new J())),
        (this.onError = this.a.event),
        (this.f = []),
        (this.g = []),
        (this.b = Gvt(s)),
        this.b.on("error", (r) => {
          this.h.traceSocketEvent("zlibInflateError", {
            message: r?.message,
            code: r?.code,
          }),
            this.a.fire(r)
        }),
        this.b.on("data", (r) => {
          this.h.traceSocketEvent("zlibInflateData", r), this.g.push(Q.wrap(r))
        }),
        e &&
          (this.h.traceSocketEvent("zlibInflateInitialWrite", e.buffer),
          this.b.write(e.buffer),
          this.b.flush(() => {
            this.h.traceSocketEvent("zlibInflateInitialFlushFired"),
              (this.g.length = 0)
          }))
    }
    write(i) {
      this.j && this.f.push(i.clone()),
        this.h.traceSocketEvent("zlibInflateWrite", i),
        this.b.write(i.buffer)
    }
    flush(i) {
      this.b.flush(() => {
        this.h.traceSocketEvent("zlibInflateFlushFired")
        const t = Q.concat(this.g)
        ;(this.g.length = 0), i(t)
      })
    }
  },
  Kvt = class extends at {
    constructor(i, t) {
      super(),
        (this.g = i),
        (this.a = this.D(new J())),
        (this.onError = this.a.event),
        (this.f = []),
        (this.b = Vvt({ windowBits: 15 })),
        this.b.on("error", (e) => {
          this.g.traceSocketEvent("zlibDeflateError", {
            message: e?.message,
            code: e?.code,
          }),
            this.a.fire(e)
        }),
        this.b.on("data", (e) => {
          this.g.traceSocketEvent("zlibDeflateData", e), this.f.push(Q.wrap(e))
        })
    }
    write(i) {
      this.g.traceSocketEvent("zlibDeflateWrite", i.buffer),
        this.b.write(i.buffer)
    }
    flush(i) {
      this.b.flush(2, () => {
        this.g.traceSocketEvent("zlibDeflateFlushFired")
        let t = Q.concat(this.f)
        ;(this.f.length = 0), (t = t.slice(0, t.byteLength - 4)), i(t)
      })
    }
  }
function Zvt(i, t) {
  if (t === 0) return
  const e = i.byteLength >>> 2
  for (let l = 0; l < e; l++) {
    const u = i.readUInt32BE(l * 4)
    i.writeUInt32BE(u ^ t, l * 4)
  }
  const s = e * 4,
    r = i.byteLength - s,
    a = (t >>> 24) & 255,
    o = (t >>> 16) & 255,
    c = (t >>> 8) & 255
  r >= 1 && i.writeUInt8(i.readUInt8(s) ^ a, s),
    r >= 2 && i.writeUInt8(i.readUInt8(s + 1) ^ o, s + 1),
    r >= 3 && i.writeUInt8(i.readUInt8(s + 2) ^ c, s + 2)
}
var UY = process.env.XDG_RUNTIME_DIR,
  t1t = { 2: 107, 1: 103 }
function e1t() {
  const i = Ze()
  if (process.platform === "win32") return `\\\\.\\pipe\\vscode-ipc-${i}-sock`
  const t = process.platform !== "darwin" && UY ? UY : jvt(),
    e = se(t, `vscode-ipc-${i}.sock`)
  return i1t(e), e
}
function i1t(i) {
  const t = t1t[gdt]
  typeof t == "number" &&
    i.length >= t &&
    console.warn(
      `WARNING: IPC handle "${i}" is longer than ${t} chars, try a shorter --user-data-dir`,
    )
}
function pe(i) {
  if (!i || typeof i != "object" || i instanceof RegExp) return i
  const t = Array.isArray(i) ? [] : {}
  return (
    Object.entries(i).forEach(([e, s]) => {
      t[e] = s && typeof s == "object" ? pe(s) : s
    }),
    t
  )
}
function MY(i) {
  if (!i || typeof i != "object") return i
  const t = [i]
  for (; t.length > 0; ) {
    const e = t.shift()
    Object.freeze(e)
    for (const s in e)
      if (HY.call(e, s)) {
        const r = e[s]
        typeof r == "object" && !Object.isFrozen(r) && !Zdt(r) && t.push(r)
      }
  }
  return i
}
var HY = Object.prototype.hasOwnProperty
function Sc(i, t) {
  return wq(i, t, new Set())
}
function wq(i, t, e) {
  if (Fe(i)) return i
  const s = t(i)
  if (typeof s < "u") return s
  if (Array.isArray(i)) {
    const r = []
    for (const a of i) r.push(wq(a, t, e))
    return r
  }
  if (Je(i)) {
    if (e.has(i)) throw new Error("Cannot clone recursive data-structure")
    e.add(i)
    const r = {}
    for (const a in i) HY.call(i, a) && (r[a] = wq(i[a], t, e))
    return e.delete(i), r
  }
  return i
}
function en(i, t, e = !0) {
  return Je(i)
    ? (Je(t) &&
        Object.keys(t).forEach((s) => {
          s in i
            ? e && (Je(i[s]) && Je(t[s]) ? en(i[s], t[s], e) : (i[s] = t[s]))
            : (i[s] = t[s])
        }),
      i)
    : t
}
function Qs(i, t) {
  if (i === t) return !0
  if (
    i == null ||
    t === null ||
    t === void 0 ||
    typeof i != typeof t ||
    typeof i != "object" ||
    Array.isArray(i) !== Array.isArray(t)
  )
    return !1
  let e, s
  if (Array.isArray(i)) {
    if (i.length !== t.length) return !1
    for (e = 0; e < i.length; e++) if (!Qs(i[e], t[e])) return !1
  } else {
    const r = []
    for (s in i) r.push(s)
    r.sort()
    const a = []
    for (s in t) a.push(s)
    if ((a.sort(), !Qs(r, a))) return !1
    for (e = 0; e < r.length; e++) if (!Qs(i[r[e]], t[r[e]])) return !1
  }
  return !0
}
function s1t(i) {
  const t = new Set()
  return JSON.stringify(i, (e, s) => {
    if (Je(s) || Array.isArray(s)) {
      if (t.has(s)) return "[Circular]"
      t.add(s)
    }
    return typeof s == "bigint" ? `[BigInt ${s.toString()}]` : s
  })
}
function WY(i, t) {
  const e = Object.create(null)
  for (const [s, r] of Object.entries(i)) t(s, r) && (e[s] = r)
  return e
}
var jY = {
    tabSize: 4,
    indentSize: 4,
    insertSpaces: !0,
    detectIndentation: !0,
    trimAutoWhitespace: !0,
    largeFileOptimizations: !0,
    bracketPairColorizationOptions: {
      enabled: !0,
      independentColorPoolPerBracketType: !1,
    },
  },
  VY = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?"
function r1t(i = "") {
  let t = "(-?\\d*\\.\\d\\w*)|([^"
  for (const e of VY) i.indexOf(e) >= 0 || (t += "\\" + e)
  return (t += "\\s]+)"), new RegExp(t, "g")
}
var n1t = r1t()
function GY(i) {
  let t = n1t
  if (i && i instanceof RegExp)
    if (i.global) t = i
    else {
      let e = "g"
      i.ignoreCase && (e += "i"),
        i.multiline && (e += "m"),
        i.unicode && (e += "u"),
        (t = new RegExp(i.source, e))
    }
  return (t.lastIndex = 0), t
}
var zY = new Ru()
zY.unshift({ maxLen: 1e3, windowSize: 15, timeBudget: 150 })
function YY(i, t, e, s, r) {
  if (((t = GY(t)), r || (r = ms.first(zY)), e.length > r.maxLen)) {
    let u = i - r.maxLen / 2
    return (
      u < 0 ? (u = 0) : (s += u),
      (e = e.substring(u, i + r.maxLen / 2)),
      YY(i, t, e, s, r)
    )
  }
  const a = Date.now(),
    o = i - 1 - s
  let c = -1,
    l = null
  for (let u = 1; !(Date.now() - a >= r.timeBudget); u++) {
    const d = o - r.windowSize * u
    t.lastIndex = Math.max(0, d)
    const m = a1t(t, e, o, c)
    if ((!m && l) || ((l = m), d <= 0)) break
    c = d
  }
  if (l) {
    const u = {
      word: l[0],
      startColumn: s + 1 + l.index,
      endColumn: s + 1 + l.index + l[0].length,
    }
    return (t.lastIndex = 0), u
  }
  return null
}
function a1t(i, t, e, s) {
  let r
  for (; (r = i.exec(t)); ) {
    const a = r.index || 0
    if (a <= e && i.lastIndex >= e) return r
    if (s > 0 && a > s) return null
  }
  return null
}
var QY
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Keep = 1)] = "Keep"),
    (i[(i.Brackets = 2)] = "Brackets"),
    (i[(i.Advanced = 3)] = "Advanced"),
    (i[(i.Full = 4)] = "Full")
})(QY || (QY = {}))
var o1t = 8,
  c1t = class {
    constructor() {
      ;(this.stableMinimapLayoutInput = null),
        (this.stableFitMaxMinimapScale = 0),
        (this.stableFitRemainingWidth = 0)
    }
  },
  ne = class {
    constructor(i, t, e, s) {
      ;(this.id = i),
        (this.name = t),
        (this.defaultValue = e),
        (this.schema = s)
    }
    applyUpdate(i, t) {
      return X_(i, t)
    }
    compute(i, t, e) {
      return e
    }
  },
  Q_ = class {
    constructor(i, t) {
      ;(this.newValue = i), (this.didChange = t)
    }
  }
function X_(i, t) {
  if (typeof i != "object" || typeof t != "object" || !i || !t)
    return new Q_(t, i !== t)
  if (Array.isArray(i) || Array.isArray(t)) {
    const s = Array.isArray(i) && Array.isArray(t) && Er(i, t)
    return new Q_(t, !s)
  }
  let e = !1
  for (const s in t)
    if (t.hasOwnProperty(s)) {
      const r = X_(i[s], t[s])
      r.didChange && ((i[s] = r.newValue), (e = !0))
    }
  return new Q_(i, e)
}
var Ec = class {
    constructor(i) {
      ;(this.schema = void 0),
        (this.id = i),
        (this.name = "_never_"),
        (this.defaultValue = void 0)
    }
    applyUpdate(i, t) {
      return X_(i, t)
    }
    validate(i) {
      return this.defaultValue
    }
  },
  Ic = class {
    constructor(i, t, e, s) {
      ;(this.id = i),
        (this.name = t),
        (this.defaultValue = e),
        (this.schema = s)
    }
    applyUpdate(i, t) {
      return X_(i, t)
    }
    validate(i) {
      return typeof i > "u" ? this.defaultValue : i
    }
    compute(i, t, e) {
      return e
    }
  }
function st(i, t) {
  return typeof i > "u" ? t : i === "false" ? !1 : !!i
}
var Pt = class extends Ic {
  constructor(i, t, e, s = void 0) {
    typeof s < "u" && ((s.type = "boolean"), (s.default = e)), super(i, t, e, s)
  }
  validate(i) {
    return st(i, this.defaultValue)
  }
}
function l1t(i, t, e, s) {
  if (typeof i > "u") return t
  let r = parseInt(i, 10)
  return isNaN(r) ? t : ((r = Math.max(e, r)), (r = Math.min(s, r)), r | 0)
}
var zt = class Dlt extends Ic {
    static clampedInt(t, e, s, r) {
      return l1t(t, e, s, r)
    }
    constructor(t, e, s, r, a, o = void 0) {
      typeof o < "u" &&
        ((o.type = "integer"),
        (o.default = s),
        (o.minimum = r),
        (o.maximum = a)),
        super(t, e, s, o),
        (this.minimum = r),
        (this.maximum = a)
    }
    validate(t) {
      return Dlt.clampedInt(t, this.defaultValue, this.minimum, this.maximum)
    }
  },
  Jr = class Flt extends Ic {
    static clamp(t, e, s) {
      return t < e ? e : t > s ? s : t
    }
    static float(t, e) {
      if (typeof t == "number") return t
      if (typeof t > "u") return e
      const s = parseFloat(t)
      return isNaN(s) ? e : s
    }
    constructor(t, e, s, r, a) {
      typeof a < "u" && ((a.type = "number"), (a.default = s)),
        super(t, e, s, a),
        (this.validationFn = r)
    }
    validate(t) {
      return this.validationFn(Flt.float(t, this.defaultValue))
    }
  },
  Hi = class Alt extends Ic {
    static string(t, e) {
      return typeof t != "string" ? e : t
    }
    constructor(t, e, s, r = void 0) {
      typeof r < "u" && ((r.type = "string"), (r.default = s)),
        super(t, e, s, r)
    }
    validate(t) {
      return Alt.string(t, this.defaultValue)
    }
  }
function ge(i, t, e, s) {
  return typeof i != "string"
    ? t
    : s && i in s
      ? s[i]
      : e.indexOf(i) === -1
        ? t
        : i
}
var le = class extends Ic {
    constructor(i, t, e, s, r = void 0) {
      typeof r < "u" && ((r.type = "string"), (r.enum = s), (r.default = e)),
        super(i, t, e, r),
        (this.c = s)
    }
    validate(i) {
      return ge(i, this.defaultValue, this.c)
    }
  },
  Zu = class extends ne {
    constructor(i, t, e, s, r, a, o = void 0) {
      typeof o < "u" && ((o.type = "string"), (o.enum = r), (o.default = s)),
        super(i, t, e, o),
        (this.c = r),
        (this.d = a)
    }
    validate(i) {
      return typeof i != "string"
        ? this.defaultValue
        : this.c.indexOf(i) === -1
          ? this.defaultValue
          : this.d(i)
    }
  }
function u1t(i) {
  switch (i) {
    case "none":
      return 0
    case "keep":
      return 1
    case "brackets":
      return 2
    case "advanced":
      return 3
    case "full":
      return 4
  }
}
var h1t = class extends ne {
    constructor() {
      super(2, "accessibilitySupport", 0, {
        type: "string",
        enum: ["auto", "on", "off"],
        enumDescriptions: [g(309, null), g(310, null), g(311, null)],
        default: "auto",
        tags: ["accessibility"],
        description: g(312, null),
      })
    }
    validate(i) {
      switch (i) {
        case "auto":
          return 0
        case "off":
          return 1
        case "on":
          return 2
      }
      return this.defaultValue
    }
    compute(i, t, e) {
      return e === 0 ? i.accessibilitySupport : e
    }
  },
  d1t = class extends ne {
    constructor() {
      const i = { insertSpace: !0, ignoreEmptyLines: !0 }
      super(23, "comments", i, {
        "editor.comments.insertSpace": {
          type: "boolean",
          default: i.insertSpace,
          description: g(313, null),
        },
        "editor.comments.ignoreEmptyLines": {
          type: "boolean",
          default: i.ignoreEmptyLines,
          description: g(314, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        insertSpace: st(t.insertSpace, this.defaultValue.insertSpace),
        ignoreEmptyLines: st(
          t.ignoreEmptyLines,
          this.defaultValue.ignoreEmptyLines,
        ),
      }
    }
  },
  XY
;(function (i) {
  ;(i[(i.Hidden = 0)] = "Hidden"),
    (i[(i.Blink = 1)] = "Blink"),
    (i[(i.Smooth = 2)] = "Smooth"),
    (i[(i.Phase = 3)] = "Phase"),
    (i[(i.Expand = 4)] = "Expand"),
    (i[(i.Solid = 5)] = "Solid")
})(XY || (XY = {}))
function m1t(i) {
  switch (i) {
    case "blink":
      return 1
    case "smooth":
      return 2
    case "phase":
      return 3
    case "expand":
      return 4
    case "solid":
      return 5
  }
}
var Xs
;(function (i) {
  ;(i[(i.Line = 1)] = "Line"),
    (i[(i.Block = 2)] = "Block"),
    (i[(i.Underline = 3)] = "Underline"),
    (i[(i.LineThin = 4)] = "LineThin"),
    (i[(i.BlockOutline = 5)] = "BlockOutline"),
    (i[(i.UnderlineThin = 6)] = "UnderlineThin")
})(Xs || (Xs = {}))
function KY(i) {
  switch (i) {
    case "line":
      return Xs.Line
    case "block":
      return Xs.Block
    case "underline":
      return Xs.Underline
    case "line-thin":
      return Xs.LineThin
    case "block-outline":
      return Xs.BlockOutline
    case "underline-thin":
      return Xs.UnderlineThin
  }
}
var f1t = class extends Ec {
    constructor() {
      super(148)
    }
    compute(i, t, e) {
      const s = ["monaco-editor"]
      return (
        t.get(41) && s.push(t.get(41)),
        i.extraEditorClassName && s.push(i.extraEditorClassName),
        t.get(75) === "default"
          ? s.push("mouse-default")
          : t.get(75) === "copy" && s.push("mouse-copy"),
        t.get(116) && s.push("showUnused"),
        t.get(145) && s.push("showDeprecated"),
        s.join(" ")
      )
    }
  },
  p1t = class extends Pt {
    constructor() {
      super(38, "emptySelectionClipboard", !0, { description: g(315, null) })
    }
    compute(i, t, e) {
      return e && i.emptySelectionClipboard
    }
  },
  g1t = class extends ne {
    constructor() {
      const i = {
        cursorMoveOnType: !0,
        seedSearchStringFromSelection: "always",
        autoFindInSelection: "never",
        globalFindClipboard: !1,
        addExtraSpaceOnTop: !0,
        loop: !0,
        history: "workspace",
      }
      super(43, "find", i, {
        "editor.find.cursorMoveOnType": {
          type: "boolean",
          default: i.cursorMoveOnType,
          description: g(316, null),
        },
        "editor.find.seedSearchStringFromSelection": {
          type: "string",
          enum: ["never", "always", "selection"],
          default: i.seedSearchStringFromSelection,
          enumDescriptions: [g(317, null), g(318, null), g(319, null)],
          description: g(320, null),
        },
        "editor.find.autoFindInSelection": {
          type: "string",
          enum: ["never", "always", "multiline"],
          default: i.autoFindInSelection,
          enumDescriptions: [g(321, null), g(322, null), g(323, null)],
          description: g(324, null),
        },
        "editor.find.globalFindClipboard": {
          type: "boolean",
          default: i.globalFindClipboard,
          description: g(325, null),
          included: Ke,
        },
        "editor.find.addExtraSpaceOnTop": {
          type: "boolean",
          default: i.addExtraSpaceOnTop,
          description: g(326, null),
        },
        "editor.find.loop": {
          type: "boolean",
          default: i.loop,
          description: g(327, null),
        },
        "editor.find.history": {
          type: "string",
          enum: ["never", "workspace"],
          default: "workspace",
          enumDescriptions: [g(328, null), g(329, null)],
          description: g(330, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        cursorMoveOnType: st(
          t.cursorMoveOnType,
          this.defaultValue.cursorMoveOnType,
        ),
        seedSearchStringFromSelection:
          typeof i.seedSearchStringFromSelection == "boolean"
            ? i.seedSearchStringFromSelection
              ? "always"
              : "never"
            : ge(
                t.seedSearchStringFromSelection,
                this.defaultValue.seedSearchStringFromSelection,
                ["never", "always", "selection"],
              ),
        autoFindInSelection:
          typeof i.autoFindInSelection == "boolean"
            ? i.autoFindInSelection
              ? "always"
              : "never"
            : ge(t.autoFindInSelection, this.defaultValue.autoFindInSelection, [
                "never",
                "always",
                "multiline",
              ]),
        globalFindClipboard: st(
          t.globalFindClipboard,
          this.defaultValue.globalFindClipboard,
        ),
        addExtraSpaceOnTop: st(
          t.addExtraSpaceOnTop,
          this.defaultValue.addExtraSpaceOnTop,
        ),
        loop: st(t.loop, this.defaultValue.loop),
        history: ge(t.history, this.defaultValue.history, [
          "never",
          "workspace",
        ]),
      }
    }
  },
  v1t = class eu extends ne {
    static {
      this.OFF = '"liga" off, "calt" off'
    }
    static {
      this.ON = '"liga" on, "calt" on'
    }
    constructor() {
      super(53, "fontLigatures", eu.OFF, {
        anyOf: [
          { type: "boolean", description: g(331, null) },
          { type: "string", description: g(332, null) },
        ],
        description: g(333, null),
        default: !1,
      })
    }
    validate(t) {
      return typeof t > "u"
        ? this.defaultValue
        : typeof t == "string"
          ? t === "false" || t.length === 0
            ? eu.OFF
            : t === "true"
              ? eu.ON
              : t
          : t
            ? eu.ON
            : eu.OFF
    }
  },
  w1t = class iu extends ne {
    static {
      this.OFF = "normal"
    }
    static {
      this.TRANSLATE = "translate"
    }
    constructor() {
      super(56, "fontVariations", iu.OFF, {
        anyOf: [
          { type: "boolean", description: g(334, null) },
          { type: "string", description: g(335, null) },
        ],
        description: g(336, null),
        default: !1,
      })
    }
    validate(t) {
      return typeof t > "u"
        ? this.defaultValue
        : typeof t == "string"
          ? t === "false"
            ? iu.OFF
            : t === "true"
              ? iu.TRANSLATE
              : t
          : t
            ? iu.TRANSLATE
            : iu.OFF
    }
    compute(t, e, s) {
      return t.fontInfo.fontVariationSettings
    }
  },
  y1t = class extends Ec {
    constructor() {
      super(52)
    }
    compute(i, t, e) {
      return i.fontInfo
    }
  },
  b1t = class extends Ec {
    constructor() {
      super(147)
    }
    compute(i, t, e) {
      return i.inputMode === "overtype" ? t.get(84) : t.get(28)
    }
  },
  T1t = class extends Ic {
    constructor() {
      super(54, "fontSize", rn.fontSize, {
        type: "number",
        minimum: 6,
        maximum: 100,
        default: rn.fontSize,
        description: g(337, null),
      })
    }
    validate(i) {
      const t = Jr.float(i, this.defaultValue)
      return t === 0 ? rn.fontSize : Jr.clamp(t, 6, 100)
    }
    compute(i, t, e) {
      return i.fontInfo.fontSize
    }
  },
  k1t = class su extends ne {
    static {
      this.c = [
        "normal",
        "bold",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900",
      ]
    }
    static {
      this.d = 1
    }
    static {
      this.e = 1e3
    }
    constructor() {
      super(55, "fontWeight", rn.fontWeight, {
        anyOf: [
          {
            type: "number",
            minimum: su.d,
            maximum: su.e,
            errorMessage: g(338, null),
          },
          { type: "string", pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$" },
          { enum: su.c },
        ],
        default: rn.fontWeight,
        description: g(339, null),
      })
    }
    validate(t) {
      return t === "normal" || t === "bold"
        ? t
        : String(zt.clampedInt(t, rn.fontWeight, su.d, su.e))
    }
  },
  S1t = class extends ne {
    constructor() {
      const i = {
          multiple: "peek",
          multipleDefinitions: "peek",
          multipleTypeDefinitions: "peek",
          multipleDeclarations: "peek",
          multipleImplementations: "peek",
          multipleReferences: "peek",
          multipleTests: "peek",
          alternativeDefinitionCommand: "editor.action.goToReferences",
          alternativeTypeDefinitionCommand: "editor.action.goToReferences",
          alternativeDeclarationCommand: "editor.action.goToReferences",
          alternativeImplementationCommand: "",
          alternativeReferenceCommand: "",
          alternativeTestsCommand: "",
        },
        t = {
          type: "string",
          enum: ["peek", "gotoAndPeek", "goto"],
          default: i.multiple,
          enumDescriptions: [g(340, null), g(341, null), g(342, null)],
        },
        e = [
          "",
          "editor.action.referenceSearch.trigger",
          "editor.action.goToReferences",
          "editor.action.peekImplementation",
          "editor.action.goToImplementation",
          "editor.action.peekTypeDefinition",
          "editor.action.goToTypeDefinition",
          "editor.action.explainSymbol",
          "editor.action.peekDeclaration",
          "editor.action.revealDeclaration",
          "editor.action.peekDefinition",
          "editor.action.revealDefinitionAside",
          "editor.action.revealDefinition",
        ]
      super(60, "gotoLocation", i, {
        "editor.gotoLocation.multiple": { deprecationMessage: g(343, null) },
        "editor.gotoLocation.multipleDefinitions": {
          description: g(344, null),
          ...t,
        },
        "editor.gotoLocation.multipleTypeDefinitions": {
          description: g(345, null),
          ...t,
        },
        "editor.gotoLocation.multipleDeclarations": {
          description: g(346, null),
          ...t,
        },
        "editor.gotoLocation.multipleImplementations": {
          description: g(347, null),
          ...t,
        },
        "editor.gotoLocation.multipleReferences": {
          description: g(348, null),
          ...t,
        },
        "editor.gotoLocation.alternativeDefinitionCommand": {
          type: "string",
          default: i.alternativeDefinitionCommand,
          enum: e,
          description: g(349, null),
        },
        "editor.gotoLocation.alternativeTypeDefinitionCommand": {
          type: "string",
          default: i.alternativeTypeDefinitionCommand,
          enum: e,
          description: g(350, null),
        },
        "editor.gotoLocation.alternativeDeclarationCommand": {
          type: "string",
          default: i.alternativeDeclarationCommand,
          enum: e,
          description: g(351, null),
        },
        "editor.gotoLocation.alternativeImplementationCommand": {
          type: "string",
          default: i.alternativeImplementationCommand,
          enum: e,
          description: g(352, null),
        },
        "editor.gotoLocation.alternativeReferenceCommand": {
          type: "string",
          default: i.alternativeReferenceCommand,
          enum: e,
          description: g(353, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        multiple: ge(t.multiple, this.defaultValue.multiple, [
          "peek",
          "gotoAndPeek",
          "goto",
        ]),
        multipleDefinitions:
          t.multipleDefinitions ??
          ge(t.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleTypeDefinitions:
          t.multipleTypeDefinitions ??
          ge(t.multipleTypeDefinitions, "peek", [
            "peek",
            "gotoAndPeek",
            "goto",
          ]),
        multipleDeclarations:
          t.multipleDeclarations ??
          ge(t.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleImplementations:
          t.multipleImplementations ??
          ge(t.multipleImplementations, "peek", [
            "peek",
            "gotoAndPeek",
            "goto",
          ]),
        multipleReferences:
          t.multipleReferences ??
          ge(t.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleTests:
          t.multipleTests ??
          ge(t.multipleTests, "peek", ["peek", "gotoAndPeek", "goto"]),
        alternativeDefinitionCommand: Hi.string(
          t.alternativeDefinitionCommand,
          this.defaultValue.alternativeDefinitionCommand,
        ),
        alternativeTypeDefinitionCommand: Hi.string(
          t.alternativeTypeDefinitionCommand,
          this.defaultValue.alternativeTypeDefinitionCommand,
        ),
        alternativeDeclarationCommand: Hi.string(
          t.alternativeDeclarationCommand,
          this.defaultValue.alternativeDeclarationCommand,
        ),
        alternativeImplementationCommand: Hi.string(
          t.alternativeImplementationCommand,
          this.defaultValue.alternativeImplementationCommand,
        ),
        alternativeReferenceCommand: Hi.string(
          t.alternativeReferenceCommand,
          this.defaultValue.alternativeReferenceCommand,
        ),
        alternativeTestsCommand: Hi.string(
          t.alternativeTestsCommand,
          this.defaultValue.alternativeTestsCommand,
        ),
      }
    }
  },
  E1t = class extends ne {
    constructor() {
      const i = {
        enabled: !0,
        delay: 300,
        hidingDelay: 300,
        sticky: !0,
        above: !0,
      }
      super(62, "hover", i, {
        "editor.hover.enabled": {
          type: "boolean",
          default: i.enabled,
          description: g(354, null),
        },
        "editor.hover.delay": {
          type: "number",
          default: i.delay,
          minimum: 0,
          maximum: 1e4,
          description: g(355, null),
        },
        "editor.hover.sticky": {
          type: "boolean",
          default: i.sticky,
          description: g(356, null),
        },
        "editor.hover.hidingDelay": {
          type: "integer",
          minimum: 0,
          default: i.hidingDelay,
          description: g(357, null),
        },
        "editor.hover.above": {
          type: "boolean",
          default: i.above,
          description: g(358, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: st(t.enabled, this.defaultValue.enabled),
        delay: zt.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
        sticky: st(t.sticky, this.defaultValue.sticky),
        hidingDelay: zt.clampedInt(
          t.hidingDelay,
          this.defaultValue.hidingDelay,
          0,
          6e5,
        ),
        above: st(t.above, this.defaultValue.above),
      }
    }
  },
  ZY
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Text = 1)] = "Text"),
    (i[(i.Blocks = 2)] = "Blocks")
})(ZY || (ZY = {}))
var I1t = class H3 extends Ec {
    constructor() {
      super(151)
    }
    compute(t, e, s) {
      return H3.computeLayout(e, {
        memory: t.memory,
        outerWidth: t.outerWidth,
        outerHeight: t.outerHeight,
        isDominatedByLongLines: t.isDominatedByLongLines,
        lineHeight: t.fontInfo.lineHeight,
        viewLineCount: t.viewLineCount,
        lineNumbersDigitCount: t.lineNumbersDigitCount,
        typicalHalfwidthCharacterWidth:
          t.fontInfo.typicalHalfwidthCharacterWidth,
        maxDigitWidth: t.fontInfo.maxDigitWidth,
        pixelRatio: t.pixelRatio,
        glyphMarginDecorationLaneCount: t.glyphMarginDecorationLaneCount,
      })
    }
    static computeContainedMinimapLineCount(t) {
      const e = t.height / t.lineHeight,
        s = Math.floor(t.paddingTop / t.lineHeight)
      let r = Math.floor(t.paddingBottom / t.lineHeight)
      t.scrollBeyondLastLine && (r = Math.max(r, e - 1))
      const a = (s + t.viewLineCount + r) / (t.pixelRatio * t.height),
        o = Math.floor(t.viewLineCount / a)
      return {
        typicalViewportLineCount: e,
        extraLinesBeforeFirstLine: s,
        extraLinesBeyondLastLine: r,
        desiredRatio: a,
        minimapLineCount: o,
      }
    }
    static c(t, e) {
      const s = t.outerWidth,
        r = t.outerHeight,
        a = t.pixelRatio
      if (!t.minimap.enabled)
        return {
          renderMinimap: 0,
          minimapLeft: 0,
          minimapWidth: 0,
          minimapHeightIsEditorHeight: !1,
          minimapIsSampling: !1,
          minimapScale: 1,
          minimapLineHeight: 1,
          minimapCanvasInnerWidth: 0,
          minimapCanvasInnerHeight: Math.floor(a * r),
          minimapCanvasOuterWidth: 0,
          minimapCanvasOuterHeight: r,
        }
      const o = e.stableMinimapLayoutInput,
        c =
          o &&
          t.outerHeight === o.outerHeight &&
          t.lineHeight === o.lineHeight &&
          t.typicalHalfwidthCharacterWidth ===
            o.typicalHalfwidthCharacterWidth &&
          t.pixelRatio === o.pixelRatio &&
          t.scrollBeyondLastLine === o.scrollBeyondLastLine &&
          t.paddingTop === o.paddingTop &&
          t.paddingBottom === o.paddingBottom &&
          t.minimap.enabled === o.minimap.enabled &&
          t.minimap.side === o.minimap.side &&
          t.minimap.size === o.minimap.size &&
          t.minimap.showSlider === o.minimap.showSlider &&
          t.minimap.renderCharacters === o.minimap.renderCharacters &&
          t.minimap.maxColumn === o.minimap.maxColumn &&
          t.minimap.scale === o.minimap.scale &&
          t.verticalScrollbarWidth === o.verticalScrollbarWidth &&
          t.isViewportWrapping === o.isViewportWrapping,
        l = t.lineHeight,
        u = t.typicalHalfwidthCharacterWidth,
        d = t.scrollBeyondLastLine,
        m = t.minimap.renderCharacters
      let f = a >= 2 ? Math.round(t.minimap.scale * 2) : t.minimap.scale
      const p = t.minimap.maxColumn,
        v = t.minimap.size,
        b = t.minimap.side,
        k = t.verticalScrollbarWidth,
        E = t.viewLineCount,
        P = t.remainingWidth,
        C = t.isViewportWrapping,
        R = m ? 2 : 3
      let D = Math.floor(a * r)
      const V = D / a
      let tt = !1,
        Z = !1,
        M = R * f,
        rt = f / a,
        Jt = 1
      if (v === "fill" || v === "fit") {
        const {
          typicalViewportLineCount: nt,
          extraLinesBeforeFirstLine: $t,
          extraLinesBeyondLastLine: Bt,
          desiredRatio: xt,
          minimapLineCount: oe,
        } = H3.computeContainedMinimapLineCount({
          viewLineCount: E,
          scrollBeyondLastLine: d,
          paddingTop: t.paddingTop,
          paddingBottom: t.paddingBottom,
          height: r,
          lineHeight: l,
          pixelRatio: a,
        })
        if (E / oe > 1) (tt = !0), (Z = !0), (f = 1), (M = 1), (rt = f / a)
        else {
          let Ce = !1,
            wi = f + 1
          if (v === "fit") {
            const Ri = Math.ceil(($t + E + Bt) * M)
            C && c && P <= e.stableFitRemainingWidth
              ? ((Ce = !0), (wi = e.stableFitMaxMinimapScale))
              : (Ce = Ri > D)
          }
          if (v === "fill" || Ce) {
            tt = !0
            const Ri = f
            ;(M = Math.min(l * a, Math.max(1, Math.floor(1 / xt)))),
              C &&
                c &&
                P <= e.stableFitRemainingWidth &&
                (wi = e.stableFitMaxMinimapScale),
              (f = Math.min(wi, Math.max(1, Math.floor(M / R)))),
              f > Ri && (Jt = Math.min(2, f / Ri)),
              (rt = f / a / Jt),
              (D = Math.ceil(Math.max(nt, $t + E + Bt) * M)),
              C
                ? ((e.stableMinimapLayoutInput = t),
                  (e.stableFitRemainingWidth = P),
                  (e.stableFitMaxMinimapScale = f))
                : ((e.stableMinimapLayoutInput = null),
                  (e.stableFitRemainingWidth = 0))
          }
        }
      }
      const ct = Math.floor(p * rt),
        me = Math.min(
          ct,
          Math.max(0, Math.floor(((P - k - 2) * rt) / (u + rt))) + o1t,
        )
      let j = Math.floor(a * me)
      const z = j / a
      j = Math.floor(j * Jt)
      const ot = m ? 1 : 2,
        it = b === "left" ? 0 : s - me - k
      return {
        renderMinimap: ot,
        minimapLeft: it,
        minimapWidth: me,
        minimapHeightIsEditorHeight: tt,
        minimapIsSampling: Z,
        minimapScale: f,
        minimapLineHeight: M,
        minimapCanvasInnerWidth: j,
        minimapCanvasInnerHeight: D,
        minimapCanvasOuterWidth: z,
        minimapCanvasOuterHeight: V,
      }
    }
    static computeLayout(t, e) {
      const s = e.outerWidth | 0,
        r = e.outerHeight | 0,
        a = e.lineHeight | 0,
        o = e.lineNumbersDigitCount | 0,
        c = e.typicalHalfwidthCharacterWidth,
        l = e.maxDigitWidth,
        u = e.pixelRatio,
        d = e.viewLineCount,
        m = t.get(142),
        f = m === "inherit" ? t.get(141) : m,
        p = f === "inherit" ? t.get(137) : f,
        v = t.get(140),
        b = e.isDominatedByLongLines,
        k = t.get(59),
        E = t.get(69).renderType !== 0,
        P = t.get(70),
        C = t.get(110),
        R = t.get(88),
        D = t.get(74),
        V = t.get(108),
        tt = V.verticalScrollbarSize,
        Z = V.verticalHasArrows,
        M = V.arrowSize,
        rt = V.horizontalScrollbarSize,
        Jt = t.get(45),
        ct = t.get(115) !== "never"
      let me = t.get(67)
      Jt && ct && (me += 16)
      let j = 0
      if (E) {
        const Vr = Math.max(o, P)
        j = Math.round(Vr * l)
      }
      let z = 0
      k && (z = a * e.glyphMarginDecorationLaneCount)
      let ot = 0,
        it = ot + z,
        nt = it + j,
        $t = nt + me
      const Bt = s - z - j - me
      let xt = !1,
        oe = !1,
        mi = -1
      f === "inherit" && b
        ? ((xt = !0), (oe = !0))
        : p === "on" || p === "bounded"
          ? (oe = !0)
          : p === "wordWrapColumn" && (mi = v)
      const Ce = H3.c(
        {
          outerWidth: s,
          outerHeight: r,
          lineHeight: a,
          typicalHalfwidthCharacterWidth: c,
          pixelRatio: u,
          scrollBeyondLastLine: C,
          paddingTop: R.top,
          paddingBottom: R.bottom,
          minimap: D,
          verticalScrollbarWidth: tt,
          viewLineCount: d,
          remainingWidth: Bt,
          isViewportWrapping: oe,
        },
        e.memory || new c1t(),
      )
      Ce.renderMinimap !== 0 &&
        Ce.minimapLeft === 0 &&
        ((ot += Ce.minimapWidth),
        (it += Ce.minimapWidth),
        (nt += Ce.minimapWidth),
        ($t += Ce.minimapWidth))
      const wi = Bt - Ce.minimapWidth,
        Ri = Math.max(1, Math.floor((wi - tt - 2) / c)),
        ye = Z ? M : 0
      return (
        oe &&
          ((mi = Math.max(1, Ri)), p === "bounded" && (mi = Math.min(mi, v))),
        {
          width: s,
          height: r,
          glyphMarginLeft: ot,
          glyphMarginWidth: z,
          glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount,
          lineNumbersLeft: it,
          lineNumbersWidth: j,
          decorationsLeft: nt,
          decorationsWidth: me,
          contentLeft: $t,
          contentWidth: wi,
          minimap: Ce,
          viewportColumn: Ri,
          isWordWrapMinified: xt,
          isViewportWrapping: oe,
          wrappingColumn: mi,
          verticalScrollbarWidth: tt,
          horizontalScrollbarHeight: rt,
          overviewRuler: { top: ye, width: tt, height: r - 2 * ye, right: 0 },
        }
      )
    }
  },
  P1t = class extends ne {
    constructor() {
      super(144, "wrappingStrategy", "simple", {
        "editor.wrappingStrategy": {
          enumDescriptions: [g(359, null), g(360, null)],
          type: "string",
          enum: ["simple", "advanced"],
          default: "simple",
          description: g(361, null),
        },
      })
    }
    validate(i) {
      return ge(i, "simple", ["simple", "advanced"])
    }
    compute(i, t, e) {
      return t.get(2) === 2 ? "advanced" : e
    }
  },
  sn
;(function (i) {
  ;(i.Off = "off"), (i.OnCode = "onCode"), (i.On = "on")
})(sn || (sn = {}))
var $1t = class extends ne {
    constructor() {
      const i = { enabled: sn.Off }
      super(66, "lightbulb", i, {
        "editor.lightbulb.enabled": {
          type: "string",
          enum: [sn.Off, sn.OnCode, sn.On],
          default: i.enabled,
          enumDescriptions: [g(362, null), g(363, null), g(364, null)],
          description: g(365, null),
        },
      })
    }
    validate(i) {
      return !i || typeof i != "object"
        ? this.defaultValue
        : {
            enabled: ge(i.enabled, this.defaultValue.enabled, [
              sn.Off,
              sn.OnCode,
              sn.On,
            ]),
          }
    }
  },
  x1t = class extends ne {
    constructor() {
      const i = {
        enabled: !0,
        maxLineCount: 5,
        defaultModel: "outlineModel",
        scrollWithEditor: !0,
      }
      super(120, "stickyScroll", i, {
        "editor.stickyScroll.enabled": {
          type: "boolean",
          default: i.enabled,
          description: g(366, null),
        },
        "editor.stickyScroll.maxLineCount": {
          type: "number",
          default: i.maxLineCount,
          minimum: 1,
          maximum: 20,
          description: g(367, null),
        },
        "editor.stickyScroll.defaultModel": {
          type: "string",
          enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
          default: i.defaultModel,
          description: g(368, null),
        },
        "editor.stickyScroll.scrollWithEditor": {
          type: "boolean",
          default: i.scrollWithEditor,
          description: g(369, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: st(t.enabled, this.defaultValue.enabled),
        maxLineCount: zt.clampedInt(
          t.maxLineCount,
          this.defaultValue.maxLineCount,
          1,
          20,
        ),
        defaultModel: ge(t.defaultModel, this.defaultValue.defaultModel, [
          "outlineModel",
          "foldingProviderModel",
          "indentationModel",
        ]),
        scrollWithEditor: st(
          t.scrollWithEditor,
          this.defaultValue.scrollWithEditor,
        ),
      }
    }
  },
  N1t = class extends ne {
    constructor() {
      const i = {
        enabled: "on",
        fontSize: 0,
        fontFamily: "",
        padding: !1,
        maximumLength: 43,
      }
      super(146, "inlayHints", i, {
        "editor.inlayHints.enabled": {
          type: "string",
          default: i.enabled,
          description: g(370, null),
          enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
          markdownEnumDescriptions: [
            g(371, null),
            g(372, null, Ke ? "Ctrl+Option" : "Ctrl+Alt"),
            g(373, null, Ke ? "Ctrl+Option" : "Ctrl+Alt"),
            g(374, null),
          ],
        },
        "editor.inlayHints.fontSize": {
          type: "number",
          default: i.fontSize,
          markdownDescription: g(375, null, "`#editor.fontSize#`", "`5`"),
        },
        "editor.inlayHints.fontFamily": {
          type: "string",
          default: i.fontFamily,
          markdownDescription: g(376, null, "`#editor.fontFamily#`"),
        },
        "editor.inlayHints.padding": {
          type: "boolean",
          default: i.padding,
          description: g(377, null),
        },
        "editor.inlayHints.maximumLength": {
          type: "number",
          default: i.maximumLength,
          markdownDescription: g(378, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return (
        typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"),
        {
          enabled: ge(t.enabled, this.defaultValue.enabled, [
            "on",
            "off",
            "offUnlessPressed",
            "onUnlessPressed",
          ]),
          fontSize: zt.clampedInt(
            t.fontSize,
            this.defaultValue.fontSize,
            0,
            100,
          ),
          fontFamily: Hi.string(t.fontFamily, this.defaultValue.fontFamily),
          padding: st(t.padding, this.defaultValue.padding),
          maximumLength: zt.clampedInt(
            t.maximumLength,
            this.defaultValue.maximumLength,
            0,
            Number.MAX_SAFE_INTEGER,
          ),
        }
      )
    }
  },
  C1t = class extends ne {
    constructor() {
      super(67, "lineDecorationsWidth", 10)
    }
    validate(i) {
      return typeof i == "string" && /^\d+(\.\d+)?ch$/.test(i)
        ? -parseFloat(i.substring(0, i.length - 2))
        : zt.clampedInt(i, this.defaultValue, 0, 1e3)
    }
    compute(i, t, e) {
      return e < 0
        ? zt.clampedInt(
            -e * i.fontInfo.typicalHalfwidthCharacterWidth,
            this.defaultValue,
            0,
            1e3,
          )
        : e
    }
  },
  J1t = class extends Jr {
    constructor() {
      super(68, "lineHeight", rn.lineHeight, (i) => Jr.clamp(i, 0, 150), {
        markdownDescription: g(379, null),
      })
    }
    compute(i, t, e) {
      return i.fontInfo.lineHeight
    }
  },
  L1t = class extends ne {
    constructor() {
      const i = {
        enabled: !1,
        size: "proportional",
        side: "right",
        showSlider: "mouseover",
        autohide: !1,
        renderCharacters: !0,
        maxColumn: 120,
        scale: 1,
        showRegionSectionHeaders: !0,
        showMarkSectionHeaders: !0,
        sectionHeaderFontSize: 9,
        sectionHeaderLetterSpacing: 1,
      }
      super(74, "minimap", i, {
        "editor.minimap.enabled": {
          type: "boolean",
          default: i.enabled,
          description: g(380, null),
        },
        "editor.minimap.autohide": {
          type: "boolean",
          default: i.autohide,
          description: g(381, null),
        },
        "editor.minimap.size": {
          type: "string",
          enum: ["proportional", "fill", "fit"],
          enumDescriptions: [g(382, null), g(383, null), g(384, null)],
          default: i.size,
          description: g(385, null),
        },
        "editor.minimap.side": {
          type: "string",
          enum: ["left", "right"],
          default: i.side,
          description: g(386, null),
        },
        "editor.minimap.showSlider": {
          type: "string",
          enum: ["always", "mouseover"],
          default: i.showSlider,
          description: g(387, null),
        },
        "editor.minimap.scale": {
          type: "number",
          default: i.scale,
          minimum: 1,
          maximum: 3,
          enum: [1, 2, 3],
          description: g(388, null),
        },
        "editor.minimap.renderCharacters": {
          type: "boolean",
          default: i.renderCharacters,
          description: g(389, null),
        },
        "editor.minimap.maxColumn": {
          type: "number",
          default: i.maxColumn,
          description: g(390, null),
        },
        "editor.minimap.showRegionSectionHeaders": {
          type: "boolean",
          default: i.showRegionSectionHeaders,
          description: g(391, null),
        },
        "editor.minimap.showMarkSectionHeaders": {
          type: "boolean",
          default: i.showMarkSectionHeaders,
          description: g(392, null),
        },
        "editor.minimap.sectionHeaderFontSize": {
          type: "number",
          default: i.sectionHeaderFontSize,
          description: g(393, null),
        },
        "editor.minimap.sectionHeaderLetterSpacing": {
          type: "number",
          default: i.sectionHeaderLetterSpacing,
          description: g(394, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: st(t.enabled, this.defaultValue.enabled),
        autohide: st(t.autohide, this.defaultValue.autohide),
        size: ge(t.size, this.defaultValue.size, [
          "proportional",
          "fill",
          "fit",
        ]),
        side: ge(t.side, this.defaultValue.side, ["right", "left"]),
        showSlider: ge(t.showSlider, this.defaultValue.showSlider, [
          "always",
          "mouseover",
        ]),
        renderCharacters: st(
          t.renderCharacters,
          this.defaultValue.renderCharacters,
        ),
        scale: zt.clampedInt(t.scale, 1, 1, 3),
        maxColumn: zt.clampedInt(
          t.maxColumn,
          this.defaultValue.maxColumn,
          1,
          1e4,
        ),
        showRegionSectionHeaders: st(
          t.showRegionSectionHeaders,
          this.defaultValue.showRegionSectionHeaders,
        ),
        showMarkSectionHeaders: st(
          t.showMarkSectionHeaders,
          this.defaultValue.showMarkSectionHeaders,
        ),
        sectionHeaderFontSize: Jr.clamp(
          t.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize,
          4,
          32,
        ),
        sectionHeaderLetterSpacing: Jr.clamp(
          t.sectionHeaderLetterSpacing ??
            this.defaultValue.sectionHeaderLetterSpacing,
          0,
          5,
        ),
      }
    }
  }
function R1t(i) {
  return i === "ctrlCmd" ? (Ke ? "metaKey" : "ctrlKey") : "altKey"
}
var D1t = class extends ne {
    constructor() {
      super(
        88,
        "padding",
        { top: 0, bottom: 0 },
        {
          "editor.padding.top": {
            type: "number",
            default: 0,
            minimum: 0,
            maximum: 1e3,
            description: g(395, null),
          },
          "editor.padding.bottom": {
            type: "number",
            default: 0,
            minimum: 0,
            maximum: 1e3,
            description: g(396, null),
          },
        },
      )
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        top: zt.clampedInt(t.top, 0, 0, 1e3),
        bottom: zt.clampedInt(t.bottom, 0, 0, 1e3),
      }
    }
  },
  F1t = class extends ne {
    constructor() {
      const i = { enabled: !0, cycle: !0 }
      super(90, "parameterHints", i, {
        "editor.parameterHints.enabled": {
          type: "boolean",
          default: i.enabled,
          description: g(397, null),
        },
        "editor.parameterHints.cycle": {
          type: "boolean",
          default: i.cycle,
          description: g(398, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: st(t.enabled, this.defaultValue.enabled),
        cycle: st(t.cycle, this.defaultValue.cycle),
      }
    }
  },
  A1t = class extends Ec {
    constructor() {
      super(149)
    }
    compute(i, t, e) {
      return i.pixelRatio
    }
  },
  _1t = class extends ne {
    constructor() {
      super(92, "placeholder", void 0)
    }
    validate(i) {
      return typeof i > "u"
        ? this.defaultValue
        : typeof i == "string"
          ? i
          : this.defaultValue
    }
  },
  O1t = class extends ne {
    constructor() {
      const i = { other: "on", comments: "off", strings: "off" },
        t = [
          { type: "boolean" },
          {
            type: "string",
            enum: ["on", "inline", "off"],
            enumDescriptions: [g(399, null), g(400, null), g(401, null)],
          },
        ]
      super(94, "quickSuggestions", i, {
        type: "object",
        additionalProperties: !1,
        properties: {
          strings: { anyOf: t, default: i.strings, description: g(402, null) },
          comments: {
            anyOf: t,
            default: i.comments,
            description: g(403, null),
          },
          other: { anyOf: t, default: i.other, description: g(404, null) },
        },
        default: i,
        markdownDescription: g(
          405,
          null,
          "`#editor.suggestOnTriggerCharacters#`",
        ),
      }),
        (this.defaultValue = i)
    }
    validate(i) {
      if (typeof i == "boolean") {
        const l = i ? "on" : "off"
        return { comments: l, strings: l, other: l }
      }
      if (!i || typeof i != "object") return this.defaultValue
      const { other: t, comments: e, strings: s } = i,
        r = ["on", "inline", "off"]
      let a, o, c
      return (
        typeof t == "boolean"
          ? (a = t ? "on" : "off")
          : (a = ge(t, this.defaultValue.other, r)),
        typeof e == "boolean"
          ? (o = e ? "on" : "off")
          : (o = ge(e, this.defaultValue.comments, r)),
        typeof s == "boolean"
          ? (c = s ? "on" : "off")
          : (c = ge(s, this.defaultValue.strings, r)),
        { other: a, comments: o, strings: c }
      )
    }
  },
  tQ
;(function (i) {
  ;(i[(i.Off = 0)] = "Off"),
    (i[(i.On = 1)] = "On"),
    (i[(i.Relative = 2)] = "Relative"),
    (i[(i.Interval = 3)] = "Interval"),
    (i[(i.Custom = 4)] = "Custom")
})(tQ || (tQ = {}))
var B1t = class extends ne {
    constructor() {
      super(
        69,
        "lineNumbers",
        { renderType: 1, renderFn: null },
        {
          type: "string",
          enum: ["off", "on", "relative", "interval"],
          enumDescriptions: [
            g(406, null),
            g(407, null),
            g(408, null),
            g(409, null),
          ],
          default: "on",
          description: g(410, null),
        },
      )
    }
    validate(i) {
      let t = this.defaultValue.renderType,
        e = this.defaultValue.renderFn
      return (
        typeof i < "u" &&
          (typeof i == "function"
            ? ((t = 4), (e = i))
            : i === "interval"
              ? (t = 3)
              : i === "relative"
                ? (t = 2)
                : i === "on"
                  ? (t = 1)
                  : (t = 0)),
        { renderType: t, renderFn: e }
      )
    }
  },
  q1t = class extends ne {
    constructor() {
      const i = [],
        t = { type: "number", description: g(411, null) }
      super(107, "rulers", i, {
        type: "array",
        items: {
          anyOf: [
            t,
            {
              type: ["object"],
              properties: {
                column: t,
                color: {
                  type: "string",
                  description: g(412, null),
                  format: "color-hex",
                },
              },
            },
          ],
        },
        default: i,
        description: g(413, null),
      })
    }
    validate(i) {
      if (Array.isArray(i)) {
        const t = []
        for (const e of i)
          if (typeof e == "number")
            t.push({ column: zt.clampedInt(e, 0, 0, 1e4), color: null })
          else if (e && typeof e == "object") {
            const s = e
            t.push({
              column: zt.clampedInt(s.column, 0, 0, 1e4),
              color: s.color,
            })
          }
        return t.sort((e, s) => e.column - s.column), t
      }
      return this.defaultValue
    }
  },
  U1t = class extends ne {
    constructor() {
      super(97, "readOnlyMessage", void 0)
    }
    validate(i) {
      return !i || typeof i != "object" ? this.defaultValue : i
    }
  }
function eQ(i, t) {
  if (typeof i != "string") return t
  switch (i) {
    case "hidden":
      return 2
    case "visible":
      return 3
    default:
      return 1
  }
}
var M1t = class extends ne {
    constructor() {
      const i = {
        vertical: 1,
        horizontal: 1,
        arrowSize: 11,
        useShadows: !0,
        verticalHasArrows: !1,
        horizontalHasArrows: !1,
        horizontalScrollbarSize: 12,
        horizontalSliderSize: 12,
        verticalScrollbarSize: 14,
        verticalSliderSize: 14,
        handleMouseWheel: !0,
        ignoreVerticalScrolling: !1,
        alwaysConsumeMouseWheel: !0,
        scrollByPage: !1,
        ignoreHorizontalScrollbarInContentHeight: !1,
      }
      super(108, "scrollbar", i, {
        "editor.scrollbar.vertical": {
          type: "string",
          enum: ["auto", "visible", "hidden"],
          enumDescriptions: [g(414, null), g(415, null), g(416, null)],
          default: "auto",
          description: g(417, null),
        },
        "editor.scrollbar.horizontal": {
          type: "string",
          enum: ["auto", "visible", "hidden"],
          enumDescriptions: [g(418, null), g(419, null), g(420, null)],
          default: "auto",
          description: g(421, null),
        },
        "editor.scrollbar.verticalScrollbarSize": {
          type: "number",
          default: i.verticalScrollbarSize,
          description: g(422, null),
        },
        "editor.scrollbar.horizontalScrollbarSize": {
          type: "number",
          default: i.horizontalScrollbarSize,
          description: g(423, null),
        },
        "editor.scrollbar.scrollByPage": {
          type: "boolean",
          default: i.scrollByPage,
          description: g(424, null),
        },
        "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
          type: "boolean",
          default: i.ignoreHorizontalScrollbarInContentHeight,
          description: g(425, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i,
        e = zt.clampedInt(
          t.horizontalScrollbarSize,
          this.defaultValue.horizontalScrollbarSize,
          0,
          1e3,
        ),
        s = zt.clampedInt(
          t.verticalScrollbarSize,
          this.defaultValue.verticalScrollbarSize,
          0,
          1e3,
        )
      return {
        arrowSize: zt.clampedInt(
          t.arrowSize,
          this.defaultValue.arrowSize,
          0,
          1e3,
        ),
        vertical: eQ(t.vertical, this.defaultValue.vertical),
        horizontal: eQ(t.horizontal, this.defaultValue.horizontal),
        useShadows: st(t.useShadows, this.defaultValue.useShadows),
        verticalHasArrows: st(
          t.verticalHasArrows,
          this.defaultValue.verticalHasArrows,
        ),
        horizontalHasArrows: st(
          t.horizontalHasArrows,
          this.defaultValue.horizontalHasArrows,
        ),
        handleMouseWheel: st(
          t.handleMouseWheel,
          this.defaultValue.handleMouseWheel,
        ),
        ignoreVerticalScrolling: st(
          t.ignoreVerticalScrolling,
          this.defaultValue.ignoreVerticalScrolling,
        ),
        alwaysConsumeMouseWheel: st(
          t.alwaysConsumeMouseWheel,
          this.defaultValue.alwaysConsumeMouseWheel,
        ),
        horizontalScrollbarSize: e,
        horizontalSliderSize: zt.clampedInt(t.horizontalSliderSize, e, 0, 1e3),
        verticalScrollbarSize: s,
        verticalSliderSize: zt.clampedInt(t.verticalSliderSize, s, 0, 1e3),
        scrollByPage: st(t.scrollByPage, this.defaultValue.scrollByPage),
        ignoreHorizontalScrollbarInContentHeight: st(
          t.ignoreHorizontalScrollbarInContentHeight,
          this.defaultValue.ignoreHorizontalScrollbarInContentHeight,
        ),
      }
    }
  },
  Ks = "inUntrustedWorkspace",
  Ka = {
    allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
    invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
    nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
    ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
    includeComments: "editor.unicodeHighlight.includeComments",
    includeStrings: "editor.unicodeHighlight.includeStrings",
    allowedLocales: "editor.unicodeHighlight.allowedLocales",
  },
  H1t = class extends ne {
    constructor() {
      const i = {
        nonBasicASCII: Ks,
        invisibleCharacters: !0,
        ambiguousCharacters: !0,
        includeComments: Ks,
        includeStrings: !0,
        allowedCharacters: {},
        allowedLocales: { _os: !0, _vscode: !0 },
      }
      super(130, "unicodeHighlight", i, {
        [Ka.nonBasicASCII]: {
          restricted: !0,
          type: ["boolean", "string"],
          enum: [!0, !1, Ks],
          default: i.nonBasicASCII,
          description: g(426, null),
        },
        [Ka.invisibleCharacters]: {
          restricted: !0,
          type: "boolean",
          default: i.invisibleCharacters,
          description: g(427, null),
        },
        [Ka.ambiguousCharacters]: {
          restricted: !0,
          type: "boolean",
          default: i.ambiguousCharacters,
          description: g(428, null),
        },
        [Ka.includeComments]: {
          restricted: !0,
          type: ["boolean", "string"],
          enum: [!0, !1, Ks],
          default: i.includeComments,
          description: g(429, null),
        },
        [Ka.includeStrings]: {
          restricted: !0,
          type: ["boolean", "string"],
          enum: [!0, !1, Ks],
          default: i.includeStrings,
          description: g(430, null),
        },
        [Ka.allowedCharacters]: {
          restricted: !0,
          type: "object",
          default: i.allowedCharacters,
          description: g(431, null),
          additionalProperties: { type: "boolean" },
        },
        [Ka.allowedLocales]: {
          restricted: !0,
          type: "object",
          additionalProperties: { type: "boolean" },
          default: i.allowedLocales,
          description: g(432, null),
        },
      })
    }
    applyUpdate(i, t) {
      let e = !1
      t.allowedCharacters &&
        i &&
        (Qs(i.allowedCharacters, t.allowedCharacters) ||
          ((i = { ...i, allowedCharacters: t.allowedCharacters }), (e = !0))),
        t.allowedLocales &&
          i &&
          (Qs(i.allowedLocales, t.allowedLocales) ||
            ((i = { ...i, allowedLocales: t.allowedLocales }), (e = !0)))
      const s = super.applyUpdate(i, t)
      return e ? new Q_(s.newValue, !0) : s
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        nonBasicASCII: Pc(t.nonBasicASCII, Ks, [!0, !1, Ks]),
        invisibleCharacters: st(
          t.invisibleCharacters,
          this.defaultValue.invisibleCharacters,
        ),
        ambiguousCharacters: st(
          t.ambiguousCharacters,
          this.defaultValue.ambiguousCharacters,
        ),
        includeComments: Pc(t.includeComments, Ks, [!0, !1, Ks]),
        includeStrings: Pc(t.includeStrings, Ks, [!0, !1, Ks]),
        allowedCharacters: this.c(
          i.allowedCharacters,
          this.defaultValue.allowedCharacters,
        ),
        allowedLocales: this.c(
          i.allowedLocales,
          this.defaultValue.allowedLocales,
        ),
      }
    }
    c(i, t) {
      if (typeof i != "object" || !i) return t
      const e = {}
      for (const [s, r] of Object.entries(i)) r === !0 && (e[s] = !0)
      return e
    }
  },
  W1t = class extends ne {
    constructor() {
      const i = {
        enabled: !0,
        mode: "subwordSmart",
        showToolbar: "onHover",
        suppressSuggestions: !1,
        keepOnBlur: !1,
        fontFamily: "default",
        syntaxHighlightingEnabled: !1,
        edits: {
          experimental: {
            enabled: !0,
            useMixedLinesDiff: "never",
            useInterleavedLinesDiff: "never",
            onlyShowWhenCloseToCursor: !0,
          },
        },
      }
      super(64, "inlineSuggest", i, {
        "editor.inlineSuggest.enabled": {
          type: "boolean",
          default: i.enabled,
          description: g(433, null),
        },
        "editor.inlineSuggest.showToolbar": {
          type: "string",
          default: i.showToolbar,
          enum: ["always", "onHover", "never"],
          enumDescriptions: [g(434, null), g(435, null), g(436, null)],
          description: g(437, null),
        },
        "editor.inlineSuggest.syntaxHighlightingEnabled": {
          type: "boolean",
          default: i.syntaxHighlightingEnabled,
          description: g(438, null),
        },
        "editor.inlineSuggest.suppressSuggestions": {
          type: "boolean",
          default: i.suppressSuggestions,
          description: g(439, null),
        },
        "editor.inlineSuggest.fontFamily": {
          type: "string",
          default: i.fontFamily,
          description: g(440, null),
        },
        "editor.inlineSuggest.edits.experimental.enabled": {
          type: "boolean",
          default: i.edits.experimental.enabled,
          description: g(441, null),
        },
        "editor.inlineSuggest.edits.experimental.useMixedLinesDiff": {
          type: "string",
          default: i.edits.experimental.useMixedLinesDiff,
          description: g(442, null),
          enum: ["never", "whenPossible"],
        },
        "editor.inlineSuggest.edits.experimental.useInterleavedLinesDiff": {
          type: "string",
          default: i.edits.experimental.useInterleavedLinesDiff,
          description: g(443, null),
          enum: ["never", "always", "afterJump"],
        },
        "editor.inlineSuggest.edits.experimental.onlyShowWhenCloseToCursor": {
          type: "boolean",
          default: i.edits.experimental.onlyShowWhenCloseToCursor,
          description: g(444, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: st(t.enabled, this.defaultValue.enabled),
        mode: ge(t.mode, this.defaultValue.mode, [
          "prefix",
          "subword",
          "subwordSmart",
        ]),
        showToolbar: ge(t.showToolbar, this.defaultValue.showToolbar, [
          "always",
          "onHover",
          "never",
        ]),
        suppressSuggestions: st(
          t.suppressSuggestions,
          this.defaultValue.suppressSuggestions,
        ),
        keepOnBlur: st(t.keepOnBlur, this.defaultValue.keepOnBlur),
        fontFamily: Hi.string(t.fontFamily, this.defaultValue.fontFamily),
        syntaxHighlightingEnabled: st(
          t.syntaxHighlightingEnabled,
          this.defaultValue.syntaxHighlightingEnabled,
        ),
        edits: {
          experimental: {
            enabled: st(
              t.edits?.experimental?.enabled,
              this.defaultValue.edits.experimental.enabled,
            ),
            useMixedLinesDiff: ge(
              t.edits?.experimental?.useMixedLinesDiff,
              this.defaultValue.edits.experimental.useMixedLinesDiff,
              ["never", "whenPossible", "afterJumpWhenPossible"],
            ),
            useInterleavedLinesDiff: ge(
              t.edits?.experimental?.useInterleavedLinesDiff,
              this.defaultValue.edits.experimental.useInterleavedLinesDiff,
              ["never", "always", "afterJump"],
            ),
            onlyShowWhenCloseToCursor: st(
              t.edits?.experimental?.onlyShowWhenCloseToCursor,
              this.defaultValue.edits.experimental.onlyShowWhenCloseToCursor,
            ),
          },
        },
      }
    }
  },
  j1t = class extends ne {
    constructor() {
      const i = {
        enabled: jY.bracketPairColorizationOptions.enabled,
        independentColorPoolPerBracketType:
          jY.bracketPairColorizationOptions.independentColorPoolPerBracketType,
      }
      super(15, "bracketPairColorization", i, {
        "editor.bracketPairColorization.enabled": {
          type: "boolean",
          default: i.enabled,
          markdownDescription: g(
            445,
            null,
            "`#workbench.colorCustomizations#`",
          ),
        },
        "editor.bracketPairColorization.independentColorPoolPerBracketType": {
          type: "boolean",
          default: i.independentColorPoolPerBracketType,
          description: g(446, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: st(t.enabled, this.defaultValue.enabled),
        independentColorPoolPerBracketType: st(
          t.independentColorPoolPerBracketType,
          this.defaultValue.independentColorPoolPerBracketType,
        ),
      }
    }
  },
  V1t = class extends ne {
    constructor() {
      const i = {
        bracketPairs: !1,
        bracketPairsHorizontal: "active",
        highlightActiveBracketPair: !0,
        indentation: !0,
        highlightActiveIndentation: !0,
      }
      super(16, "guides", i, {
        "editor.guides.bracketPairs": {
          type: ["boolean", "string"],
          enum: [!0, "active", !1],
          enumDescriptions: [g(447, null), g(448, null), g(449, null)],
          default: i.bracketPairs,
          description: g(450, null),
        },
        "editor.guides.bracketPairsHorizontal": {
          type: ["boolean", "string"],
          enum: [!0, "active", !1],
          enumDescriptions: [g(451, null), g(452, null), g(453, null)],
          default: i.bracketPairsHorizontal,
          description: g(454, null),
        },
        "editor.guides.highlightActiveBracketPair": {
          type: "boolean",
          default: i.highlightActiveBracketPair,
          description: g(455, null),
        },
        "editor.guides.indentation": {
          type: "boolean",
          default: i.indentation,
          description: g(456, null),
        },
        "editor.guides.highlightActiveIndentation": {
          type: ["boolean", "string"],
          enum: [!0, "always", !1],
          enumDescriptions: [g(457, null), g(458, null), g(459, null)],
          default: i.highlightActiveIndentation,
          description: g(460, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        bracketPairs: Pc(t.bracketPairs, this.defaultValue.bracketPairs, [
          !0,
          !1,
          "active",
        ]),
        bracketPairsHorizontal: Pc(
          t.bracketPairsHorizontal,
          this.defaultValue.bracketPairsHorizontal,
          [!0, !1, "active"],
        ),
        highlightActiveBracketPair: st(
          t.highlightActiveBracketPair,
          this.defaultValue.highlightActiveBracketPair,
        ),
        indentation: st(t.indentation, this.defaultValue.indentation),
        highlightActiveIndentation: Pc(
          t.highlightActiveIndentation,
          this.defaultValue.highlightActiveIndentation,
          [!0, !1, "always"],
        ),
      }
    }
  }
function Pc(i, t, e) {
  const s = e.indexOf(i)
  return s === -1 ? t : e[s]
}
var G1t = class extends ne {
    constructor() {
      const i = {
        insertMode: "insert",
        filterGraceful: !0,
        snippetsPreventQuickSuggestions: !1,
        localityBonus: !1,
        shareSuggestSelections: !1,
        selectionMode: "always",
        showIcons: !0,
        showStatusBar: !1,
        preview: !1,
        previewMode: "subwordSmart",
        showInlineDetails: !0,
        showMethods: !0,
        showFunctions: !0,
        showConstructors: !0,
        showDeprecated: !0,
        matchOnWordStartOnly: !0,
        showFields: !0,
        showVariables: !0,
        showClasses: !0,
        showStructs: !0,
        showInterfaces: !0,
        showModules: !0,
        showProperties: !0,
        showEvents: !0,
        showOperators: !0,
        showUnits: !0,
        showValues: !0,
        showConstants: !0,
        showEnums: !0,
        showEnumMembers: !0,
        showKeywords: !0,
        showWords: !0,
        showColors: !0,
        showFiles: !0,
        showReferences: !0,
        showFolders: !0,
        showTypeParameters: !0,
        showSnippets: !0,
        showUsers: !0,
        showIssues: !0,
      }
      super(123, "suggest", i, {
        "editor.suggest.insertMode": {
          type: "string",
          enum: ["insert", "replace"],
          enumDescriptions: [g(461, null), g(462, null)],
          default: i.insertMode,
          description: g(463, null),
        },
        "editor.suggest.filterGraceful": {
          type: "boolean",
          default: i.filterGraceful,
          description: g(464, null),
        },
        "editor.suggest.localityBonus": {
          type: "boolean",
          default: i.localityBonus,
          description: g(465, null),
        },
        "editor.suggest.shareSuggestSelections": {
          type: "boolean",
          default: i.shareSuggestSelections,
          markdownDescription: g(466, null),
        },
        "editor.suggest.selectionMode": {
          type: "string",
          enum: [
            "always",
            "never",
            "whenTriggerCharacter",
            "whenQuickSuggestion",
          ],
          enumDescriptions: [
            g(467, null),
            g(468, null),
            g(469, null),
            g(470, null),
          ],
          default: i.selectionMode,
          markdownDescription: g(
            471,
            null,
            "`#editor.quickSuggestions#`",
            "`#editor.suggestOnTriggerCharacters#`",
          ),
        },
        "editor.suggest.snippetsPreventQuickSuggestions": {
          type: "boolean",
          default: i.snippetsPreventQuickSuggestions,
          description: g(472, null),
        },
        "editor.suggest.showIcons": {
          type: "boolean",
          default: i.showIcons,
          description: g(473, null),
        },
        "editor.suggest.showStatusBar": {
          type: "boolean",
          default: i.showStatusBar,
          description: g(474, null),
        },
        "editor.suggest.preview": {
          type: "boolean",
          default: i.preview,
          description: g(475, null),
        },
        "editor.suggest.showInlineDetails": {
          type: "boolean",
          default: i.showInlineDetails,
          description: g(476, null),
        },
        "editor.suggest.maxVisibleSuggestions": {
          type: "number",
          deprecationMessage: g(477, null),
        },
        "editor.suggest.filteredTypes": {
          type: "object",
          deprecationMessage: g(478, null),
        },
        "editor.suggest.showMethods": {
          type: "boolean",
          default: !0,
          markdownDescription: g(479, null),
        },
        "editor.suggest.showFunctions": {
          type: "boolean",
          default: !0,
          markdownDescription: g(480, null),
        },
        "editor.suggest.showConstructors": {
          type: "boolean",
          default: !0,
          markdownDescription: g(481, null),
        },
        "editor.suggest.showDeprecated": {
          type: "boolean",
          default: !0,
          markdownDescription: g(482, null),
        },
        "editor.suggest.matchOnWordStartOnly": {
          type: "boolean",
          default: !0,
          markdownDescription: g(483, null),
        },
        "editor.suggest.showFields": {
          type: "boolean",
          default: !0,
          markdownDescription: g(484, null),
        },
        "editor.suggest.showVariables": {
          type: "boolean",
          default: !0,
          markdownDescription: g(485, null),
        },
        "editor.suggest.showClasses": {
          type: "boolean",
          default: !0,
          markdownDescription: g(486, null),
        },
        "editor.suggest.showStructs": {
          type: "boolean",
          default: !0,
          markdownDescription: g(487, null),
        },
        "editor.suggest.showInterfaces": {
          type: "boolean",
          default: !0,
          markdownDescription: g(488, null),
        },
        "editor.suggest.showModules": {
          type: "boolean",
          default: !0,
          markdownDescription: g(489, null),
        },
        "editor.suggest.showProperties": {
          type: "boolean",
          default: !0,
          markdownDescription: g(490, null),
        },
        "editor.suggest.showEvents": {
          type: "boolean",
          default: !0,
          markdownDescription: g(491, null),
        },
        "editor.suggest.showOperators": {
          type: "boolean",
          default: !0,
          markdownDescription: g(492, null),
        },
        "editor.suggest.showUnits": {
          type: "boolean",
          default: !0,
          markdownDescription: g(493, null),
        },
        "editor.suggest.showValues": {
          type: "boolean",
          default: !0,
          markdownDescription: g(494, null),
        },
        "editor.suggest.showConstants": {
          type: "boolean",
          default: !0,
          markdownDescription: g(495, null),
        },
        "editor.suggest.showEnums": {
          type: "boolean",
          default: !0,
          markdownDescription: g(496, null),
        },
        "editor.suggest.showEnumMembers": {
          type: "boolean",
          default: !0,
          markdownDescription: g(497, null),
        },
        "editor.suggest.showKeywords": {
          type: "boolean",
          default: !0,
          markdownDescription: g(498, null),
        },
        "editor.suggest.showWords": {
          type: "boolean",
          default: !0,
          markdownDescription: g(499, null),
        },
        "editor.suggest.showColors": {
          type: "boolean",
          default: !0,
          markdownDescription: g(500, null),
        },
        "editor.suggest.showFiles": {
          type: "boolean",
          default: !0,
          markdownDescription: g(501, null),
        },
        "editor.suggest.showReferences": {
          type: "boolean",
          default: !0,
          markdownDescription: g(502, null),
        },
        "editor.suggest.showCustomcolors": {
          type: "boolean",
          default: !0,
          markdownDescription: g(503, null),
        },
        "editor.suggest.showFolders": {
          type: "boolean",
          default: !0,
          markdownDescription: g(504, null),
        },
        "editor.suggest.showTypeParameters": {
          type: "boolean",
          default: !0,
          markdownDescription: g(505, null),
        },
        "editor.suggest.showSnippets": {
          type: "boolean",
          default: !0,
          markdownDescription: g(506, null),
        },
        "editor.suggest.showUsers": {
          type: "boolean",
          default: !0,
          markdownDescription: g(507, null),
        },
        "editor.suggest.showIssues": {
          type: "boolean",
          default: !0,
          markdownDescription: g(508, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        insertMode: ge(t.insertMode, this.defaultValue.insertMode, [
          "insert",
          "replace",
        ]),
        filterGraceful: st(t.filterGraceful, this.defaultValue.filterGraceful),
        snippetsPreventQuickSuggestions: st(
          t.snippetsPreventQuickSuggestions,
          this.defaultValue.filterGraceful,
        ),
        localityBonus: st(t.localityBonus, this.defaultValue.localityBonus),
        shareSuggestSelections: st(
          t.shareSuggestSelections,
          this.defaultValue.shareSuggestSelections,
        ),
        selectionMode: ge(t.selectionMode, this.defaultValue.selectionMode, [
          "always",
          "never",
          "whenQuickSuggestion",
          "whenTriggerCharacter",
        ]),
        showIcons: st(t.showIcons, this.defaultValue.showIcons),
        showStatusBar: st(t.showStatusBar, this.defaultValue.showStatusBar),
        preview: st(t.preview, this.defaultValue.preview),
        previewMode: ge(t.previewMode, this.defaultValue.previewMode, [
          "prefix",
          "subword",
          "subwordSmart",
        ]),
        showInlineDetails: st(
          t.showInlineDetails,
          this.defaultValue.showInlineDetails,
        ),
        showMethods: st(t.showMethods, this.defaultValue.showMethods),
        showFunctions: st(t.showFunctions, this.defaultValue.showFunctions),
        showConstructors: st(
          t.showConstructors,
          this.defaultValue.showConstructors,
        ),
        showDeprecated: st(t.showDeprecated, this.defaultValue.showDeprecated),
        matchOnWordStartOnly: st(
          t.matchOnWordStartOnly,
          this.defaultValue.matchOnWordStartOnly,
        ),
        showFields: st(t.showFields, this.defaultValue.showFields),
        showVariables: st(t.showVariables, this.defaultValue.showVariables),
        showClasses: st(t.showClasses, this.defaultValue.showClasses),
        showStructs: st(t.showStructs, this.defaultValue.showStructs),
        showInterfaces: st(t.showInterfaces, this.defaultValue.showInterfaces),
        showModules: st(t.showModules, this.defaultValue.showModules),
        showProperties: st(t.showProperties, this.defaultValue.showProperties),
        showEvents: st(t.showEvents, this.defaultValue.showEvents),
        showOperators: st(t.showOperators, this.defaultValue.showOperators),
        showUnits: st(t.showUnits, this.defaultValue.showUnits),
        showValues: st(t.showValues, this.defaultValue.showValues),
        showConstants: st(t.showConstants, this.defaultValue.showConstants),
        showEnums: st(t.showEnums, this.defaultValue.showEnums),
        showEnumMembers: st(
          t.showEnumMembers,
          this.defaultValue.showEnumMembers,
        ),
        showKeywords: st(t.showKeywords, this.defaultValue.showKeywords),
        showWords: st(t.showWords, this.defaultValue.showWords),
        showColors: st(t.showColors, this.defaultValue.showColors),
        showFiles: st(t.showFiles, this.defaultValue.showFiles),
        showReferences: st(t.showReferences, this.defaultValue.showReferences),
        showFolders: st(t.showFolders, this.defaultValue.showFolders),
        showTypeParameters: st(
          t.showTypeParameters,
          this.defaultValue.showTypeParameters,
        ),
        showSnippets: st(t.showSnippets, this.defaultValue.showSnippets),
        showUsers: st(t.showUsers, this.defaultValue.showUsers),
        showIssues: st(t.showIssues, this.defaultValue.showIssues),
      }
    }
  },
  z1t = class extends ne {
    constructor() {
      super(
        118,
        "smartSelect",
        { selectLeadingAndTrailingWhitespace: !0, selectSubwords: !0 },
        {
          "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
            description: g(509, null),
            default: !0,
            type: "boolean",
          },
          "editor.smartSelect.selectSubwords": {
            description: g(510, null),
            default: !0,
            type: "boolean",
          },
        },
      )
    }
    validate(i) {
      return !i || typeof i != "object"
        ? this.defaultValue
        : {
            selectLeadingAndTrailingWhitespace: st(
              i.selectLeadingAndTrailingWhitespace,
              this.defaultValue.selectLeadingAndTrailingWhitespace,
            ),
            selectSubwords: st(
              i.selectSubwords,
              this.defaultValue.selectSubwords,
            ),
          }
    }
  },
  Y1t = class extends ne {
    constructor() {
      const i = []
      super(135, "wordSegmenterLocales", i, {
        anyOf: [
          { description: g(511, null), type: "string" },
          {
            description: g(512, null),
            type: "array",
            items: { type: "string" },
          },
        ],
      })
    }
    validate(i) {
      if ((typeof i == "string" && (i = [i]), Array.isArray(i))) {
        const t = []
        for (const e of i)
          if (typeof e == "string")
            try {
              Intl.Segmenter.supportedLocalesOf(e).length > 0 && t.push(e)
            } catch {}
        return t
      }
      return this.defaultValue
    }
  },
  iQ
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Same = 1)] = "Same"),
    (i[(i.Indent = 2)] = "Indent"),
    (i[(i.DeepIndent = 3)] = "DeepIndent")
})(iQ || (iQ = {}))
var Q1t = class extends ne {
    constructor() {
      super(143, "wrappingIndent", 1, {
        "editor.wrappingIndent": {
          type: "string",
          enum: ["none", "same", "indent", "deepIndent"],
          enumDescriptions: [
            g(513, null),
            g(514, null),
            g(515, null),
            g(516, null),
          ],
          description: g(517, null),
          default: "same",
        },
      })
    }
    validate(i) {
      switch (i) {
        case "none":
          return 0
        case "same":
          return 1
        case "indent":
          return 2
        case "deepIndent":
          return 3
      }
      return 1
    }
    compute(i, t, e) {
      return t.get(2) === 2 ? 0 : e
    }
  },
  X1t = class extends Ec {
    constructor() {
      super(152)
    }
    compute(i, t, e) {
      const s = t.get(151)
      return {
        isDominatedByLongLines: i.isDominatedByLongLines,
        isWordWrapMinified: s.isWordWrapMinified,
        isViewportWrapping: s.isViewportWrapping,
        wrappingColumn: s.wrappingColumn,
      }
    }
  },
  K1t = class extends ne {
    constructor() {
      const i = { enabled: !0, showDropSelector: "afterDrop" }
      super(36, "dropIntoEditor", i, {
        "editor.dropIntoEditor.enabled": {
          type: "boolean",
          default: i.enabled,
          markdownDescription: g(518, null),
        },
        "editor.dropIntoEditor.showDropSelector": {
          type: "string",
          markdownDescription: g(519, null),
          enum: ["afterDrop", "never"],
          enumDescriptions: [g(520, null), g(521, null)],
          default: "afterDrop",
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: st(t.enabled, this.defaultValue.enabled),
        showDropSelector: ge(
          t.showDropSelector,
          this.defaultValue.showDropSelector,
          ["afterDrop", "never"],
        ),
      }
    }
  },
  Z1t = class extends ne {
    constructor() {
      const i = { enabled: !1, showPasteSelector: "afterPaste" }
      super(89, "pasteAs", i, {
        "editor.pasteAs.enabled": {
          type: "boolean",
          default: i.enabled,
          markdownDescription: g(522, null),
        },
        "editor.pasteAs.showPasteSelector": {
          type: "string",
          markdownDescription: g(523, null),
          enum: ["afterPaste", "never"],
          enumDescriptions: [g(524, null), g(525, null)],
          default: "afterPaste",
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: st(t.enabled, this.defaultValue.enabled),
        showPasteSelector: ge(
          t.showPasteSelector,
          this.defaultValue.showPasteSelector,
          ["afterPaste", "never"],
        ),
      }
    }
  },
  twt = "Consolas, 'Courier New', monospace",
  ewt = "Menlo, Monaco, 'Courier New', monospace",
  iwt = "'Droid Sans Mono', 'monospace', monospace",
  rn = {
    fontFamily: Ke ? ewt : De ? iwt : twt,
    fontWeight: "normal",
    fontSize: Ke ? 12 : 14,
    lineHeight: 0,
    letterSpacing: 0,
  },
  swt = []
function F(i) {
  return (swt[i.id] = i), i
}
var sQ
;(function (i) {
  ;(i[(i.acceptSuggestionOnCommitCharacter = 0)] =
    "acceptSuggestionOnCommitCharacter"),
    (i[(i.acceptSuggestionOnEnter = 1)] = "acceptSuggestionOnEnter"),
    (i[(i.accessibilitySupport = 2)] = "accessibilitySupport"),
    (i[(i.accessibilityPageSize = 3)] = "accessibilityPageSize"),
    (i[(i.ariaLabel = 4)] = "ariaLabel"),
    (i[(i.ariaRequired = 5)] = "ariaRequired"),
    (i[(i.autoClosingBrackets = 6)] = "autoClosingBrackets"),
    (i[(i.autoClosingComments = 7)] = "autoClosingComments"),
    (i[(i.screenReaderAnnounceInlineSuggestion = 8)] =
      "screenReaderAnnounceInlineSuggestion"),
    (i[(i.autoClosingDelete = 9)] = "autoClosingDelete"),
    (i[(i.autoClosingOvertype = 10)] = "autoClosingOvertype"),
    (i[(i.autoClosingQuotes = 11)] = "autoClosingQuotes"),
    (i[(i.autoIndent = 12)] = "autoIndent"),
    (i[(i.automaticLayout = 13)] = "automaticLayout"),
    (i[(i.autoSurround = 14)] = "autoSurround"),
    (i[(i.bracketPairColorization = 15)] = "bracketPairColorization"),
    (i[(i.guides = 16)] = "guides"),
    (i[(i.codeLens = 17)] = "codeLens"),
    (i[(i.codeLensFontFamily = 18)] = "codeLensFontFamily"),
    (i[(i.codeLensFontSize = 19)] = "codeLensFontSize"),
    (i[(i.colorDecorators = 20)] = "colorDecorators"),
    (i[(i.colorDecoratorsLimit = 21)] = "colorDecoratorsLimit"),
    (i[(i.columnSelection = 22)] = "columnSelection"),
    (i[(i.comments = 23)] = "comments"),
    (i[(i.contextmenu = 24)] = "contextmenu"),
    (i[(i.copyWithSyntaxHighlighting = 25)] = "copyWithSyntaxHighlighting"),
    (i[(i.cursorBlinking = 26)] = "cursorBlinking"),
    (i[(i.cursorSmoothCaretAnimation = 27)] = "cursorSmoothCaretAnimation"),
    (i[(i.cursorStyle = 28)] = "cursorStyle"),
    (i[(i.cursorSurroundingLines = 29)] = "cursorSurroundingLines"),
    (i[(i.cursorSurroundingLinesStyle = 30)] = "cursorSurroundingLinesStyle"),
    (i[(i.cursorWidth = 31)] = "cursorWidth"),
    (i[(i.disableLayerHinting = 32)] = "disableLayerHinting"),
    (i[(i.disableMonospaceOptimizations = 33)] =
      "disableMonospaceOptimizations"),
    (i[(i.domReadOnly = 34)] = "domReadOnly"),
    (i[(i.dragAndDrop = 35)] = "dragAndDrop"),
    (i[(i.dropIntoEditor = 36)] = "dropIntoEditor"),
    (i[(i.experimentalEditContextEnabled = 37)] =
      "experimentalEditContextEnabled"),
    (i[(i.emptySelectionClipboard = 38)] = "emptySelectionClipboard"),
    (i[(i.experimentalGpuAcceleration = 39)] = "experimentalGpuAcceleration"),
    (i[(i.experimentalWhitespaceRendering = 40)] =
      "experimentalWhitespaceRendering"),
    (i[(i.extraEditorClassName = 41)] = "extraEditorClassName"),
    (i[(i.fastScrollSensitivity = 42)] = "fastScrollSensitivity"),
    (i[(i.find = 43)] = "find"),
    (i[(i.fixedOverflowWidgets = 44)] = "fixedOverflowWidgets"),
    (i[(i.folding = 45)] = "folding"),
    (i[(i.foldingStrategy = 46)] = "foldingStrategy"),
    (i[(i.foldingHighlight = 47)] = "foldingHighlight"),
    (i[(i.foldingImportsByDefault = 48)] = "foldingImportsByDefault"),
    (i[(i.foldingMaximumRegions = 49)] = "foldingMaximumRegions"),
    (i[(i.unfoldOnClickAfterEndOfLine = 50)] = "unfoldOnClickAfterEndOfLine"),
    (i[(i.fontFamily = 51)] = "fontFamily"),
    (i[(i.fontInfo = 52)] = "fontInfo"),
    (i[(i.fontLigatures = 53)] = "fontLigatures"),
    (i[(i.fontSize = 54)] = "fontSize"),
    (i[(i.fontWeight = 55)] = "fontWeight"),
    (i[(i.fontVariations = 56)] = "fontVariations"),
    (i[(i.formatOnPaste = 57)] = "formatOnPaste"),
    (i[(i.formatOnType = 58)] = "formatOnType"),
    (i[(i.glyphMargin = 59)] = "glyphMargin"),
    (i[(i.gotoLocation = 60)] = "gotoLocation"),
    (i[(i.hideCursorInOverviewRuler = 61)] = "hideCursorInOverviewRuler"),
    (i[(i.hover = 62)] = "hover"),
    (i[(i.inDiffEditor = 63)] = "inDiffEditor"),
    (i[(i.inlineSuggest = 64)] = "inlineSuggest"),
    (i[(i.letterSpacing = 65)] = "letterSpacing"),
    (i[(i.lightbulb = 66)] = "lightbulb"),
    (i[(i.lineDecorationsWidth = 67)] = "lineDecorationsWidth"),
    (i[(i.lineHeight = 68)] = "lineHeight"),
    (i[(i.lineNumbers = 69)] = "lineNumbers"),
    (i[(i.lineNumbersMinChars = 70)] = "lineNumbersMinChars"),
    (i[(i.linkedEditing = 71)] = "linkedEditing"),
    (i[(i.links = 72)] = "links"),
    (i[(i.matchBrackets = 73)] = "matchBrackets"),
    (i[(i.minimap = 74)] = "minimap"),
    (i[(i.mouseStyle = 75)] = "mouseStyle"),
    (i[(i.mouseWheelScrollSensitivity = 76)] = "mouseWheelScrollSensitivity"),
    (i[(i.mouseWheelZoom = 77)] = "mouseWheelZoom"),
    (i[(i.multiCursorMergeOverlapping = 78)] = "multiCursorMergeOverlapping"),
    (i[(i.multiCursorModifier = 79)] = "multiCursorModifier"),
    (i[(i.multiCursorPaste = 80)] = "multiCursorPaste"),
    (i[(i.multiCursorLimit = 81)] = "multiCursorLimit"),
    (i[(i.occurrencesHighlight = 82)] = "occurrencesHighlight"),
    (i[(i.occurrencesHighlightDelay = 83)] = "occurrencesHighlightDelay"),
    (i[(i.overtypeCursorStyle = 84)] = "overtypeCursorStyle"),
    (i[(i.overtypeOnPaste = 85)] = "overtypeOnPaste"),
    (i[(i.overviewRulerBorder = 86)] = "overviewRulerBorder"),
    (i[(i.overviewRulerLanes = 87)] = "overviewRulerLanes"),
    (i[(i.padding = 88)] = "padding"),
    (i[(i.pasteAs = 89)] = "pasteAs"),
    (i[(i.parameterHints = 90)] = "parameterHints"),
    (i[(i.peekWidgetDefaultFocus = 91)] = "peekWidgetDefaultFocus"),
    (i[(i.placeholder = 92)] = "placeholder"),
    (i[(i.definitionLinkOpensInPeek = 93)] = "definitionLinkOpensInPeek"),
    (i[(i.quickSuggestions = 94)] = "quickSuggestions"),
    (i[(i.quickSuggestionsDelay = 95)] = "quickSuggestionsDelay"),
    (i[(i.readOnly = 96)] = "readOnly"),
    (i[(i.readOnlyMessage = 97)] = "readOnlyMessage"),
    (i[(i.renameOnType = 98)] = "renameOnType"),
    (i[(i.renderControlCharacters = 99)] = "renderControlCharacters"),
    (i[(i.renderFinalNewline = 100)] = "renderFinalNewline"),
    (i[(i.renderLineHighlight = 101)] = "renderLineHighlight"),
    (i[(i.renderLineHighlightOnlyWhenFocus = 102)] =
      "renderLineHighlightOnlyWhenFocus"),
    (i[(i.renderValidationDecorations = 103)] = "renderValidationDecorations"),
    (i[(i.renderWhitespace = 104)] = "renderWhitespace"),
    (i[(i.revealHorizontalRightPadding = 105)] =
      "revealHorizontalRightPadding"),
    (i[(i.roundedSelection = 106)] = "roundedSelection"),
    (i[(i.rulers = 107)] = "rulers"),
    (i[(i.scrollbar = 108)] = "scrollbar"),
    (i[(i.scrollBeyondLastColumn = 109)] = "scrollBeyondLastColumn"),
    (i[(i.scrollBeyondLastLine = 110)] = "scrollBeyondLastLine"),
    (i[(i.scrollPredominantAxis = 111)] = "scrollPredominantAxis"),
    (i[(i.selectionClipboard = 112)] = "selectionClipboard"),
    (i[(i.selectionHighlight = 113)] = "selectionHighlight"),
    (i[(i.selectOnLineNumbers = 114)] = "selectOnLineNumbers"),
    (i[(i.showFoldingControls = 115)] = "showFoldingControls"),
    (i[(i.showUnused = 116)] = "showUnused"),
    (i[(i.snippetSuggestions = 117)] = "snippetSuggestions"),
    (i[(i.smartSelect = 118)] = "smartSelect"),
    (i[(i.smoothScrolling = 119)] = "smoothScrolling"),
    (i[(i.stickyScroll = 120)] = "stickyScroll"),
    (i[(i.stickyTabStops = 121)] = "stickyTabStops"),
    (i[(i.stopRenderingLineAfter = 122)] = "stopRenderingLineAfter"),
    (i[(i.suggest = 123)] = "suggest"),
    (i[(i.suggestFontSize = 124)] = "suggestFontSize"),
    (i[(i.suggestLineHeight = 125)] = "suggestLineHeight"),
    (i[(i.suggestOnTriggerCharacters = 126)] = "suggestOnTriggerCharacters"),
    (i[(i.suggestSelection = 127)] = "suggestSelection"),
    (i[(i.tabCompletion = 128)] = "tabCompletion"),
    (i[(i.tabIndex = 129)] = "tabIndex"),
    (i[(i.unicodeHighlighting = 130)] = "unicodeHighlighting"),
    (i[(i.unusualLineTerminators = 131)] = "unusualLineTerminators"),
    (i[(i.useShadowDOM = 132)] = "useShadowDOM"),
    (i[(i.useTabStops = 133)] = "useTabStops"),
    (i[(i.wordBreak = 134)] = "wordBreak"),
    (i[(i.wordSegmenterLocales = 135)] = "wordSegmenterLocales"),
    (i[(i.wordSeparators = 136)] = "wordSeparators"),
    (i[(i.wordWrap = 137)] = "wordWrap"),
    (i[(i.wordWrapBreakAfterCharacters = 138)] =
      "wordWrapBreakAfterCharacters"),
    (i[(i.wordWrapBreakBeforeCharacters = 139)] =
      "wordWrapBreakBeforeCharacters"),
    (i[(i.wordWrapColumn = 140)] = "wordWrapColumn"),
    (i[(i.wordWrapOverride1 = 141)] = "wordWrapOverride1"),
    (i[(i.wordWrapOverride2 = 142)] = "wordWrapOverride2"),
    (i[(i.wrappingIndent = 143)] = "wrappingIndent"),
    (i[(i.wrappingStrategy = 144)] = "wrappingStrategy"),
    (i[(i.showDeprecated = 145)] = "showDeprecated"),
    (i[(i.inlayHints = 146)] = "inlayHints"),
    (i[(i.effectiveCursorStyle = 147)] = "effectiveCursorStyle"),
    (i[(i.editorClassName = 148)] = "editorClassName"),
    (i[(i.pixelRatio = 149)] = "pixelRatio"),
    (i[(i.tabFocusMode = 150)] = "tabFocusMode"),
    (i[(i.layoutInfo = 151)] = "layoutInfo"),
    (i[(i.wrappingInfo = 152)] = "wrappingInfo"),
    (i[(i.defaultColorDecorators = 153)] = "defaultColorDecorators"),
    (i[(i.colorDecoratorsActivatedOn = 154)] = "colorDecoratorsActivatedOn"),
    (i[(i.inlineCompletionsAccessibilityVerbose = 155)] =
      "inlineCompletionsAccessibilityVerbose"),
    (i[(i.automaticLayoutIgnoreHeight = 156)] = "automaticLayoutIgnoreHeight")
})(sQ || (sQ = {}))
var Zjt = {
    acceptSuggestionOnCommitCharacter: F(
      new Pt(0, "acceptSuggestionOnCommitCharacter", !0, {
        markdownDescription: g(526, null),
      }),
    ),
    acceptSuggestionOnEnter: F(
      new le(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
        markdownEnumDescriptions: ["", g(527, null), ""],
        markdownDescription: g(528, null),
      }),
    ),
    accessibilitySupport: F(new h1t()),
    accessibilityPageSize: F(
      new zt(3, "accessibilityPageSize", 10, 1, 1073741824, {
        description: g(529, null),
        tags: ["accessibility"],
      }),
    ),
    ariaLabel: F(new Hi(4, "ariaLabel", g(530, null))),
    ariaRequired: F(new Pt(5, "ariaRequired", !1, void 0)),
    screenReaderAnnounceInlineSuggestion: F(
      new Pt(8, "screenReaderAnnounceInlineSuggestion", !0, {
        description: g(531, null),
        tags: ["accessibility"],
      }),
    ),
    autoClosingBrackets: F(
      new le(
        6,
        "autoClosingBrackets",
        "languageDefined",
        ["always", "languageDefined", "beforeWhitespace", "never"],
        {
          enumDescriptions: ["", g(532, null), g(533, null), ""],
          description: g(534, null),
        },
      ),
    ),
    autoClosingComments: F(
      new le(
        7,
        "autoClosingComments",
        "languageDefined",
        ["always", "languageDefined", "beforeWhitespace", "never"],
        {
          enumDescriptions: ["", g(535, null), g(536, null), ""],
          description: g(537, null),
        },
      ),
    ),
    autoClosingDelete: F(
      new le(9, "autoClosingDelete", "auto", ["always", "auto", "never"], {
        enumDescriptions: ["", g(538, null), ""],
        description: g(539, null),
      }),
    ),
    autoClosingOvertype: F(
      new le(10, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
        enumDescriptions: ["", g(540, null), ""],
        description: g(541, null),
      }),
    ),
    autoClosingQuotes: F(
      new le(
        11,
        "autoClosingQuotes",
        "languageDefined",
        ["always", "languageDefined", "beforeWhitespace", "never"],
        {
          enumDescriptions: ["", g(542, null), g(543, null), ""],
          description: g(544, null),
        },
      ),
    ),
    autoIndent: F(
      new Zu(
        12,
        "autoIndent",
        4,
        "full",
        ["none", "keep", "brackets", "advanced", "full"],
        u1t,
        {
          enumDescriptions: [
            g(545, null),
            g(546, null),
            g(547, null),
            g(548, null),
            g(549, null),
          ],
          description: g(550, null),
        },
      ),
    ),
    automaticLayout: F(new Pt(13, "automaticLayout", !1)),
    autoSurround: F(
      new le(
        14,
        "autoSurround",
        "languageDefined",
        ["languageDefined", "quotes", "brackets", "never"],
        {
          enumDescriptions: [g(551, null), g(552, null), g(553, null), ""],
          description: g(554, null),
        },
      ),
    ),
    bracketPairColorization: F(new j1t()),
    bracketPairGuides: F(new V1t()),
    stickyTabStops: F(
      new Pt(121, "stickyTabStops", !1, { description: g(555, null) }),
    ),
    codeLens: F(new Pt(17, "codeLens", !0, { description: g(556, null) })),
    codeLensFontFamily: F(
      new Hi(18, "codeLensFontFamily", "", { description: g(557, null) }),
    ),
    codeLensFontSize: F(
      new zt(19, "codeLensFontSize", 0, 0, 100, {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 100,
        markdownDescription: g(558, null),
      }),
    ),
    colorDecorators: F(
      new Pt(20, "colorDecorators", !0, { description: g(559, null) }),
    ),
    colorDecoratorActivatedOn: F(
      new le(
        154,
        "colorDecoratorsActivatedOn",
        "clickAndHover",
        ["clickAndHover", "hover", "click"],
        {
          enumDescriptions: [g(560, null), g(561, null), g(562, null)],
          description: g(563, null),
        },
      ),
    ),
    colorDecoratorsLimit: F(
      new zt(21, "colorDecoratorsLimit", 500, 1, 1e6, {
        markdownDescription: g(564, null),
      }),
    ),
    columnSelection: F(
      new Pt(22, "columnSelection", !1, { description: g(565, null) }),
    ),
    comments: F(new d1t()),
    contextmenu: F(new Pt(24, "contextmenu", !0)),
    copyWithSyntaxHighlighting: F(
      new Pt(25, "copyWithSyntaxHighlighting", !0, {
        description: g(566, null),
      }),
    ),
    cursorBlinking: F(
      new Zu(
        26,
        "cursorBlinking",
        1,
        "blink",
        ["blink", "smooth", "phase", "expand", "solid"],
        m1t,
        { description: g(567, null) },
      ),
    ),
    cursorSmoothCaretAnimation: F(
      new le(
        27,
        "cursorSmoothCaretAnimation",
        "off",
        ["off", "explicit", "on"],
        {
          enumDescriptions: [g(568, null), g(569, null), g(570, null)],
          description: g(571, null),
        },
      ),
    ),
    cursorStyle: F(
      new Zu(
        28,
        "cursorStyle",
        Xs.Line,
        "line",
        [
          "line",
          "block",
          "underline",
          "line-thin",
          "block-outline",
          "underline-thin",
        ],
        KY,
        { description: g(572, null) },
      ),
    ),
    overtypeCursorStyle: F(
      new Zu(
        84,
        "overtypeCursorStyle",
        Xs.Block,
        "block",
        [
          "line",
          "block",
          "underline",
          "line-thin",
          "block-outline",
          "underline-thin",
        ],
        KY,
        { description: g(573, null) },
      ),
    ),
    cursorSurroundingLines: F(
      new zt(29, "cursorSurroundingLines", 0, 0, 1073741824, {
        description: g(574, null),
      }),
    ),
    cursorSurroundingLinesStyle: F(
      new le(30, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
        enumDescriptions: [g(575, null), g(576, null)],
        markdownDescription: g(577, null),
      }),
    ),
    cursorWidth: F(
      new zt(31, "cursorWidth", 0, 0, 1073741824, {
        markdownDescription: g(578, null),
      }),
    ),
    disableLayerHinting: F(new Pt(32, "disableLayerHinting", !1)),
    disableMonospaceOptimizations: F(
      new Pt(33, "disableMonospaceOptimizations", !1),
    ),
    domReadOnly: F(new Pt(34, "domReadOnly", !1)),
    dragAndDrop: F(
      new Pt(35, "dragAndDrop", !0, { description: g(579, null) }),
    ),
    emptySelectionClipboard: F(new p1t()),
    dropIntoEditor: F(new K1t()),
    experimentalEditContextEnabled: F(
      new Pt(37, "experimentalEditContextEnabled", !1, {
        description: g(580, null),
        included: y7 || aG || ZV,
      }),
    ),
    stickyScroll: F(new x1t()),
    experimentalGpuAcceleration: F(
      new le(39, "experimentalGpuAcceleration", "off", ["off", "on"], void 0),
    ),
    experimentalWhitespaceRendering: F(
      new le(
        40,
        "experimentalWhitespaceRendering",
        "svg",
        ["svg", "font", "off"],
        {
          enumDescriptions: [g(581, null), g(582, null), g(583, null)],
          description: g(584, null),
        },
      ),
    ),
    extraEditorClassName: F(new Hi(41, "extraEditorClassName", "")),
    fastScrollSensitivity: F(
      new Jr(42, "fastScrollSensitivity", 5, (i) => (i <= 0 ? 5 : i), {
        markdownDescription: g(585, null),
      }),
    ),
    find: F(new g1t()),
    fixedOverflowWidgets: F(new Pt(44, "fixedOverflowWidgets", !1)),
    folding: F(new Pt(45, "folding", !0, { description: g(586, null) })),
    foldingStrategy: F(
      new le(46, "foldingStrategy", "auto", ["auto", "indentation"], {
        enumDescriptions: [g(587, null), g(588, null)],
        description: g(589, null),
      }),
    ),
    foldingHighlight: F(
      new Pt(47, "foldingHighlight", !0, { description: g(590, null) }),
    ),
    foldingImportsByDefault: F(
      new Pt(48, "foldingImportsByDefault", !1, { description: g(591, null) }),
    ),
    foldingMaximumRegions: F(
      new zt(49, "foldingMaximumRegions", 5e3, 10, 65e3, {
        description: g(592, null),
      }),
    ),
    unfoldOnClickAfterEndOfLine: F(
      new Pt(50, "unfoldOnClickAfterEndOfLine", !1, {
        description: g(593, null),
      }),
    ),
    fontFamily: F(
      new Hi(51, "fontFamily", rn.fontFamily, { description: g(594, null) }),
    ),
    fontInfo: F(new y1t()),
    fontLigatures2: F(new v1t()),
    fontSize: F(new T1t()),
    fontWeight: F(new k1t()),
    fontVariations: F(new w1t()),
    formatOnPaste: F(
      new Pt(57, "formatOnPaste", !1, { description: g(595, null) }),
    ),
    formatOnType: F(
      new Pt(58, "formatOnType", !1, { description: g(596, null) }),
    ),
    glyphMargin: F(
      new Pt(59, "glyphMargin", !0, { description: g(597, null) }),
    ),
    gotoLocation: F(new S1t()),
    hideCursorInOverviewRuler: F(
      new Pt(61, "hideCursorInOverviewRuler", !1, {
        description: g(598, null),
      }),
    ),
    hover: F(new E1t()),
    inDiffEditor: F(new Pt(63, "inDiffEditor", !1)),
    letterSpacing: F(
      new Jr(
        65,
        "letterSpacing",
        rn.letterSpacing,
        (i) => Jr.clamp(i, -5, 20),
        { description: g(599, null) },
      ),
    ),
    lightbulb: F(new $1t()),
    lineDecorationsWidth: F(new C1t()),
    lineHeight: F(new J1t()),
    lineNumbers: F(new B1t()),
    lineNumbersMinChars: F(new zt(70, "lineNumbersMinChars", 5, 1, 300)),
    linkedEditing: F(
      new Pt(71, "linkedEditing", !1, { description: g(600, null) }),
    ),
    links: F(new Pt(72, "links", !0, { description: g(601, null) })),
    matchBrackets: F(
      new le(73, "matchBrackets", "always", ["always", "near", "never"], {
        description: g(602, null),
      }),
    ),
    minimap: F(new L1t()),
    mouseStyle: F(
      new le(75, "mouseStyle", "text", ["text", "default", "copy"]),
    ),
    mouseWheelScrollSensitivity: F(
      new Jr(76, "mouseWheelScrollSensitivity", 1, (i) => (i === 0 ? 1 : i), {
        markdownDescription: g(603, null),
      }),
    ),
    mouseWheelZoom: F(
      new Pt(77, "mouseWheelZoom", !1, {
        markdownDescription: g(Ke ? 604 : 605, null),
      }),
    ),
    multiCursorMergeOverlapping: F(
      new Pt(78, "multiCursorMergeOverlapping", !0, {
        description: g(606, null),
      }),
    ),
    multiCursorModifier: F(
      new Zu(
        79,
        "multiCursorModifier",
        "altKey",
        "alt",
        ["ctrlCmd", "alt"],
        R1t,
        {
          markdownEnumDescriptions: [g(607, null), g(608, null)],
          markdownDescription: g(609, null),
        },
      ),
    ),
    multiCursorPaste: F(
      new le(80, "multiCursorPaste", "spread", ["spread", "full"], {
        markdownEnumDescriptions: [g(610, null), g(611, null)],
        markdownDescription: g(612, null),
      }),
    ),
    multiCursorLimit: F(
      new zt(81, "multiCursorLimit", 1e4, 1, 1e5, {
        markdownDescription: g(613, null),
      }),
    ),
    occurrencesHighlight: F(
      new le(
        82,
        "occurrencesHighlight",
        "singleFile",
        ["off", "singleFile", "multiFile"],
        {
          markdownEnumDescriptions: [g(614, null), g(615, null), g(616, null)],
          markdownDescription: g(617, null),
        },
      ),
    ),
    occurrencesHighlightDelay: F(
      new zt(83, "occurrencesHighlightDelay", 250, 0, 2e3, {
        description: g(618, null),
        tags: ["preview"],
      }),
    ),
    overtypeOnPaste: F(
      new Pt(85, "overtypeOnPaste", !0, { description: g(619, null) }),
    ),
    overviewRulerBorder: F(
      new Pt(86, "overviewRulerBorder", !0, { description: g(620, null) }),
    ),
    overviewRulerLanes: F(new zt(87, "overviewRulerLanes", 3, 0, 3)),
    padding: F(new D1t()),
    pasteAs: F(new Z1t()),
    parameterHints: F(new F1t()),
    peekWidgetDefaultFocus: F(
      new le(91, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
        enumDescriptions: [g(621, null), g(622, null)],
        description: g(623, null),
      }),
    ),
    placeholder: F(new _1t()),
    definitionLinkOpensInPeek: F(
      new Pt(93, "definitionLinkOpensInPeek", !1, {
        description: g(624, null),
      }),
    ),
    quickSuggestions: F(new O1t()),
    quickSuggestionsDelay: F(
      new zt(95, "quickSuggestionsDelay", 10, 0, 1073741824, {
        description: g(625, null),
      }),
    ),
    readOnly: F(new Pt(96, "readOnly", !1)),
    readOnlyMessage: F(new U1t()),
    renameOnType: F(
      new Pt(98, "renameOnType", !1, {
        description: g(626, null),
        markdownDeprecationMessage: g(627, null),
      }),
    ),
    renderControlCharacters: F(
      new Pt(99, "renderControlCharacters", !0, {
        description: g(628, null),
        restricted: !0,
      }),
    ),
    renderFinalNewline: F(
      new le(
        100,
        "renderFinalNewline",
        De ? "dimmed" : "on",
        ["off", "on", "dimmed"],
        { description: g(629, null) },
      ),
    ),
    renderLineHighlight: F(
      new le(
        101,
        "renderLineHighlight",
        "line",
        ["none", "gutter", "line", "all"],
        {
          enumDescriptions: ["", "", "", g(630, null)],
          description: g(631, null),
        },
      ),
    ),
    renderLineHighlightOnlyWhenFocus: F(
      new Pt(102, "renderLineHighlightOnlyWhenFocus", !1, {
        description: g(632, null),
      }),
    ),
    renderValidationDecorations: F(
      new le(103, "renderValidationDecorations", "editable", [
        "editable",
        "on",
        "off",
      ]),
    ),
    renderWhitespace: F(
      new le(
        104,
        "renderWhitespace",
        "selection",
        ["none", "boundary", "selection", "trailing", "all"],
        {
          enumDescriptions: ["", g(633, null), g(634, null), g(635, null), ""],
          description: g(636, null),
        },
      ),
    ),
    revealHorizontalRightPadding: F(
      new zt(105, "revealHorizontalRightPadding", 15, 0, 1e3),
    ),
    roundedSelection: F(
      new Pt(106, "roundedSelection", !0, { description: g(637, null) }),
    ),
    rulers: F(new q1t()),
    scrollbar: F(new M1t()),
    scrollBeyondLastColumn: F(
      new zt(109, "scrollBeyondLastColumn", 4, 0, 1073741824, {
        description: g(638, null),
      }),
    ),
    scrollBeyondLastLine: F(
      new Pt(110, "scrollBeyondLastLine", !0, { description: g(639, null) }),
    ),
    scrollPredominantAxis: F(
      new Pt(111, "scrollPredominantAxis", !0, { description: g(640, null) }),
    ),
    selectionClipboard: F(
      new Pt(112, "selectionClipboard", !0, {
        description: g(641, null),
        included: De,
      }),
    ),
    selectionHighlight: F(
      new Pt(113, "selectionHighlight", !0, { description: g(642, null) }),
    ),
    selectOnLineNumbers: F(new Pt(114, "selectOnLineNumbers", !0)),
    showFoldingControls: F(
      new le(
        115,
        "showFoldingControls",
        "mouseover",
        ["always", "never", "mouseover"],
        {
          enumDescriptions: [g(643, null), g(644, null), g(645, null)],
          description: g(646, null),
        },
      ),
    ),
    showUnused: F(new Pt(116, "showUnused", !0, { description: g(647, null) })),
    showDeprecated: F(
      new Pt(145, "showDeprecated", !0, { description: g(648, null) }),
    ),
    inlayHints: F(new N1t()),
    snippetSuggestions: F(
      new le(
        117,
        "snippetSuggestions",
        "inline",
        ["top", "bottom", "inline", "none"],
        {
          enumDescriptions: [
            g(649, null),
            g(650, null),
            g(651, null),
            g(652, null),
          ],
          description: g(653, null),
        },
      ),
    ),
    smartSelect: F(new z1t()),
    smoothScrolling: F(
      new Pt(119, "smoothScrolling", !1, { description: g(654, null) }),
    ),
    stopRenderingLineAfter: F(
      new zt(122, "stopRenderingLineAfter", 1e4, -1, 1073741824),
    ),
    suggest: F(new G1t()),
    inlineSuggest: F(new W1t()),
    inlineCompletionsAccessibilityVerbose: F(
      new Pt(155, "inlineCompletionsAccessibilityVerbose", !1, {
        description: g(655, null),
      }),
    ),
    automaticLayoutIgnoreHeight: F(
      new Pt(156, "automaticLayoutIgnoreHeight", !1),
    ),
    suggestFontSize: F(
      new zt(124, "suggestFontSize", 0, 0, 1e3, {
        markdownDescription: g(656, null, "`0`", "`#editor.fontSize#`"),
      }),
    ),
    suggestLineHeight: F(
      new zt(125, "suggestLineHeight", 0, 0, 1e3, {
        markdownDescription: g(657, null, "`0`", "`#editor.lineHeight#`"),
      }),
    ),
    suggestOnTriggerCharacters: F(
      new Pt(126, "suggestOnTriggerCharacters", !0, {
        description: g(658, null),
      }),
    ),
    suggestSelection: F(
      new le(
        127,
        "suggestSelection",
        "first",
        ["first", "recentlyUsed", "recentlyUsedByPrefix"],
        {
          markdownEnumDescriptions: [g(659, null), g(660, null), g(661, null)],
          description: g(662, null),
        },
      ),
    ),
    tabCompletion: F(
      new le(128, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
        enumDescriptions: [g(663, null), g(664, null), g(665, null)],
        description: g(666, null),
      }),
    ),
    tabIndex: F(new zt(129, "tabIndex", 0, -1, 1073741824)),
    unicodeHighlight: F(new H1t()),
    unusualLineTerminators: F(
      new le(
        131,
        "unusualLineTerminators",
        "prompt",
        ["auto", "off", "prompt"],
        {
          enumDescriptions: [g(667, null), g(668, null), g(669, null)],
          description: g(670, null),
        },
      ),
    ),
    useShadowDOM: F(new Pt(132, "useShadowDOM", !0)),
    useTabStops: F(
      new Pt(133, "useTabStops", !0, { description: g(671, null) }),
    ),
    wordBreak: F(
      new le(134, "wordBreak", "normal", ["normal", "keepAll"], {
        markdownEnumDescriptions: [g(672, null), g(673, null)],
        description: g(674, null),
      }),
    ),
    wordSegmenterLocales: F(new Y1t()),
    wordSeparators: F(
      new Hi(136, "wordSeparators", VY, { description: g(675, null) }),
    ),
    wordWrap: F(
      new le(
        137,
        "wordWrap",
        "off",
        ["off", "on", "wordWrapColumn", "bounded"],
        {
          markdownEnumDescriptions: [
            g(676, null),
            g(677, null),
            g(678, null),
            g(679, null),
          ],
          description: g(680, null),
        },
      ),
    ),
    wordWrapBreakAfterCharacters: F(
      new Hi(
        138,
        "wordWrapBreakAfterCharacters",
        " 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63",
      ),
    ),
    wordWrapBreakBeforeCharacters: F(
      new Hi(
        139,
        "wordWrapBreakBeforeCharacters",
        "([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B",
      ),
    ),
    wordWrapColumn: F(
      new zt(140, "wordWrapColumn", 80, 1, 1073741824, {
        markdownDescription: g(681, null),
      }),
    ),
    wordWrapOverride1: F(
      new le(141, "wordWrapOverride1", "inherit", ["off", "on", "inherit"]),
    ),
    wordWrapOverride2: F(
      new le(142, "wordWrapOverride2", "inherit", ["off", "on", "inherit"]),
    ),
    effectiveCursorStyle: F(new b1t()),
    editorClassName: F(new f1t()),
    defaultColorDecorators: F(
      new le(
        153,
        "defaultColorDecorators",
        "auto",
        ["auto", "always", "never"],
        {
          enumDescriptions: [g(682, null), g(683, null), g(684, null)],
          description: g(685, null),
        },
      ),
    ),
    pixelRatio: F(new A1t()),
    tabFocusMode: F(
      new Pt(150, "tabFocusMode", !1, { markdownDescription: g(686, null) }),
    ),
    layoutInfo: F(new I1t()),
    wrappingInfo: F(new X1t()),
    wrappingIndent: F(new Q1t()),
    wrappingStrategy: F(new P1t()),
  },
  li,
  yq = globalThis.vscode
if (typeof yq < "u" && typeof yq.context < "u") {
  const i = yq.context.configuration()
  if (i) li = i.product
  else
    throw new Error(
      "Sandbox: unable to resolve product configuration from preload script.",
    )
} else if (globalThis._VSCODE_PRODUCT_JSON && globalThis._VSCODE_PACKAGE_JSON) {
  if (
    ((li = globalThis._VSCODE_PRODUCT_JSON),
    Mn.VSCODE_DEV &&
      Object.assign(li, {
        nameShort: `${li.nameShort} Dev`,
        nameLong: `${li.nameLong} Dev`,
        dataFolderName: `${li.dataFolderName}-dev`,
        serverDataFolderName: li.serverDataFolderName
          ? `${li.serverDataFolderName}-dev`
          : void 0,
      }),
    Mn.VSCODE_DEV_ONBOARDING &&
      Object.assign(li, {
        nameShort: `${li.nameShort} Onboarding`,
        nameLong: `${li.nameLong} Onboarding`,
        dataFolderName: `${li.dataFolderName}-onboarding`,
        serverDataFolderName: li.serverDataFolderName
          ? `${li.serverDataFolderName}-onboarding`
          : void 0,
      }),
    !li.version)
  ) {
    const i = globalThis._VSCODE_PACKAGE_JSON
    Object.assign(li, { version: i.version })
  }
} else
  (li = {}),
    Object.keys(li).length === 0 &&
      Object.assign(li, {
        version: "1.94.0-dev",
        nameShort: "Cursor Dev",
        nameLong: "Cursor Dev",
        applicationName: "cursor",
        dataFolderName: ".cursor",
        urlProtocol: "cursor",
        reportIssueUrl: "https://github.com/getcursor/cursor/issues/new",
        licenseName: "MIT",
        licenseUrl: "https://github.com/getcursor/cursor/",
        serverLicenseUrl: "https://github.com/getcursor/cursor/",
      })
var K_ = li,
  rQ = class _lt {
    static {
      this.count = 0
    }
    constructor(t) {
      ;(this._proxyIdentifierBrand = void 0),
        (this.sid = t),
        (this.nid = ++_lt.count)
    }
  },
  nQ = []
function O(i) {
  const t = new rQ(i)
  return (nQ[t.nid] = t), t
}
function Z_(i) {
  return nQ[i].sid
}
var gs = class {
    constructor(i) {
      this.value = i
    }
  },
  aQ
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.InCenter = 1)] = "InCenter"),
    (i[(i.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
    (i[(i.AtTop = 3)] = "AtTop")
})(aQ || (aQ = {}))
var oQ
;(function (i) {
  ;(i[(i.UnknownInput = 0)] = "UnknownInput"),
    (i[(i.TextInput = 1)] = "TextInput"),
    (i[(i.TextDiffInput = 2)] = "TextDiffInput"),
    (i[(i.TextMergeInput = 3)] = "TextMergeInput"),
    (i[(i.NotebookInput = 4)] = "NotebookInput"),
    (i[(i.NotebookDiffInput = 5)] = "NotebookDiffInput"),
    (i[(i.CustomEditorInput = 6)] = "CustomEditorInput"),
    (i[(i.WebviewEditorInput = 7)] = "WebviewEditorInput"),
    (i[(i.TerminalEditorInput = 8)] = "TerminalEditorInput"),
    (i[(i.InteractiveEditorInput = 9)] = "InteractiveEditorInput"),
    (i[(i.ChatEditorInput = 10)] = "ChatEditorInput"),
    (i[(i.MultiDiffEditorInput = 11)] = "MultiDiffEditorInput")
})(oQ || (oQ = {}))
var cQ
;(function (i) {
  ;(i[(i.TAB_OPEN = 0)] = "TAB_OPEN"),
    (i[(i.TAB_CLOSE = 1)] = "TAB_CLOSE"),
    (i[(i.TAB_UPDATE = 2)] = "TAB_UPDATE"),
    (i[(i.TAB_MOVE = 3)] = "TAB_MOVE")
})(cQ || (cQ = {}))
var lQ
;(function (i) {
  ;(i[(i.Editable = 0)] = "Editable"),
    (i[(i.SupportsHotExit = 1)] = "SupportsHotExit")
})(lQ || (lQ = {}))
var uQ
;(function (i) {
  ;(i[(i.Int8Array = 1)] = "Int8Array"),
    (i[(i.Uint8Array = 2)] = "Uint8Array"),
    (i[(i.Uint8ClampedArray = 3)] = "Uint8ClampedArray"),
    (i[(i.Int16Array = 4)] = "Int16Array"),
    (i[(i.Uint16Array = 5)] = "Uint16Array"),
    (i[(i.Int32Array = 6)] = "Int32Array"),
    (i[(i.Uint32Array = 7)] = "Uint32Array"),
    (i[(i.Float32Array = 8)] = "Float32Array"),
    (i[(i.Float64Array = 9)] = "Float64Array"),
    (i[(i.BigInt64Array = 10)] = "BigInt64Array"),
    (i[(i.BigUint64Array = 11)] = "BigUint64Array")
})(uQ || (uQ = {}))
var hQ
;(function (i) {
  ;(i[(i.Text = 1)] = "Text"),
    (i[(i.Error = 2)] = "Error"),
    (i[(i.Rich = 3)] = "Rich")
})(hQ || (hQ = {}))
var dQ
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.InCenter = 1)] = "InCenter"),
    (i[(i.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
    (i[(i.AtTop = 3)] = "AtTop")
})(dQ || (dQ = {}))
var bq
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Process = 1)] = "Process"),
    (i[(i.Output = 2)] = "Output"),
    (i[(i.Hybrid = 3)] = "Hybrid")
})(bq || (bq = {}))
var tVt = class Olt {
    static {
      this.a = 0
    }
    static mixin(t) {
      return (t._id = Olt.a++), t
    }
  },
  mQ
;(function (i) {
  ;(i.label = "a"),
    (i.kind = "b"),
    (i.detail = "c"),
    (i.documentation = "d"),
    (i.sortText = "e"),
    (i.filterText = "f"),
    (i.preselect = "g"),
    (i.insertText = "h"),
    (i.insertTextRules = "i"),
    (i.range = "j"),
    (i.commitCharacters = "k"),
    (i.additionalTextEdits = "l"),
    (i.kindModifier = "m"),
    (i.commandIdent = "n"),
    (i.commandId = "o"),
    (i.commandArguments = "p")
})(mQ || (mQ = {}))
var fQ
;(function (i) {
  ;(i.defaultRanges = "a"),
    (i.completions = "b"),
    (i.isIncomplete = "c"),
    (i.duration = "d")
})(fQ || (fQ = {}))
var pQ
;(function (i) {
  ;(i[(i.Workspace = 0)] = "Workspace"),
    (i[(i.TextDocument = 1)] = "TextDocument")
})(pQ || (pQ = {}))
var K = {
    MainThreadAuthentication: O("MainThreadAuthentication"),
    MainThreadBulkEdits: O("MainThreadBulkEdits"),
    MainThreadLanguageModels: O("MainThreadLanguageModels"),
    MainThreadEmbeddings: O("MainThreadEmbeddings"),
    MainThreadChatAgents2: O("MainThreadChatAgents2"),
    MainThreadCodeMapper: O("MainThreadCodeMapper"),
    MainThreadChatVariables: O("MainThreadChatVariables"),
    MainThreadLanguageModelTools: O("MainThreadChatSkills"),
    MainThreadClipboard: O("MainThreadClipboard"),
    MainThreadCommands: O("MainThreadCommands"),
    MainThreadComments: O("MainThreadComments"),
    MainThreadConfiguration: O("MainThreadConfiguration"),
    MainThreadConsole: O("MainThreadConsole"),
    MainThreadDebugService: O("MainThreadDebugService"),
    MainThreadDecorations: O("MainThreadDecorations"),
    MainThreadDiagnostics: O("MainThreadDiagnostics"),
    MainThreadDialogs: O("MainThreadDiaglogs"),
    MainThreadDocuments: O("MainThreadDocuments"),
    MainThreadDocumentContentProviders: O("MainThreadDocumentContentProviders"),
    MainThreadTextEditors: O("MainThreadTextEditors"),
    MainThreadEditorInsets: O("MainThreadEditorInsets"),
    MainThreadEditorTabs: O("MainThreadEditorTabs"),
    MainThreadErrors: O("MainThreadErrors"),
    MainThreadTreeViews: O("MainThreadTreeViews"),
    MainThreadDownloadService: O("MainThreadDownloadService"),
    MainThreadLanguageFeatures: O("MainThreadLanguageFeatures"),
    MainThreadLanguages: O("MainThreadLanguages"),
    MainThreadLogger: O("MainThreadLogger"),
    MainThreadMessageService: O("MainThreadMessageService"),
    MainThreadOutputService: O("MainThreadOutputService"),
    MainThreadProgress: O("MainThreadProgress"),
    MainThreadQuickDiff: O("MainThreadQuickDiff"),
    MainThreadQuickOpen: O("MainThreadQuickOpen"),
    MainThreadStatusBar: O("MainThreadStatusBar"),
    MainThreadSecretState: O("MainThreadSecretState"),
    MainThreadStorage: O("MainThreadStorage"),
    MainThreadSpeech: O("MainThreadSpeechProvider"),
    MainThreadTelemetry: O("MainThreadTelemetry"),
    MainThreadTerminalService: O("MainThreadTerminalService"),
    MainThreadTerminalShellIntegration: O("MainThreadTerminalShellIntegration"),
    MainThreadWebviews: O("MainThreadWebviews"),
    MainThreadWebviewPanels: O("MainThreadWebviewPanels"),
    MainThreadWebviewViews: O("MainThreadWebviewViews"),
    MainThreadCustomEditors: O("MainThreadCustomEditors"),
    MainThreadUrls: O("MainThreadUrls"),
    MainThreadUriOpeners: O("MainThreadUriOpeners"),
    MainThreadProfileContentHandlers: O("MainThreadProfileContentHandlers"),
    MainThreadWorkspace: O("MainThreadWorkspace"),
    MainThreadFileSystem: O("MainThreadFileSystem"),
    MainThreadFileSystemEventService: O("MainThreadFileSystemEventService"),
    MainThreadExtensionService: O("MainThreadExtensionService"),
    MainThreadSCM: O("MainThreadSCM"),
    MainThreadSearch: O("MainThreadSearch"),
    MainThreadShare: O("MainThreadShare"),
    MainThreadTask: O("MainThreadTask"),
    MainThreadWindow: O("MainThreadWindow"),
    MainThreadLabelService: O("MainThreadLabelService"),
    MainThreadNotebook: O("MainThreadNotebook"),
    MainThreadNotebookDocuments: O("MainThreadNotebookDocumentsShape"),
    MainThreadNotebookEditors: O("MainThreadNotebookEditorsShape"),
    MainThreadNotebookKernels: O("MainThreadNotebookKernels"),
    MainThreadNotebookRenderers: O("MainThreadNotebookRenderers"),
    MainThreadInteractive: O("MainThreadInteractive"),
    MainThreadTheming: O("MainThreadTheming"),
    MainThreadTunnelService: O("MainThreadTunnelService"),
    MainThreadManagedSockets: O("MainThreadManagedSockets"),
    MainThreadTimeline: O("MainThreadTimeline"),
    MainThreadTesting: O("MainThreadTesting"),
    MainThreadLocalization: O("MainThreadLocalizationShape"),
    MainThreadAiRelatedInformation: O("MainThreadAiRelatedInformation"),
    MainThreadAiEmbeddingVector: O("MainThreadAiEmbeddingVector"),
    MainThreadCursor: O("MainThreadCursor"),
  },
  lt = {
    ExtHostCodeMapper: O("ExtHostCodeMapper"),
    ExtHostCommands: O("ExtHostCommands"),
    ExtHostConfiguration: O("ExtHostConfiguration"),
    ExtHostDiagnostics: O("ExtHostDiagnostics"),
    ExtHostDebugService: O("ExtHostDebugService"),
    ExtHostDecorations: O("ExtHostDecorations"),
    ExtHostDocumentsAndEditors: O("ExtHostDocumentsAndEditors"),
    ExtHostDocuments: O("ExtHostDocuments"),
    ExtHostDocumentContentProviders: O("ExtHostDocumentContentProviders"),
    ExtHostDocumentSaveParticipant: O("ExtHostDocumentSaveParticipant"),
    ExtHostEditors: O("ExtHostEditors"),
    ExtHostTreeViews: O("ExtHostTreeViews"),
    ExtHostFileSystem: O("ExtHostFileSystem"),
    ExtHostFileSystemInfo: O("ExtHostFileSystemInfo"),
    ExtHostFileSystemEventService: O("ExtHostFileSystemEventService"),
    ExtHostLanguages: O("ExtHostLanguages"),
    ExtHostLanguageFeatures: O("ExtHostLanguageFeatures"),
    ExtHostQuickOpen: O("ExtHostQuickOpen"),
    ExtHostQuickDiff: O("ExtHostQuickDiff"),
    ExtHostStatusBar: O("ExtHostStatusBar"),
    ExtHostShare: O("ExtHostShare"),
    ExtHostExtensionService: O("ExtHostExtensionService"),
    ExtHostLogLevelServiceShape: O("ExtHostLogLevelServiceShape"),
    ExtHostTerminalService: O("ExtHostTerminalService"),
    ExtHostTerminalShellIntegration: O("ExtHostTerminalShellIntegration"),
    ExtHostSCM: O("ExtHostSCM"),
    ExtHostSearch: O("ExtHostSearch"),
    ExtHostTask: O("ExtHostTask"),
    ExtHostWorkspace: O("ExtHostWorkspace"),
    ExtHostWindow: O("ExtHostWindow"),
    ExtHostWebviews: O("ExtHostWebviews"),
    ExtHostWebviewPanels: O("ExtHostWebviewPanels"),
    ExtHostCustomEditors: O("ExtHostCustomEditors"),
    ExtHostWebviewViews: O("ExtHostWebviewViews"),
    ExtHostEditorInsets: O("ExtHostEditorInsets"),
    ExtHostEditorTabs: O("ExtHostEditorTabs"),
    ExtHostProgress: O("ExtHostProgress"),
    ExtHostComments: O("ExtHostComments"),
    ExtHostSecretState: O("ExtHostSecretState"),
    ExtHostStorage: O("ExtHostStorage"),
    ExtHostUrls: O("ExtHostUrls"),
    ExtHostUriOpeners: O("ExtHostUriOpeners"),
    ExtHostProfileContentHandlers: O("ExtHostProfileContentHandlers"),
    ExtHostOutputService: O("ExtHostOutputService"),
    ExtHostLabelService: O("ExtHostLabelService"),
    ExtHostNotebook: O("ExtHostNotebook"),
    ExtHostNotebookDocuments: O("ExtHostNotebookDocuments"),
    ExtHostNotebookEditors: O("ExtHostNotebookEditors"),
    ExtHostNotebookKernels: O("ExtHostNotebookKernels"),
    ExtHostNotebookRenderers: O("ExtHostNotebookRenderers"),
    ExtHostNotebookDocumentSaveParticipant: O(
      "ExtHostNotebookDocumentSaveParticipant",
    ),
    ExtHostInteractive: O("ExtHostInteractive"),
    ExtHostChatAgents2: O("ExtHostChatAgents"),
    ExtHostChatVariables: O("ExtHostChatVariables"),
    ExtHostLanguageModelTools: O("ExtHostChatSkills"),
    ExtHostChatProvider: O("ExtHostChatProvider"),
    ExtHostSpeech: O("ExtHostSpeech"),
    ExtHostEmbeddings: O("ExtHostEmbeddings"),
    ExtHostAiRelatedInformation: O("ExtHostAiRelatedInformation"),
    ExtHostAiEmbeddingVector: O("ExtHostAiEmbeddingVector"),
    ExtHostTheming: O("ExtHostTheming"),
    ExtHostTunnelService: O("ExtHostTunnelService"),
    ExtHostManagedSockets: O("ExtHostManagedSockets"),
    ExtHostAuthentication: O("ExtHostAuthentication"),
    ExtHostTimeline: O("ExtHostTimeline"),
    ExtHostTesting: O("ExtHostTesting"),
    ExtHostTelemetry: O("ExtHostTelemetry"),
    ExtHostLocalization: O("ExtHostLocalization"),
    ExtHostCursor: O("ExtHostCursor"),
  }
function gQ(i) {
  return i.toJSON()
}
var rwt = class {
    constructor(i) {
      this.a = i
    }
    transformIncoming(i) {
      const t = this.a.transformIncoming(i)
      return t === i ? i : gQ(S.from(t))
    }
    transformOutgoing(i) {
      const t = this.a.transformOutgoing(i)
      return t === i ? i : gQ(S.from(t))
    }
    transformOutgoingURI(i) {
      const t = this.a.transformOutgoing(i)
      return t === i ? i : S.from(t)
    }
    transformOutgoingScheme(i) {
      return this.a.transformOutgoingScheme(i)
    }
  },
  eVt = new (class {
    transformIncoming(i) {
      return i
    }
    transformOutgoing(i) {
      return i
    }
    transformOutgoingURI(i) {
      return i
    }
    transformOutgoingScheme(i) {
      return i
    }
  })()
function vQ(i, t, e, s) {
  if (!i || s > 200) return null
  if (typeof i == "object") {
    if (i.$mid === 1)
      return e ? S.revive(t.transformIncoming(i)) : t.transformIncoming(i)
    if (i instanceof Q) return null
    for (const r in i)
      if (Object.hasOwnProperty.call(i, r)) {
        const a = vQ(i[r], t, e, s + 1)
        a !== null && (i[r] = a)
      }
  }
  return null
}
function th(i, t) {
  const e = vQ(i, t, !1, 0)
  return e === null ? i : e
}
var wQ = class {
    constructor() {
      ;(this.a = null),
        (this.b = null),
        (this.d = null),
        (this.f = !1),
        (this.g = null),
        (this.h = !1),
        (this.i = null)
    }
    get [Symbol.toStringTag]() {
      return this.toString()
    }
    j() {
      return (
        this.a ||
          (this.a = new Promise((i, t) => {
            ;(this.b = i),
              (this.d = t),
              this.f && this.b(this.g),
              this.h && this.d(this.i)
          })),
        this.a
      )
    }
    resolveOk(i) {
      this.f || this.h || ((this.f = !0), (this.g = i), this.a && this.b(i))
    }
    resolveErr(i) {
      this.f ||
        this.h ||
        ((this.h = !0), (this.i = i), this.a ? this.d(i) : $e(i))
    }
    then(i, t) {
      return this.j().then(i, t)
    }
    catch(i) {
      return this.j().then(void 0, i)
    }
    finally(i) {
      return this.j().finally(i)
    }
  },
  nwt = class extends wQ {
    constructor() {
      super(), (this.h = !0), (this.i = new bi())
    }
  },
  yQ
function Tq(i, t) {
  try {
    return JSON.stringify(i, t)
  } catch {
    return "null"
  }
}
var kq = "$$ref$$",
  awt = { [kq]: -1 }
function bQ(i, t = null, e = !1) {
  const s = []
  return {
    jsonString: (e ? Tq : JSON.stringify)(i, (a, o) => {
      if (typeof o > "u") return awt
      if (typeof o == "object") {
        if (o instanceof Q) {
          const c = s.push(o) - 1
          return { [kq]: c }
        }
        if (t) return t(a, o)
      }
      return o
    }),
    referencedBuffers: s,
  }
}
function TQ(i, t, e) {
  return JSON.parse(i, (s, r) => {
    if (r) {
      const a = r[kq]
      if (typeof a == "number") return t[a]
      if (e && r.$mid === 1) return e.transformIncoming(r)
    }
    return r
  })
}
function kQ(i, t) {
  return JSON.stringify(i, t)
}
function owt(i) {
  return i ? (t, e) => (e && e.$mid === 1 ? i.transformOutgoing(e) : e) : null
}
var SQ
;(function (i) {
  ;(i[(i.LocalSide = 0)] = "LocalSide"), (i[(i.OtherSide = 1)] = "OtherSide")
})(SQ || (SQ = {}))
var EQ
;(function (i) {
  ;(i[(i.Responsive = 0)] = "Responsive"),
    (i[(i.Unresponsive = 1)] = "Unresponsive")
})(EQ || (EQ = {}))
var cwt = () => {},
  lwt = Symbol.for("rpcProtocol"),
  uwt = Symbol.for("rpcProxy"),
  hwt = class iV extends at {
    static {
      yQ = lwt
    }
    static {
      this.a = 3 * 1e3
    }
    constructor(t, e = null, s = null) {
      super(),
        (this[yQ] = !0),
        (this.b = this.D(new J())),
        (this.onDidChangeResponsiveState = this.b.event),
        (this.c = t),
        (this.f = e),
        (this.g = s),
        (this.h = owt(this.g)),
        (this.j = !1),
        (this.m = []),
        (this.q = [])
      for (let r = 0, a = rQ.count; r < a; r++)
        (this.m[r] = null), (this.q[r] = null)
      ;(this.s = 0),
        (this.t = Object.create(null)),
        (this.u = {}),
        (this.w = 0),
        (this.y = 0),
        (this.z = 0),
        (this.C = this.D(new tn(() => this.H(), 1e3))),
        this.D(this.c.onMessage((r) => this.L(r)))
    }
    dispose() {
      ;(this.j = !0),
        Object.keys(this.u).forEach((t) => {
          const e = this.u[t]
          delete this.u[t], e.resolveErr(Nu())
        }),
        super.dispose()
    }
    drain() {
      return typeof this.c.drain == "function"
        ? this.c.drain()
        : Promise.resolve()
    }
    F(t) {
      this.y === 0 && (this.z = Date.now() + iV.a),
        this.y++,
        this.C.isScheduled() || this.C.schedule()
    }
    G(t) {
      ;(this.z = Date.now() + iV.a),
        this.y--,
        this.y === 0 && this.C.cancel(),
        this.I(0)
    }
    H() {
      this.y !== 0 && (Date.now() > this.z ? this.I(1) : this.C.schedule())
    }
    I(t) {
      this.w !== t && ((this.w = t), this.b.fire(this.w))
    }
    get responsiveState() {
      return this.w
    }
    transformIncomingURIs(t) {
      return this.g ? th(t, this.g) : t
    }
    getProxy(t) {
      const { nid: e, sid: s } = t
      return this.q[e] || (this.q[e] = this.J(e, s)), this.q[e]
    }
    J(t, e) {
      const s = {
        get: (r, a) => (
          typeof a == "string" &&
            !r[a] &&
            a.charCodeAt(0) === 36 &&
            (r[a] = (...o) => this.U(t, a, o)),
          a === uwt ? e : r[a]
        ),
      }
      return new Proxy(Object.create(null), s)
    }
    set(t, e) {
      return (this.m[t.nid] = e), e
    }
    assertRegistered(t) {
      for (let e = 0, s = t.length; e < s; e++) {
        const r = t[e]
        if (!this.m[r.nid]) throw new Error(`Missing proxy instance ${r.sid}`)
      }
    }
    L(t) {
      if (this.j) return
      const e = t.byteLength,
        s = We.read(t, 0),
        r = s.readUInt8(),
        a = s.readUInt32()
      switch (r) {
        case 1:
        case 2: {
          let {
            rpcId: o,
            method: c,
            args: l,
          } = Cs.deserializeRequestJSONArgs(s)
          this.g && (l = th(l, this.g)), this.M(e, a, o, c, l, r === 2)
          break
        }
        case 3:
        case 4: {
          let {
            rpcId: o,
            method: c,
            args: l,
          } = Cs.deserializeRequestMixedArgs(s)
          this.g && (l = th(l, this.g)), this.M(e, a, o, c, l, r === 4)
          break
        }
        case 5: {
          this.f?.logIncoming(e, a, 0, "ack"), this.G(a)
          break
        }
        case 6: {
          this.N(e, a)
          break
        }
        case 7: {
          this.O(e, a, void 0)
          break
        }
        case 9: {
          let o = Cs.deserializeReplyOKJSON(s)
          this.g && (o = th(o, this.g)), this.O(e, a, o)
          break
        }
        case 10: {
          const o = Cs.deserializeReplyOKJSONWithBuffers(s, this.g)
          this.O(e, a, o)
          break
        }
        case 8: {
          const o = Cs.deserializeReplyOKVSBuffer(s)
          this.O(e, a, o)
          break
        }
        case 11: {
          let o = Cs.deserializeReplyErrError(s)
          this.g && (o = th(o, this.g)), this.P(e, a, o)
          break
        }
        case 12: {
          this.P(e, a, void 0)
          break
        }
        default:
          console.error("received unexpected message"), console.error(t)
      }
    }
    M(t, e, s, r, a, o) {
      this.f?.logIncoming(t, e, 1, `receiveRequest ${Z_(s)}.${r}(`, a)
      const c = String(e)
      let l, u
      if (o) {
        const m = new fe()
        a.push(m.token), (l = this.Q(s, r, a)), (u = () => m.cancel())
      } else (l = this.Q(s, r, a)), (u = cwt)
      this.t[c] = u
      const d = Cs.serializeAcknowledged(e)
      this.f?.logOutgoing(d.byteLength, e, 1, "ack"),
        this.c.send(d),
        l.then(
          (m) => {
            delete this.t[c]
            const f = Cs.serializeReplyOK(e, m, this.h)
            this.f?.logOutgoing(f.byteLength, e, 1, "reply:", m), this.c.send(f)
          },
          (m) => {
            delete this.t[c]
            const f = Cs.serializeReplyErr(e, m)
            this.f?.logOutgoing(f.byteLength, e, 1, "replyErr:", m),
              this.c.send(f)
          },
        )
    }
    N(t, e) {
      this.f?.logIncoming(t, e, 1, "receiveCancel")
      const s = String(e)
      this.t[s]?.()
    }
    O(t, e, s) {
      this.f?.logIncoming(t, e, 0, "receiveReply:", s)
      const r = String(e)
      if (!this.u.hasOwnProperty(r)) return
      const a = this.u[r]
      delete this.u[r], a.resolveOk(s)
    }
    P(t, e, s) {
      this.f?.logIncoming(t, e, 0, "receiveReplyErr:", s)
      const r = String(e)
      if (!this.u.hasOwnProperty(r)) return
      const a = this.u[r]
      delete this.u[r]
      let o
      s &&
        (s.$isError
          ? ((o = new Error()),
            (o.name = s.name),
            (o.message = s.message),
            (o.stack = s.stack))
          : (o = s)),
        a.resolveErr(o)
    }
    Q(t, e, s) {
      try {
        return Promise.resolve(this.S(t, e, s))
      } catch (r) {
        return Promise.reject(r)
      }
    }
    S(t, e, s) {
      const r = this.m[t]
      if (!r) throw new Error("Unknown actor " + Z_(t))
      const a = r[e]
      if (typeof a != "function")
        throw new Error("Unknown method " + e + " on actor " + Z_(t))
      return a.apply(r, s)
    }
    U(t, e, s) {
      if (this.j) return new nwt()
      let r = null
      if (
        (s.length > 0 &&
          ce.isCancellationToken(s[s.length - 1]) &&
          (r = s.pop()),
        r && r.isCancellationRequested)
      )
        return Promise.reject(Nu())
      const a = Cs.serializeRequestArguments(s, this.h),
        o = ++this.s,
        c = String(o),
        l = new wQ(),
        u = new gt()
      r &&
        u.add(
          r.onCancellationRequested(() => {
            const m = Cs.serializeCancel(o)
            this.f?.logOutgoing(m.byteLength, o, 0, "cancel"), this.c.send(m)
          }),
        ),
        (this.u[c] = new dwt(l, u)),
        this.F(o)
      const d = Cs.serializeRequest(o, t, e, a, !!r)
      return (
        this.f?.logOutgoing(d.byteLength, o, 0, `request: ${Z_(t)}.${e}(`, s),
        this.c.send(d),
        l
      )
    }
  },
  dwt = class {
    constructor(i, t) {
      ;(this.a = i), (this.b = t)
    }
    resolveOk(i) {
      this.a.resolveOk(i), this.b.dispose()
    }
    resolveErr(i) {
      this.a.resolveErr(i), this.b.dispose()
    }
  },
  We = class sV {
    static alloc(t, e, s) {
      const r = new sV(Q.alloc(s + 1 + 4), 0)
      return r.writeUInt8(t), r.writeUInt32(e), r
    }
    static read(t, e) {
      return new sV(t, e)
    }
    get buffer() {
      return this.a
    }
    constructor(t, e) {
      ;(this.a = t), (this.b = e)
    }
    static sizeUInt8() {
      return 1
    }
    static {
      this.sizeUInt32 = 4
    }
    writeUInt8(t) {
      this.a.writeUInt8(t, this.b), (this.b += 1)
    }
    readUInt8() {
      const t = this.a.readUInt8(this.b)
      return (this.b += 1), t
    }
    writeUInt32(t) {
      this.a.writeUInt32BE(t, this.b), (this.b += 4)
    }
    readUInt32() {
      const t = this.a.readUInt32BE(this.b)
      return (this.b += 4), t
    }
    static sizeShortString(t) {
      return 1 + t.byteLength
    }
    writeShortString(t) {
      this.a.writeUInt8(t.byteLength, this.b),
        (this.b += 1),
        this.a.set(t, this.b),
        (this.b += t.byteLength)
    }
    readShortString() {
      const t = this.a.readUInt8(this.b)
      this.b += 1
      const s = this.a.slice(this.b, this.b + t).toString()
      return (this.b += t), s
    }
    static sizeLongString(t) {
      return 4 + t.byteLength
    }
    writeLongString(t) {
      this.a.writeUInt32BE(t.byteLength, this.b),
        (this.b += 4),
        this.a.set(t, this.b),
        (this.b += t.byteLength)
    }
    readLongString() {
      const t = this.a.readUInt32BE(this.b)
      this.b += 4
      const s = this.a.slice(this.b, this.b + t).toString()
      return (this.b += t), s
    }
    writeBuffer(t) {
      this.a.writeUInt32BE(t.byteLength, this.b),
        (this.b += 4),
        this.a.set(t, this.b),
        (this.b += t.byteLength)
    }
    static sizeVSBuffer(t) {
      return 4 + t.byteLength
    }
    writeVSBuffer(t) {
      this.a.writeUInt32BE(t.byteLength, this.b),
        (this.b += 4),
        this.a.set(t, this.b),
        (this.b += t.byteLength)
    }
    readVSBuffer() {
      const t = this.a.readUInt32BE(this.b)
      this.b += 4
      const e = this.a.slice(this.b, this.b + t)
      return (this.b += t), e
    }
    static sizeMixedArray(t) {
      let e = 0
      e += 1
      for (let s = 0, r = t.length; s < r; s++) {
        const a = t[s]
        switch (((e += 1), a.type)) {
          case 1:
            e += this.sizeLongString(a.value)
            break
          case 2:
            e += this.sizeVSBuffer(a.value)
            break
          case 3:
            ;(e += this.sizeUInt32), (e += this.sizeLongString(a.value))
            for (let o = 0; o < a.buffers.length; ++o)
              e += this.sizeVSBuffer(a.buffers[o])
            break
          case 4:
            break
        }
      }
      return e
    }
    writeMixedArray(t) {
      this.a.writeUInt8(t.length, this.b), (this.b += 1)
      for (let e = 0, s = t.length; e < s; e++) {
        const r = t[e]
        switch (r.type) {
          case 1:
            this.writeUInt8(1), this.writeLongString(r.value)
            break
          case 2:
            this.writeUInt8(2), this.writeVSBuffer(r.value)
            break
          case 3:
            this.writeUInt8(3),
              this.writeUInt32(r.buffers.length),
              this.writeLongString(r.value)
            for (let a = 0; a < r.buffers.length; ++a)
              this.writeBuffer(r.buffers[a])
            break
          case 4:
            this.writeUInt8(4)
            break
        }
      }
    }
    readMixedArray() {
      const t = this.a.readUInt8(this.b)
      this.b += 1
      const e = new Array(t)
      for (let s = 0; s < t; s++)
        switch (this.readUInt8()) {
          case 1:
            e[s] = this.readLongString()
            break
          case 2:
            e[s] = this.readVSBuffer()
            break
          case 3: {
            const a = this.readUInt32(),
              o = this.readLongString(),
              c = []
            for (let l = 0; l < a; ++l) c.push(this.readVSBuffer())
            e[s] = new gs(TQ(o, c, null))
            break
          }
          case 4:
            e[s] = void 0
            break
        }
      return e
    }
  },
  IQ
;(function (i) {
  ;(i[(i.Simple = 0)] = "Simple"), (i[(i.Mixed = 1)] = "Mixed")
})(IQ || (IQ = {}))
var Cs = class {
    static a(i) {
      for (let t = 0, e = i.length; t < e; t++)
        if (i[t] instanceof Q || i[t] instanceof gs || typeof i[t] > "u")
          return !0
      return !1
    }
    static serializeRequestArguments(i, t) {
      if (this.a(i)) {
        const e = []
        for (let s = 0, r = i.length; s < r; s++) {
          const a = i[s]
          if (a instanceof Q) e[s] = { type: 2, value: a }
          else if (typeof a > "u") e[s] = { type: 4 }
          else if (a instanceof gs) {
            const { jsonString: o, referencedBuffers: c } = bQ(a.value, t)
            e[s] = { type: 3, value: Q.fromString(o), buffers: c }
          } else e[s] = { type: 1, value: Q.fromString(kQ(a, t)) }
        }
        return { type: 1, args: e }
      }
      return { type: 0, args: kQ(i, t) }
    }
    static serializeRequest(i, t, e, s, r) {
      switch (s.type) {
        case 0:
          return this.b(i, t, e, s.args, r)
        case 1:
          return this.c(i, t, e, s.args, r)
      }
    }
    static b(i, t, e, s, r) {
      const a = Q.fromString(e),
        o = Q.fromString(s)
      let c = 0
      ;(c += We.sizeUInt8()),
        (c += We.sizeShortString(a)),
        (c += We.sizeLongString(o))
      const l = We.alloc(r ? 2 : 1, i, c)
      return (
        l.writeUInt8(t), l.writeShortString(a), l.writeLongString(o), l.buffer
      )
    }
    static deserializeRequestJSONArgs(i) {
      const t = i.readUInt8(),
        e = i.readShortString(),
        s = i.readLongString()
      return { rpcId: t, method: e, args: JSON.parse(s) }
    }
    static c(i, t, e, s, r) {
      const a = Q.fromString(e)
      let o = 0
      ;(o += We.sizeUInt8()),
        (o += We.sizeShortString(a)),
        (o += We.sizeMixedArray(s))
      const c = We.alloc(r ? 4 : 3, i, o)
      return (
        c.writeUInt8(t), c.writeShortString(a), c.writeMixedArray(s), c.buffer
      )
    }
    static deserializeRequestMixedArgs(i) {
      const t = i.readUInt8(),
        e = i.readShortString(),
        s = i.readMixedArray(),
        r = new Array(s.length)
      for (let a = 0, o = s.length; a < o; a++) {
        const c = s[a]
        typeof c == "string" ? (r[a] = JSON.parse(c)) : (r[a] = c)
      }
      return { rpcId: t, method: e, args: r }
    }
    static serializeAcknowledged(i) {
      return We.alloc(5, i, 0).buffer
    }
    static serializeCancel(i) {
      return We.alloc(6, i, 0).buffer
    }
    static serializeReplyOK(i, t, e) {
      if (typeof t > "u") return this.d(i)
      if (t instanceof Q) return this.e(i, t)
      if (t instanceof gs) {
        const { jsonString: s, referencedBuffers: r } = bQ(t.value, e, !0)
        return this.g(i, s, r)
      } else return this.f(i, Tq(t, e))
    }
    static d(i) {
      return We.alloc(7, i, 0).buffer
    }
    static e(i, t) {
      let e = 0
      e += We.sizeVSBuffer(t)
      const s = We.alloc(8, i, e)
      return s.writeVSBuffer(t), s.buffer
    }
    static deserializeReplyOKVSBuffer(i) {
      return i.readVSBuffer()
    }
    static f(i, t) {
      const e = Q.fromString(t)
      let s = 0
      s += We.sizeLongString(e)
      const r = We.alloc(9, i, s)
      return r.writeLongString(e), r.buffer
    }
    static g(i, t, e) {
      const s = Q.fromString(t)
      let r = 0
      ;(r += We.sizeUInt32), (r += We.sizeLongString(s))
      for (const o of e) r += We.sizeVSBuffer(o)
      const a = We.alloc(10, i, r)
      a.writeUInt32(e.length), a.writeLongString(s)
      for (const o of e) a.writeBuffer(o)
      return a.buffer
    }
    static deserializeReplyOKJSON(i) {
      const t = i.readLongString()
      return JSON.parse(t)
    }
    static deserializeReplyOKJSONWithBuffers(i, t) {
      const e = i.readUInt32(),
        s = i.readLongString(),
        r = []
      for (let a = 0; a < e; ++a) r.push(i.readVSBuffer())
      return new gs(TQ(s, r, t))
    }
    static serializeReplyErr(i, t) {
      const e = t ? Tq(xu(t), null) : void 0
      if (typeof e != "string") return this.h(i)
      const s = Q.fromString(e)
      let r = 0
      r += We.sizeLongString(s)
      const a = We.alloc(11, i, r)
      return a.writeLongString(s), a.buffer
    }
    static deserializeReplyErrError(i) {
      const t = i.readLongString()
      return JSON.parse(t)
    }
    static h(i) {
      return We.alloc(12, i, 0).buffer
    }
  },
  PQ
;(function (i) {
  ;(i[(i.RequestJSONArgs = 1)] = "RequestJSONArgs"),
    (i[(i.RequestJSONArgsWithCancellation = 2)] =
      "RequestJSONArgsWithCancellation"),
    (i[(i.RequestMixedArgs = 3)] = "RequestMixedArgs"),
    (i[(i.RequestMixedArgsWithCancellation = 4)] =
      "RequestMixedArgsWithCancellation"),
    (i[(i.Acknowledged = 5)] = "Acknowledged"),
    (i[(i.Cancel = 6)] = "Cancel"),
    (i[(i.ReplyOKEmpty = 7)] = "ReplyOKEmpty"),
    (i[(i.ReplyOKVSBuffer = 8)] = "ReplyOKVSBuffer"),
    (i[(i.ReplyOKJSON = 9)] = "ReplyOKJSON"),
    (i[(i.ReplyOKJSONWithBuffers = 10)] = "ReplyOKJSONWithBuffers"),
    (i[(i.ReplyErrError = 11)] = "ReplyErrError"),
    (i[(i.ReplyErrEmpty = 12)] = "ReplyErrEmpty")
})(PQ || (PQ = {}))
var $Q
;(function (i) {
  ;(i[(i.String = 1)] = "String"),
    (i[(i.VSBuffer = 2)] = "VSBuffer"),
    (i[(i.SerializedObjectWithBuffers = 3)] = "SerializedObjectWithBuffers"),
    (i[(i.Undefined = 4)] = "Undefined")
})($Q || ($Q = {}))
function Sq(i, t) {
  return t && (i.stack || i.stacktrace)
    ? g(110, null, NQ(i), xQ(i.stack) || xQ(i.stacktrace))
    : NQ(i)
}
function xQ(i) {
  return Array.isArray(i)
    ? i.join(`
`)
    : i
}
function NQ(i) {
  return i.code === "ERR_UNC_HOST_NOT_ALLOWED"
    ? `${i.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`
    : typeof i.code == "string" &&
        typeof i.errno == "number" &&
        typeof i.syscall == "string"
      ? g(111, null, i.message)
      : i.message || g(112, null)
}
function Zs(i = null, t = !1) {
  if (!i) return g(113, null)
  if (Array.isArray(i)) {
    const e = Ue(i),
      s = Zs(e[0], t)
    return e.length > 1 ? g(114, null, s, e.length) : s
  }
  if (_t(i)) return i
  if (i.detail) {
    const e = i.detail
    if (e.error) return Sq(e.error, t)
    if (e.exception) return Sq(e.exception, t)
  }
  return i.stack ? Sq(i, t) : i.message ? i.message : g(115, null)
}
function nn(i) {
  return Eq(i, 0)
}
function Eq(i, t) {
  switch (typeof i) {
    case "object":
      return i === null ? an(349, t) : Array.isArray(i) ? fwt(i, t) : pwt(i, t)
    case "string":
      return CQ(i, t)
    case "boolean":
      return mwt(i, t)
    case "number":
      return an(i, t)
    case "undefined":
      return an(937, t)
    default:
      return an(617, t)
  }
}
function an(i, t) {
  return ((t << 5) - t + i) | 0
}
function mwt(i, t) {
  return an(i ? 433 : 863, t)
}
function CQ(i, t) {
  t = an(149417, t)
  for (let e = 0, s = i.length; e < s; e++) t = an(i.charCodeAt(e), t)
  return t
}
function fwt(i, t) {
  return (t = an(104579, t)), i.reduce((e, s) => Eq(s, e), t)
}
function pwt(i, t) {
  return (
    (t = an(181387, t)),
    Object.keys(i)
      .sort()
      .reduce((e, s) => ((e = CQ(s, e)), Eq(i[s], e)), t)
  )
}
var JQ
;(function (i) {
  ;(i[(i.BLOCK_SIZE = 64)] = "BLOCK_SIZE"),
    (i[(i.UNICODE_REPLACEMENT = 65533)] = "UNICODE_REPLACEMENT")
})(JQ || (JQ = {}))
function Iq(i, t, e = 32) {
  const s = e - t,
    r = ~((1 << s) - 1)
  return ((i << t) | ((r & i) >>> s)) >>> 0
}
function eh(i, t = 32) {
  return i instanceof ArrayBuffer
    ? Array.from(new Uint8Array(i))
        .map((e) => e.toString(16).padStart(2, "0"))
        .join("")
    : (i >>> 0).toString(16).padStart(t / 4, "0")
}
var iVt = class Blt {
    static {
      this.g = new DataView(new ArrayBuffer(320))
    }
    constructor() {
      ;(this.h = 1732584193),
        (this.l = 4023233417),
        (this.m = 2562383102),
        (this.n = 271733878),
        (this.o = 3285377520),
        (this.p = new Uint8Array(67)),
        (this.q = new DataView(this.p.buffer)),
        (this.r = 0),
        (this.t = 0),
        (this.u = 0),
        (this.v = !1)
    }
    update(t) {
      const e = t.length
      if (e === 0) return
      const s = this.p
      let r = this.r,
        a = this.u,
        o,
        c
      for (
        a !== 0
          ? ((o = a), (c = -1), (a = 0))
          : ((o = t.charCodeAt(0)), (c = 0));
        ;

      ) {
        let l = o
        if (P_(o))
          if (c + 1 < e) {
            const u = t.charCodeAt(c + 1)
            $_(u) ? (c++, (l = E7(o, u))) : (l = 65533)
          } else {
            a = o
            break
          }
        else $_(o) && (l = 65533)
        if (((r = this.w(s, r, l)), c++, c < e)) o = t.charCodeAt(c)
        else break
      }
      ;(this.r = r), (this.u = a)
    }
    w(t, e, s) {
      return (
        s < 128
          ? (t[e++] = s)
          : s < 2048
            ? ((t[e++] = 192 | ((s & 1984) >>> 6)),
              (t[e++] = 128 | ((s & 63) >>> 0)))
            : s < 65536
              ? ((t[e++] = 224 | ((s & 61440) >>> 12)),
                (t[e++] = 128 | ((s & 4032) >>> 6)),
                (t[e++] = 128 | ((s & 63) >>> 0)))
              : ((t[e++] = 240 | ((s & 1835008) >>> 18)),
                (t[e++] = 128 | ((s & 258048) >>> 12)),
                (t[e++] = 128 | ((s & 4032) >>> 6)),
                (t[e++] = 128 | ((s & 63) >>> 0))),
        e >= 64 &&
          (this.y(),
          (e -= 64),
          (this.t += 64),
          (t[0] = t[64]),
          (t[1] = t[65]),
          (t[2] = t[66])),
        e
      )
    }
    digest() {
      return (
        this.v ||
          ((this.v = !0),
          this.u && ((this.u = 0), (this.r = this.w(this.p, this.r, 65533))),
          (this.t += this.r),
          this.x()),
        eh(this.h) + eh(this.l) + eh(this.m) + eh(this.n) + eh(this.o)
      )
    }
    x() {
      ;(this.p[this.r++] = 128),
        this.p.subarray(this.r).fill(0),
        this.r > 56 && (this.y(), this.p.fill(0))
      const t = 8 * this.t
      this.q.setUint32(56, Math.floor(t / 4294967296), !1),
        this.q.setUint32(60, t % 4294967296, !1),
        this.y()
    }
    y() {
      const t = Blt.g,
        e = this.q
      for (let m = 0; m < 64; m += 4) t.setUint32(m, e.getUint32(m, !1), !1)
      for (let m = 64; m < 320; m += 4)
        t.setUint32(
          m,
          Iq(
            t.getUint32(m - 12, !1) ^
              t.getUint32(m - 32, !1) ^
              t.getUint32(m - 56, !1) ^
              t.getUint32(m - 64, !1),
            1,
          ),
          !1,
        )
      let s = this.h,
        r = this.l,
        a = this.m,
        o = this.n,
        c = this.o,
        l,
        u,
        d
      for (let m = 0; m < 80; m++)
        m < 20
          ? ((l = (r & a) | (~r & o)), (u = 1518500249))
          : m < 40
            ? ((l = r ^ a ^ o), (u = 1859775393))
            : m < 60
              ? ((l = (r & a) | (r & o) | (a & o)), (u = 2400959708))
              : ((l = r ^ a ^ o), (u = 3395469782)),
          (d = (Iq(s, 5) + l + c + u + t.getUint32(m * 4, !1)) & 4294967295),
          (c = o),
          (o = a),
          (a = Iq(r, 30)),
          (r = s),
          (s = d)
      ;(this.h = (this.h + s) & 4294967295),
        (this.l = (this.l + r) & 4294967295),
        (this.m = (this.m + a) & 4294967295),
        (this.n = (this.n + o) & 4294967295),
        (this.o = (this.o + c) & 4294967295)
    }
  },
  LQ
;(function (i) {
  ;(i[(i.LParen = 0)] = "LParen"),
    (i[(i.RParen = 1)] = "RParen"),
    (i[(i.Neg = 2)] = "Neg"),
    (i[(i.Eq = 3)] = "Eq"),
    (i[(i.NotEq = 4)] = "NotEq"),
    (i[(i.Lt = 5)] = "Lt"),
    (i[(i.LtEq = 6)] = "LtEq"),
    (i[(i.Gt = 7)] = "Gt"),
    (i[(i.GtEq = 8)] = "GtEq"),
    (i[(i.RegexOp = 9)] = "RegexOp"),
    (i[(i.RegexStr = 10)] = "RegexStr"),
    (i[(i.True = 11)] = "True"),
    (i[(i.False = 12)] = "False"),
    (i[(i.In = 13)] = "In"),
    (i[(i.Not = 14)] = "Not"),
    (i[(i.And = 15)] = "And"),
    (i[(i.Or = 16)] = "Or"),
    (i[(i.Str = 17)] = "Str"),
    (i[(i.QuotedStr = 18)] = "QuotedStr"),
    (i[(i.Error = 19)] = "Error"),
    (i[(i.EOF = 20)] = "EOF")
})(LQ || (LQ = {}))
function Pq(...i) {
  switch (i.length) {
    case 1:
      return g(1736, null, i[0])
    case 2:
      return g(1737, null, i[0], i[1])
    case 3:
      return g(1738, null, i[0], i[1], i[2])
    default:
      return
  }
}
var gwt = g(1739, null),
  vwt = g(1740, null),
  ih = class rV {
    constructor() {
      ;(this.c = ""),
        (this.d = 0),
        (this.e = 0),
        (this.f = []),
        (this.g = []),
        (this.m = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy)
    }
    static getLexeme(t) {
      switch (t.type) {
        case 0:
          return "("
        case 1:
          return ")"
        case 2:
          return "!"
        case 3:
          return t.isTripleEq ? "===" : "=="
        case 4:
          return t.isTripleEq ? "!==" : "!="
        case 5:
          return "<"
        case 6:
          return "<="
        case 7:
          return ">="
        case 8:
          return ">="
        case 9:
          return "=~"
        case 10:
          return t.lexeme
        case 11:
          return "true"
        case 12:
          return "false"
        case 13:
          return "in"
        case 14:
          return "not"
        case 15:
          return "&&"
        case 16:
          return "||"
        case 17:
          return t.lexeme
        case 18:
          return t.lexeme
        case 19:
          return t.lexeme
        case 20:
          return "EOF"
        default:
          throw u7(
            `unhandled token type: ${JSON.stringify(t)}; have you forgotten to add a case?`,
          )
      }
    }
    static {
      this.a = new Set(
        ["i", "g", "s", "m", "y", "u"].map((t) => t.charCodeAt(0)),
      )
    }
    static {
      this.b = new Map([
        ["not", 14],
        ["in", 13],
        ["false", 12],
        ["true", 11],
      ])
    }
    get errors() {
      return this.g
    }
    reset(t) {
      return (
        (this.c = t),
        (this.d = 0),
        (this.e = 0),
        (this.f = []),
        (this.g = []),
        this
      )
    }
    scan() {
      for (; !this.r(); )
        switch (((this.d = this.e), this.i())) {
          case 40:
            this.k(0)
            break
          case 41:
            this.k(1)
            break
          case 33:
            if (this.h(61)) {
              const e = this.h(61)
              this.f.push({ type: 4, offset: this.d, isTripleEq: e })
            } else this.k(2)
            break
          case 39:
            this.o()
            break
          case 47:
            this.q()
            break
          case 61:
            if (this.h(61)) {
              const e = this.h(61)
              this.f.push({ type: 3, offset: this.d, isTripleEq: e })
            } else this.h(126) ? this.k(9) : this.l(Pq("==", "=~"))
            break
          case 60:
            this.k(this.h(61) ? 6 : 5)
            break
          case 62:
            this.k(this.h(61) ? 8 : 7)
            break
          case 38:
            this.h(38) ? this.k(15) : this.l(Pq("&&"))
            break
          case 124:
            this.h(124) ? this.k(16) : this.l(Pq("||"))
            break
          case 32:
          case 13:
          case 9:
          case 10:
          case 160:
            break
          default:
            this.n()
        }
      return (this.d = this.e), this.k(20), Array.from(this.f)
    }
    h(t) {
      return this.r() || this.c.charCodeAt(this.e) !== t ? !1 : (this.e++, !0)
    }
    i() {
      return this.c.charCodeAt(this.e++)
    }
    j() {
      return this.r() ? 0 : this.c.charCodeAt(this.e)
    }
    k(t) {
      this.f.push({ type: t, offset: this.d })
    }
    l(t) {
      const e = this.d,
        s = this.c.substring(this.d, this.e),
        r = { type: 19, offset: this.d, lexeme: s }
      this.g.push({ offset: e, lexeme: s, additionalInfo: t }), this.f.push(r)
    }
    n() {
      this.m.lastIndex = this.d
      const t = this.m.exec(this.c)
      if (t) {
        this.e = this.d + t[0].length
        const e = this.c.substring(this.d, this.e),
          s = rV.b.get(e)
        s ? this.k(s) : this.f.push({ type: 17, lexeme: e, offset: this.d })
      }
    }
    o() {
      for (; this.j() !== 39 && !this.r(); ) this.i()
      if (this.r()) {
        this.l(gwt)
        return
      }
      this.i(),
        this.f.push({
          type: 18,
          lexeme: this.c.substring(this.d + 1, this.e - 1),
          offset: this.d + 1,
        })
    }
    q() {
      let t = this.e,
        e = !1,
        s = !1
      for (;;) {
        if (t >= this.c.length) {
          ;(this.e = t), this.l(vwt)
          return
        }
        const a = this.c.charCodeAt(t)
        if (e) e = !1
        else if (a === 47 && !s) {
          t++
          break
        } else a === 91 ? (s = !0) : a === 92 ? (e = !0) : a === 93 && (s = !1)
        t++
      }
      for (; t < this.c.length && rV.a.has(this.c.charCodeAt(t)); ) t++
      this.e = t
      const r = this.c.substring(this.d, this.e)
      this.f.push({ type: 10, lexeme: r, offset: this.d })
    }
    r() {
      return this.e >= this.c.length
    }
  },
  tr
;(function (i) {
  ;(i.serviceIds = new Map()),
    (i.DI_TARGET = "$di$target"),
    (i.DI_DEPENDENCIES = "$di$dependencies")
  function t(e) {
    return e[i.DI_DEPENDENCIES] || []
  }
  i.getServiceDependencies = t
})(tr || (tr = {}))
var t6 = X("instantiationService")
function wwt(i, t, e) {
  t[tr.DI_TARGET] === t
    ? t[tr.DI_DEPENDENCIES].push({ id: i, index: e })
    : ((t[tr.DI_DEPENDENCIES] = [{ id: i, index: e }]), (t[tr.DI_TARGET] = t))
}
function X(i) {
  if (tr.serviceIds.has(i)) return tr.serviceIds.get(i)
  const t = function (e, s, r) {
    if (arguments.length !== 3)
      throw new Error(
        "@IServiceName-decorator can only be used to decorate a parameter",
      )
    wwt(t, e, r)
  }
  return (t.toString = () => i), tr.serviceIds.set(i, t), t
}
function sVt(i) {
  return i
}
var pi = new Map()
pi.set("false", !1),
  pi.set("true", !0),
  pi.set("isMac", Ke),
  pi.set("isLinux", De),
  pi.set("isWindows", ie),
  pi.set("isWeb", v7),
  pi.set("isMacNative", Ke && !v7),
  pi.set("isEdge", aG),
  pi.set("isFirefox", wdt),
  pi.set("isChrome", y7),
  pi.set("isSafari", ydt)
var ywt = Object.prototype.hasOwnProperty,
  RQ
;(function (i) {
  ;(i[(i.False = 0)] = "False"),
    (i[(i.True = 1)] = "True"),
    (i[(i.Defined = 2)] = "Defined"),
    (i[(i.Not = 3)] = "Not"),
    (i[(i.Equals = 4)] = "Equals"),
    (i[(i.NotEquals = 5)] = "NotEquals"),
    (i[(i.And = 6)] = "And"),
    (i[(i.Regex = 7)] = "Regex"),
    (i[(i.NotRegex = 8)] = "NotRegex"),
    (i[(i.Or = 9)] = "Or"),
    (i[(i.In = 10)] = "In"),
    (i[(i.NotIn = 11)] = "NotIn"),
    (i[(i.Greater = 12)] = "Greater"),
    (i[(i.GreaterEquals = 13)] = "GreaterEquals"),
    (i[(i.Smaller = 14)] = "Smaller"),
    (i[(i.SmallerEquals = 15)] = "SmallerEquals"),
    (i[(i.Function = 16)] = "Function")
})(RQ || (RQ = {}))
var bwt = { regexParsingWithErrorRecovery: !0 },
  Twt = g(1716, null),
  kwt = g(1717, null),
  Swt = g(1718, null),
  DQ = g(1719, null),
  Ewt = g(1720, null),
  Iwt = g(1721, null),
  Pwt = g(1722, null),
  $wt = g(1723, null),
  FQ = class tp {
    static {
      this.c = new Error()
    }
    get lexingErrors() {
      return this.d.errors
    }
    get parsingErrors() {
      return this.h
    }
    constructor(t = bwt) {
      ;(this.k = t),
        (this.d = new ih()),
        (this.f = []),
        (this.g = 0),
        (this.h = []),
        (this.v = /g|y/g)
    }
    parse(t) {
      if (t === "") {
        this.h.push({
          message: Twt,
          offset: 0,
          lexeme: "",
          additionalInfo: kwt,
        })
        return
      }
      ;(this.f = this.d.reset(t).scan()), (this.g = 0), (this.h = [])
      try {
        const e = this.l()
        if (!this.E()) {
          const s = this.D(),
            r = s.type === 17 ? Iwt : void 0
          throw (
            (this.h.push({
              message: Ewt,
              offset: s.offset,
              lexeme: ih.getLexeme(s),
              additionalInfo: r,
            }),
            tp.c)
          )
        }
        return e
      } catch (e) {
        if (e !== tp.c) throw e
        return
      }
    }
    l() {
      return this.m()
    }
    m() {
      const t = [this.o()]
      for (; this.y(16); ) {
        const e = this.o()
        t.push(e)
      }
      return t.length === 1 ? t[0] : ui.or(...t)
    }
    o() {
      const t = [this.s()]
      for (; this.y(15); ) {
        const e = this.s()
        t.push(e)
      }
      return t.length === 1 ? t[0] : ui.and(...t)
    }
    s() {
      if (this.y(2)) {
        const t = this.D()
        switch (t.type) {
          case 11:
            return this.z(), Wi.INSTANCE
          case 12:
            return this.z(), os.INSTANCE
          case 0: {
            this.z()
            const e = this.l()
            return this.A(1, DQ), e?.negate()
          }
          case 17:
            return this.z(), nh.create(t.lexeme)
          default:
            throw this.B("KEY | true | false | '(' expression ')'", t)
        }
      }
      return this.t()
    }
    t() {
      const t = this.D()
      switch (t.type) {
        case 11:
          return this.z(), ui.true()
        case 12:
          return this.z(), ui.false()
        case 0: {
          this.z()
          const e = this.l()
          return this.A(1, DQ), e
        }
        case 17: {
          const e = t.lexeme
          if ((this.z(), this.y(9))) {
            const r = this.D()
            if (!this.k.regexParsingWithErrorRecovery) {
              if ((this.z(), r.type !== 10)) throw this.B("REGEX", r)
              const a = r.lexeme,
                o = a.lastIndexOf("/"),
                c = o === a.length - 1 ? void 0 : this.w(a.substring(o + 1))
              let l
              try {
                l = new RegExp(a.substring(1, o), c)
              } catch {
                throw this.B("REGEX", r)
              }
              return Rq.create(e, l)
            }
            switch (r.type) {
              case 10:
              case 19: {
                const a = [r.lexeme]
                this.z()
                let o = this.D(),
                  c = 0
                for (let f = 0; f < r.lexeme.length; f++)
                  r.lexeme.charCodeAt(f) === 40
                    ? c++
                    : r.lexeme.charCodeAt(f) === 41 && c--
                for (; !this.E() && o.type !== 15 && o.type !== 16; ) {
                  switch (o.type) {
                    case 0:
                      c++
                      break
                    case 1:
                      c--
                      break
                    case 10:
                    case 18:
                      for (let f = 0; f < o.lexeme.length; f++)
                        o.lexeme.charCodeAt(f) === 40
                          ? c++
                          : r.lexeme.charCodeAt(f) === 41 && c--
                  }
                  if (c < 0) break
                  a.push(ih.getLexeme(o)), this.z(), (o = this.D())
                }
                const l = a.join(""),
                  u = l.lastIndexOf("/"),
                  d = u === l.length - 1 ? void 0 : this.w(l.substring(u + 1))
                let m
                try {
                  m = new RegExp(l.substring(1, u), d)
                } catch {
                  throw this.B("REGEX", r)
                }
                return ui.regex(e, m)
              }
              case 18: {
                const a = r.lexeme
                this.z()
                let o = null
                if (!E_(a)) {
                  const c = a.indexOf("/"),
                    l = a.lastIndexOf("/")
                  if (c !== l && c >= 0) {
                    const u = a.slice(c + 1, l),
                      d = a[l + 1] === "i" ? "i" : ""
                    try {
                      o = new RegExp(u, d)
                    } catch {
                      throw this.B("REGEX", r)
                    }
                  }
                }
                if (o === null) throw this.B("REGEX", r)
                return Rq.create(e, o)
              }
              default:
                throw this.B("REGEX", this.D())
            }
          }
          if (this.y(14)) {
            this.A(13, Swt)
            const r = this.u()
            return ui.notIn(e, r)
          }
          switch (this.D().type) {
            case 3: {
              this.z()
              const r = this.u()
              if (this.x().type === 18) return ui.equals(e, r)
              switch (r) {
                case "true":
                  return ui.has(e)
                case "false":
                  return ui.not(e)
                default:
                  return ui.equals(e, r)
              }
            }
            case 4: {
              this.z()
              const r = this.u()
              if (this.x().type === 18) return ui.notEquals(e, r)
              switch (r) {
                case "true":
                  return ui.not(e)
                case "false":
                  return ui.has(e)
                default:
                  return ui.notEquals(e, r)
              }
            }
            case 5:
              return this.z(), Jq.create(e, this.u())
            case 6:
              return this.z(), Lq.create(e, this.u())
            case 7:
              return this.z(), Nq.create(e, this.u())
            case 8:
              return this.z(), Cq.create(e, this.u())
            case 13:
              return this.z(), ui.in(e, this.u())
            default:
              return ui.has(e)
          }
        }
        case 20:
          throw (
            (this.h.push({
              message: Pwt,
              offset: t.offset,
              lexeme: "",
              additionalInfo: $wt,
            }),
            tp.c)
          )
        default:
          throw this.B(
            `true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`,
            this.D(),
          )
      }
    }
    u() {
      const t = this.D()
      switch (t.type) {
        case 17:
        case 18:
          return this.z(), t.lexeme
        case 11:
          return this.z(), "true"
        case 12:
          return this.z(), "false"
        case 13:
          return this.z(), "in"
        default:
          return ""
      }
    }
    w(t) {
      return t.replaceAll(this.v, "")
    }
    x() {
      return this.f[this.g - 1]
    }
    y(t) {
      return this.C(t) ? (this.z(), !0) : !1
    }
    z() {
      return this.E() || this.g++, this.x()
    }
    A(t, e) {
      if (this.C(t)) return this.z()
      throw this.B(e, this.D())
    }
    B(t, e, s) {
      const r = g(1724, null, t, ih.getLexeme(e)),
        a = e.offset,
        o = ih.getLexeme(e)
      return (
        this.h.push({ message: r, offset: a, lexeme: o, additionalInfo: s }),
        tp.c
      )
    }
    C(t) {
      return this.D().type === t
    }
    D() {
      return this.f[this.g]
    }
    E() {
      return this.D().type === 20
    }
  },
  ui = class {
    static false() {
      return Wi.INSTANCE
    }
    static true() {
      return os.INSTANCE
    }
    static has(i) {
      return rh.create(i)
    }
    static equals(i, t) {
      return $q.create(i, t)
    }
    static notEquals(i, t) {
      return xq.create(i, t)
    }
    static regex(i, t) {
      return Rq.create(i, t)
    }
    static in(i, t) {
      return AQ.create(i, t)
    }
    static notIn(i, t) {
      return _Q.create(i, t)
    }
    static not(i) {
      return nh.create(i)
    }
    static and(...i) {
      return BQ.create(i, null, !0)
    }
    static or(...i) {
      return Dq.create(i, null, !0)
    }
    static greater(i, t) {
      return Nq.create(i, t)
    }
    static greaterEquals(i, t) {
      return Cq.create(i, t)
    }
    static smaller(i, t) {
      return Jq.create(i, t)
    }
    static smallerEquals(i, t) {
      return Lq.create(i, t)
    }
    static function(i) {
      return Nwt.create(i)
    }
    static {
      this.c = new FQ({ regexParsingWithErrorRecovery: !1 })
    }
    static deserialize(i) {
      return i == null ? void 0 : this.c.parse(i)
    }
  }
function xwt(i) {
  const t = new FQ({ regexParsingWithErrorRecovery: !1 })
  return i.map(
    (e) => (
      t.parse(e),
      t.lexingErrors.length > 0
        ? t.lexingErrors.map((s) => ({
            errorMessage: s.additionalInfo
              ? g(1725, null, s.additionalInfo)
              : g(1726, null),
            offset: s.offset,
            length: s.lexeme.length,
          }))
        : t.parsingErrors.length > 0
          ? t.parsingErrors.map((s) => ({
              errorMessage: s.additionalInfo
                ? `${s.message}. ${s.additionalInfo}`
                : s.message,
              offset: s.offset,
              length: s.lexeme.length,
            }))
          : []
    ),
  )
}
function sh(i, t) {
  return i.cmp(t)
}
var Nwt = class nV {
    static create(t) {
      return new nV(t)
    }
    constructor(t) {
      ;(this.type = 16), (this.c = t)
    }
    cmp(t) {
      return this.type - t.type
    }
    equals(t) {
      return t.type === this.type && t.c === this.c
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return this.c()
    }
    serialize() {
      return "(arbitrary function)"
    }
    keys() {
      return []
    }
    map(t) {
      return this
    }
    negate() {
      return new nV(() => !this.c())
    }
  },
  Wi = class qlt {
    static {
      this.INSTANCE = new qlt()
    }
    constructor() {
      this.type = 0
    }
    cmp(t) {
      return this.type - t.type
    }
    equals(t) {
      return t.type === this.type
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return !1
    }
    serialize() {
      return "false"
    }
    keys() {
      return []
    }
    map(t) {
      return this
    }
    negate() {
      return os.INSTANCE
    }
  },
  os = class Ult {
    static {
      this.INSTANCE = new Ult()
    }
    constructor() {
      this.type = 1
    }
    cmp(t) {
      return this.type - t.type
    }
    equals(t) {
      return t.type === this.type
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return !0
    }
    serialize() {
      return "true"
    }
    keys() {
      return []
    }
    map(t) {
      return this
    }
    negate() {
      return Wi.INSTANCE
    }
  },
  rh = class Mlt {
    static create(t, e = null) {
      const s = pi.get(t)
      return typeof s == "boolean"
        ? s
          ? os.INSTANCE
          : Wi.INSTANCE
        : new Mlt(t, e)
    }
    constructor(t, e) {
      ;(this.key = t), (this.c = e), (this.type = 2)
    }
    cmp(t) {
      return t.type !== this.type ? this.type - t.type : UQ(this.key, t.key)
    }
    equals(t) {
      return t.type === this.type ? this.key === t.key : !1
    }
    substituteConstants() {
      const t = pi.get(this.key)
      return typeof t == "boolean" ? (t ? os.INSTANCE : Wi.INSTANCE) : this
    }
    evaluate(t) {
      return !!t.getValue(this.key)
    }
    serialize() {
      return this.key
    }
    keys() {
      return [this.key]
    }
    map(t) {
      return t.mapDefined(this.key)
    }
    negate() {
      return this.c || (this.c = nh.create(this.key, this)), this.c
    }
  },
  $q = class Hlt {
    static create(t, e, s = null) {
      if (typeof e == "boolean") return e ? rh.create(t, s) : nh.create(t, s)
      const r = pi.get(t)
      return typeof r == "boolean"
        ? e === (r ? "true" : "false")
          ? os.INSTANCE
          : Wi.INSTANCE
        : new Hlt(t, e, s)
    }
    constructor(t, e, s) {
      ;(this.c = t), (this.d = e), (this.f = s), (this.type = 4)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : Za(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      const t = pi.get(this.c)
      if (typeof t == "boolean") {
        const e = t ? "true" : "false"
        return this.d === e ? os.INSTANCE : Wi.INSTANCE
      }
      return this
    }
    evaluate(t) {
      return t.getValue(this.c) == this.d
    }
    serialize() {
      return `${this.c} == '${this.d}'`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapEquals(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = xq.create(this.c, this.d, this)), this.f
    }
  },
  AQ = class Wlt {
    static create(t, e) {
      return new Wlt(t, e)
    }
    constructor(t, e) {
      ;(this.d = t), (this.f = e), (this.type = 10), (this.c = null)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : Za(this.d, this.f, t.d, t.f)
    }
    equals(t) {
      return t.type === this.type ? this.d === t.d && this.f === t.f : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      const e = t.getValue(this.f),
        s = t.getValue(this.d)
      return Array.isArray(e)
        ? e.includes(s)
        : typeof s == "string" && typeof e == "object" && e !== null
          ? ywt.call(e, s)
          : !1
    }
    serialize() {
      return `${this.d} in '${this.f}'`
    }
    keys() {
      return [this.d, this.f]
    }
    map(t) {
      return t.mapIn(this.d, this.f)
    }
    negate() {
      return this.c || (this.c = _Q.create(this.d, this.f)), this.c
    }
  },
  _Q = class jlt {
    static create(t, e) {
      return new jlt(t, e)
    }
    constructor(t, e) {
      ;(this.d = t), (this.f = e), (this.type = 11), (this.c = AQ.create(t, e))
    }
    cmp(t) {
      return t.type !== this.type ? this.type - t.type : this.c.cmp(t.c)
    }
    equals(t) {
      return t.type === this.type ? this.c.equals(t.c) : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return !this.c.evaluate(t)
    }
    serialize() {
      return `${this.d} not in '${this.f}'`
    }
    keys() {
      return this.c.keys()
    }
    map(t) {
      return t.mapNotIn(this.d, this.f)
    }
    negate() {
      return this.c
    }
  },
  xq = class Vlt {
    static create(t, e, s = null) {
      if (typeof e == "boolean") return e ? nh.create(t, s) : rh.create(t, s)
      const r = pi.get(t)
      return typeof r == "boolean"
        ? e === (r ? "true" : "false")
          ? Wi.INSTANCE
          : os.INSTANCE
        : new Vlt(t, e, s)
    }
    constructor(t, e, s) {
      ;(this.c = t), (this.d = e), (this.f = s), (this.type = 5)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : Za(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      const t = pi.get(this.c)
      if (typeof t == "boolean") {
        const e = t ? "true" : "false"
        return this.d === e ? Wi.INSTANCE : os.INSTANCE
      }
      return this
    }
    evaluate(t) {
      return t.getValue(this.c) != this.d
    }
    serialize() {
      return `${this.c} != '${this.d}'`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapNotEquals(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = $q.create(this.c, this.d, this)), this.f
    }
  },
  nh = class Glt {
    static create(t, e = null) {
      const s = pi.get(t)
      return typeof s == "boolean"
        ? s
          ? Wi.INSTANCE
          : os.INSTANCE
        : new Glt(t, e)
    }
    constructor(t, e) {
      ;(this.c = t), (this.d = e), (this.type = 3)
    }
    cmp(t) {
      return t.type !== this.type ? this.type - t.type : UQ(this.c, t.c)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c : !1
    }
    substituteConstants() {
      const t = pi.get(this.c)
      return typeof t == "boolean" ? (t ? Wi.INSTANCE : os.INSTANCE) : this
    }
    evaluate(t) {
      return !t.getValue(this.c)
    }
    serialize() {
      return `!${this.c}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapNot(this.c)
    }
    negate() {
      return this.d || (this.d = rh.create(this.c, this)), this.d
    }
  }
function e6(i, t) {
  if (typeof i == "string") {
    const e = parseFloat(i)
    isNaN(e) || (i = e)
  }
  return typeof i == "string" || typeof i == "number" ? t(i) : Wi.INSTANCE
}
var Nq = class zlt {
    static create(t, e, s = null) {
      return e6(e, (r) => new zlt(t, r, s))
    }
    constructor(t, e, s) {
      ;(this.c = t), (this.d = e), (this.f = s), (this.type = 12)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : Za(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return typeof this.d == "string"
        ? !1
        : parseFloat(t.getValue(this.c)) > this.d
    }
    serialize() {
      return `${this.c} > ${this.d}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapGreater(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = Lq.create(this.c, this.d, this)), this.f
    }
  },
  Cq = class Ylt {
    static create(t, e, s = null) {
      return e6(e, (r) => new Ylt(t, r, s))
    }
    constructor(t, e, s) {
      ;(this.c = t), (this.d = e), (this.f = s), (this.type = 13)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : Za(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return typeof this.d == "string"
        ? !1
        : parseFloat(t.getValue(this.c)) >= this.d
    }
    serialize() {
      return `${this.c} >= ${this.d}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapGreaterEquals(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = Jq.create(this.c, this.d, this)), this.f
    }
  },
  Jq = class Qlt {
    static create(t, e, s = null) {
      return e6(e, (r) => new Qlt(t, r, s))
    }
    constructor(t, e, s) {
      ;(this.c = t), (this.d = e), (this.f = s), (this.type = 14)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : Za(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return typeof this.d == "string"
        ? !1
        : parseFloat(t.getValue(this.c)) < this.d
    }
    serialize() {
      return `${this.c} < ${this.d}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapSmaller(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = Cq.create(this.c, this.d, this)), this.f
    }
  },
  Lq = class Xlt {
    static create(t, e, s = null) {
      return e6(e, (r) => new Xlt(t, r, s))
    }
    constructor(t, e, s) {
      ;(this.c = t), (this.d = e), (this.f = s), (this.type = 15)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : Za(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return typeof this.d == "string"
        ? !1
        : parseFloat(t.getValue(this.c)) <= this.d
    }
    serialize() {
      return `${this.c} <= ${this.d}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapSmallerEquals(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = Nq.create(this.c, this.d, this)), this.f
    }
  },
  Rq = class Klt {
    static create(t, e) {
      return new Klt(t, e)
    }
    constructor(t, e) {
      ;(this.d = t), (this.f = e), (this.type = 7), (this.c = null)
    }
    cmp(t) {
      if (t.type !== this.type) return this.type - t.type
      if (this.d < t.d) return -1
      if (this.d > t.d) return 1
      const e = this.f ? this.f.source : "",
        s = t.f ? t.f.source : ""
      return e < s ? -1 : e > s ? 1 : 0
    }
    equals(t) {
      if (t.type === this.type) {
        const e = this.f ? this.f.source : "",
          s = t.f ? t.f.source : ""
        return this.d === t.d && e === s
      }
      return !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      const e = t.getValue(this.d)
      return this.f ? this.f.test(e) : !1
    }
    serialize() {
      const t = this.f ? `/${this.f.source}/${this.f.flags}` : "/invalid/"
      return `${this.d} =~ ${t}`
    }
    keys() {
      return [this.d]
    }
    map(t) {
      return t.mapRegex(this.d, this.f)
    }
    negate() {
      return this.c || (this.c = Cwt.create(this)), this.c
    }
  },
  Cwt = class aV {
    static create(t) {
      return new aV(t)
    }
    constructor(t) {
      ;(this.c = t), (this.type = 8)
    }
    cmp(t) {
      return t.type !== this.type ? this.type - t.type : this.c.cmp(t.c)
    }
    equals(t) {
      return t.type === this.type ? this.c.equals(t.c) : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return !this.c.evaluate(t)
    }
    serialize() {
      return `!(${this.c.serialize()})`
    }
    keys() {
      return this.c.keys()
    }
    map(t) {
      return new aV(this.c.map(t))
    }
    negate() {
      return this.c
    }
  }
function OQ(i) {
  let t = null
  for (let e = 0, s = i.length; e < s; e++) {
    const r = i[e].substituteConstants()
    if (i[e] !== r && t === null) {
      t = []
      for (let a = 0; a < e; a++) t[a] = i[a]
    }
    t !== null && (t[e] = r)
  }
  return t === null ? i : t
}
var BQ = class ru {
    static create(t, e, s) {
      return ru.d(t, e, s)
    }
    constructor(t, e) {
      ;(this.expr = t), (this.c = e), (this.type = 6)
    }
    cmp(t) {
      if (t.type !== this.type) return this.type - t.type
      if (this.expr.length < t.expr.length) return -1
      if (this.expr.length > t.expr.length) return 1
      for (let e = 0, s = this.expr.length; e < s; e++) {
        const r = sh(this.expr[e], t.expr[e])
        if (r !== 0) return r
      }
      return 0
    }
    equals(t) {
      if (t.type === this.type) {
        if (this.expr.length !== t.expr.length) return !1
        for (let e = 0, s = this.expr.length; e < s; e++)
          if (!this.expr[e].equals(t.expr[e])) return !1
        return !0
      }
      return !1
    }
    substituteConstants() {
      const t = OQ(this.expr)
      return t === this.expr ? this : ru.create(t, this.c, !1)
    }
    evaluate(t) {
      for (let e = 0, s = this.expr.length; e < s; e++)
        if (!this.expr[e].evaluate(t)) return !1
      return !0
    }
    static d(t, e, s) {
      const r = []
      let a = !1
      for (const o of t)
        if (o) {
          if (o.type === 1) {
            a = !0
            continue
          }
          if (o.type === 0) return Wi.INSTANCE
          if (o.type === 6) {
            r.push(...o.expr)
            continue
          }
          r.push(o)
        }
      if (r.length === 0 && a) return os.INSTANCE
      if (r.length !== 0) {
        if (r.length === 1) return r[0]
        r.sort(sh)
        for (let o = 1; o < r.length; o++)
          r[o - 1].equals(r[o]) && (r.splice(o, 1), o--)
        if (r.length === 1) return r[0]
        for (; r.length > 1; ) {
          const o = r[r.length - 1]
          if (o.type !== 9) break
          r.pop()
          const c = r.pop(),
            l = r.length === 0,
            u = Dq.create(
              o.expr.map((d) => ru.create([d, c], null, s)),
              null,
              l,
            )
          u && (r.push(u), r.sort(sh))
        }
        if (r.length === 1) return r[0]
        if (s) {
          for (let o = 0; o < r.length; o++)
            for (let c = o + 1; c < r.length; c++)
              if (r[o].negate().equals(r[c])) return Wi.INSTANCE
          if (r.length === 1) return r[0]
        }
        return new ru(r, e)
      }
    }
    serialize() {
      return this.expr.map((t) => t.serialize()).join(" && ")
    }
    keys() {
      const t = []
      for (const e of this.expr) t.push(...e.keys())
      return t
    }
    map(t) {
      return new ru(
        this.expr.map((e) => e.map(t)),
        null,
      )
    }
    negate() {
      if (!this.c) {
        const t = []
        for (const e of this.expr) t.push(e.negate())
        this.c = Dq.create(t, this, !0)
      }
      return this.c
    }
  },
  Dq = class zo {
    static create(t, e, s) {
      return zo.d(t, e, s)
    }
    constructor(t, e) {
      ;(this.expr = t), (this.c = e), (this.type = 9)
    }
    cmp(t) {
      if (t.type !== this.type) return this.type - t.type
      if (this.expr.length < t.expr.length) return -1
      if (this.expr.length > t.expr.length) return 1
      for (let e = 0, s = this.expr.length; e < s; e++) {
        const r = sh(this.expr[e], t.expr[e])
        if (r !== 0) return r
      }
      return 0
    }
    equals(t) {
      if (t.type === this.type) {
        if (this.expr.length !== t.expr.length) return !1
        for (let e = 0, s = this.expr.length; e < s; e++)
          if (!this.expr[e].equals(t.expr[e])) return !1
        return !0
      }
      return !1
    }
    substituteConstants() {
      const t = OQ(this.expr)
      return t === this.expr ? this : zo.create(t, this.c, !1)
    }
    evaluate(t) {
      for (let e = 0, s = this.expr.length; e < s; e++)
        if (this.expr[e].evaluate(t)) return !0
      return !1
    }
    static d(t, e, s) {
      let r = [],
        a = !1
      if (t) {
        for (let o = 0, c = t.length; o < c; o++) {
          const l = t[o]
          if (l) {
            if (l.type === 0) {
              a = !0
              continue
            }
            if (l.type === 1) return os.INSTANCE
            if (l.type === 9) {
              r = r.concat(l.expr)
              continue
            }
            r.push(l)
          }
        }
        if (r.length === 0 && a) return Wi.INSTANCE
        r.sort(sh)
      }
      if (r.length !== 0) {
        if (r.length === 1) return r[0]
        for (let o = 1; o < r.length; o++)
          r[o - 1].equals(r[o]) && (r.splice(o, 1), o--)
        if (r.length === 1) return r[0]
        if (s) {
          for (let o = 0; o < r.length; o++)
            for (let c = o + 1; c < r.length; c++)
              if (r[o].negate().equals(r[c])) return os.INSTANCE
          if (r.length === 1) return r[0]
        }
        return new zo(r, e)
      }
    }
    serialize() {
      return this.expr.map((t) => t.serialize()).join(" || ")
    }
    keys() {
      const t = []
      for (const e of this.expr) t.push(...e.keys())
      return t
    }
    map(t) {
      return new zo(
        this.expr.map((e) => e.map(t)),
        null,
      )
    }
    negate() {
      if (!this.c) {
        const t = []
        for (const e of this.expr) t.push(e.negate())
        for (; t.length > 1; ) {
          const e = t.shift(),
            s = t.shift(),
            r = []
          for (const a of MQ(e))
            for (const o of MQ(s)) r.push(BQ.create([a, o], null, !1))
          t.unshift(zo.create(r, null, !1))
        }
        this.c = zo.create(t, this, !0)
      }
      return this.c
    }
  },
  W = class W3 extends rh {
    static {
      this.d = []
    }
    static all() {
      return W3.d.values()
    }
    constructor(t, e, s) {
      super(t, null),
        (this.f = e),
        typeof s == "object"
          ? W3.d.push({ ...s, key: t })
          : s !== !0 &&
            W3.d.push({
              key: t,
              description: s,
              type: e != null ? typeof e : void 0,
            })
    }
    bindTo(t) {
      return t.createKey(this.key, this.f)
    }
    getValue(t) {
      return t.getContextKeyValue(this.key)
    }
    toNegated() {
      return this.negate()
    }
    isEqualTo(t) {
      return $q.create(this.key, t)
    }
    notEqualsTo(t) {
      return xq.create(this.key, t)
    }
  },
  qQ = X("contextKeyService")
function UQ(i, t) {
  return i < t ? -1 : i > t ? 1 : 0
}
function Za(i, t, e, s) {
  return i < e ? -1 : i > e ? 1 : t < s ? -1 : t > s ? 1 : 0
}
function MQ(i) {
  return i.type === 9 ? i.expr : [i]
}
var Rt = X("logService"),
  $c = X("loggerService")
function Jwt(i) {
  return ps(i)
}
var vt
;(function (i) {
  ;(i[(i.Off = 0)] = "Off"),
    (i[(i.Trace = 1)] = "Trace"),
    (i[(i.Debug = 2)] = "Debug"),
    (i[(i.Info = 3)] = "Info"),
    (i[(i.Warning = 4)] = "Warning"),
    (i[(i.Error = 5)] = "Error")
})(vt || (vt = {}))
var Lwt = vt.Info
function Rwt(i, t, e) {
  switch (t) {
    case vt.Trace:
      i.trace(e)
      break
    case vt.Debug:
      i.debug(e)
      break
    case vt.Info:
      i.info(e)
      break
    case vt.Warning:
      i.warn(e)
      break
    case vt.Error:
      i.error(e)
      break
    case vt.Off:
      break
    default:
      throw new Error(`Invalid log level ${t}`)
  }
}
function xc(i, t = !1) {
  let e = ""
  for (let s = 0; s < i.length; s++) {
    let r = i[s]
    if ((r instanceof Error && (r = Zs(r, t)), typeof r == "object"))
      try {
        r = JSON.stringify(r)
      } catch {}
    e += (s > 0 ? " " : "") + r
  }
  return e
}
var HQ = class extends at {
    constructor() {
      super(...arguments),
        (this.b = Lwt),
        (this.c = this.D(new J())),
        (this.onDidChangeLogLevel = this.c.event)
    }
    setLevel(i) {
      this.b !== i && ((this.b = i), this.c.fire(this.b))
    }
    getLevel() {
      return this.b
    }
    f(i) {
      return this.b !== vt.Off && this.b <= i
    }
    g(i) {
      return this.B.isDisposed ? !1 : this.f(i)
    }
  },
  Fq = class extends HQ {
    constructor(i) {
      super(), (this.h = i)
    }
    f(i) {
      return this.h || super.f(i)
    }
    trace(i, ...t) {
      this.g(vt.Trace) && this.m(vt.Trace, xc([i, ...t], !0))
    }
    debug(i, ...t) {
      this.g(vt.Debug) && this.m(vt.Debug, xc([i, ...t]))
    }
    info(i, ...t) {
      this.g(vt.Info) && this.m(vt.Info, xc([i, ...t]))
    }
    warn(i, ...t) {
      this.g(vt.Warning) && this.m(vt.Warning, xc([i, ...t]))
    }
    error(i, ...t) {
      if (this.g(vt.Error))
        if (i instanceof Error) {
          const e = Array.prototype.slice.call(arguments)
          ;(e[0] = i.stack), this.m(vt.Error, xc(e))
        } else this.m(vt.Error, xc([i, ...t]))
    }
    flush() {}
  },
  Dwt = class extends HQ {
    constructor(i) {
      super(), (this.h = i), i.length && this.setLevel(i[0].getLevel())
    }
    setLevel(i) {
      for (const t of this.h) t.setLevel(i)
      super.setLevel(i)
    }
    trace(i, ...t) {
      for (const e of this.h) e.trace(i, ...t)
    }
    debug(i, ...t) {
      for (const e of this.h) e.debug(i, ...t)
    }
    info(i, ...t) {
      for (const e of this.h) e.info(i, ...t)
    }
    warn(i, ...t) {
      for (const e of this.h) e.warn(i, ...t)
    }
    error(i, ...t) {
      for (const e of this.h) e.error(i, ...t)
    }
    flush() {
      for (const i of this.h) i.flush()
    }
    dispose() {
      for (const i of this.h) i.dispose()
      super.dispose()
    }
  },
  Fwt = class extends at {
    constructor(i, t, e) {
      if (
        (super(),
        (this.h = i),
        (this.j = t),
        (this.b = new oi()),
        (this.c = this.D(new J())),
        (this.onDidChangeLoggers = this.c.event),
        (this.f = this.D(new J())),
        (this.onDidChangeLogLevel = this.f.event),
        (this.g = this.D(new J())),
        (this.onDidChangeVisibility = this.g.event),
        e)
      )
        for (const s of e) this.b.set(s.resource, { logger: void 0, info: s })
    }
    m(i) {
      return _t(i)
        ? [...this.b.values()].find((t) => t.info.id === i)
        : this.b.get(i)
    }
    getLogger(i) {
      return this.m(i)?.logger
    }
    createLogger(i, t) {
      const e = this.n(i),
        s = _t(i) ? i : (t?.id ?? nn(e.toString()).toString(16))
      let r = this.b.get(e)?.logger
      const a = t?.logLevel === "always" ? vt.Trace : t?.logLevel
      r || (r = this.q(e, a ?? this.getLogLevel(e) ?? this.h, { ...t, id: s }))
      const o = {
        logger: r,
        info: {
          resource: e,
          id: s,
          logLevel: a,
          name: t?.name,
          hidden: t?.hidden,
          extensionId: t?.extensionId,
          when: t?.when,
        },
      }
      return this.registerLogger(o.info), this.b.set(e, o), r
    }
    n(i) {
      return _t(i) ? He(this.j, `${i}.log`) : i
    }
    setLogLevel(i, t) {
      if (S.isUri(i)) {
        const e = i,
          s = t,
          r = this.b.get(e)
        r &&
          s !== r.info.logLevel &&
          ((r.info.logLevel = s === this.h ? void 0 : s),
          r.logger?.setLevel(s),
          this.b.set(r.info.resource, r),
          this.f.fire([e, s]))
      } else {
        this.h = i
        for (const [e, s] of this.b.entries())
          this.b.get(e)?.info.logLevel === void 0 && s.logger?.setLevel(this.h)
        this.f.fire(this.h)
      }
    }
    setVisibility(i, t) {
      const e = this.m(i)
      e &&
        t !== !e.info.hidden &&
        ((e.info.hidden = !t),
        this.b.set(e.info.resource, e),
        this.g.fire([e.info.resource, t]))
    }
    getLogLevel(i) {
      let t
      return i && (t = this.b.get(i)?.info.logLevel), t ?? this.h
    }
    registerLogger(i) {
      const t = this.b.get(i.resource)
      t
        ? t.info.hidden !== i.hidden &&
          this.setVisibility(i.resource, !i.hidden)
        : (this.b.set(i.resource, { info: i, logger: void 0 }),
          this.c.fire({ added: [i], removed: [] }))
    }
    deregisterLogger(i) {
      const t = this.b.get(i)
      t &&
        (t.logger && t.logger.dispose(),
        this.b.delete(i),
        this.c.fire({ added: [], removed: [t.info] }))
    }
    *getRegisteredLoggers() {
      for (const i of this.b.values()) yield i.info
    }
    getRegisteredLogger(i) {
      return this.b.get(i)?.info
    }
    dispose() {
      this.b.forEach((i) => i.logger?.dispose()),
        this.b.clear(),
        super.dispose()
    }
  }
function Awt(i) {
  switch (i) {
    case vt.Trace:
      return "trace"
    case vt.Debug:
      return "debug"
    case vt.Info:
      return "info"
    case vt.Warning:
      return "warn"
    case vt.Error:
      return "error"
    case vt.Off:
      return "off"
  }
}
function _wt(i) {
  switch (i) {
    case "trace":
      return vt.Trace
    case "debug":
      return vt.Debug
    case "info":
      return vt.Info
    case "warn":
      return vt.Warning
    case "error":
      return vt.Error
    case "critical":
      return vt.Error
    case "off":
      return vt.Off
  }
}
var rVt = new W("logLevel", Awt(vt.Info)),
  on = class {
    constructor(i, t = [], e = !1) {
      ;(this.ctor = i),
        (this.staticArguments = t),
        (this.supportsDelayedInstantiation = e)
    }
  },
  WQ = [],
  jQ
;(function (i) {
  ;(i[(i.Eager = 0)] = "Eager"), (i[(i.Delayed = 1)] = "Delayed")
})(jQ || (jQ = {}))
function Ut(i, t, e) {
  t instanceof on || (t = new on(t, [], !!e)), WQ.push([i, t])
}
function Owt() {
  return WQ
}
var Aq = class {
    constructor(...i) {
      this.a = new Map()
      for (const [t, e] of i) this.set(t, e)
    }
    set(i, t) {
      const e = this.a.get(i)
      return this.a.set(i, t), e
    }
    has(i) {
      return this.a.has(i)
    }
    get(i) {
      return this.a.get(i)
    }
  },
  ti = X("IExtHostInitDataService"),
  Bwt = class {
    constructor(i, t) {
      ;(this.key = i),
        (this.data = t),
        (this.incoming = new Map()),
        (this.outgoing = new Map())
    }
  },
  VQ = class {
    constructor(i) {
      ;(this.b = i), (this.a = new Map())
    }
    roots() {
      const i = []
      for (const t of this.a.values()) t.outgoing.size === 0 && i.push(t)
      return i
    }
    insertEdge(i, t) {
      const e = this.lookupOrInsertNode(i),
        s = this.lookupOrInsertNode(t)
      e.outgoing.set(s.key, s), s.incoming.set(e.key, e)
    }
    removeNode(i) {
      const t = this.b(i)
      this.a.delete(t)
      for (const e of this.a.values())
        e.outgoing.delete(t), e.incoming.delete(t)
    }
    lookupOrInsertNode(i) {
      const t = this.b(i)
      let e = this.a.get(t)
      return e || ((e = new Bwt(t, i)), this.a.set(t, e)), e
    }
    lookup(i) {
      return this.a.get(this.b(i))
    }
    isEmpty() {
      return this.a.size === 0
    }
    toString() {
      const i = []
      for (const [t, e] of this.a)
        i.push(`${t}
	(-> incoming)[${[...e.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...e.outgoing.keys()].join(",")}]
`)
      return i.join(`
`)
    }
    findCycleSlow() {
      for (const [i, t] of this.a) {
        const e = new Set([i]),
          s = this.c(t, e)
        if (s) return s
      }
    }
    c(i, t) {
      for (const [e, s] of i.outgoing) {
        if (t.has(e)) return [...t, e].join(" -> ")
        t.add(e)
        const r = this.c(s, t)
        if (r) return r
        t.delete(e)
      }
    }
  },
  qwt = !1,
  GQ = class extends Error {
    constructor(i, t) {
      super("cyclic dependency between services"),
        (this.message =
          `REASON: ${t}
` +
          (i.findCycleSlow() ??
            `UNABLE to detect cycle, dumping graph: 
${i.toString()}`))
    }
  },
  Uwt = class oV {
    constructor(t = new Aq(), e = !1, s, r = qwt) {
      ;(this.i = t),
        (this.j = e),
        (this.k = s),
        (this.l = r),
        (this.f = !1),
        (this.g = new Set()),
        (this.h = new Set()),
        (this.t = new Set()),
        this.i.set(t6, this),
        (this._globalGraph = r ? (s?._globalGraph ?? new VQ((a) => a)) : void 0)
    }
    dispose() {
      if (!this.f) {
        ;(this.f = !0), Hs(this.h), this.h.clear()
        for (const t of this.g) Ght(t) && t.dispose()
        this.g.clear()
      }
    }
    m() {
      if (this.f) throw new Error("InstantiationService has been disposed")
    }
    createChild(t, e) {
      this.m()
      const s = this,
        r = new (class extends oV {
          dispose() {
            s.h.delete(r), super.dispose()
          }
        })(t, this.j, this, this.l)
      return this.h.add(r), e?.add(r), r
    }
    invokeFunction(t, ...e) {
      this.m()
      const s = _q.traceInvocation(this.l, t)
      let r = !1
      try {
        return t(
          {
            get: (o) => {
              if (r)
                throw u7(
                  "service accessor is only valid during the invocation of its target method",
                )
              const c = this.s(o, s)
              if (!c) throw new Error(`[invokeFunction] unknown service '${o}'`)
              return c
            },
          },
          ...e,
        )
      } finally {
        ;(r = !0), s.stop()
      }
    }
    createInstance(t, ...e) {
      this.m()
      let s, r
      return (
        t instanceof on
          ? ((s = _q.traceCreation(this.l, t.ctor)),
            (r = this.o(t.ctor, t.staticArguments.concat(e), s)))
          : ((s = _q.traceCreation(this.l, t)), (r = this.o(t, e, s))),
        s.stop(),
        r
      )
    }
    o(t, e = [], s) {
      const r = tr.getServiceDependencies(t).sort((c, l) => c.index - l.index),
        a = []
      for (const c of r) {
        const l = this.s(c.id, s)
        l ||
          this.y(
            `[createInstance] ${t.name} depends on UNKNOWN service ${c.id}.`,
            !1,
          ),
          a.push(l)
      }
      const o = r.length > 0 ? r[0].index : e.length
      if (e.length !== o) {
        console.trace(
          `[createInstance] First service dependency of ${t.name} at position ${o + 1} conflicts with ${e.length} static arguments`,
        )
        const c = o - e.length
        c > 0 ? (e = e.concat(new Array(c))) : (e = e.slice(0, o))
      }
      return Reflect.construct(t, e.concat(a))
    }
    q(t, e) {
      if (this.i.get(t) instanceof on) this.i.set(t, e)
      else if (this.k) this.k.q(t, e)
      else throw new Error("illegalState - setting UNKNOWN service instance")
    }
    r(t) {
      const e = this.i.get(t)
      return !e && this.k ? this.k.r(t) : e
    }
    s(t, e) {
      this._globalGraph &&
        this.c &&
        this._globalGraph.insertEdge(this.c, String(t))
      const s = this.r(t)
      return s instanceof on
        ? this.u(t, s, e.branch(t, !0))
        : (e.branch(t, !1), s)
    }
    u(t, e, s) {
      if (this.t.has(t))
        throw new Error(
          `illegal state - RECURSIVELY instantiating service '${t}'`,
        )
      this.t.add(t)
      try {
        return this.v(t, e, s)
      } finally {
        this.t.delete(t)
      }
    }
    v(t, e, s) {
      const r = new VQ((l) => l.id.toString())
      let a = 0
      const o = [{ id: t, desc: e, _trace: s }],
        c = new Set()
      for (; o.length; ) {
        const l = o.pop()
        if (!c.has(String(l.id))) {
          if ((c.add(String(l.id)), r.lookupOrInsertNode(l), a++ > 1e4))
            throw new GQ(r, "cycle count more than 1000")
          for (const u of tr.getServiceDependencies(l.desc.ctor)) {
            const d = this.r(u.id)
            if (
              (d ||
                this.y(
                  `[createInstance] ${t} depends on ${u.id} which is NOT registered.`,
                  !0,
                ),
              this._globalGraph?.insertEdge(String(l.id), String(u.id)),
              d instanceof on)
            ) {
              const m = { id: u.id, desc: d, _trace: l._trace.branch(u.id, !0) }
              r.insertEdge(l, m), o.push(m)
            }
          }
        }
      }
      for (;;) {
        const l = r.roots()
        if (l.length === 0) {
          if (!r.isEmpty())
            throw new GQ(r, "no more roots but still nodes in the graph")
          break
        }
        for (const { data: u } of l) {
          if (this.r(u.id) instanceof on) {
            const m = this.w(
              u.id,
              u.desc.ctor,
              u.desc.staticArguments,
              u.desc.supportsDelayedInstantiation,
              u._trace,
            )
            this.q(u.id, m)
          }
          r.removeNode(u)
        }
      }
      return this.r(t)
    }
    w(t, e, s = [], r, a) {
      if (this.i.get(t) instanceof on) return this.x(t, e, s, r, a, this.g)
      if (this.k) return this.k.w(t, e, s, r, a)
      throw new Error(
        `illegalState - creating UNKNOWN service instance ${e.name}`,
      )
    }
    x(t, e, s = [], r, a, o) {
      if (r) {
        const c = new oV(void 0, this.j, this, this.l)
        c.c = String(t)
        const l = new Map(),
          u = new Bmt(() => {
            const d = c.o(e, s, a)
            for (const [m, f] of l) {
              const p = d[m]
              if (typeof p == "function")
                for (const v of f) v.disposable = p.apply(d, v.listener)
            }
            return l.clear(), o.add(d), d
          })
        return new Proxy(Object.create(null), {
          get(d, m) {
            if (
              !u.isInitialized &&
              typeof m == "string" &&
              (m.startsWith("onDid") || m.startsWith("onWill"))
            ) {
              let v = l.get(m)
              return (
                v || ((v = new Ru()), l.set(m, v)),
                (k, E, P) => {
                  if (u.isInitialized) return u.value[m](k, E, P)
                  {
                    const C = { listener: [k, E, P], disposable: void 0 },
                      R = v.push(C)
                    return et(() => {
                      R(), C.disposable?.dispose()
                    })
                  }
                }
              )
            }
            if (m in d) return d[m]
            const f = u.value
            let p = f[m]
            return typeof p != "function" || ((p = p.bind(f)), (d[m] = p)), p
          },
          set(d, m, f) {
            return (u.value[m] = f), !0
          },
          getPrototypeOf(d) {
            return e.prototype
          },
        })
      } else {
        const c = this.o(e, s, a)
        return o.add(c), c
      }
    }
    y(t, e) {
      if ((e && console.warn(t), this.j)) throw new Error(t)
    }
  },
  zQ
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Creation = 1)] = "Creation"),
    (i[(i.Invocation = 2)] = "Invocation"),
    (i[(i.Branch = 3)] = "Branch")
})(zQ || (zQ = {}))
var _q = class jr {
    static {
      this.all = new Set()
    }
    static {
      this.c = new (class extends jr {
        constructor() {
          super(0, null)
        }
        stop() {}
        branch() {
          return this
        }
      })()
    }
    static traceInvocation(t, e) {
      return t
        ? new jr(
            2,
            e.name ||
              new Error().stack
                .split(
                  `
`,
                )
                .slice(3, 4).join(`
`),
          )
        : jr.c
    }
    static traceCreation(t, e) {
      return t ? new jr(1, e.name) : jr.c
    }
    static {
      this.f = 0
    }
    constructor(t, e) {
      ;(this.type = t), (this.name = e), (this.g = Date.now()), (this.h = [])
    }
    branch(t, e) {
      const s = new jr(3, t.toString())
      return this.h.push([t, e, s]), s
    }
    stop() {
      const t = Date.now() - this.g
      jr.f += t
      let e = !1
      function s(a, o) {
        const c = [],
          l = new Array(a + 1).join("	")
        for (const [u, d, m] of o.h)
          if (d && m) {
            ;(e = !0), c.push(`${l}CREATES -> ${u}`)
            const f = s(a + 1, m)
            f && c.push(f)
          } else c.push(`${l}uses -> ${u}`)
        return c.join(`
`)
      }
      const r = [
        `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
        `${s(1, this)}`,
        `DONE, took ${t.toFixed(2)}ms (grand total ${jr.f.toFixed(2)}ms)`,
      ]
      ;(t > 2 || e) &&
        jr.all.add(
          r.join(`
`),
        )
    }
  },
  Ot = X("IExtHostRpcService"),
  Mwt = class {
    constructor(i) {
      ;(this.getProxy = i.getProxy.bind(i)),
        (this.set = i.set.bind(i)),
        (this.dispose = i.dispose.bind(i)),
        (this.assertRegistered = i.assertRegistered.bind(i)),
        (this.drain = i.drain.bind(i))
    }
  },
  ah = X("IURITransformerService"),
  Hwt = class {
    constructor(i) {
      i
        ? ((this.transformIncoming = i.transformIncoming.bind(i)),
          (this.transformOutgoing = i.transformOutgoing.bind(i)),
          (this.transformOutgoingURI = i.transformOutgoingURI.bind(i)),
          (this.transformOutgoingScheme = i.transformOutgoingScheme.bind(i)))
        : ((this.transformIncoming = (t) => t),
          (this.transformOutgoing = (t) => t),
          (this.transformOutgoingURI = (t) => t),
          (this.transformOutgoingScheme = (t) => t))
    }
  },
  Wwt = class {
    constructor() {
      ;(this.b = ""), (this.c = 0)
    }
    reset(i) {
      return (this.b = i), (this.c = 0), this
    }
    next() {
      return (this.c += 1), this
    }
    hasNext() {
      return this.c < this.b.length - 1
    }
    cmp(i) {
      const t = i.charCodeAt(0),
        e = this.b.charCodeAt(this.c)
      return t - e
    }
    value() {
      return this.b[this.c]
    }
  },
  jwt = class {
    constructor(i = !0) {
      this.e = i
    }
    reset(i) {
      return (this.b = i), (this.c = 0), (this.d = 0), this.next()
    }
    hasNext() {
      return this.d < this.b.length
    }
    next() {
      this.c = this.d
      let i = !0
      for (; this.d < this.b.length; this.d++)
        if (this.b.charCodeAt(this.d) === 46)
          if (i) this.c++
          else break
        else i = !1
      return this
    }
    cmp(i) {
      return this.e
        ? S7(i, this.b, 0, i.length, this.c, this.d)
        : Bu(i, this.b, 0, i.length, this.c, this.d)
    }
    value() {
      return this.b.substring(this.c, this.d)
    }
  },
  YQ = class {
    constructor(i = !0, t = !0) {
      ;(this.f = i), (this.g = t)
    }
    reset(i) {
      ;(this.d = 0), (this.e = 0), (this.b = i), (this.c = i.length)
      for (let t = i.length - 1; t >= 0; t--, this.c--) {
        const e = this.b.charCodeAt(t)
        if (!(e === 47 || (this.f && e === 92))) break
      }
      return this.next()
    }
    hasNext() {
      return this.e < this.c
    }
    next() {
      this.d = this.e
      let i = !0
      for (; this.e < this.c; this.e++) {
        const t = this.b.charCodeAt(this.e)
        if (t === 47 || (this.f && t === 92))
          if (i) this.d++
          else break
        else i = !1
      }
      return this
    }
    cmp(i) {
      return this.g
        ? S7(i, this.b, 0, i.length, this.d, this.e)
        : Bu(i, this.b, 0, i.length, this.d, this.e)
    }
    value() {
      return this.b.substring(this.d, this.e)
    }
  },
  QQ
;(function (i) {
  ;(i[(i.Scheme = 1)] = "Scheme"),
    (i[(i.Authority = 2)] = "Authority"),
    (i[(i.Path = 3)] = "Path"),
    (i[(i.Query = 4)] = "Query"),
    (i[(i.Fragment = 5)] = "Fragment")
})(QQ || (QQ = {}))
var XQ = class {
    constructor(i, t) {
      ;(this.f = i), (this.g = t), (this.d = []), (this.e = 0)
    }
    reset(i) {
      return (
        (this.c = i),
        (this.d = []),
        this.c.scheme && this.d.push(1),
        this.c.authority && this.d.push(2),
        this.c.path &&
          ((this.b = new YQ(!1, !this.f(i))),
          this.b.reset(i.path),
          this.b.value() && this.d.push(3)),
        this.g(i) ||
          (this.c.query && this.d.push(4), this.c.fragment && this.d.push(5)),
        (this.e = 0),
        this
      )
    }
    next() {
      return (
        this.d[this.e] === 3 && this.b.hasNext()
          ? this.b.next()
          : (this.e += 1),
        this
      )
    }
    hasNext() {
      return (
        (this.d[this.e] === 3 && this.b.hasNext()) || this.e < this.d.length - 1
      )
    }
    cmp(i) {
      if (this.d[this.e] === 1) return fG(i, this.c.scheme)
      if (this.d[this.e] === 2) return fG(i, this.c.authority)
      if (this.d[this.e] === 3) return this.b.cmp(i)
      if (this.d[this.e] === 4) return Ha(i, this.c.query)
      if (this.d[this.e] === 5) return Ha(i, this.c.fragment)
      throw new Error()
    }
    value() {
      if (this.d[this.e] === 1) return this.c.scheme
      if (this.d[this.e] === 2) return this.c.authority
      if (this.d[this.e] === 3) return this.b.value()
      if (this.d[this.e] === 4) return this.c.query
      if (this.d[this.e] === 5) return this.c.fragment
      throw new Error()
    }
  },
  i6 = class {
    constructor() {
      this.height = 1
    }
    isEmpty() {
      return !this.left && !this.mid && !this.right && !this.value
    }
    rotateLeft() {
      const i = this.right
      return (
        (this.right = i.left),
        (i.left = this),
        this.updateHeight(),
        i.updateHeight(),
        i
      )
    }
    rotateRight() {
      const i = this.left
      return (
        (this.left = i.right),
        (i.right = this),
        this.updateHeight(),
        i.updateHeight(),
        i
      )
    }
    updateHeight() {
      this.height = 1 + Math.max(this.heightLeft, this.heightRight)
    }
    balanceFactor() {
      return this.heightRight - this.heightLeft
    }
    get heightLeft() {
      return this.left?.height ?? 0
    }
    get heightRight() {
      return this.right?.height ?? 0
    }
  },
  KQ
;(function (i) {
  ;(i[(i.Left = -1)] = "Left"),
    (i[(i.Mid = 0)] = "Mid"),
    (i[(i.Right = 1)] = "Right")
})(KQ || (KQ = {}))
var ea = class ep {
  static forUris(t = () => !1, e = () => !1) {
    return new ep(new XQ(t, e))
  }
  static forPaths(t = !1) {
    return new ep(new YQ(void 0, !t))
  }
  static forStrings() {
    return new ep(new Wwt())
  }
  static forConfigKeys() {
    return new ep(new jwt())
  }
  constructor(t) {
    this.b = t
  }
  clear() {
    this.c = void 0
  }
  fill(t, e) {
    if (e) {
      const s = e.slice(0)
      RV(s)
      for (const r of s) this.set(r, t)
    } else {
      const s = t.slice(0)
      RV(s)
      for (const r of s) this.set(r[0], r[1])
    }
  }
  set(t, e) {
    const s = this.b.reset(t)
    let r
    this.c || ((this.c = new i6()), (this.c.segment = s.value()))
    const a = []
    for (r = this.c; ; ) {
      const c = s.cmp(r.segment)
      if (c > 0)
        r.left || ((r.left = new i6()), (r.left.segment = s.value())),
          a.push([-1, r]),
          (r = r.left)
      else if (c < 0)
        r.right || ((r.right = new i6()), (r.right.segment = s.value())),
          a.push([1, r]),
          (r = r.right)
      else if (s.hasNext())
        s.next(),
          r.mid || ((r.mid = new i6()), (r.mid.segment = s.value())),
          a.push([0, r]),
          (r = r.mid)
      else break
    }
    const o = r.value
    ;(r.value = e), (r.key = t)
    for (let c = a.length - 1; c >= 0; c--) {
      const l = a[c][1]
      l.updateHeight()
      const u = l.balanceFactor()
      if (u < -1 || u > 1) {
        const d = a[c][0],
          m = a[c + 1][0]
        if (d === 1 && m === 1) a[c][1] = l.rotateLeft()
        else if (d === -1 && m === -1) a[c][1] = l.rotateRight()
        else if (d === 1 && m === -1)
          (l.right = a[c + 1][1] = a[c + 1][1].rotateRight()),
            (a[c][1] = l.rotateLeft())
        else if (d === -1 && m === 1)
          (l.left = a[c + 1][1] = a[c + 1][1].rotateLeft()),
            (a[c][1] = l.rotateRight())
        else throw new Error()
        if (c > 0)
          switch (a[c - 1][0]) {
            case -1:
              a[c - 1][1].left = a[c][1]
              break
            case 1:
              a[c - 1][1].right = a[c][1]
              break
            case 0:
              a[c - 1][1].mid = a[c][1]
              break
          }
        else this.c = a[0][1]
      }
    }
    return o
  }
  get(t) {
    return this.d(t)?.value
  }
  d(t) {
    const e = this.b.reset(t)
    let s = this.c
    for (; s; ) {
      const r = e.cmp(s.segment)
      if (r > 0) s = s.left
      else if (r < 0) s = s.right
      else if (e.hasNext()) e.next(), (s = s.mid)
      else break
    }
    return s
  }
  has(t) {
    const e = this.d(t)
    return !(e?.value === void 0 && e?.mid === void 0)
  }
  delete(t) {
    return this.e(t, !1)
  }
  deleteSuperstr(t) {
    return this.e(t, !0)
  }
  e(t, e) {
    const s = this.b.reset(t),
      r = []
    let a = this.c
    for (; a; ) {
      const o = s.cmp(a.segment)
      if (o > 0) r.push([-1, a]), (a = a.left)
      else if (o < 0) r.push([1, a]), (a = a.right)
      else if (s.hasNext()) s.next(), r.push([0, a]), (a = a.mid)
      else break
    }
    if (a) {
      if (
        (e
          ? ((a.left = void 0),
            (a.mid = void 0),
            (a.right = void 0),
            (a.height = 1))
          : ((a.key = void 0), (a.value = void 0)),
        !a.mid && !a.value)
      )
        if (a.left && a.right) {
          const o = this.f(a.right)
          if (o.key) {
            const { key: c, value: l, segment: u } = o
            this.e(o.key, !1), (a.key = c), (a.value = l), (a.segment = u)
          }
        } else {
          const o = a.left ?? a.right
          if (r.length > 0) {
            const [c, l] = r[r.length - 1]
            switch (c) {
              case -1:
                l.left = o
                break
              case 0:
                l.mid = o
                break
              case 1:
                l.right = o
                break
            }
          } else this.c = o
        }
      for (let o = r.length - 1; o >= 0; o--) {
        const c = r[o][1]
        c.updateHeight()
        const l = c.balanceFactor()
        if (
          (l > 1
            ? (c.right.balanceFactor() >= 0 ||
                (c.right = c.right.rotateRight()),
              (r[o][1] = c.rotateLeft()))
            : l < -1 &&
              (c.left.balanceFactor() <= 0 || (c.left = c.left.rotateLeft()),
              (r[o][1] = c.rotateRight())),
          o > 0)
        )
          switch (r[o - 1][0]) {
            case -1:
              r[o - 1][1].left = r[o][1]
              break
            case 1:
              r[o - 1][1].right = r[o][1]
              break
            case 0:
              r[o - 1][1].mid = r[o][1]
              break
          }
        else this.c = r[0][1]
      }
    }
  }
  f(t) {
    for (; t.left; ) t = t.left
    return t
  }
  findSubstr(t) {
    const e = this.b.reset(t)
    let s = this.c,
      r
    for (; s; ) {
      const a = e.cmp(s.segment)
      if (a > 0) s = s.left
      else if (a < 0) s = s.right
      else if (e.hasNext()) e.next(), (r = s.value || r), (s = s.mid)
      else break
    }
    return (s && s.value) || r
  }
  findSuperstr(t) {
    return this.g(t, !1)
  }
  g(t, e) {
    const s = this.b.reset(t)
    let r = this.c
    for (; r; ) {
      const a = s.cmp(r.segment)
      if (a > 0) r = r.left
      else if (a < 0) r = r.right
      else if (s.hasNext()) s.next(), (r = r.mid)
      else return r.mid ? this.h(r.mid) : e ? r.value : void 0
    }
  }
  hasElementOrSubtree(t) {
    return this.g(t, !0) !== void 0
  }
  forEach(t) {
    for (const [e, s] of this) t(s, e)
  }
  *[Symbol.iterator]() {
    yield* this.h(this.c)
  }
  h(t) {
    const e = []
    return this.j(t, e), e[Symbol.iterator]()
  }
  j(t, e) {
    t &&
      (t.left && this.j(t.left, e),
      t.value && e.push([t.key, t.value]),
      t.mid && this.j(t.mid, e),
      t.right && this.j(t.right, e))
  }
  _isBalanced() {
    const t = (e) => {
      if (!e) return !0
      const s = e.balanceFactor()
      return s < -1 || s > 1 ? !1 : t(e.left) && t(e.right)
    }
    return t(this.c)
  }
}
function Vwt(i, t, e) {
  return Math.min(Math.max(i, t), e)
}
var Gwt = class {
    constructor() {
      this.a = 0
    }
    getNext() {
      return this.a++
    }
  },
  zwt = class {
    constructor() {
      ;(this.a = 1), (this.b = 0)
    }
    update(i) {
      return (this.b = this.b + (i - this.b) / this.a), (this.a += 1), this.b
    }
    get value() {
      return this.b
    }
  },
  oh
;(function (i) {
  ;(i[(i.Ignore = 0)] = "Ignore"),
    (i[(i.Info = 1)] = "Info"),
    (i[(i.Warning = 2)] = "Warning"),
    (i[(i.Error = 3)] = "Error"),
    (i[(i.AI = 4)] = "AI")
})(oh || (oh = {})),
  (function (i) {
    const t = "error",
      e = "warning",
      s = "warn",
      r = "info",
      a = "ignore"
    function o(l) {
      return l
        ? Ws(t, l)
          ? i.Error
          : Ws(e, l) || Ws(s, l)
            ? i.Warning
            : Ws(r, l)
              ? i.Info
              : i.Ignore
        : i.Ignore
    }
    i.fromValue = o
    function c(l) {
      switch (l) {
        case i.Error:
          return t
        case i.Warning:
          return e
        case i.Info:
          return r
        default:
          return a
      }
    }
    i.toString = c
  })(oh || (oh = {}))
var Le = oh,
  Ywt = Le,
  nVt = X("notificationService"),
  ZQ
;(function (i) {
  ;(i[(i.DEFAULT = 0)] = "DEFAULT"),
    (i[(i.SILENT = 1)] = "SILENT"),
    (i[(i.URGENT = 2)] = "URGENT")
})(ZQ || (ZQ = {}))
var tX
;(function (i) {
  ;(i[(i.WORKSPACE = 0)] = "WORKSPACE"),
    (i[(i.PROFILE = 1)] = "PROFILE"),
    (i[(i.APPLICATION = 2)] = "APPLICATION")
})(tX || (tX = {}))
var eX
;(function (i) {
  ;(i[(i.OFF = 0)] = "OFF"), (i[(i.ERROR = 1)] = "ERROR")
})(eX || (eX = {}))
var s6 = X("contextService")
function Qwt(i) {
  const t = i
  return typeof t?.id == "string" && S.isUri(t.uri)
}
function Xwt(i) {
  const t = i
  return typeof t?.id == "string" && S.isUri(t.configPath)
}
var iX
;(function (i) {
  ;(i[(i.EMPTY = 1)] = "EMPTY"),
    (i[(i.FOLDER = 2)] = "FOLDER"),
    (i[(i.WORKSPACE = 3)] = "WORKSPACE")
})(iX || (iX = {}))
var Kwt = class {
    constructor(i, t, e, s, r) {
      ;(this.h = i),
        (this.j = e),
        (this.k = s),
        (this.l = r),
        (this.c = ea.forUris(this.l, () => !0)),
        (this.folders = t)
    }
    update(i) {
      ;(this.h = i.id),
        (this.k = i.configuration),
        (this.j = i.transient),
        (this.l = i.l),
        (this.folders = i.folders)
    }
    get folders() {
      return this.g
    }
    set folders(i) {
      ;(this.g = i), this.n()
    }
    get id() {
      return this.h
    }
    get transient() {
      return this.j
    }
    get configuration() {
      return this.k
    }
    set configuration(i) {
      this.k = i
    }
    getFolder(i) {
      return (i && this.c.findSubstr(i)) || null
    }
    n() {
      this.c = ea.forUris(this.l, () => !0)
      for (const i of this.folders) this.c.set(i.uri, i)
    }
    toJSON() {
      return {
        id: this.id,
        folders: this.folders,
        transient: this.transient,
        configuration: this.configuration,
      }
    }
  },
  Oq = class {
    constructor(i, t) {
      ;(this.raw = t),
        (this.uri = i.uri),
        (this.index = i.index),
        (this.name = i.name)
    }
    toResource(i) {
      return He(this.uri, i)
    }
    toJSON() {
      return { uri: this.uri, name: this.name, index: this.index }
    }
  }
function Bq(i) {
  return new Oq({ uri: i, index: 0, name: L7(i) }, { uri: i.toString() })
}
var sX = "code-workspace",
  Zwt = `.${sX}`,
  aVt = [{ name: g(2540, null), extensions: [sX] }]
function tyt(i) {
  return (typeof i == "string" ? S_(i) : Pmt(i)) === Zwt
}
var eyt = class {
    constructor() {
      ;(this.a = new Set(Object.keys(G))),
        (this.b = new Map()),
        (this.extUri = new Uu((i) => {
          const t = this.b.get(i.scheme)
          return !(t === void 0 || t & 1024)
        }))
    }
    $acceptProviderInfos(i, t) {
      t === null ? this.b.delete(i.scheme) : this.b.set(i.scheme, t)
    }
    isFreeScheme(i) {
      return !this.b.has(i) && !this.a.has(i)
    }
    getCapabilities(i) {
      return this.b.get(i)
    }
  },
  Nc = X("IExtHostFileSystemInfo"),
  qq = Object.freeze({
    create: (i) =>
      ac(i.map((t) => t.toString())).join(`\r
`),
    split: (i) =>
      i.split(`\r
`),
    parse: (i) => qq.split(i).filter((t) => !t.startsWith("#")),
  }),
  oVt = new Uint32Array(10),
  rX
;(function (i) {
  ;(i[(i.InitialConsonant = 4352)] = "InitialConsonant"),
    (i[(i.Vowel = 4449)] = "Vowel"),
    (i[(i.FinalConsonant = 4520)] = "FinalConsonant"),
    (i[(i.CompatibilityJamo = 12593)] = "CompatibilityJamo")
})(rX || (rX = {}))
var nX
;(function (i) {
  ;(i[(i.NUL = 0)] = "NUL"),
    (i[(i.A = 65)] = "A"),
    (i[(i.B = 66)] = "B"),
    (i[(i.C = 67)] = "C"),
    (i[(i.D = 68)] = "D"),
    (i[(i.E = 69)] = "E"),
    (i[(i.F = 70)] = "F"),
    (i[(i.G = 71)] = "G"),
    (i[(i.H = 72)] = "H"),
    (i[(i.I = 73)] = "I"),
    (i[(i.J = 74)] = "J"),
    (i[(i.K = 75)] = "K"),
    (i[(i.L = 76)] = "L"),
    (i[(i.M = 77)] = "M"),
    (i[(i.N = 78)] = "N"),
    (i[(i.O = 79)] = "O"),
    (i[(i.P = 80)] = "P"),
    (i[(i.Q = 81)] = "Q"),
    (i[(i.R = 82)] = "R"),
    (i[(i.S = 83)] = "S"),
    (i[(i.T = 84)] = "T"),
    (i[(i.U = 85)] = "U"),
    (i[(i.V = 86)] = "V"),
    (i[(i.W = 87)] = "W"),
    (i[(i.X = 88)] = "X"),
    (i[(i.Y = 89)] = "Y"),
    (i[(i.Z = 90)] = "Z"),
    (i[(i.a = 97)] = "a"),
    (i[(i.b = 98)] = "b"),
    (i[(i.c = 99)] = "c"),
    (i[(i.d = 100)] = "d"),
    (i[(i.e = 101)] = "e"),
    (i[(i.f = 102)] = "f"),
    (i[(i.g = 103)] = "g"),
    (i[(i.h = 104)] = "h"),
    (i[(i.i = 105)] = "i"),
    (i[(i.j = 106)] = "j"),
    (i[(i.k = 107)] = "k"),
    (i[(i.l = 108)] = "l"),
    (i[(i.m = 109)] = "m"),
    (i[(i.n = 110)] = "n"),
    (i[(i.o = 111)] = "o"),
    (i[(i.p = 112)] = "p"),
    (i[(i.q = 113)] = "q"),
    (i[(i.r = 114)] = "r"),
    (i[(i.s = 115)] = "s"),
    (i[(i.t = 116)] = "t"),
    (i[(i.u = 117)] = "u"),
    (i[(i.v = 118)] = "v"),
    (i[(i.w = 119)] = "w"),
    (i[(i.x = 120)] = "x"),
    (i[(i.y = 121)] = "y"),
    (i[(i.z = 122)] = "z")
})(nX || (nX = {}))
var aX
;(function (i) {
  ;(i[(i.fa = 24934)] = "fa"),
    (i[(i.fg = 26470)] = "fg"),
    (i[(i.fq = 29030)] = "fq"),
    (i[(i.fr = 29286)] = "fr"),
    (i[(i.ft = 29798)] = "ft"),
    (i[(i.fv = 30310)] = "fv"),
    (i[(i.fx = 30822)] = "fx"),
    (i[(i.hk = 27496)] = "hk"),
    (i[(i.hl = 27752)] = "hl"),
    (i[(i.ho = 28520)] = "ho"),
    (i[(i.ml = 27757)] = "ml"),
    (i[(i.nj = 27246)] = "nj"),
    (i[(i.nl = 27758)] = "nl"),
    (i[(i.np = 28782)] = "np"),
    (i[(i.qt = 29809)] = "qt"),
    (i[(i.rt = 29810)] = "rt"),
    (i[(i.sg = 26483)] = "sg"),
    (i[(i.sw = 30579)] = "sw")
})(aX || (aX = {}))
var cVt = new Uint8Array([
    114, 82, 115, 101, 69, 102, 97, 113, 81, 116, 84, 100, 119, 87, 99, 122,
    120, 118, 103,
  ]),
  lVt = new Uint16Array([
    107, 111, 105, 79, 106, 112, 117, 80, 104, 27496, 28520, 27752, 121, 110,
    27246, 28782, 27758, 98, 109, 27757, 108,
  ]),
  uVt = new Uint16Array([
    114, 82, 29810, 115, 30579, 26483, 101, 102, 29286, 24934, 29030, 29798,
    30822, 30310, 26470, 97, 113, 29809, 116, 84, 100, 119, 99, 122, 120, 118,
    103,
  ]),
  hVt = new Uint16Array([
    114, 82, 29810, 115, 30579, 26483, 101, 69, 102, 29286, 24934, 29030, 29798,
    30822, 30310, 26470, 97, 113, 81, 29809, 116, 84, 100, 119, 87, 99, 122,
    120, 118, 103, 107, 111, 105, 79, 106, 112, 117, 80, 104, 27496, 28520,
    27752, 121, 110, 27246, 28782, 27758, 98, 109, 27757, 108,
  ])
function oX(...i) {
  return function (t, e) {
    for (let s = 0, r = i.length; s < r; s++) {
      const a = i[s](t, e)
      if (a) return a
    }
    return null
  }
}
var dVt = cX.bind(void 0, !1),
  Uq = cX.bind(void 0, !0)
function cX(i, t, e) {
  if (!e || e.length < t.length) return null
  let s
  return (
    i ? (s = I_(e, t)) : (s = e.indexOf(t) === 0),
    s ? (t.length > 0 ? [{ start: 0, end: t.length }] : []) : null
  )
}
function iyt(i, t) {
  const e = t.toLowerCase().indexOf(i.toLowerCase())
  return e === -1 ? null : [{ start: e, end: e + i.length }]
}
function syt(i, t) {
  return Mq(i.toLowerCase(), t.toLowerCase(), 0, 0)
}
function Mq(i, t, e, s) {
  if (e === i.length) return []
  if (s === t.length) return null
  if (i[e] === t[s]) {
    let r = null
    return (r = Mq(i, t, e + 1, s + 1)) ? uX({ start: s, end: s + 1 }, r) : null
  }
  return Mq(i, t, e, s + 1)
}
function Hq(i) {
  return 97 <= i && i <= 122
}
function ch(i) {
  return 65 <= i && i <= 90
}
function Wq(i) {
  return 48 <= i && i <= 57
}
function ryt(i) {
  return i === 32 || i === 9 || i === 10 || i === 13
}
var nyt = new Set()
"()[]{}<>`'\"-/;:,.?!".split("").forEach((i) => nyt.add(i.charCodeAt(0)))
function lX(i) {
  return Hq(i) || ch(i) || Wq(i)
}
function uX(i, t) {
  return (
    t.length === 0
      ? (t = [i])
      : i.end === t[0].start
        ? (t[0].start = i.start)
        : t.unshift(i),
    t
  )
}
function hX(i, t) {
  for (let e = t; e < i.length; e++) {
    const s = i.charCodeAt(e)
    if (ch(s) || Wq(s) || (e > 0 && !lX(i.charCodeAt(e - 1)))) return e
  }
  return i.length
}
function jq(i, t, e, s) {
  if (e === i.length) return []
  if (s === t.length) return null
  if (i[e] !== t[s].toLowerCase()) return null
  {
    let r = null,
      a = s + 1
    for (r = jq(i, t, e + 1, s + 1); !r && (a = hX(t, a)) < t.length; )
      (r = jq(i, t, e + 1, a)), a++
    return r === null ? null : uX({ start: s, end: s + 1 }, r)
  }
}
function ayt(i) {
  let t = 0,
    e = 0,
    s = 0,
    r = 0,
    a = 0
  for (let d = 0; d < i.length; d++)
    (a = i.charCodeAt(d)),
      ch(a) && t++,
      Hq(a) && e++,
      lX(a) && s++,
      Wq(a) && r++
  const o = t / i.length,
    c = e / i.length,
    l = s / i.length,
    u = r / i.length
  return {
    upperPercent: o,
    lowerPercent: c,
    alphaPercent: l,
    numericPercent: u,
  }
}
function oyt(i) {
  const { upperPercent: t, lowerPercent: e } = i
  return e === 0 && t > 0.6
}
function cyt(i) {
  const {
    upperPercent: t,
    lowerPercent: e,
    alphaPercent: s,
    numericPercent: r,
  } = i
  return e > 0.2 && t < 0.8 && s > 0.6 && r < 0.2
}
function lyt(i) {
  let t = 0,
    e = 0,
    s = 0,
    r = 0
  for (let a = 0; a < i.length; a++)
    (s = i.charCodeAt(a)), ch(s) && t++, Hq(s) && e++, ryt(s) && r++
  return (t === 0 || e === 0) && r === 0 ? i.length <= 30 : t <= 5
}
function dX(i, t) {
  if (!t || ((t = t.trim()), t.length === 0) || !lyt(i)) return null
  t.length > 60 && (t = t.substring(0, 60))
  const e = ayt(t)
  if (!cyt(e)) {
    if (!oyt(e)) return null
    t = t.toLowerCase()
  }
  let s = null,
    r = 0
  for (i = i.toLowerCase(); r < t.length && (s = jq(i, t, 0, r)) === null; )
    r = hX(t, r + 1)
  return s
}
var mVt = oX(Uq, dX, iyt),
  fVt = oX(Uq, dX, syt),
  pVt = new Ju(1e4),
  r6 = 128
function Vq() {
  const i = [],
    t = []
  for (let e = 0; e <= r6; e++) t[e] = 0
  for (let e = 0; e <= r6; e++) i.push(t.slice(0))
  return i
}
function mX(i) {
  const t = []
  for (let e = 0; e <= i; e++) t[e] = 0
  return t
}
var gVt = mX(2 * r6),
  vVt = mX(2 * r6),
  wVt = Vq(),
  yVt = Vq(),
  bVt = Vq(),
  fX
;(function (i) {
  ;(i[(i.Diag = 1)] = "Diag"),
    (i[(i.Left = 2)] = "Left"),
    (i[(i.LeftLeft = 3)] = "LeftLeft")
})(fX || (fX = {}))
var pX
;(function (i) {
  i.Default = [-100, 0]
  function t(e) {
    return !e || (e.length === 2 && e[0] === -100 && e[1] === 0)
  }
  i.isDefault = t
})(pX || (pX = {}))
var TVt = class {
    static {
      this.default = { boostFullMatch: !0, firstMatchCanBeWeak: !1 }
    }
    constructor(i, t) {
      ;(this.firstMatchCanBeWeak = i), (this.boostFullMatch = t)
    }
  },
  Gq = Object.create(null)
function w(i, t) {
  if (_t(t)) {
    const e = Gq[t]
    if (e === void 0)
      throw new Error(`${i} references an unknown codicon: ${t}`)
    t = e
  }
  return (Gq[i] = t), { id: i }
}
function uyt() {
  return Gq
}
var hyt = {
    semantic: w("semantic", 62e3),
    githubCopilot: w("github-copilot", 62001),
    plusCircle: w("plus-circle", 62002),
    smileySad: w("smiley-sad", 62003),
    smileyHappy: w("smiley-happy", 62004),
    smileyMedium: w("smiley-medium", 62005),
    sparkleStrikethrough: w("sparkle-strikethrough", 62006),
    keyPlusSparkle: w("key-plus-sparkle", 62007),
    paperclip: w("paperclip", 60500),
    atSign: w("at-sign", 60501),
    image: w("image", 60502),
    logo: w("logo", 60503),
    sparkleTwo: w("sparkle-two", 60504),
    logoSlash: w("logo-slash", 60505),
    add: w("add", 6e4),
    plus: w("plus", 6e4),
    gistNew: w("gist-new", 6e4),
    repoCreate: w("repo-create", 6e4),
    lightbulb: w("lightbulb", 60001),
    lightBulb: w("light-bulb", 60001),
    repo: w("repo", 60002),
    repoDelete: w("repo-delete", 60002),
    gistFork: w("gist-fork", 60003),
    repoForked: w("repo-forked", 60003),
    gitPullRequest: w("git-pull-request", 60004),
    gitPullRequestAbandoned: w("git-pull-request-abandoned", 60004),
    recordKeys: w("record-keys", 60005),
    keyboard: w("keyboard", 60005),
    tag: w("tag", 60006),
    gitPullRequestLabel: w("git-pull-request-label", 60006),
    tagAdd: w("tag-add", 60006),
    tagRemove: w("tag-remove", 60006),
    person: w("person", 60007),
    personFollow: w("person-follow", 60007),
    personOutline: w("person-outline", 60007),
    personFilled: w("person-filled", 60007),
    gitBranch: w("git-branch", 60008),
    gitBranchCreate: w("git-branch-create", 60008),
    gitBranchDelete: w("git-branch-delete", 60008),
    sourceControl: w("source-control", 60008),
    mirror: w("mirror", 60009),
    mirrorPublic: w("mirror-public", 60009),
    star: w("star", 60010),
    starAdd: w("star-add", 60010),
    starDelete: w("star-delete", 60010),
    starEmpty: w("star-empty", 60010),
    comment: w("comment", 60011),
    commentAdd: w("comment-add", 60011),
    alert: w("alert", 60012),
    warning: w("warning", 60012),
    search: w("search", 60013),
    searchSave: w("search-save", 60013),
    logOut: w("log-out", 60014),
    signOut: w("sign-out", 60014),
    logIn: w("log-in", 60015),
    signIn: w("sign-in", 60015),
    eye: w("eye", 60016),
    eyeUnwatch: w("eye-unwatch", 60016),
    eyeWatch: w("eye-watch", 60016),
    circleFilled: w("circle-filled", 60017),
    primitiveDot: w("primitive-dot", 60017),
    closeDirty: w("close-dirty", 60017),
    debugBreakpoint: w("debug-breakpoint", 60017),
    debugBreakpointDisabled: w("debug-breakpoint-disabled", 60017),
    debugHint: w("debug-hint", 60017),
    terminalDecorationSuccess: w("terminal-decoration-success", 60017),
    primitiveSquare: w("primitive-square", 60018),
    edit: w("edit", 60019),
    pencil: w("pencil", 60019),
    info: w("info", 60020),
    issueOpened: w("issue-opened", 60020),
    gistPrivate: w("gist-private", 60021),
    gitForkPrivate: w("git-fork-private", 60021),
    lock: w("lock", 60021),
    mirrorPrivate: w("mirror-private", 60021),
    close: w("close", 60022),
    removeClose: w("remove-close", 60022),
    x: w("x", 60022),
    repoSync: w("repo-sync", 60023),
    sync: w("sync", 60023),
    clone: w("clone", 60024),
    desktopDownload: w("desktop-download", 60024),
    beaker: w("beaker", 60025),
    microscope: w("microscope", 60025),
    vm: w("vm", 60026),
    deviceDesktop: w("device-desktop", 60026),
    file: w("file", 60027),
    fileText: w("file-text", 60027),
    more: w("more", 60028),
    ellipsis: w("ellipsis", 60028),
    kebabHorizontal: w("kebab-horizontal", 60028),
    mailReply: w("mail-reply", 60029),
    reply: w("reply", 60029),
    organization: w("organization", 60030),
    organizationFilled: w("organization-filled", 60030),
    organizationOutline: w("organization-outline", 60030),
    newFile: w("new-file", 60031),
    fileAdd: w("file-add", 60031),
    newFolder: w("new-folder", 60032),
    fileDirectoryCreate: w("file-directory-create", 60032),
    trash: w("trash", 60033),
    trashcan: w("trashcan", 60033),
    history: w("history", 60034),
    clock: w("clock", 60034),
    folder: w("folder", 60035),
    fileDirectory: w("file-directory", 60035),
    symbolFolder: w("symbol-folder", 60035),
    logoGithub: w("logo-github", 60036),
    markGithub: w("mark-github", 60036),
    github: w("github", 60036),
    terminal: w("terminal", 60037),
    console: w("console", 60037),
    repl: w("repl", 60037),
    zap: w("zap", 60038),
    symbolEvent: w("symbol-event", 60038),
    error: w("error", 60039),
    stop: w("stop", 60039),
    variable: w("variable", 60040),
    symbolVariable: w("symbol-variable", 60040),
    array: w("array", 60042),
    symbolArray: w("symbol-array", 60042),
    symbolModule: w("symbol-module", 60043),
    symbolPackage: w("symbol-package", 60043),
    symbolNamespace: w("symbol-namespace", 60043),
    symbolObject: w("symbol-object", 60043),
    symbolMethod: w("symbol-method", 60044),
    symbolFunction: w("symbol-function", 60044),
    symbolConstructor: w("symbol-constructor", 60044),
    symbolBoolean: w("symbol-boolean", 60047),
    symbolNull: w("symbol-null", 60047),
    symbolNumeric: w("symbol-numeric", 60048),
    symbolNumber: w("symbol-number", 60048),
    symbolStructure: w("symbol-structure", 60049),
    symbolStruct: w("symbol-struct", 60049),
    symbolParameter: w("symbol-parameter", 60050),
    symbolTypeParameter: w("symbol-type-parameter", 60050),
    symbolKey: w("symbol-key", 60051),
    symbolText: w("symbol-text", 60051),
    symbolReference: w("symbol-reference", 60052),
    goToFile: w("go-to-file", 60052),
    symbolEnum: w("symbol-enum", 60053),
    symbolValue: w("symbol-value", 60053),
    symbolRuler: w("symbol-ruler", 60054),
    symbolUnit: w("symbol-unit", 60054),
    activateBreakpoints: w("activate-breakpoints", 60055),
    archive: w("archive", 60056),
    arrowBoth: w("arrow-both", 60057),
    arrowDown: w("arrow-down", 60058),
    arrowLeft: w("arrow-left", 60059),
    arrowRight: w("arrow-right", 60060),
    arrowSmallDown: w("arrow-small-down", 60061),
    arrowSmallLeft: w("arrow-small-left", 60062),
    arrowSmallRight: w("arrow-small-right", 60063),
    arrowSmallUp: w("arrow-small-up", 60064),
    arrowUp: w("arrow-up", 60065),
    bell: w("bell", 60066),
    bold: w("bold", 60067),
    book: w("book", 60068),
    bookmark: w("bookmark", 60069),
    debugBreakpointConditionalUnverified: w(
      "debug-breakpoint-conditional-unverified",
      60070,
    ),
    debugBreakpointConditional: w("debug-breakpoint-conditional", 60071),
    debugBreakpointConditionalDisabled: w(
      "debug-breakpoint-conditional-disabled",
      60071,
    ),
    debugBreakpointDataUnverified: w("debug-breakpoint-data-unverified", 60072),
    debugBreakpointData: w("debug-breakpoint-data", 60073),
    debugBreakpointDataDisabled: w("debug-breakpoint-data-disabled", 60073),
    debugBreakpointLogUnverified: w("debug-breakpoint-log-unverified", 60074),
    debugBreakpointLog: w("debug-breakpoint-log", 60075),
    debugBreakpointLogDisabled: w("debug-breakpoint-log-disabled", 60075),
    briefcase: w("briefcase", 60076),
    broadcast: w("broadcast", 60077),
    browser: w("browser", 60078),
    bug: w("bug", 60079),
    calendar: w("calendar", 60080),
    caseSensitive: w("case-sensitive", 60081),
    check: w("check", 60082),
    checklist: w("checklist", 60083),
    chevronDown: w("chevron-down", 60084),
    chevronLeft: w("chevron-left", 60085),
    chevronRight: w("chevron-right", 60086),
    chevronUp: w("chevron-up", 60087),
    chromeClose: w("chrome-close", 60088),
    chromeMaximize: w("chrome-maximize", 60089),
    chromeMinimize: w("chrome-minimize", 60090),
    chromeRestore: w("chrome-restore", 60091),
    circleOutline: w("circle-outline", 60092),
    circle: w("circle", 60092),
    debugBreakpointUnverified: w("debug-breakpoint-unverified", 60092),
    terminalDecorationIncomplete: w("terminal-decoration-incomplete", 60092),
    circleSlash: w("circle-slash", 60093),
    circuitBoard: w("circuit-board", 60094),
    clearAll: w("clear-all", 60095),
    clippy: w("clippy", 60096),
    closeAll: w("close-all", 60097),
    cloudDownload: w("cloud-download", 60098),
    cloudUpload: w("cloud-upload", 60099),
    code: w("code", 60100),
    collapseAll: w("collapse-all", 60101),
    colorMode: w("color-mode", 60102),
    commentDiscussion: w("comment-discussion", 60103),
    creditCard: w("credit-card", 60105),
    dash: w("dash", 60108),
    dashboard: w("dashboard", 60109),
    database: w("database", 60110),
    debugContinue: w("debug-continue", 60111),
    debugDisconnect: w("debug-disconnect", 60112),
    debugPause: w("debug-pause", 60113),
    debugRestart: w("debug-restart", 60114),
    debugStart: w("debug-start", 60115),
    debugStepInto: w("debug-step-into", 60116),
    debugStepOut: w("debug-step-out", 60117),
    debugStepOver: w("debug-step-over", 60118),
    debugStop: w("debug-stop", 60119),
    debug: w("debug", 60120),
    deviceCameraVideo: w("device-camera-video", 60121),
    deviceCamera: w("device-camera", 60122),
    deviceMobile: w("device-mobile", 60123),
    diffAdded: w("diff-added", 60124),
    diffIgnored: w("diff-ignored", 60125),
    diffModified: w("diff-modified", 60126),
    diffRemoved: w("diff-removed", 60127),
    diffRenamed: w("diff-renamed", 60128),
    diff: w("diff", 60129),
    diffSidebyside: w("diff-sidebyside", 60129),
    discard: w("discard", 60130),
    editorLayout: w("editor-layout", 60131),
    emptyWindow: w("empty-window", 60132),
    exclude: w("exclude", 60133),
    extensions: w("extensions", 60134),
    eyeClosed: w("eye-closed", 60135),
    fileBinary: w("file-binary", 60136),
    fileCode: w("file-code", 60137),
    fileMedia: w("file-media", 60138),
    filePdf: w("file-pdf", 60139),
    fileSubmodule: w("file-submodule", 60140),
    fileSymlinkDirectory: w("file-symlink-directory", 60141),
    fileSymlinkFile: w("file-symlink-file", 60142),
    fileZip: w("file-zip", 60143),
    files: w("files", 60144),
    filter: w("filter", 60145),
    flame: w("flame", 60146),
    foldDown: w("fold-down", 60147),
    foldUp: w("fold-up", 60148),
    fold: w("fold", 60149),
    folderActive: w("folder-active", 60150),
    folderOpened: w("folder-opened", 60151),
    gear: w("gear", 60152),
    gift: w("gift", 60153),
    gistSecret: w("gist-secret", 60154),
    gist: w("gist", 60155),
    gitCommit: w("git-commit", 60156),
    gitCompare: w("git-compare", 60157),
    compareChanges: w("compare-changes", 60157),
    gitMerge: w("git-merge", 60158),
    githubAction: w("github-action", 60159),
    githubAlt: w("github-alt", 60160),
    globe: w("globe", 60161),
    grabber: w("grabber", 60162),
    graph: w("graph", 60163),
    gripper: w("gripper", 60164),
    heart: w("heart", 60165),
    home: w("home", 60166),
    horizontalRule: w("horizontal-rule", 60167),
    hubot: w("hubot", 60168),
    inbox: w("inbox", 60169),
    issueReopened: w("issue-reopened", 60171),
    issues: w("issues", 60172),
    italic: w("italic", 60173),
    jersey: w("jersey", 60174),
    json: w("json", 60175),
    kebabVertical: w("kebab-vertical", 60176),
    key: w("key", 60177),
    law: w("law", 60178),
    lightbulbAutofix: w("lightbulb-autofix", 60179),
    linkExternal: w("link-external", 60180),
    link: w("link", 60181),
    listOrdered: w("list-ordered", 60182),
    listUnordered: w("list-unordered", 60183),
    liveShare: w("live-share", 60184),
    loading: w("loading", 60185),
    location: w("location", 60186),
    mailRead: w("mail-read", 60187),
    mail: w("mail", 60188),
    markdown: w("markdown", 60189),
    megaphone: w("megaphone", 60190),
    mention: w("mention", 60191),
    milestone: w("milestone", 60192),
    gitPullRequestMilestone: w("git-pull-request-milestone", 60192),
    mortarBoard: w("mortar-board", 60193),
    move: w("move", 60194),
    multipleWindows: w("multiple-windows", 60195),
    mute: w("mute", 60196),
    noNewline: w("no-newline", 60197),
    note: w("note", 60198),
    octoface: w("octoface", 60199),
    openPreview: w("open-preview", 60200),
    package: w("package", 60201),
    paintcan: w("paintcan", 60202),
    pin: w("pin", 60203),
    play: w("play", 60204),
    run: w("run", 60204),
    plug: w("plug", 60205),
    preserveCase: w("preserve-case", 60206),
    preview: w("preview", 60207),
    project: w("project", 60208),
    pulse: w("pulse", 60209),
    question: w("question", 60210),
    quote: w("quote", 60211),
    radioTower: w("radio-tower", 60212),
    reactions: w("reactions", 60213),
    references: w("references", 60214),
    refresh: w("refresh", 60215),
    regex: w("regex", 60216),
    remoteExplorer: w("remote-explorer", 60217),
    remote: w("remote", 60218),
    remove: w("remove", 60219),
    replaceAll: w("replace-all", 60220),
    replace: w("replace", 60221),
    repoClone: w("repo-clone", 60222),
    repoForcePush: w("repo-force-push", 60223),
    repoPull: w("repo-pull", 60224),
    repoPush: w("repo-push", 60225),
    report: w("report", 60226),
    requestChanges: w("request-changes", 60227),
    rocket: w("rocket", 60228),
    rootFolderOpened: w("root-folder-opened", 60229),
    rootFolder: w("root-folder", 60230),
    rss: w("rss", 60231),
    ruby: w("ruby", 60232),
    saveAll: w("save-all", 60233),
    saveAs: w("save-as", 60234),
    save: w("save", 60235),
    screenFull: w("screen-full", 60236),
    screenNormal: w("screen-normal", 60237),
    searchStop: w("search-stop", 60238),
    server: w("server", 60240),
    settingsGear: w("settings-gear", 60241),
    settings: w("settings", 60242),
    shield: w("shield", 60243),
    smiley: w("smiley", 60244),
    sortPrecedence: w("sort-precedence", 60245),
    splitHorizontal: w("split-horizontal", 60246),
    splitVertical: w("split-vertical", 60247),
    squirrel: w("squirrel", 60248),
    starFull: w("star-full", 60249),
    starHalf: w("star-half", 60250),
    symbolClass: w("symbol-class", 60251),
    symbolColor: w("symbol-color", 60252),
    symbolConstant: w("symbol-constant", 60253),
    symbolEnumMember: w("symbol-enum-member", 60254),
    symbolField: w("symbol-field", 60255),
    symbolFile: w("symbol-file", 60256),
    symbolInterface: w("symbol-interface", 60257),
    symbolKeyword: w("symbol-keyword", 60258),
    symbolMisc: w("symbol-misc", 60259),
    symbolOperator: w("symbol-operator", 60260),
    symbolProperty: w("symbol-property", 60261),
    wrench: w("wrench", 60261),
    wrenchSubaction: w("wrench-subaction", 60261),
    symbolSnippet: w("symbol-snippet", 60262),
    tasklist: w("tasklist", 60263),
    telescope: w("telescope", 60264),
    textSize: w("text-size", 60265),
    threeBars: w("three-bars", 60266),
    thumbsdown: w("thumbsdown", 60267),
    thumbsup: w("thumbsup", 60268),
    tools: w("tools", 60269),
    triangleDown: w("triangle-down", 60270),
    triangleLeft: w("triangle-left", 60271),
    triangleRight: w("triangle-right", 60272),
    triangleUp: w("triangle-up", 60273),
    twitter: w("twitter", 60274),
    unfold: w("unfold", 60275),
    unlock: w("unlock", 60276),
    unmute: w("unmute", 60277),
    unverified: w("unverified", 60278),
    verified: w("verified", 60279),
    versions: w("versions", 60280),
    vmActive: w("vm-active", 60281),
    vmOutline: w("vm-outline", 60282),
    vmRunning: w("vm-running", 60283),
    watch: w("watch", 60284),
    whitespace: w("whitespace", 60285),
    wholeWord: w("whole-word", 60286),
    window: w("window", 60287),
    wordWrap: w("word-wrap", 60288),
    zoomIn: w("zoom-in", 60289),
    zoomOut: w("zoom-out", 60290),
    listFilter: w("list-filter", 60291),
    listFlat: w("list-flat", 60292),
    listSelection: w("list-selection", 60293),
    selection: w("selection", 60293),
    listTree: w("list-tree", 60294),
    debugBreakpointFunctionUnverified: w(
      "debug-breakpoint-function-unverified",
      60295,
    ),
    debugBreakpointFunction: w("debug-breakpoint-function", 60296),
    debugBreakpointFunctionDisabled: w(
      "debug-breakpoint-function-disabled",
      60296,
    ),
    debugStackframeActive: w("debug-stackframe-active", 60297),
    circleSmallFilled: w("circle-small-filled", 60298),
    debugStackframeDot: w("debug-stackframe-dot", 60298),
    terminalDecorationMark: w("terminal-decoration-mark", 60298),
    debugStackframe: w("debug-stackframe", 60299),
    debugStackframeFocused: w("debug-stackframe-focused", 60299),
    debugBreakpointUnsupported: w("debug-breakpoint-unsupported", 60300),
    symbolString: w("symbol-string", 60301),
    debugReverseContinue: w("debug-reverse-continue", 60302),
    debugStepBack: w("debug-step-back", 60303),
    debugRestartFrame: w("debug-restart-frame", 60304),
    debugAlt: w("debug-alt", 60305),
    callIncoming: w("call-incoming", 60306),
    callOutgoing: w("call-outgoing", 60307),
    menu: w("menu", 60308),
    expandAll: w("expand-all", 60309),
    feedback: w("feedback", 60310),
    gitPullRequestReviewer: w("git-pull-request-reviewer", 60310),
    groupByRefType: w("group-by-ref-type", 60311),
    ungroupByRefType: w("ungroup-by-ref-type", 60312),
    account: w("account", 60313),
    gitPullRequestAssignee: w("git-pull-request-assignee", 60313),
    bellDot: w("bell-dot", 60314),
    debugConsole: w("debug-console", 60315),
    library: w("library", 60316),
    output: w("output", 60317),
    runAll: w("run-all", 60318),
    syncIgnored: w("sync-ignored", 60319),
    pinned: w("pinned", 60320),
    githubInverted: w("github-inverted", 60321),
    serverProcess: w("server-process", 60322),
    serverEnvironment: w("server-environment", 60323),
    pass: w("pass", 60324),
    issueClosed: w("issue-closed", 60324),
    stopCircle: w("stop-circle", 60325),
    playCircle: w("play-circle", 60326),
    record: w("record", 60327),
    debugAltSmall: w("debug-alt-small", 60328),
    vmConnect: w("vm-connect", 60329),
    cloud: w("cloud", 60330),
    merge: w("merge", 60331),
    export: w("export", 60332),
    graphLeft: w("graph-left", 60333),
    magnet: w("magnet", 60334),
    notebook: w("notebook", 60335),
    redo: w("redo", 60336),
    checkAll: w("check-all", 60337),
    pinnedDirty: w("pinned-dirty", 60338),
    passFilled: w("pass-filled", 60339),
    circleLargeFilled: w("circle-large-filled", 60340),
    circleLarge: w("circle-large", 60341),
    circleLargeOutline: w("circle-large-outline", 60341),
    combine: w("combine", 60342),
    gather: w("gather", 60342),
    table: w("table", 60343),
    variableGroup: w("variable-group", 60344),
    typeHierarchy: w("type-hierarchy", 60345),
    typeHierarchySub: w("type-hierarchy-sub", 60346),
    typeHierarchySuper: w("type-hierarchy-super", 60347),
    gitPullRequestCreate: w("git-pull-request-create", 60348),
    runAbove: w("run-above", 60349),
    runBelow: w("run-below", 60350),
    notebookTemplate: w("notebook-template", 60351),
    debugRerun: w("debug-rerun", 60352),
    workspaceTrusted: w("workspace-trusted", 60353),
    workspaceUntrusted: w("workspace-untrusted", 60354),
    workspaceUnknown: w("workspace-unknown", 60355),
    terminalCmd: w("terminal-cmd", 60356),
    terminalDebian: w("terminal-debian", 60357),
    terminalLinux: w("terminal-linux", 60358),
    terminalPowershell: w("terminal-powershell", 60359),
    terminalTmux: w("terminal-tmux", 60360),
    terminalUbuntu: w("terminal-ubuntu", 60361),
    terminalBash: w("terminal-bash", 60362),
    arrowSwap: w("arrow-swap", 60363),
    copy: w("copy", 60364),
    personAdd: w("person-add", 60365),
    filterFilled: w("filter-filled", 60366),
    wand: w("wand", 60367),
    debugLineByLine: w("debug-line-by-line", 60368),
    inspect: w("inspect", 60369),
    layers: w("layers", 60370),
    layersDot: w("layers-dot", 60371),
    layersActive: w("layers-active", 60372),
    compass: w("compass", 60373),
    compassDot: w("compass-dot", 60374),
    compassActive: w("compass-active", 60375),
    azure: w("azure", 60376),
    issueDraft: w("issue-draft", 60377),
    gitPullRequestClosed: w("git-pull-request-closed", 60378),
    gitPullRequestDraft: w("git-pull-request-draft", 60379),
    debugAll: w("debug-all", 60380),
    debugCoverage: w("debug-coverage", 60381),
    runErrors: w("run-errors", 60382),
    folderLibrary: w("folder-library", 60383),
    debugContinueSmall: w("debug-continue-small", 60384),
    beakerStop: w("beaker-stop", 60385),
    graphLine: w("graph-line", 60386),
    graphScatter: w("graph-scatter", 60387),
    pieChart: w("pie-chart", 60388),
    bracket: w("bracket", 60175),
    bracketDot: w("bracket-dot", 60389),
    bracketError: w("bracket-error", 60390),
    lockSmall: w("lock-small", 60391),
    azureDevops: w("azure-devops", 60392),
    verifiedFilled: w("verified-filled", 60393),
    newline: w("newline", 60394),
    layout: w("layout", 60395),
    layoutActivitybarLeft: w("layout-activitybar-left", 60396),
    layoutActivitybarRight: w("layout-activitybar-right", 60397),
    layoutPanelLeft: w("layout-panel-left", 60398),
    layoutPanelCenter: w("layout-panel-center", 60399),
    layoutPanelJustify: w("layout-panel-justify", 60400),
    layoutPanelRight: w("layout-panel-right", 60401),
    layoutPanel: w("layout-panel", 60402),
    layoutSidebarLeft: w("layout-sidebar-left", 60403),
    layoutSidebarRight: w("layout-sidebar-right", 60404),
    layoutStatusbar: w("layout-statusbar", 60405),
    layoutMenubar: w("layout-menubar", 60406),
    layoutCentered: w("layout-centered", 60407),
    target: w("target", 60408),
    indent: w("indent", 60409),
    recordSmall: w("record-small", 60410),
    errorSmall: w("error-small", 60411),
    terminalDecorationError: w("terminal-decoration-error", 60411),
    arrowCircleDown: w("arrow-circle-down", 60412),
    arrowCircleLeft: w("arrow-circle-left", 60413),
    arrowCircleRight: w("arrow-circle-right", 60414),
    arrowCircleUp: w("arrow-circle-up", 60415),
    layoutSidebarRightOff: w("layout-sidebar-right-off", 60416),
    layoutPanelOff: w("layout-panel-off", 60417),
    layoutSidebarLeftOff: w("layout-sidebar-left-off", 60418),
    blank: w("blank", 60419),
    heartFilled: w("heart-filled", 60420),
    map: w("map", 60421),
    mapHorizontal: w("map-horizontal", 60421),
    foldHorizontal: w("fold-horizontal", 60421),
    mapFilled: w("map-filled", 60422),
    mapHorizontalFilled: w("map-horizontal-filled", 60422),
    foldHorizontalFilled: w("fold-horizontal-filled", 60422),
    circleSmall: w("circle-small", 60423),
    bellSlash: w("bell-slash", 60424),
    bellSlashDot: w("bell-slash-dot", 60425),
    commentUnresolved: w("comment-unresolved", 60426),
    gitPullRequestGoToChanges: w("git-pull-request-go-to-changes", 60427),
    gitPullRequestNewChanges: w("git-pull-request-new-changes", 60428),
    searchFuzzy: w("search-fuzzy", 60429),
    commentDraft: w("comment-draft", 60430),
    send: w("send", 60431),
    sparkle: w("sparkle", 60432),
    insert: w("insert", 60433),
    mic: w("mic", 60434),
    thumbsdownFilled: w("thumbsdown-filled", 60435),
    thumbsupFilled: w("thumbsup-filled", 60436),
    coffee: w("coffee", 60437),
    snake: w("snake", 60438),
    game: w("game", 60439),
    vr: w("vr", 60440),
    chip: w("chip", 60441),
    piano: w("piano", 60442),
    music: w("music", 60443),
    micFilled: w("mic-filled", 60444),
    repoFetch: w("repo-fetch", 60445),
    copilot: w("copilot", 60446),
    lightbulbSparkle: w("lightbulb-sparkle", 60447),
    robot: w("robot", 60448),
    sparkleFilled: w("sparkle-filled", 60449),
    diffSingle: w("diff-single", 60450),
    diffMultiple: w("diff-multiple", 60451),
    surroundWith: w("surround-with", 60452),
    share: w("share", 60453),
    gitStash: w("git-stash", 60454),
    gitStashApply: w("git-stash-apply", 60455),
    gitStashPop: w("git-stash-pop", 60456),
    vscode: w("vscode", 60457),
    vscodeInsiders: w("vscode-insiders", 60458),
    codeOss: w("code-oss", 60459),
    runCoverage: w("run-coverage", 60460),
    runAllCoverage: w("run-all-coverage", 60461),
    coverage: w("coverage", 60462),
    githubProject: w("github-project", 60463),
    mapVertical: w("map-vertical", 60464),
    foldVertical: w("fold-vertical", 60464),
    mapVerticalFilled: w("map-vertical-filled", 60465),
    foldVerticalFilled: w("fold-vertical-filled", 60465),
    goToSearch: w("go-to-search", 60466),
    percentage: w("percentage", 60467),
    sortPercentage: w("sort-percentage", 60467),
    attach: w("attach", 60468),
    goToEditingSession: w("go-to-editing-session", 60469),
    editSession: w("edit-session", 60470),
    codeReview: w("code-review", 60471),
    copilotWarning: w("copilot-warning", 60472),
    python: w("python", 60473),
    copilotLarge: w("copilot-large", 60474),
    copilotWarningLarge: w("copilot-warning-large", 60475),
  },
  dyt = {
    dialogError: w("dialog-error", "error"),
    dialogWarning: w("dialog-warning", "warning"),
    dialogInfo: w("dialog-info", "info"),
    dialogClose: w("dialog-close", "close"),
    treeItemExpanded: w("tree-item-expanded", "chevron-down"),
    treeFilterOnTypeOn: w("tree-filter-on-type-on", "list-filter"),
    treeFilterOnTypeOff: w("tree-filter-on-type-off", "list-selection"),
    treeFilterClear: w("tree-filter-clear", "close"),
    treeItemLoading: w("tree-item-loading", "loading"),
    menuSelection: w("menu-selection", "check"),
    menuSubmenu: w("menu-submenu", "chevron-right"),
    menuBarMore: w("menubar-more", "more"),
    scrollbarButtonLeft: w("scrollbar-button-left", "triangle-left"),
    scrollbarButtonRight: w("scrollbar-button-right", "triangle-right"),
    scrollbarButtonUp: w("scrollbar-button-up", "triangle-up"),
    scrollbarButtonDown: w("scrollbar-button-down", "triangle-down"),
    toolBarMore: w("toolbar-more", "more"),
    quickInputBack: w("quick-input-back", "arrow-left"),
    dropDownButton: w("drop-down-button", 60084),
    symbolCustomColor: w("symbol-customcolor", 60252),
    exportIcon: w("export", 60332),
    workspaceUnspecified: w("workspace-unspecified", 60355),
    newLine: w("newline", 60394),
    thumbsDownFilled: w("thumbsdown-filled", 60435),
    thumbsUpFilled: w("thumbsup-filled", 60436),
    gitFetch: w("git-fetch", 60445),
    lightbulbSparkleAutofix: w("lightbulb-sparkle-autofix", 60447),
    debugBreakpointPending: w("debug-breakpoint-pending", 60377),
  },
  pt = { ...hyt, ...dyt },
  Cc
;(function (i) {
  function t(e) {
    return e && typeof e == "object" && typeof e.id == "string"
  }
  i.isThemeColor = t
})(Cc || (Cc = {}))
var gi
;(function (i) {
  ;(i.iconNameSegment = "[A-Za-z0-9]+"),
    (i.iconNameExpression = "[A-Za-z0-9-]+"),
    (i.iconModifierExpression = "~[A-Za-z]+"),
    (i.iconNameCharacter = "[A-Za-z0-9~-]")
  const t = new RegExp(
    `^(${i.iconNameExpression})(${i.iconModifierExpression})?$`,
  )
  function e(f) {
    const p = t.exec(f.id)
    if (!p) return e(pt.error)
    const [, v, b] = p,
      k = ["codicon", "codicon-" + v]
    return b && k.push("codicon-modifier-" + b.substring(1)), k
  }
  i.asClassNameArray = e
  function s(f) {
    return e(f).join(" ")
  }
  i.asClassName = s
  function r(f) {
    return "." + e(f).join(".")
  }
  i.asCSSSelector = r
  function a(f) {
    return (
      f &&
      typeof f == "object" &&
      typeof f.id == "string" &&
      (typeof f.color > "u" || Cc.isThemeColor(f.color))
    )
  }
  i.isThemeIcon = a
  const o = new RegExp(
    `^\\$\\((${i.iconNameExpression}(?:${i.iconModifierExpression})?)\\)$`,
  )
  function c(f) {
    const p = o.exec(f)
    if (!p) return
    const [, v] = p
    return { id: v }
  }
  i.fromString = c
  function l(f) {
    return { id: f }
  }
  i.fromId = l
  function u(f, p) {
    let v = f.id
    const b = v.lastIndexOf("~")
    return (
      b !== -1 && (v = v.substring(0, b)), p && (v = `${v}~${p}`), { id: v }
    )
  }
  i.modify = u
  function d(f) {
    const p = f.id.lastIndexOf("~")
    if (p !== -1) return f.id.substring(p + 1)
  }
  i.getModifier = d
  function m(f, p) {
    return f.id === p.id && f.color?.id === p.color?.id
  }
  i.isEqual = m
})(gi || (gi = {}))
var zq = new RegExp(
    `\\$\\(${gi.iconNameExpression}(?:${gi.iconModifierExpression})?\\)`,
    "g",
  ),
  myt = new RegExp(`(\\\\)?${zq.source}`, "g")
function fyt(i) {
  return i.replace(myt, (t, e) => (e ? t : `\\${t}`))
}
var kVt = new RegExp(`\\\\${zq.source}`, "g"),
  SVt = new RegExp(`(\\s)?(\\\\)?${zq.source}(\\s)?`, "g"),
  EVt = new RegExp(`\\$\\(${gi.iconNameCharacter}+\\)`, "g"),
  gX
;(function (i) {
  ;(i[(i.Paragraph = 0)] = "Paragraph"), (i[(i.Break = 1)] = "Break")
})(gX || (gX = {}))
var vX = class {
  constructor(i = "", t = !1) {
    if (((this.value = i), typeof this.value != "string")) throw Lt("value")
    typeof t == "boolean"
      ? ((this.isTrusted = t),
        (this.supportThemeIcons = !1),
        (this.supportHtml = !1))
      : ((this.isTrusted = t.isTrusted ?? void 0),
        (this.supportThemeIcons = t.supportThemeIcons ?? !1),
        (this.supportHtml = t.supportHtml ?? !1))
  }
  appendText(i, t = 0) {
    return (
      (this.value += pyt(this.supportThemeIcons ? fyt(i) : i)
        .replace(/([ \t]+)/g, (e, s) => "&nbsp;".repeat(s.length))
        .replace(/\>/gm, "\\>")
        .replace(
          /\n/g,
          t === 1
            ? `\\
`
            : `

`,
        )),
      this
    )
  }
  appendMarkdown(i) {
    return (this.value += i), this
  }
  appendCodeblock(i, t) {
    return (
      (this.value += `
${gyt(t, i)}
`),
      this
    )
  }
  appendLink(i, t, e) {
    return (
      (this.value += "["),
      (this.value += this.c(t, "]")),
      (this.value += "]("),
      (this.value += this.c(String(i), ")")),
      e && (this.value += ` "${this.c(this.c(e, '"'), ")")}"`),
      (this.value += ")"),
      this
    )
  }
  c(i, t) {
    const e = new RegExp(Vn(t), "g")
    return i.replace(e, (s, r) => (i.charAt(r - 1) !== "\\" ? `\\${s}` : s))
  }
}
function to(i) {
  return i instanceof vX
    ? !0
    : i && typeof i == "object"
      ? typeof i.value == "string" &&
        (typeof i.isTrusted == "boolean" ||
          typeof i.isTrusted == "object" ||
          i.isTrusted === void 0) &&
        (typeof i.supportThemeIcons == "boolean" ||
          i.supportThemeIcons === void 0)
      : !1
}
function pyt(i) {
  return i.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&")
}
function gyt(i, t) {
  const e =
      i.match(/^`+/gm)?.reduce((r, a) => (r.length > a.length ? r : a))
        .length ?? 0,
    s = e >= 3 ? e + 1 : 3
  return [`${"`".repeat(s)}${t}`, i, `${"`".repeat(s)}`].join(`
`)
}
function vyt(i) {
  const t = [],
    e = i.split("|").map((r) => r.trim())
  i = e[0]
  const s = e[1]
  if (s) {
    const r = /height=(\d+)/.exec(s),
      a = /width=(\d+)/.exec(s),
      o = r ? r[1] : "",
      c = a ? a[1] : "",
      l = isFinite(parseInt(c)),
      u = isFinite(parseInt(o))
    l && t.push(`width="${c}"`), u && t.push(`height="${o}"`)
  }
  return { href: i, dimensions: t }
}
function Yq() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null,
  }
}
var eo = Yq()
function wX(i) {
  eo = i
}
var yX = /[&<>"']/,
  wyt = new RegExp(yX.source, "g"),
  bX = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  yyt = new RegExp(bX.source, "g"),
  byt = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" },
  TX = (i) => byt[i]
function vs(i, t) {
  if (t) {
    if (yX.test(i)) return i.replace(wyt, TX)
  } else if (bX.test(i)) return i.replace(yyt, TX)
  return i
}
var Tyt = /(^|[^\[])\^/g
function be(i, t) {
  let e = typeof i == "string" ? i : i.source
  t = t || ""
  const s = {
    replace: (r, a) => {
      let o = typeof a == "string" ? a : a.source
      return (o = o.replace(Tyt, "$1")), (e = e.replace(r, o)), s
    },
    getRegex: () => new RegExp(e, t),
  }
  return s
}
function kX(i) {
  try {
    i = encodeURI(i).replace(/%25/g, "%")
  } catch {
    return null
  }
  return i
}
var lh = { exec: () => null }
function SX(i, t) {
  const e = i.replace(/\|/g, (a, o, c) => {
      let l = !1,
        u = o
      for (; --u >= 0 && c[u] === "\\"; ) l = !l
      return l ? "|" : " |"
    }),
    s = e.split(/ \|/)
  let r = 0
  if (
    (s[0].trim() || s.shift(),
    s.length > 0 && !s[s.length - 1].trim() && s.pop(),
    t)
  )
    if (s.length > t) s.splice(t)
    else for (; s.length < t; ) s.push("")
  for (; r < s.length; r++) s[r] = s[r].trim().replace(/\\\|/g, "|")
  return s
}
function uh(i, t, e) {
  const s = i.length
  if (s === 0) return ""
  let r = 0
  for (; r < s; ) {
    const a = i.charAt(s - r - 1)
    if (a === t && !e) r++
    else if (a !== t && e) r++
    else break
  }
  return i.slice(0, s - r)
}
function kyt(i, t) {
  if (i.indexOf(t[1]) === -1) return -1
  let e = 0
  for (let s = 0; s < i.length; s++)
    if (i[s] === "\\") s++
    else if (i[s] === t[0]) e++
    else if (i[s] === t[1] && (e--, e < 0)) return s
  return -1
}
function EX(i, t, e, s) {
  const r = t.href,
    a = t.title ? vs(t.title) : null,
    o = i[1].replace(/\\([\[\]])/g, "$1")
  if (i[0].charAt(0) !== "!") {
    s.state.inLink = !0
    const c = {
      type: "link",
      raw: e,
      href: r,
      title: a,
      text: o,
      tokens: s.inlineTokens(o),
    }
    return (s.state.inLink = !1), c
  }
  return { type: "image", raw: e, href: r, title: a, text: vs(o) }
}
function Syt(i, t) {
  const e = i.match(/^(\s+)(?:```)/)
  if (e === null) return t
  const s = e[1]
  return t
    .split(
      `
`,
    )
    .map((r) => {
      const a = r.match(/^\s+/)
      if (a === null) return r
      const [o] = a
      return o.length >= s.length ? r.slice(s.length) : r
    }).join(`
`)
}
var n6 = class {
    options
    rules
    lexer
    constructor(i) {
      this.options = i || eo
    }
    space(i) {
      const t = this.rules.block.newline.exec(i)
      if (t && t[0].length > 0) return { type: "space", raw: t[0] }
    }
    code(i) {
      const t = this.rules.block.code.exec(i)
      if (t) {
        const e = t[0].replace(/^ {1,4}/gm, "")
        return {
          type: "code",
          raw: t[0],
          codeBlockStyle: "indented",
          text: this.options.pedantic
            ? e
            : uh(
                e,
                `
`,
              ),
        }
      }
    }
    fences(i) {
      const t = this.rules.block.fences.exec(i)
      if (t) {
        const e = t[0],
          s = Syt(e, t[3] || "")
        return {
          type: "code",
          raw: e,
          lang: t[2]
            ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1")
            : t[2],
          text: s,
        }
      }
    }
    heading(i) {
      const t = this.rules.block.heading.exec(i)
      if (t) {
        let e = t[2].trim()
        if (/#$/.test(e)) {
          const s = uh(e, "#")
          ;(this.options.pedantic || !s || / $/.test(s)) && (e = s.trim())
        }
        return {
          type: "heading",
          raw: t[0],
          depth: t[1].length,
          text: e,
          tokens: this.lexer.inline(e),
        }
      }
    }
    hr(i) {
      const t = this.rules.block.hr.exec(i)
      if (t)
        return {
          type: "hr",
          raw: uh(
            t[0],
            `
`,
          ),
        }
    }
    blockquote(i) {
      const t = this.rules.block.blockquote.exec(i)
      if (t) {
        let e = uh(
            t[0],
            `
`,
          ).split(`
`),
          s = "",
          r = ""
        const a = []
        for (; e.length > 0; ) {
          let o = !1
          const c = []
          let l
          for (l = 0; l < e.length; l++)
            if (/^ {0,3}>/.test(e[l])) c.push(e[l]), (o = !0)
            else if (!o) c.push(e[l])
            else break
          e = e.slice(l)
          const u = c.join(`
`),
            d = u
              .replace(
                /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
                `
    $1`,
              )
              .replace(/^ {0,3}>[ \t]?/gm, "")
          ;(s = s
            ? `${s}
${u}`
            : u),
            (r = r
              ? `${r}
${d}`
              : d)
          const m = this.lexer.state.top
          if (
            ((this.lexer.state.top = !0),
            this.lexer.blockTokens(d, a, !0),
            (this.lexer.state.top = m),
            e.length === 0)
          )
            break
          const f = a[a.length - 1]
          if (f?.type === "code") break
          if (f?.type === "blockquote") {
            const p = f,
              v =
                p.raw +
                `
` +
                e.join(`
`),
              b = this.blockquote(v)
            ;(a[a.length - 1] = b),
              (s = s.substring(0, s.length - p.raw.length) + b.raw),
              (r = r.substring(0, r.length - p.text.length) + b.text)
            break
          } else if (f?.type === "list") {
            const p = f,
              v =
                p.raw +
                `
` +
                e.join(`
`),
              b = this.list(v)
            ;(a[a.length - 1] = b),
              (s = s.substring(0, s.length - f.raw.length) + b.raw),
              (r = r.substring(0, r.length - p.raw.length) + b.raw),
              (e = v.substring(a[a.length - 1].raw.length).split(`
`))
            continue
          }
        }
        return { type: "blockquote", raw: s, tokens: a, text: r }
      }
    }
    list(i) {
      let t = this.rules.block.list.exec(i)
      if (t) {
        let e = t[1].trim()
        const s = e.length > 1,
          r = {
            type: "list",
            raw: "",
            ordered: s,
            start: s ? +e.slice(0, -1) : "",
            loose: !1,
            items: [],
          }
        ;(e = s ? `\\d{1,9}\\${e.slice(-1)}` : `\\${e}`),
          this.options.pedantic && (e = s ? e : "[*+-]")
        const a = new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`)
        let o = !1
        for (; i; ) {
          let c = !1,
            l = "",
            u = ""
          if (!(t = a.exec(i)) || this.rules.block.hr.test(i)) break
          ;(l = t[0]), (i = i.substring(l.length))
          let d = t[2]
              .split(
                `
`,
                1,
              )[0]
              .replace(/^\t+/, (k) => " ".repeat(3 * k.length)),
            m = i.split(
              `
`,
              1,
            )[0],
            f = !d.trim(),
            p = 0
          if (
            (this.options.pedantic
              ? ((p = 2), (u = d.trimStart()))
              : f
                ? (p = t[1].length + 1)
                : ((p = t[2].search(/[^ ]/)),
                  (p = p > 4 ? 1 : p),
                  (u = d.slice(p)),
                  (p += t[1].length)),
            f &&
              /^ *$/.test(m) &&
              ((l +=
                m +
                `
`),
              (i = i.substring(m.length + 1)),
              (c = !0)),
            !c)
          ) {
            const k = new RegExp(
                `^ {0,${Math.min(3, p - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`,
              ),
              E = new RegExp(
                `^ {0,${Math.min(3, p - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`,
              ),
              P = new RegExp(`^ {0,${Math.min(3, p - 1)}}(?:\`\`\`|~~~)`),
              C = new RegExp(`^ {0,${Math.min(3, p - 1)}}#`)
            for (; i; ) {
              const R = i.split(
                `
`,
                1,
              )[0]
              if (
                ((m = R),
                this.options.pedantic &&
                  (m = m.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
                P.test(m) || C.test(m) || k.test(m) || E.test(i))
              )
                break
              if (m.search(/[^ ]/) >= p || !m.trim())
                u +=
                  `
` + m.slice(p)
              else {
                if (
                  f ||
                  d.search(/[^ ]/) >= 4 ||
                  P.test(d) ||
                  C.test(d) ||
                  E.test(d)
                )
                  break
                u +=
                  `
` + m
              }
              !f && !m.trim() && (f = !0),
                (l +=
                  R +
                  `
`),
                (i = i.substring(R.length + 1)),
                (d = m.slice(p))
            }
          }
          r.loose || (o ? (r.loose = !0) : /\n *\n *$/.test(l) && (o = !0))
          let v = null,
            b
          this.options.gfm &&
            ((v = /^\[[ xX]\] /.exec(u)),
            v && ((b = v[0] !== "[ ] "), (u = u.replace(/^\[[ xX]\] +/, "")))),
            r.items.push({
              type: "list_item",
              raw: l,
              task: !!v,
              checked: b,
              loose: !1,
              text: u,
              tokens: [],
            }),
            (r.raw += l)
        }
        ;(r.items[r.items.length - 1].raw =
          r.items[r.items.length - 1].raw.trimEnd()),
          (r.items[r.items.length - 1].text =
            r.items[r.items.length - 1].text.trimEnd()),
          (r.raw = r.raw.trimEnd())
        for (let c = 0; c < r.items.length; c++)
          if (
            ((this.lexer.state.top = !1),
            (r.items[c].tokens = this.lexer.blockTokens(r.items[c].text, [])),
            !r.loose)
          ) {
            const l = r.items[c].tokens.filter((d) => d.type === "space"),
              u = l.length > 0 && l.some((d) => /\n.*\n/.test(d.raw))
            r.loose = u
          }
        if (r.loose)
          for (let c = 0; c < r.items.length; c++) r.items[c].loose = !0
        return r
      }
    }
    html(i) {
      const t = this.rules.block.html.exec(i)
      if (t)
        return {
          type: "html",
          block: !0,
          raw: t[0],
          pre: t[1] === "pre" || t[1] === "script" || t[1] === "style",
          text: t[0],
        }
    }
    def(i) {
      const t = this.rules.block.def.exec(i)
      if (t) {
        const e = t[1].toLowerCase().replace(/\s+/g, " "),
          s = t[2]
            ? t[2]
                .replace(/^<(.*)>$/, "$1")
                .replace(this.rules.inline.anyPunctuation, "$1")
            : "",
          r = t[3]
            ? t[3]
                .substring(1, t[3].length - 1)
                .replace(this.rules.inline.anyPunctuation, "$1")
            : t[3]
        return { type: "def", tag: e, raw: t[0], href: s, title: r }
      }
    }
    table(i) {
      const t = this.rules.block.table.exec(i)
      if (!t || !/[:|]/.test(t[2])) return
      const e = SX(t[1]),
        s = t[2].replace(/^\||\| *$/g, "").split("|"),
        r =
          t[3] && t[3].trim()
            ? t[3].replace(/\n[ \t]*$/, "").split(`
`)
            : [],
        a = { type: "table", raw: t[0], header: [], align: [], rows: [] }
      if (e.length === s.length) {
        for (const o of s)
          /^ *-+: *$/.test(o)
            ? a.align.push("right")
            : /^ *:-+: *$/.test(o)
              ? a.align.push("center")
              : /^ *:-+ *$/.test(o)
                ? a.align.push("left")
                : a.align.push(null)
        for (let o = 0; o < e.length; o++)
          a.header.push({
            text: e[o],
            tokens: this.lexer.inline(e[o]),
            header: !0,
            align: a.align[o],
          })
        for (const o of r)
          a.rows.push(
            SX(o, a.header.length).map((c, l) => ({
              text: c,
              tokens: this.lexer.inline(c),
              header: !1,
              align: a.align[l],
            })),
          )
        return a
      }
    }
    lheading(i) {
      const t = this.rules.block.lheading.exec(i)
      if (t)
        return {
          type: "heading",
          raw: t[0],
          depth: t[2].charAt(0) === "=" ? 1 : 2,
          text: t[1],
          tokens: this.lexer.inline(t[1]),
        }
    }
    paragraph(i) {
      const t = this.rules.block.paragraph.exec(i)
      if (t) {
        const e =
          t[1].charAt(t[1].length - 1) ===
          `
`
            ? t[1].slice(0, -1)
            : t[1]
        return {
          type: "paragraph",
          raw: t[0],
          text: e,
          tokens: this.lexer.inline(e),
        }
      }
    }
    text(i) {
      const t = this.rules.block.text.exec(i)
      if (t)
        return {
          type: "text",
          raw: t[0],
          text: t[0],
          tokens: this.lexer.inline(t[0]),
        }
    }
    escape(i) {
      const t = this.rules.inline.escape.exec(i)
      if (t) return { type: "escape", raw: t[0], text: vs(t[1]) }
    }
    tag(i) {
      const t = this.rules.inline.tag.exec(i)
      if (t)
        return (
          !this.lexer.state.inLink && /^<a /i.test(t[0])
            ? (this.lexer.state.inLink = !0)
            : this.lexer.state.inLink &&
              /^<\/a>/i.test(t[0]) &&
              (this.lexer.state.inLink = !1),
          !this.lexer.state.inRawBlock &&
          /^<(pre|code|kbd|script)(\s|>)/i.test(t[0])
            ? (this.lexer.state.inRawBlock = !0)
            : this.lexer.state.inRawBlock &&
              /^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) &&
              (this.lexer.state.inRawBlock = !1),
          {
            type: "html",
            raw: t[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: !1,
            text: t[0],
          }
        )
    }
    link(i) {
      const t = this.rules.inline.link.exec(i)
      if (t) {
        const e = t[2].trim()
        if (!this.options.pedantic && /^</.test(e)) {
          if (!/>$/.test(e)) return
          const a = uh(e.slice(0, -1), "\\")
          if ((e.length - a.length) % 2 === 0) return
        } else {
          const a = kyt(t[2], "()")
          if (a > -1) {
            const c = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + a
            ;(t[2] = t[2].substring(0, a)),
              (t[0] = t[0].substring(0, c).trim()),
              (t[3] = "")
          }
        }
        let s = t[2],
          r = ""
        if (this.options.pedantic) {
          const a = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(s)
          a && ((s = a[1]), (r = a[3]))
        } else r = t[3] ? t[3].slice(1, -1) : ""
        return (
          (s = s.trim()),
          /^</.test(s) &&
            (this.options.pedantic && !/>$/.test(e)
              ? (s = s.slice(1))
              : (s = s.slice(1, -1))),
          EX(
            t,
            {
              href: s && s.replace(this.rules.inline.anyPunctuation, "$1"),
              title: r && r.replace(this.rules.inline.anyPunctuation, "$1"),
            },
            t[0],
            this.lexer,
          )
        )
      }
    }
    reflink(i, t) {
      let e
      if (
        (e = this.rules.inline.reflink.exec(i)) ||
        (e = this.rules.inline.nolink.exec(i))
      ) {
        const s = (e[2] || e[1]).replace(/\s+/g, " "),
          r = t[s.toLowerCase()]
        if (!r) {
          const a = e[0].charAt(0)
          return { type: "text", raw: a, text: a }
        }
        return EX(e, r, e[0], this.lexer)
      }
    }
    emStrong(i, t, e = "") {
      let s = this.rules.inline.emStrongLDelim.exec(i)
      if (!s || (s[3] && e.match(/[\p{L}\p{N}]/u))) return
      if (
        !(s[1] || s[2] || "") ||
        !e ||
        this.rules.inline.punctuation.exec(e)
      ) {
        const a = [...s[0]].length - 1
        let o,
          c,
          l = a,
          u = 0
        const d =
          s[0][0] === "*"
            ? this.rules.inline.emStrongRDelimAst
            : this.rules.inline.emStrongRDelimUnd
        for (
          d.lastIndex = 0, t = t.slice(-1 * i.length + a);
          (s = d.exec(t)) != null;

        ) {
          if (((o = s[1] || s[2] || s[3] || s[4] || s[5] || s[6]), !o)) continue
          if (((c = [...o].length), s[3] || s[4])) {
            l += c
            continue
          } else if ((s[5] || s[6]) && a % 3 && !((a + c) % 3)) {
            u += c
            continue
          }
          if (((l -= c), l > 0)) continue
          c = Math.min(c, c + l + u)
          const m = [...s[0]][0].length,
            f = i.slice(0, a + s.index + m + c)
          if (Math.min(a, c) % 2) {
            const v = f.slice(1, -1)
            return {
              type: "em",
              raw: f,
              text: v,
              tokens: this.lexer.inlineTokens(v),
            }
          }
          const p = f.slice(2, -2)
          return {
            type: "strong",
            raw: f,
            text: p,
            tokens: this.lexer.inlineTokens(p),
          }
        }
      }
    }
    codespan(i) {
      const t = this.rules.inline.code.exec(i)
      if (t) {
        let e = t[2].replace(/\n/g, " ")
        const s = /[^ ]/.test(e),
          r = /^ /.test(e) && / $/.test(e)
        return (
          s && r && (e = e.substring(1, e.length - 1)),
          (e = vs(e, !0)),
          { type: "codespan", raw: t[0], text: e }
        )
      }
    }
    br(i) {
      const t = this.rules.inline.br.exec(i)
      if (t) return { type: "br", raw: t[0] }
    }
    del(i) {
      const t = this.rules.inline.del.exec(i)
      if (t)
        return {
          type: "del",
          raw: t[0],
          text: t[2],
          tokens: this.lexer.inlineTokens(t[2]),
        }
    }
    autolink(i) {
      const t = this.rules.inline.autolink.exec(i)
      if (t) {
        let e, s
        return (
          t[2] === "@"
            ? ((e = vs(t[1])), (s = "mailto:" + e))
            : ((e = vs(t[1])), (s = e)),
          {
            type: "link",
            raw: t[0],
            text: e,
            href: s,
            tokens: [{ type: "text", raw: e, text: e }],
          }
        )
      }
    }
    url(i) {
      let t
      if ((t = this.rules.inline.url.exec(i))) {
        let e, s
        if (t[2] === "@") (e = vs(t[0])), (s = "mailto:" + e)
        else {
          let r
          do
            (r = t[0]),
              (t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "")
          while (r !== t[0])
          ;(e = vs(t[0])), t[1] === "www." ? (s = "http://" + t[0]) : (s = t[0])
        }
        return {
          type: "link",
          raw: t[0],
          text: e,
          href: s,
          tokens: [{ type: "text", raw: e, text: e }],
        }
      }
    }
    inlineText(i) {
      const t = this.rules.inline.text.exec(i)
      if (t) {
        let e
        return (
          this.lexer.state.inRawBlock ? (e = t[0]) : (e = vs(t[0])),
          { type: "text", raw: t[0], text: e }
        )
      }
    }
  },
  Eyt = /^(?: *(?:\n|$))+/,
  Iyt = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  Pyt =
    /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hh = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  $yt = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  IX = /(?:[*+-]|\d{1,9}[.)])/,
  PX = be(
    /^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  )
    .replace(/bull/g, IX)
    .replace(/blockCode/g, / {4}/)
    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
    .replace(/blockquote/g, / {0,3}>/)
    .replace(/heading/g, / {0,3}#{1,6}/)
    .replace(/html/g, / {0,3}<[^\n>]+>\n/)
    .getRegex(),
  Qq =
    /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  xyt = /^[^\n]+/,
  Xq = /(?!\s*\])(?:\\.|[^\[\]\\])+/,
  Nyt = be(
    /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  )
    .replace("label", Xq)
    .replace(
      "title",
      /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/,
    )
    .getRegex(),
  Cyt = be(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
    .replace(/bull/g, IX)
    .getRegex(),
  a6 =
    "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",
  Kq = /<!--(?:-?>|[\s\S]*?(?:-->|$))/,
  Jyt = be(
    "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
    "i",
  )
    .replace("comment", Kq)
    .replace("tag", a6)
    .replace(
      "attribute",
      / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/,
    )
    .getRegex(),
  $X = be(Qq)
    .replace("hr", hh)
    .replace("heading", " {0,3}#{1,6}(?:\\s|$)")
    .replace("|lheading", "")
    .replace("|table", "")
    .replace("blockquote", " {0,3}>")
    .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
    .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
    .replace(
      "html",
      "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
    )
    .replace("tag", a6)
    .getRegex(),
  Lyt = be(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
    .replace("paragraph", $X)
    .getRegex(),
  Zq = {
    blockquote: Lyt,
    code: Iyt,
    def: Nyt,
    fences: Pyt,
    heading: $yt,
    hr: hh,
    html: Jyt,
    lheading: PX,
    list: Cyt,
    newline: Eyt,
    paragraph: $X,
    table: lh,
    text: xyt,
  },
  xX = be(
    "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
  )
    .replace("hr", hh)
    .replace("heading", " {0,3}#{1,6}(?:\\s|$)")
    .replace("blockquote", " {0,3}>")
    .replace("code", " {4}[^\\n]")
    .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
    .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
    .replace(
      "html",
      "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
    )
    .replace("tag", a6)
    .getRegex(),
  Ryt = {
    ...Zq,
    table: xX,
    paragraph: be(Qq)
      .replace("hr", hh)
      .replace("heading", " {0,3}#{1,6}(?:\\s|$)")
      .replace("|lheading", "")
      .replace("table", xX)
      .replace("blockquote", " {0,3}>")
      .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
      .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
      .replace(
        "html",
        "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
      )
      .replace("tag", a6)
      .getRegex(),
  },
  Dyt = {
    ...Zq,
    html: be(
      `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`,
    )
      .replace("comment", Kq)
      .replace(
        /tag/g,
        "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b",
      )
      .getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: lh,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: be(Qq)
      .replace("hr", hh)
      .replace(
        "heading",
        ` *#{1,6} *[^
]`,
      )
      .replace("lheading", PX)
      .replace("|table", "")
      .replace("blockquote", " {0,3}>")
      .replace("|fences", "")
      .replace("|list", "")
      .replace("|html", "")
      .replace("|tag", "")
      .getRegex(),
  },
  NX = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  Fyt = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  CX = /^( {2,}|\\)\n(?!\s*$)/,
  Ayt =
    /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  dh = "\\p{P}\\p{S}",
  _yt = be(/^((?![*_])[\spunctuation])/, "u")
    .replace(/punctuation/g, dh)
    .getRegex(),
  Oyt = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g,
  Byt = be(
    /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
    "u",
  )
    .replace(/punct/g, dh)
    .getRegex(),
  qyt = be(
    "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])",
    "gu",
  )
    .replace(/punct/g, dh)
    .getRegex(),
  Uyt = be(
    "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])",
    "gu",
  )
    .replace(/punct/g, dh)
    .getRegex(),
  Myt = be(/\\([punct])/, "gu")
    .replace(/punct/g, dh)
    .getRegex(),
  Hyt = be(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
    .replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
    .replace(
      "email",
      /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,
    )
    .getRegex(),
  Wyt = be(Kq).replace("(?:-->|$)", "-->").getRegex(),
  jyt = be(
    "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  )
    .replace("comment", Wyt)
    .replace(
      "attribute",
      /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,
    )
    .getRegex(),
  o6 = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,
  Vyt = be(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
    .replace("label", o6)
    .replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
    .replace(
      "title",
      /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,
    )
    .getRegex(),
  JX = be(/^!?\[(label)\]\[(ref)\]/)
    .replace("label", o6)
    .replace("ref", Xq)
    .getRegex(),
  LX = be(/^!?\[(ref)\](?:\[\])?/)
    .replace("ref", Xq)
    .getRegex(),
  Gyt = be("reflink|nolink(?!\\()", "g")
    .replace("reflink", JX)
    .replace("nolink", LX)
    .getRegex(),
  t2 = {
    _backpedal: lh,
    anyPunctuation: Myt,
    autolink: Hyt,
    blockSkip: Oyt,
    br: CX,
    code: Fyt,
    del: lh,
    emStrongLDelim: Byt,
    emStrongRDelimAst: qyt,
    emStrongRDelimUnd: Uyt,
    escape: NX,
    link: Vyt,
    nolink: LX,
    punctuation: _yt,
    reflink: JX,
    reflinkSearch: Gyt,
    tag: jyt,
    text: Ayt,
    url: lh,
  },
  zyt = {
    ...t2,
    link: be(/^!?\[(label)\]\((.*?)\)/)
      .replace("label", o6)
      .getRegex(),
    reflink: be(/^!?\[(label)\]\s*\[([^\]]*)\]/)
      .replace("label", o6)
      .getRegex(),
  },
  e2 = {
    ...t2,
    escape: be(NX).replace("])", "~|])").getRegex(),
    url: be(
      /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      "i",
    )
      .replace(
        "email",
        /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      )
      .getRegex(),
    _backpedal:
      /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
  },
  Yyt = {
    ...e2,
    br: be(CX).replace("{2,}", "*").getRegex(),
    text: be(e2.text)
      .replace("\\b_", "\\b_| {2,}\\n")
      .replace(/\{2,\}/g, "*")
      .getRegex(),
  },
  c6 = { normal: Zq, gfm: Ryt, pedantic: Dyt },
  mh = { normal: t2, gfm: e2, breaks: Yyt, pedantic: zyt },
  io = class cV {
    tokens
    options
    state
    tokenizer
    inlineQueue
    constructor(t) {
      ;(this.tokens = []),
        (this.tokens.links = Object.create(null)),
        (this.options = t || eo),
        (this.options.tokenizer = this.options.tokenizer || new n6()),
        (this.tokenizer = this.options.tokenizer),
        (this.tokenizer.options = this.options),
        (this.tokenizer.lexer = this),
        (this.inlineQueue = []),
        (this.state = { inLink: !1, inRawBlock: !1, top: !0 })
      const e = { block: c6.normal, inline: mh.normal }
      this.options.pedantic
        ? ((e.block = c6.pedantic), (e.inline = mh.pedantic))
        : this.options.gfm &&
          ((e.block = c6.gfm),
          this.options.breaks ? (e.inline = mh.breaks) : (e.inline = mh.gfm)),
        (this.tokenizer.rules = e)
    }
    static get rules() {
      return { block: c6, inline: mh }
    }
    static lex(t, e) {
      return new cV(e).lex(t)
    }
    static lexInline(t, e) {
      return new cV(e).inlineTokens(t)
    }
    lex(t) {
      ;(t = t.replace(
        /\r\n|\r/g,
        `
`,
      )),
        this.blockTokens(t, this.tokens)
      for (let e = 0; e < this.inlineQueue.length; e++) {
        const s = this.inlineQueue[e]
        this.inlineTokens(s.src, s.tokens)
      }
      return (this.inlineQueue = []), this.tokens
    }
    blockTokens(t, e = [], s = !1) {
      this.options.pedantic
        ? (t = t.replace(/\t/g, "    ").replace(/^ +$/gm, ""))
        : (t = t.replace(
            /^( *)(\t+)/gm,
            (c, l, u) => l + "    ".repeat(u.length),
          ))
      let r, a, o
      for (; t; )
        if (
          !(
            this.options.extensions &&
            this.options.extensions.block &&
            this.options.extensions.block.some((c) =>
              (r = c.call({ lexer: this }, t, e))
                ? ((t = t.substring(r.raw.length)), e.push(r), !0)
                : !1,
            )
          )
        ) {
          if ((r = this.tokenizer.space(t))) {
            ;(t = t.substring(r.raw.length)),
              r.raw.length === 1 && e.length > 0
                ? (e[e.length - 1].raw += `
`)
                : e.push(r)
            continue
          }
          if ((r = this.tokenizer.code(t))) {
            ;(t = t.substring(r.raw.length)),
              (a = e[e.length - 1]),
              a && (a.type === "paragraph" || a.type === "text")
                ? ((a.raw +=
                    `
` + r.raw),
                  (a.text +=
                    `
` + r.text),
                  (this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
                : e.push(r)
            continue
          }
          if ((r = this.tokenizer.fences(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.heading(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.hr(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.blockquote(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.list(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.html(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.def(t))) {
            ;(t = t.substring(r.raw.length)),
              (a = e[e.length - 1]),
              a && (a.type === "paragraph" || a.type === "text")
                ? ((a.raw +=
                    `
` + r.raw),
                  (a.text +=
                    `
` + r.raw),
                  (this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
                : this.tokens.links[r.tag] ||
                  (this.tokens.links[r.tag] = { href: r.href, title: r.title })
            continue
          }
          if ((r = this.tokenizer.table(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.lheading(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if (
            ((o = t),
            this.options.extensions && this.options.extensions.startBlock)
          ) {
            let c = 1 / 0
            const l = t.slice(1)
            let u
            this.options.extensions.startBlock.forEach((d) => {
              ;(u = d.call({ lexer: this }, l)),
                typeof u == "number" && u >= 0 && (c = Math.min(c, u))
            }),
              c < 1 / 0 && c >= 0 && (o = t.substring(0, c + 1))
          }
          if (this.state.top && (r = this.tokenizer.paragraph(o))) {
            ;(a = e[e.length - 1]),
              s && a?.type === "paragraph"
                ? ((a.raw +=
                    `
` + r.raw),
                  (a.text +=
                    `
` + r.text),
                  this.inlineQueue.pop(),
                  (this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
                : e.push(r),
              (s = o.length !== t.length),
              (t = t.substring(r.raw.length))
            continue
          }
          if ((r = this.tokenizer.text(t))) {
            ;(t = t.substring(r.raw.length)),
              (a = e[e.length - 1]),
              a && a.type === "text"
                ? ((a.raw +=
                    `
` + r.raw),
                  (a.text +=
                    `
` + r.text),
                  this.inlineQueue.pop(),
                  (this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
                : e.push(r)
            continue
          }
          if (t) {
            const c = "Infinite loop on byte: " + t.charCodeAt(0)
            if (this.options.silent) {
              console.error(c)
              break
            } else throw new Error(c)
          }
        }
      return (this.state.top = !0), e
    }
    inline(t, e = []) {
      return this.inlineQueue.push({ src: t, tokens: e }), e
    }
    inlineTokens(t, e = []) {
      let s,
        r,
        a,
        o = t,
        c,
        l,
        u
      if (this.tokens.links) {
        const d = Object.keys(this.tokens.links)
        if (d.length > 0)
          for (
            ;
            (c = this.tokenizer.rules.inline.reflinkSearch.exec(o)) != null;

          )
            d.includes(c[0].slice(c[0].lastIndexOf("[") + 1, -1)) &&
              (o =
                o.slice(0, c.index) +
                "[" +
                "a".repeat(c[0].length - 2) +
                "]" +
                o.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
      }
      for (; (c = this.tokenizer.rules.inline.blockSkip.exec(o)) != null; )
        o =
          o.slice(0, c.index) +
          "[" +
          "a".repeat(c[0].length - 2) +
          "]" +
          o.slice(this.tokenizer.rules.inline.blockSkip.lastIndex)
      for (; (c = this.tokenizer.rules.inline.anyPunctuation.exec(o)) != null; )
        o =
          o.slice(0, c.index) +
          "++" +
          o.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex)
      for (; t; )
        if (
          (l || (u = ""),
          (l = !1),
          !(
            this.options.extensions &&
            this.options.extensions.inline &&
            this.options.extensions.inline.some((d) =>
              (s = d.call({ lexer: this }, t, e))
                ? ((t = t.substring(s.raw.length)), e.push(s), !0)
                : !1,
            )
          ))
        ) {
          if ((s = this.tokenizer.escape(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.tag(t))) {
            ;(t = t.substring(s.raw.length)),
              (r = e[e.length - 1]),
              r && s.type === "text" && r.type === "text"
                ? ((r.raw += s.raw), (r.text += s.text))
                : e.push(s)
            continue
          }
          if ((s = this.tokenizer.link(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.reflink(t, this.tokens.links))) {
            ;(t = t.substring(s.raw.length)),
              (r = e[e.length - 1]),
              r && s.type === "text" && r.type === "text"
                ? ((r.raw += s.raw), (r.text += s.text))
                : e.push(s)
            continue
          }
          if ((s = this.tokenizer.emStrong(t, o, u))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.codespan(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.br(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.del(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.autolink(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if (!this.state.inLink && (s = this.tokenizer.url(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if (
            ((a = t),
            this.options.extensions && this.options.extensions.startInline)
          ) {
            let d = 1 / 0
            const m = t.slice(1)
            let f
            this.options.extensions.startInline.forEach((p) => {
              ;(f = p.call({ lexer: this }, m)),
                typeof f == "number" && f >= 0 && (d = Math.min(d, f))
            }),
              d < 1 / 0 && d >= 0 && (a = t.substring(0, d + 1))
          }
          if ((s = this.tokenizer.inlineText(a))) {
            ;(t = t.substring(s.raw.length)),
              s.raw.slice(-1) !== "_" && (u = s.raw.slice(-1)),
              (l = !0),
              (r = e[e.length - 1]),
              r && r.type === "text"
                ? ((r.raw += s.raw), (r.text += s.text))
                : e.push(s)
            continue
          }
          if (t) {
            const d = "Infinite loop on byte: " + t.charCodeAt(0)
            if (this.options.silent) {
              console.error(d)
              break
            } else throw new Error(d)
          }
        }
      return e
    }
  },
  l6 = class {
    options
    parser
    constructor(i) {
      this.options = i || eo
    }
    space(i) {
      return ""
    }
    code({ text: i, lang: t, escaped: e }) {
      const s = (t || "").match(/^\S*/)?.[0],
        r =
          i.replace(/\n$/, "") +
          `
`
      return s
        ? '<pre><code class="language-' +
            vs(s) +
            '">' +
            (e ? r : vs(r, !0)) +
            `</code></pre>
`
        : "<pre><code>" +
            (e ? r : vs(r, !0)) +
            `</code></pre>
`
    }
    blockquote({ tokens: i }) {
      return `<blockquote>
${this.parser.parse(i)}</blockquote>
`
    }
    html({ text: i }) {
      return i
    }
    heading({ tokens: i, depth: t }) {
      return `<h${t}>${this.parser.parseInline(i)}</h${t}>
`
    }
    hr(i) {
      return `<hr>
`
    }
    list(i) {
      const t = i.ordered,
        e = i.start
      let s = ""
      for (let o = 0; o < i.items.length; o++) {
        const c = i.items[o]
        s += this.listitem(c)
      }
      const r = t ? "ol" : "ul",
        a = t && e !== 1 ? ' start="' + e + '"' : ""
      return (
        "<" +
        r +
        a +
        `>
` +
        s +
        "</" +
        r +
        `>
`
      )
    }
    listitem(i) {
      let t = ""
      if (i.task) {
        const e = this.checkbox({ checked: !!i.checked })
        i.loose
          ? i.tokens.length > 0 && i.tokens[0].type === "paragraph"
            ? ((i.tokens[0].text = e + " " + i.tokens[0].text),
              i.tokens[0].tokens &&
                i.tokens[0].tokens.length > 0 &&
                i.tokens[0].tokens[0].type === "text" &&
                (i.tokens[0].tokens[0].text =
                  e + " " + i.tokens[0].tokens[0].text))
            : i.tokens.unshift({ type: "text", raw: e + " ", text: e + " " })
          : (t += e + " ")
      }
      return (
        (t += this.parser.parse(i.tokens, !!i.loose)),
        `<li>${t}</li>
`
      )
    }
    checkbox({ checked: i }) {
      return (
        "<input " + (i ? 'checked="" ' : "") + 'disabled="" type="checkbox">'
      )
    }
    paragraph({ tokens: i }) {
      return `<p>${this.parser.parseInline(i)}</p>
`
    }
    table(i) {
      let t = "",
        e = ""
      for (let r = 0; r < i.header.length; r++) e += this.tablecell(i.header[r])
      t += this.tablerow({ text: e })
      let s = ""
      for (let r = 0; r < i.rows.length; r++) {
        const a = i.rows[r]
        e = ""
        for (let o = 0; o < a.length; o++) e += this.tablecell(a[o])
        s += this.tablerow({ text: e })
      }
      return (
        s && (s = `<tbody>${s}</tbody>`),
        `<table>
<thead>
` +
          t +
          `</thead>
` +
          s +
          `</table>
`
      )
    }
    tablerow({ text: i }) {
      return `<tr>
${i}</tr>
`
    }
    tablecell(i) {
      const t = this.parser.parseInline(i.tokens),
        e = i.header ? "th" : "td"
      return (
        (i.align ? `<${e} align="${i.align}">` : `<${e}>`) +
        t +
        `</${e}>
`
      )
    }
    strong({ tokens: i }) {
      return `<strong>${this.parser.parseInline(i)}</strong>`
    }
    em({ tokens: i }) {
      return `<em>${this.parser.parseInline(i)}</em>`
    }
    codespan({ text: i }) {
      return `<code>${i}</code>`
    }
    br(i) {
      return "<br>"
    }
    del({ tokens: i }) {
      return `<del>${this.parser.parseInline(i)}</del>`
    }
    link({ href: i, title: t, tokens: e }) {
      const s = this.parser.parseInline(e),
        r = kX(i)
      if (r === null) return s
      i = r
      let a = '<a href="' + i + '"'
      return t && (a += ' title="' + t + '"'), (a += ">" + s + "</a>"), a
    }
    image({ href: i, title: t, text: e }) {
      const s = kX(i)
      if (s === null) return e
      i = s
      let r = `<img src="${i}" alt="${e}"`
      return t && (r += ` title="${t}"`), (r += ">"), r
    }
    text(i) {
      return "tokens" in i && i.tokens
        ? this.parser.parseInline(i.tokens)
        : i.text
    }
  },
  i2 = class {
    strong({ text: i }) {
      return i
    }
    em({ text: i }) {
      return i
    }
    codespan({ text: i }) {
      return i
    }
    del({ text: i }) {
      return i
    }
    html({ text: i }) {
      return i
    }
    text({ text: i }) {
      return i
    }
    link({ text: i }) {
      return "" + i
    }
    image({ text: i }) {
      return "" + i
    }
    br() {
      return ""
    }
  },
  so = class lV {
    options
    renderer
    textRenderer
    constructor(t) {
      ;(this.options = t || eo),
        (this.options.renderer = this.options.renderer || new l6()),
        (this.renderer = this.options.renderer),
        (this.renderer.options = this.options),
        (this.renderer.parser = this),
        (this.textRenderer = new i2())
    }
    static parse(t, e) {
      return new lV(e).parse(t)
    }
    static parseInline(t, e) {
      return new lV(e).parseInline(t)
    }
    parse(t, e = !0) {
      let s = ""
      for (let r = 0; r < t.length; r++) {
        const a = t[r]
        if (
          this.options.extensions &&
          this.options.extensions.renderers &&
          this.options.extensions.renderers[a.type]
        ) {
          const c = a,
            l = this.options.extensions.renderers[c.type].call(
              { parser: this },
              c,
            )
          if (
            l !== !1 ||
            ![
              "space",
              "hr",
              "heading",
              "code",
              "table",
              "blockquote",
              "list",
              "html",
              "paragraph",
              "text",
            ].includes(c.type)
          ) {
            s += l || ""
            continue
          }
        }
        const o = a
        switch (o.type) {
          case "space": {
            s += this.renderer.space(o)
            continue
          }
          case "hr": {
            s += this.renderer.hr(o)
            continue
          }
          case "heading": {
            s += this.renderer.heading(o)
            continue
          }
          case "code": {
            s += this.renderer.code(o)
            continue
          }
          case "table": {
            s += this.renderer.table(o)
            continue
          }
          case "blockquote": {
            s += this.renderer.blockquote(o)
            continue
          }
          case "list": {
            s += this.renderer.list(o)
            continue
          }
          case "html": {
            s += this.renderer.html(o)
            continue
          }
          case "paragraph": {
            s += this.renderer.paragraph(o)
            continue
          }
          case "text": {
            let c = o,
              l = this.renderer.text(c)
            for (; r + 1 < t.length && t[r + 1].type === "text"; )
              (c = t[++r]),
                (l +=
                  `
` + this.renderer.text(c))
            e
              ? (s += this.renderer.paragraph({
                  type: "paragraph",
                  raw: l,
                  text: l,
                  tokens: [{ type: "text", raw: l, text: l }],
                }))
              : (s += l)
            continue
          }
          default: {
            const c = 'Token with "' + o.type + '" type was not found.'
            if (this.options.silent) return console.error(c), ""
            throw new Error(c)
          }
        }
      }
      return s
    }
    parseInline(t, e) {
      e = e || this.renderer
      let s = ""
      for (let r = 0; r < t.length; r++) {
        const a = t[r]
        if (
          this.options.extensions &&
          this.options.extensions.renderers &&
          this.options.extensions.renderers[a.type]
        ) {
          const c = this.options.extensions.renderers[a.type].call(
            { parser: this },
            a,
          )
          if (
            c !== !1 ||
            ![
              "escape",
              "html",
              "link",
              "image",
              "strong",
              "em",
              "codespan",
              "br",
              "del",
              "text",
            ].includes(a.type)
          ) {
            s += c || ""
            continue
          }
        }
        const o = a
        switch (o.type) {
          case "escape": {
            s += e.text(o)
            break
          }
          case "html": {
            s += e.html(o)
            break
          }
          case "link": {
            s += e.link(o)
            break
          }
          case "image": {
            s += e.image(o)
            break
          }
          case "strong": {
            s += e.strong(o)
            break
          }
          case "em": {
            s += e.em(o)
            break
          }
          case "codespan": {
            s += e.codespan(o)
            break
          }
          case "br": {
            s += e.br(o)
            break
          }
          case "del": {
            s += e.del(o)
            break
          }
          case "text": {
            s += e.text(o)
            break
          }
          default: {
            const c = 'Token with "' + o.type + '" type was not found.'
            if (this.options.silent) return console.error(c), ""
            throw new Error(c)
          }
        }
      }
      return s
    }
  },
  u6 = class {
    options
    constructor(i) {
      this.options = i || eo
    }
    static passThroughHooks = new Set([
      "preprocess",
      "postprocess",
      "processAllTokens",
    ])
    preprocess(i) {
      return i
    }
    postprocess(i) {
      return i
    }
    processAllTokens(i) {
      return i
    }
  },
  Qyt = class {
    defaults = Yq()
    options = this.setOptions
    parse = this.parseMarkdown(io.lex, so.parse)
    parseInline = this.parseMarkdown(io.lexInline, so.parseInline)
    Parser = so
    Renderer = l6
    TextRenderer = i2
    Lexer = io
    Tokenizer = n6
    Hooks = u6
    constructor(...i) {
      this.use(...i)
    }
    walkTokens(i, t) {
      let e = []
      for (const s of i)
        switch (((e = e.concat(t.call(this, s))), s.type)) {
          case "table": {
            const r = s
            for (const a of r.header) e = e.concat(this.walkTokens(a.tokens, t))
            for (const a of r.rows)
              for (const o of a) e = e.concat(this.walkTokens(o.tokens, t))
            break
          }
          case "list": {
            const r = s
            e = e.concat(this.walkTokens(r.items, t))
            break
          }
          default: {
            const r = s
            this.defaults.extensions?.childTokens?.[r.type]
              ? this.defaults.extensions.childTokens[r.type].forEach((a) => {
                  const o = r[a].flat(1 / 0)
                  e = e.concat(this.walkTokens(o, t))
                })
              : r.tokens && (e = e.concat(this.walkTokens(r.tokens, t)))
          }
        }
      return e
    }
    use(...i) {
      const t = this.defaults.extensions || { renderers: {}, childTokens: {} }
      return (
        i.forEach((e) => {
          const s = { ...e }
          if (
            ((s.async = this.defaults.async || s.async || !1),
            e.extensions &&
              (e.extensions.forEach((r) => {
                if (!r.name) throw new Error("extension name required")
                if ("renderer" in r) {
                  const a = t.renderers[r.name]
                  a
                    ? (t.renderers[r.name] = function (...o) {
                        let c = r.renderer.apply(this, o)
                        return c === !1 && (c = a.apply(this, o)), c
                      })
                    : (t.renderers[r.name] = r.renderer)
                }
                if ("tokenizer" in r) {
                  if (!r.level || (r.level !== "block" && r.level !== "inline"))
                    throw new Error(
                      "extension level must be 'block' or 'inline'",
                    )
                  const a = t[r.level]
                  a ? a.unshift(r.tokenizer) : (t[r.level] = [r.tokenizer]),
                    r.start &&
                      (r.level === "block"
                        ? t.startBlock
                          ? t.startBlock.push(r.start)
                          : (t.startBlock = [r.start])
                        : r.level === "inline" &&
                          (t.startInline
                            ? t.startInline.push(r.start)
                            : (t.startInline = [r.start])))
                }
                "childTokens" in r &&
                  r.childTokens &&
                  (t.childTokens[r.name] = r.childTokens)
              }),
              (s.extensions = t)),
            e.renderer)
          ) {
            const r = this.defaults.renderer || new l6(this.defaults)
            for (const a in e.renderer) {
              if (!(a in r)) throw new Error(`renderer '${a}' does not exist`)
              if (["options", "parser"].includes(a)) continue
              const o = a,
                c = e.renderer[o],
                l = r[o]
              r[o] = (...u) => {
                let d = c.apply(r, u)
                return d === !1 && (d = l.apply(r, u)), d || ""
              }
            }
            s.renderer = r
          }
          if (e.tokenizer) {
            const r = this.defaults.tokenizer || new n6(this.defaults)
            for (const a in e.tokenizer) {
              if (!(a in r)) throw new Error(`tokenizer '${a}' does not exist`)
              if (["options", "rules", "lexer"].includes(a)) continue
              const o = a,
                c = e.tokenizer[o],
                l = r[o]
              r[o] = (...u) => {
                let d = c.apply(r, u)
                return d === !1 && (d = l.apply(r, u)), d
              }
            }
            s.tokenizer = r
          }
          if (e.hooks) {
            const r = this.defaults.hooks || new u6()
            for (const a in e.hooks) {
              if (!(a in r)) throw new Error(`hook '${a}' does not exist`)
              if (a === "options") continue
              const o = a,
                c = e.hooks[o],
                l = r[o]
              u6.passThroughHooks.has(a)
                ? (r[o] = (u) => {
                    if (this.defaults.async)
                      return Promise.resolve(c.call(r, u)).then((m) =>
                        l.call(r, m),
                      )
                    const d = c.call(r, u)
                    return l.call(r, d)
                  })
                : (r[o] = (...u) => {
                    let d = c.apply(r, u)
                    return d === !1 && (d = l.apply(r, u)), d
                  })
            }
            s.hooks = r
          }
          if (e.walkTokens) {
            const r = this.defaults.walkTokens,
              a = e.walkTokens
            s.walkTokens = function (o) {
              let c = []
              return (
                c.push(a.call(this, o)), r && (c = c.concat(r.call(this, o))), c
              )
            }
          }
          this.defaults = { ...this.defaults, ...s }
        }),
        this
      )
    }
    setOptions(i) {
      return (this.defaults = { ...this.defaults, ...i }), this
    }
    lexer(i, t) {
      return io.lex(i, t ?? this.defaults)
    }
    parser(i, t) {
      return so.parse(i, t ?? this.defaults)
    }
    parseMarkdown(i, t) {
      return (s, r) => {
        const a = { ...r },
          o = { ...this.defaults, ...a },
          c = this.onError(!!o.silent, !!o.async)
        if (this.defaults.async === !0 && a.async === !1)
          return c(
            new Error(
              "marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.",
            ),
          )
        if (typeof s > "u" || s === null)
          return c(new Error("marked(): input parameter is undefined or null"))
        if (typeof s != "string")
          return c(
            new Error(
              "marked(): input parameter is of type " +
                Object.prototype.toString.call(s) +
                ", string expected",
            ),
          )
        if ((o.hooks && (o.hooks.options = o), o.async))
          return Promise.resolve(o.hooks ? o.hooks.preprocess(s) : s)
            .then((l) => i(l, o))
            .then((l) => (o.hooks ? o.hooks.processAllTokens(l) : l))
            .then((l) =>
              o.walkTokens
                ? Promise.all(this.walkTokens(l, o.walkTokens)).then(() => l)
                : l,
            )
            .then((l) => t(l, o))
            .then((l) => (o.hooks ? o.hooks.postprocess(l) : l))
            .catch(c)
        try {
          o.hooks && (s = o.hooks.preprocess(s))
          let l = i(s, o)
          o.hooks && (l = o.hooks.processAllTokens(l)),
            o.walkTokens && this.walkTokens(l, o.walkTokens)
          let u = t(l, o)
          return o.hooks && (u = o.hooks.postprocess(u)), u
        } catch (l) {
          return c(l)
        }
      }
    }
    onError(i, t) {
      return (e) => {
        if (
          ((e.message += `
Please report this to https://github.com/markedjs/marked.`),
          i)
        ) {
          const s =
            "<p>An error occurred:</p><pre>" + vs(e.message + "", !0) + "</pre>"
          return t ? Promise.resolve(s) : s
        }
        if (t) return Promise.reject(e)
        throw e
      }
    }
  },
  ro = new Qyt()
function ve(i, t) {
  return ro.parse(i, t)
}
;(ve.options = ve.setOptions =
  function (i) {
    return ro.setOptions(i), (ve.defaults = ro.defaults), wX(ve.defaults), ve
  }),
  (ve.getDefaults = Yq),
  (ve.defaults = eo),
  (ve.use = function (...i) {
    return ro.use(...i), (ve.defaults = ro.defaults), wX(ve.defaults), ve
  }),
  (ve.walkTokens = function (i, t) {
    return ro.walkTokens(i, t)
  }),
  (ve.parseInline = ro.parseInline),
  (ve.Parser = so),
  (ve.parser = so.parse),
  (ve.Renderer = l6),
  (ve.TextRenderer = i2),
  (ve.Lexer = io),
  (ve.lexer = io.lex),
  (ve.Tokenizer = n6),
  (ve.Hooks = u6),
  (ve.parse = ve)
var IVt = ve.options,
  PVt = ve.setOptions,
  $Vt = ve.use,
  xVt = ve.walkTokens,
  NVt = ve.parseInline,
  CVt = so.parse,
  JVt = io.lex,
  cn = Object.freeze({
    text: "text/plain",
    binary: "application/octet-stream",
    unknown: "application/unknown",
    markdown: "text/markdown",
    latex: "text/latex",
    uriList: "text/uri-list",
  }),
  Xyt = /^(.+)\/(.+?)(;.+)?$/
function RX(i, t) {
  const e = Xyt.exec(i)
  return e
    ? `${e[1].toLowerCase()}/${e[2].toLowerCase()}${e[3] ?? ""}`
    : t
      ? void 0
      : i
}
var _i = Symbol("unset"),
  Kyt = class {
    constructor() {
      ;(this.root = new s2()), (this.a = 0)
    }
    get size() {
      return this.a
    }
    get nodes() {
      return this.root.children?.values() || ms.empty()
    }
    get entries() {
      return this.root.children?.entries() || ms.empty()
    }
    insert(i, t, e) {
      this.c(i, (s) => (s._value = t), e)
    }
    mutate(i, t) {
      this.c(i, (e) => (e._value = t(e._value === _i ? void 0 : e._value)))
    }
    mutatePath(i, t) {
      this.c(
        i,
        () => {},
        (e) => t(e),
      )
    }
    delete(i) {
      const t = this.b(i)
      if (!t) return
      let e = t.length - 1
      const s = t[e].node._value
      if (s !== _i) {
        for (this.a--, t[e].node._value = _i; e > 0; e--) {
          const { node: r, part: a } = t[e]
          if (r.children?.size || r._value !== _i) break
          t[e - 1].node.children.delete(a)
        }
        return s
      }
    }
    *deleteRecursive(i) {
      const t = this.b(i)
      if (!t) return
      const e = t[t.length - 1].node
      for (let s = t.length - 1; s > 0; s--) {
        const r = t[s - 1]
        if (
          (r.node.children.delete(t[s].part),
          r.node.children.size > 0 || r.node._value !== _i)
        )
          break
      }
      for (const s of DX(e)) s._value !== _i && (this.a--, yield s._value)
      e === this.root &&
        ((this.root._value = _i), (this.root.children = void 0))
    }
    find(i) {
      let t = this.root
      for (const e of i) {
        const s = t.children?.get(e)
        if (!s) return
        t = s
      }
      return t._value === _i ? void 0 : t._value
    }
    hasKeyOrParent(i) {
      let t = this.root
      for (const e of i) {
        const s = t.children?.get(e)
        if (!s) return !1
        if (s._value !== _i) return !0
        t = s
      }
      return !1
    }
    hasKeyOrChildren(i) {
      let t = this.root
      for (const e of i) {
        const s = t.children?.get(e)
        if (!s) return !1
        t = s
      }
      return !0
    }
    hasKey(i) {
      let t = this.root
      for (const e of i) {
        const s = t.children?.get(e)
        if (!s) return !1
        t = s
      }
      return t._value !== _i
    }
    b(i) {
      const t = [{ part: "", node: this.root }]
      let e = 0
      for (const s of i) {
        const r = t[e].node.children?.get(s)
        if (!r) return
        t.push({ part: s, node: r }), e++
      }
      return t
    }
    c(i, t, e) {
      let s = this.root
      for (const o of i) {
        if (s.children)
          if (s.children.has(o)) s = s.children.get(o)
          else {
            const c = new s2()
            s.children.set(o, c), (s = c)
          }
        else {
          const c = new s2()
          ;(s.children = new Map([[o, c]])), (s = c)
        }
        e?.(s)
      }
      const r = s._value === _i ? 0 : 1
      t(s)
      const a = s._value === _i ? 0 : 1
      this.a += a - r
    }
    *values() {
      for (const { _value: i } of DX(this.root)) i !== _i && (yield i)
    }
  }
function* DX(i) {
  const t = [i]
  for (; t.length > 0; ) {
    const e = t.pop()
    if ((yield e, e.children)) for (const s of e.children.values()) t.push(s)
  }
}
var s2 = class {
    constructor() {
      this._value = _i
    }
    get value() {
      return this._value === _i ? void 0 : this._value
    }
    set value(i) {
      this._value = i === void 0 ? _i : i
    }
  },
  ws = class Yo {
    constructor(t, e) {
      ;(this.lineNumber = t), (this.column = e)
    }
    with(t = this.lineNumber, e = this.column) {
      return t === this.lineNumber && e === this.column ? this : new Yo(t, e)
    }
    delta(t = 0, e = 0) {
      return this.with(this.lineNumber + t, this.column + e)
    }
    equals(t) {
      return Yo.equals(this, t)
    }
    static equals(t, e) {
      return !t && !e
        ? !0
        : !!t && !!e && t.lineNumber === e.lineNumber && t.column === e.column
    }
    isBefore(t) {
      return Yo.isBefore(this, t)
    }
    static isBefore(t, e) {
      return t.lineNumber < e.lineNumber
        ? !0
        : e.lineNumber < t.lineNumber
          ? !1
          : t.column < e.column
    }
    isBeforeOrEqual(t) {
      return Yo.isBeforeOrEqual(this, t)
    }
    static isBeforeOrEqual(t, e) {
      return t.lineNumber < e.lineNumber
        ? !0
        : e.lineNumber < t.lineNumber
          ? !1
          : t.column <= e.column
    }
    static compare(t, e) {
      const s = t.lineNumber | 0,
        r = e.lineNumber | 0
      if (s === r) {
        const a = t.column | 0,
          o = e.column | 0
        return a - o
      }
      return s - r
    }
    clone() {
      return new Yo(this.lineNumber, this.column)
    }
    toString() {
      return "(" + this.lineNumber + "," + this.column + ")"
    }
    static lift(t) {
      return new Yo(t.lineNumber, t.column)
    }
    static isIPosition(t) {
      return t && typeof t.lineNumber == "number" && typeof t.column == "number"
    }
    toJSON() {
      return { lineNumber: this.lineNumber, column: this.column }
    }
  },
  ue = class Re {
    constructor(t, e, s, r) {
      let a, o, c, l
      t == null || typeof t == "number" || Number.isNaN(t)
        ? ((a = t), (o = e), (c = s), (l = r))
        : "startLineNumber" in t && "startColumn" in t
          ? ((a = t.startLineNumber),
            (o = t.startColumn),
            (c = t.endLineNumber),
            (l = t.endColumn))
          : ((a = t.startLineNumber),
            (o = 1),
            (c = t.endLineNumberExclusive),
            (l = 1)),
        a > c || (a === c && o > l)
          ? ((this.startLineNumber = c),
            (this.startColumn = l),
            (this.endLineNumber = a),
            (this.endColumn = o))
          : ((this.startLineNumber = a),
            (this.startColumn = o),
            (this.endLineNumber = c),
            (this.endColumn = l))
    }
    asIRange() {
      return {
        startLineNumber: this.startLineNumber,
        startColumn: this.startColumn,
        endLineNumber: this.endLineNumber,
        endColumn: this.endColumn,
      }
    }
    isEmpty() {
      return Re.isEmpty(this)
    }
    static isEmpty(t) {
      return (
        t.startLineNumber === t.endLineNumber && t.startColumn === t.endColumn
      )
    }
    containsPosition(t) {
      return Re.containsPosition(this, t)
    }
    static containsPosition(t, e) {
      return !(
        e.lineNumber < t.startLineNumber ||
        e.lineNumber > t.endLineNumber ||
        (e.lineNumber === t.startLineNumber && e.column < t.startColumn) ||
        (e.lineNumber === t.endLineNumber && e.column > t.endColumn)
      )
    }
    static strictContainsPosition(t, e) {
      return !(
        e.lineNumber < t.startLineNumber ||
        e.lineNumber > t.endLineNumber ||
        (e.lineNumber === t.startLineNumber && e.column <= t.startColumn) ||
        (e.lineNumber === t.endLineNumber && e.column >= t.endColumn)
      )
    }
    containsRange(t) {
      return Re.containsRange(this, t)
    }
    static containsRange(t, e) {
      return !(
        e.startLineNumber < t.startLineNumber ||
        e.endLineNumber < t.startLineNumber ||
        e.startLineNumber > t.endLineNumber ||
        e.endLineNumber > t.endLineNumber ||
        (e.startLineNumber === t.startLineNumber &&
          e.startColumn < t.startColumn) ||
        (e.endLineNumber === t.endLineNumber && e.endColumn > t.endColumn)
      )
    }
    strictContainsRange(t) {
      return Re.strictContainsRange(this, t)
    }
    static strictContainsRange(t, e) {
      return !(
        e.startLineNumber < t.startLineNumber ||
        e.endLineNumber < t.startLineNumber ||
        e.startLineNumber > t.endLineNumber ||
        e.endLineNumber > t.endLineNumber ||
        (e.startLineNumber === t.startLineNumber &&
          e.startColumn <= t.startColumn) ||
        (e.endLineNumber === t.endLineNumber && e.endColumn >= t.endColumn)
      )
    }
    plusRange(t) {
      return Re.plusRange(this, t)
    }
    static getRangeAbove(t, e) {
      const s = Math.max(t.startLineNumber - e, 1),
        r = t.startLineNumber
      return new Re(s, t.startColumn, r, t.startColumn)
    }
    static getRangeOnBelow(t, e, s) {
      const r = t.endLineNumber,
        a = Math.min(t.endLineNumber + e, s)
      return new Re(r, t.endColumn, a, t.endColumn)
    }
    static getExtendedRange(t, e, s) {
      const r = Math.max(t.startLineNumber - e, 0),
        a = Math.min(t.endLineNumber + e, s)
      return new Re(r, t.startColumn, a, t.endColumn)
    }
    static plusRange(t, e) {
      let s, r, a, o
      return (
        e.startLineNumber < t.startLineNumber
          ? ((s = e.startLineNumber), (r = e.startColumn))
          : e.startLineNumber === t.startLineNumber
            ? ((s = e.startLineNumber),
              (r = Math.min(e.startColumn, t.startColumn)))
            : ((s = t.startLineNumber), (r = t.startColumn)),
        e.endLineNumber > t.endLineNumber
          ? ((a = e.endLineNumber), (o = e.endColumn))
          : e.endLineNumber === t.endLineNumber
            ? ((a = e.endLineNumber), (o = Math.max(e.endColumn, t.endColumn)))
            : ((a = t.endLineNumber), (o = t.endColumn)),
        new Re(s, r, a, o)
      )
    }
    intersectRanges(t) {
      return Re.intersectRanges(this, t)
    }
    static intersectRanges(t, e) {
      let s = t.startLineNumber,
        r = t.startColumn,
        a = t.endLineNumber,
        o = t.endColumn
      const c = e.startLineNumber,
        l = e.startColumn,
        u = e.endLineNumber,
        d = e.endColumn
      return (
        s < c ? ((s = c), (r = l)) : s === c && (r = Math.max(r, l)),
        a > u ? ((a = u), (o = d)) : a === u && (o = Math.min(o, d)),
        s > a || (s === a && r > o) ? null : new Re(s, r, a, o)
      )
    }
    static inverseEditRange(t, e) {
      return {
        startLineNumber: t.startLineNumber,
        startColumn: t.startColumn,
        endLineNumber:
          t.startLineNumber +
          e.split(`
`).length -
          1,
        endColumn:
          e.lastIndexOf(`
`) === -1
            ? t.startColumn + e.length
            : e.length -
              e.lastIndexOf(`
`),
      }
    }
    whereIs(t) {
      return t.endLineNumber < this.startLineNumber ||
        (t.endLineNumber === this.startLineNumber &&
          t.endColumn <= this.startColumn)
        ? "before"
        : t.startLineNumber > this.endLineNumber ||
            (t.startLineNumber === this.endLineNumber &&
              t.startColumn >= this.endColumn)
          ? "after"
          : "overlapping"
    }
    static rangeAfterEdit(t, e) {
      const s = Re.lift(t).whereIs(e.range)
      switch (s) {
        case "overlapping":
          throw new Error(
            "Range is overlapping. The range after edit is ambiguous.",
          )
        case "after":
          return t
        case "before": {
          const r =
            e.text.split(`
`).length -
            1 -
            (e.range.endLineNumber - e.range.startLineNumber)
          if (e.range.endLineNumber < t.startLineNumber)
            return {
              startLineNumber: t.startLineNumber + r,
              startColumn: t.startColumn,
              endLineNumber: t.endLineNumber + r,
              endColumn: t.endColumn,
            }
          {
            const a =
                e.text.lastIndexOf(`
`) === -1
                  ? e.text.length
                  : e.text.length -
                    e.text.lastIndexOf(`
`) -
                    1,
              o =
                e.range.startLineNumber === e.range.endLineNumber
                  ? e.range.endColumn - e.range.startColumn
                  : e.range.endColumn - 1,
              c = a - o
            return {
              startLineNumber: t.startLineNumber + r,
              startColumn: t.startColumn + c,
              endLineNumber: t.endLineNumber + r,
              endColumn:
                t.startLineNumber === t.endLineNumber
                  ? t.endColumn + c
                  : t.endColumn,
            }
          }
        }
        default: {
          const r = s
          return t
        }
      }
    }
    equalsRange(t) {
      return Re.equalsRange(this, t)
    }
    static equalsRange(t, e) {
      return !t && !e
        ? !0
        : !!t &&
            !!e &&
            t.startLineNumber === e.startLineNumber &&
            t.startColumn === e.startColumn &&
            t.endLineNumber === e.endLineNumber &&
            t.endColumn === e.endColumn
    }
    getEndPosition() {
      return Re.getEndPosition(this)
    }
    static getEndPosition(t) {
      return new ws(t.endLineNumber, t.endColumn)
    }
    getStartPosition() {
      return Re.getStartPosition(this)
    }
    static getStartPosition(t) {
      return new ws(t.startLineNumber, t.startColumn)
    }
    toString() {
      return (
        "[" +
        this.startLineNumber +
        "," +
        this.startColumn +
        " -> " +
        this.endLineNumber +
        "," +
        this.endColumn +
        "]"
      )
    }
    setEndPosition(t, e) {
      return new Re(this.startLineNumber, this.startColumn, t, e)
    }
    setStartPosition(t, e) {
      return new Re(t, e, this.endLineNumber, this.endColumn)
    }
    collapseToStart() {
      return Re.collapseToStart(this)
    }
    static collapseToStart(t) {
      return new Re(
        t.startLineNumber,
        t.startColumn,
        t.startLineNumber,
        t.startColumn,
      )
    }
    collapseToEnd() {
      return Re.collapseToEnd(this)
    }
    static collapseToEnd(t) {
      return new Re(t.endLineNumber, t.endColumn, t.endLineNumber, t.endColumn)
    }
    delta(t) {
      return new Re(
        this.startLineNumber + t,
        this.startColumn,
        this.endLineNumber + t,
        this.endColumn,
      )
    }
    static fromPositions(t, e = t) {
      return new Re(t.lineNumber, t.column, e.lineNumber, e.column)
    }
    static lift(t) {
      return t
        ? new Re(t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn)
        : null
    }
    static isIRange(t) {
      return (
        t &&
        typeof t.startLineNumber == "number" &&
        typeof t.startColumn == "number" &&
        typeof t.endLineNumber == "number" &&
        typeof t.endColumn == "number"
      )
    }
    static areIntersectingOrTouching(t, e) {
      return !(
        t.endLineNumber < e.startLineNumber ||
        (t.endLineNumber === e.startLineNumber &&
          t.endColumn < e.startColumn) ||
        e.endLineNumber < t.startLineNumber ||
        (e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn)
      )
    }
    static areIntersecting(t, e) {
      return !(
        t.endLineNumber < e.startLineNumber ||
        (t.endLineNumber === e.startLineNumber &&
          t.endColumn <= e.startColumn) ||
        e.endLineNumber < t.startLineNumber ||
        (e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn)
      )
    }
    static compareRangesUsingStarts(t, e) {
      if (t && e) {
        const a = t.startLineNumber | 0,
          o = e.startLineNumber | 0
        if (a === o) {
          const c = t.startColumn | 0,
            l = e.startColumn | 0
          if (c === l) {
            const u = t.endLineNumber | 0,
              d = e.endLineNumber | 0
            if (u === d) {
              const m = t.endColumn | 0,
                f = e.endColumn | 0
              return m - f
            }
            return u - d
          }
          return c - l
        }
        return a - o
      }
      return (t ? 1 : 0) - (e ? 1 : 0)
    }
    static compareRangesUsingEnds(t, e) {
      return t.endLineNumber === e.endLineNumber
        ? t.endColumn === e.endColumn
          ? t.startLineNumber === e.startLineNumber
            ? t.startColumn - e.startColumn
            : t.startLineNumber - e.startLineNumber
          : t.endColumn - e.endColumn
        : t.endLineNumber - e.endLineNumber
    }
    static spansMultipleLines(t) {
      return t.endLineNumber > t.startLineNumber
    }
    toJSON() {
      return this
    }
  },
  FX = class {
    constructor() {
      ;(this.a = new Map()),
        (this.b = new Map()),
        (this.c = new J()),
        (this.onDidChange = this.c.event),
        (this.d = null)
    }
    handleChange(i) {
      this.c.fire({ changedLanguages: i, changedColorMap: !1 })
    }
    register(i, t) {
      return (
        this.a.set(i, t),
        this.handleChange([i]),
        et(() => {
          this.a.get(i) === t && (this.a.delete(i), this.handleChange([i]))
        })
      )
    }
    get(i) {
      return this.a.get(i) || null
    }
    registerFactory(i, t) {
      this.b.get(i)?.dispose()
      const e = new Zyt(this, i, t)
      return (
        this.b.set(i, e),
        et(() => {
          const s = this.b.get(i)
          !s || s !== e || (this.b.delete(i), s.dispose())
        })
      )
    }
    async getOrCreate(i) {
      const t = this.get(i)
      if (t) return t
      const e = this.b.get(i)
      return !e || e.isResolved ? null : (await e.resolve(), this.get(i))
    }
    isResolved(i) {
      if (this.get(i)) return !0
      const e = this.b.get(i)
      return !!(!e || e.isResolved)
    }
    setColorMap(i) {
      ;(this.d = i),
        this.c.fire({
          changedLanguages: Array.from(this.a.keys()),
          changedColorMap: !0,
        })
    }
    getColorMap() {
      return this.d
    }
    getDefaultBackground() {
      return this.d && this.d.length > 2 ? this.d[2] : null
    }
  },
  Zyt = class extends at {
    get isResolved() {
      return this.c
    }
    constructor(i, t, e) {
      super(),
        (this.f = i),
        (this.g = t),
        (this.h = e),
        (this.a = !1),
        (this.b = null),
        (this.c = !1)
    }
    dispose() {
      ;(this.a = !0), super.dispose()
    }
    async resolve() {
      return this.b || (this.b = this.j()), this.b
    }
    async j() {
      const i = await this.h.tokenizationSupport
      ;(this.c = !0), i && !this.a && this.D(this.f.register(this.g, i))
    }
  },
  AX
;(function (i) {
  ;(i[(i.Increase = 0)] = "Increase"), (i[(i.Decrease = 1)] = "Decrease")
})(AX || (AX = {}))
var _X
;(function (i) {
  ;(i[(i.Method = 0)] = "Method"),
    (i[(i.Function = 1)] = "Function"),
    (i[(i.Constructor = 2)] = "Constructor"),
    (i[(i.Field = 3)] = "Field"),
    (i[(i.Variable = 4)] = "Variable"),
    (i[(i.Class = 5)] = "Class"),
    (i[(i.Struct = 6)] = "Struct"),
    (i[(i.Interface = 7)] = "Interface"),
    (i[(i.Module = 8)] = "Module"),
    (i[(i.Property = 9)] = "Property"),
    (i[(i.Event = 10)] = "Event"),
    (i[(i.Operator = 11)] = "Operator"),
    (i[(i.Unit = 12)] = "Unit"),
    (i[(i.Value = 13)] = "Value"),
    (i[(i.Constant = 14)] = "Constant"),
    (i[(i.Enum = 15)] = "Enum"),
    (i[(i.EnumMember = 16)] = "EnumMember"),
    (i[(i.Keyword = 17)] = "Keyword"),
    (i[(i.Text = 18)] = "Text"),
    (i[(i.Color = 19)] = "Color"),
    (i[(i.File = 20)] = "File"),
    (i[(i.Reference = 21)] = "Reference"),
    (i[(i.Customcolor = 22)] = "Customcolor"),
    (i[(i.Folder = 23)] = "Folder"),
    (i[(i.TypeParameter = 24)] = "TypeParameter"),
    (i[(i.User = 25)] = "User"),
    (i[(i.Issue = 26)] = "Issue"),
    (i[(i.Snippet = 27)] = "Snippet")
})(_X || (_X = {}))
var OX
;(function (i) {
  const t = new Map()
  t.set(0, pt.symbolMethod),
    t.set(1, pt.symbolFunction),
    t.set(2, pt.symbolConstructor),
    t.set(3, pt.symbolField),
    t.set(4, pt.symbolVariable),
    t.set(5, pt.symbolClass),
    t.set(6, pt.symbolStruct),
    t.set(7, pt.symbolInterface),
    t.set(8, pt.symbolModule),
    t.set(9, pt.symbolProperty),
    t.set(10, pt.symbolEvent),
    t.set(11, pt.symbolOperator),
    t.set(12, pt.symbolUnit),
    t.set(13, pt.symbolValue),
    t.set(15, pt.symbolEnum),
    t.set(14, pt.symbolConstant),
    t.set(15, pt.symbolEnum),
    t.set(16, pt.symbolEnumMember),
    t.set(17, pt.symbolKeyword),
    t.set(27, pt.symbolSnippet),
    t.set(18, pt.symbolText),
    t.set(19, pt.symbolColor),
    t.set(20, pt.symbolFile),
    t.set(21, pt.symbolReference),
    t.set(22, pt.symbolCustomColor),
    t.set(23, pt.symbolFolder),
    t.set(24, pt.symbolTypeParameter),
    t.set(25, pt.account),
    t.set(26, pt.issues)
  function e(a) {
    let o = t.get(a)
    return (
      o ||
        (console.info("No codicon found for CompletionItemKind " + a),
        (o = pt.symbolProperty)),
      o
    )
  }
  i.toIcon = e
  const s = new Map()
  s.set("method", 0),
    s.set("function", 1),
    s.set("constructor", 2),
    s.set("field", 3),
    s.set("variable", 4),
    s.set("class", 5),
    s.set("struct", 6),
    s.set("interface", 7),
    s.set("module", 8),
    s.set("property", 9),
    s.set("event", 10),
    s.set("operator", 11),
    s.set("unit", 12),
    s.set("value", 13),
    s.set("constant", 14),
    s.set("enum", 15),
    s.set("enum-member", 16),
    s.set("enumMember", 16),
    s.set("keyword", 17),
    s.set("snippet", 27),
    s.set("text", 18),
    s.set("color", 19),
    s.set("file", 20),
    s.set("reference", 21),
    s.set("customcolor", 22),
    s.set("folder", 23),
    s.set("type-parameter", 24),
    s.set("typeParameter", 24),
    s.set("account", 25),
    s.set("issue", 26)
  function r(a, o) {
    let c = s.get(a)
    return typeof c > "u" && !o && (c = 9), c
  }
  i.fromString = r
})(OX || (OX = {}))
var BX
;(function (i) {
  i[(i.Deprecated = 1)] = "Deprecated"
})(BX || (BX = {}))
var qX
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.KeepWhitespace = 1)] = "KeepWhitespace"),
    (i[(i.InsertAsSnippet = 4)] = "InsertAsSnippet")
})(qX || (qX = {}))
var UX
;(function (i) {
  ;(i[(i.Word = 0)] = "Word"),
    (i[(i.Line = 1)] = "Line"),
    (i[(i.Suggest = 2)] = "Suggest")
})(UX || (UX = {}))
var MX
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"),
    (i[(i.TriggerCharacter = 1)] = "TriggerCharacter"),
    (i[(i.TriggerForIncompleteCompletions = 2)] =
      "TriggerForIncompleteCompletions")
})(MX || (MX = {}))
var h6
;(function (i) {
  ;(i[(i.Automatic = 0)] = "Automatic"), (i[(i.Explicit = 1)] = "Explicit")
})(h6 || (h6 = {}))
var HX
;(function (i) {
  ;(i[(i.Invoke = 1)] = "Invoke"), (i[(i.Auto = 2)] = "Auto")
})(HX || (HX = {}))
var WX
;(function (i) {
  ;(i[(i.Automatic = 0)] = "Automatic"), (i[(i.PasteAs = 1)] = "PasteAs")
})(WX || (WX = {}))
var jX
;(function (i) {
  ;(i[(i.Invoke = 1)] = "Invoke"),
    (i[(i.TriggerCharacter = 2)] = "TriggerCharacter"),
    (i[(i.ContentChange = 3)] = "ContentChange")
})(jX || (jX = {}))
var VX
;(function (i) {
  ;(i[(i.Text = 0)] = "Text"),
    (i[(i.Read = 1)] = "Read"),
    (i[(i.Write = 2)] = "Write")
})(VX || (VX = {}))
function t0t(i) {
  return (
    i &&
    S.isUri(i.uri) &&
    ue.isIRange(i.range) &&
    (ue.isIRange(i.originSelectionRange) || ue.isIRange(i.targetSelectionRange))
  )
}
var GX
;(function (i) {
  ;(i[(i.File = 0)] = "File"),
    (i[(i.Module = 1)] = "Module"),
    (i[(i.Namespace = 2)] = "Namespace"),
    (i[(i.Package = 3)] = "Package"),
    (i[(i.Class = 4)] = "Class"),
    (i[(i.Method = 5)] = "Method"),
    (i[(i.Property = 6)] = "Property"),
    (i[(i.Field = 7)] = "Field"),
    (i[(i.Constructor = 8)] = "Constructor"),
    (i[(i.Enum = 9)] = "Enum"),
    (i[(i.Interface = 10)] = "Interface"),
    (i[(i.Function = 11)] = "Function"),
    (i[(i.Variable = 12)] = "Variable"),
    (i[(i.Constant = 13)] = "Constant"),
    (i[(i.String = 14)] = "String"),
    (i[(i.Number = 15)] = "Number"),
    (i[(i.Boolean = 16)] = "Boolean"),
    (i[(i.Array = 17)] = "Array"),
    (i[(i.Object = 18)] = "Object"),
    (i[(i.Key = 19)] = "Key"),
    (i[(i.Null = 20)] = "Null"),
    (i[(i.EnumMember = 21)] = "EnumMember"),
    (i[(i.Struct = 22)] = "Struct"),
    (i[(i.Event = 23)] = "Event"),
    (i[(i.Operator = 24)] = "Operator"),
    (i[(i.TypeParameter = 25)] = "TypeParameter")
})(GX || (GX = {}))
var LVt = {
    17: g(806, null),
    16: g(807, null),
    4: g(808, null),
    13: g(809, null),
    8: g(810, null),
    9: g(811, null),
    21: g(812, null),
    23: g(813, null),
    7: g(814, null),
    0: g(815, null),
    11: g(816, null),
    10: g(817, null),
    19: g(818, null),
    5: g(819, null),
    1: g(820, null),
    2: g(821, null),
    20: g(822, null),
    15: g(823, null),
    18: g(824, null),
    24: g(825, null),
    3: g(826, null),
    6: g(827, null),
    14: g(828, null),
    22: g(829, null),
    25: g(830, null),
    12: g(831, null),
  },
  zX
;(function (i) {
  i[(i.Deprecated = 1)] = "Deprecated"
})(zX || (zX = {}))
var YX
;(function (i) {
  const t = new Map()
  t.set(0, pt.symbolFile),
    t.set(1, pt.symbolModule),
    t.set(2, pt.symbolNamespace),
    t.set(3, pt.symbolPackage),
    t.set(4, pt.symbolClass),
    t.set(5, pt.symbolMethod),
    t.set(6, pt.symbolProperty),
    t.set(7, pt.symbolField),
    t.set(8, pt.symbolConstructor),
    t.set(9, pt.symbolEnum),
    t.set(10, pt.symbolInterface),
    t.set(11, pt.symbolFunction),
    t.set(12, pt.symbolVariable),
    t.set(13, pt.symbolConstant),
    t.set(14, pt.symbolString),
    t.set(15, pt.symbolNumber),
    t.set(16, pt.symbolBoolean),
    t.set(17, pt.symbolArray),
    t.set(18, pt.symbolObject),
    t.set(19, pt.symbolKey),
    t.set(20, pt.symbolNull),
    t.set(21, pt.symbolEnumMember),
    t.set(22, pt.symbolStruct),
    t.set(23, pt.symbolEvent),
    t.set(24, pt.symbolOperator),
    t.set(25, pt.symbolTypeParameter)
  function e(a) {
    let o = t.get(a)
    return (
      o ||
        (console.info("No codicon found for SymbolKind " + a),
        (o = pt.symbolProperty)),
      o
    )
  }
  i.toIcon = e
  const s = new Map()
  s.set(0, 20),
    s.set(1, 8),
    s.set(2, 8),
    s.set(3, 8),
    s.set(4, 5),
    s.set(5, 0),
    s.set(6, 9),
    s.set(7, 3),
    s.set(8, 2),
    s.set(9, 15),
    s.set(10, 7),
    s.set(11, 1),
    s.set(12, 4),
    s.set(13, 14),
    s.set(14, 18),
    s.set(15, 13),
    s.set(16, 13),
    s.set(17, 13),
    s.set(18, 13),
    s.set(19, 17),
    s.set(20, 13),
    s.set(21, 16),
    s.set(22, 6),
    s.set(23, 10),
    s.set(24, 11),
    s.set(25, 24)
  function r(a) {
    let o = s.get(a)
    return (
      o === void 0 &&
        (console.info("No completion kind found for SymbolKind " + a),
        (o = 20)),
      o
    )
  }
  i.toCompletionKind = r
})(YX || (YX = {}))
var Jc = class Ra {
    static {
      this.Comment = new Ra("comment")
    }
    static {
      this.Imports = new Ra("imports")
    }
    static {
      this.Region = new Ra("region")
    }
    static fromValue(t) {
      switch (t) {
        case "comment":
          return Ra.Comment
        case "imports":
          return Ra.Imports
        case "region":
          return Ra.Region
      }
      return new Ra(t)
    }
    constructor(t) {
      this.value = t
    }
  },
  QX
;(function (i) {
  i[(i.AIGenerated = 1)] = "AIGenerated"
})(QX || (QX = {}))
var d6
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})(d6 || (d6 = {}))
var r2
;(function (i) {
  function t(e) {
    return !e || typeof e != "object"
      ? !1
      : typeof e.id == "string" && typeof e.title == "string"
  }
  i.is = t
})(r2 || (r2 = {}))
var Lc
;(function (i) {
  ;(i[(i.Collapsed = 0)] = "Collapsed"), (i[(i.Expanded = 1)] = "Expanded")
})(Lc || (Lc = {}))
var fh
;(function (i) {
  ;(i[(i.Unresolved = 0)] = "Unresolved"), (i[(i.Resolved = 1)] = "Resolved")
})(fh || (fh = {}))
var ph
;(function (i) {
  ;(i[(i.Current = 0)] = "Current"), (i[(i.Outdated = 1)] = "Outdated")
})(ph || (ph = {}))
var XX
;(function (i) {
  ;(i[(i.Editing = 0)] = "Editing"), (i[(i.Preview = 1)] = "Preview")
})(XX || (XX = {}))
var KX
;(function (i) {
  ;(i[(i.Published = 0)] = "Published"), (i[(i.Draft = 1)] = "Draft")
})(KX || (KX = {}))
var ZX
;(function (i) {
  ;(i[(i.Type = 1)] = "Type"), (i[(i.Parameter = 2)] = "Parameter")
})(ZX || (ZX = {}))
var RVt = new FX(),
  DVt = new FX(),
  tK
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Option = 1)] = "Option"),
    (i[(i.Default = 2)] = "Default"),
    (i[(i.Preferred = 3)] = "Preferred")
})(tK || (tK = {}))
var m6
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})(m6 || (m6 = {}))
var eK
;(function (i) {
  ;(i[(i.Unnecessary = 1)] = "Unnecessary"),
    (i[(i.Deprecated = 2)] = "Deprecated")
})(eK || (eK = {}))
var ji
;(function (i) {
  ;(i[(i.Hint = 1)] = "Hint"),
    (i[(i.Info = 2)] = "Info"),
    (i[(i.AI = 3)] = "AI"),
    (i[(i.Warning = 4)] = "Warning"),
    (i[(i.Error = 8)] = "Error")
})(ji || (ji = {})),
  (function (i) {
    function t(o, c) {
      return c - o
    }
    i.compare = t
    const e = Object.create(null)
    ;(e[i.Error] = g(2010, null)),
      (e[i.Warning] = g(2011, null)),
      (e[i.Info] = g(2012, null)),
      (e[i.AI] = "AI Hint")
    function s(o) {
      return e[o] || ""
    }
    i.toString = s
    function r(o) {
      switch (o) {
        case Le.Error:
          return i.Error
        case Le.Warning:
          return i.Warning
        case Le.Info:
          return i.Info
        case Le.Ignore:
          return i.Hint
        case Le.AI:
          return i.AI
      }
    }
    i.fromSeverity = r
    function a(o) {
      switch (o) {
        case i.Error:
          return Le.Error
        case i.Warning:
          return Le.Warning
        case i.Info:
          return Le.Info
        case i.Hint:
          return Le.Ignore
        case i.AI:
          return Le.AI
      }
    }
    i.toSeverity = a
  })(ji || (ji = {}))
var iK
;(function (i) {
  const t = ""
  function e(r) {
    return s(r, !0)
  }
  i.makeKey = e
  function s(r, a) {
    const o = [t]
    return (
      r.source ? o.push(r.source.replace("\xA6", "\\\xA6")) : o.push(t),
      r.code
        ? typeof r.code == "string"
          ? o.push(r.code.replace("\xA6", "\\\xA6"))
          : o.push(r.code.value.replace("\xA6", "\\\xA6"))
        : o.push(t),
      r.severity !== void 0 && r.severity !== null
        ? o.push(ji.toString(r.severity))
        : o.push(t),
      r.message && a ? o.push(r.message.replace("\xA6", "\\\xA6")) : o.push(t),
      r.startLineNumber !== void 0 && r.startLineNumber !== null
        ? o.push(r.startLineNumber.toString())
        : o.push(t),
      r.startColumn !== void 0 && r.startColumn !== null
        ? o.push(r.startColumn.toString())
        : o.push(t),
      r.endLineNumber !== void 0 && r.endLineNumber !== null
        ? o.push(r.endLineNumber.toString())
        : o.push(t),
      r.endColumn !== void 0 && r.endColumn !== null
        ? o.push(r.endColumn.toString())
        : o.push(t),
      o.push(t),
      o.join("\xA6")
    )
  }
  i.makeKeyOptionalMessage = s
})(iK || (iK = {}))
var FVt = X("markerService")
function Vi(i, t) {
  if (!i) throw new Error(t ? `Assertion failed (${t})` : "Assertion Failed")
}
function e0t(i, t = "Unreachable") {
  throw new Error(t)
}
function sK(i) {
  if (!i()) {
    debugger
    i(), $e(new nc("Assertion Failed"))
  }
}
var i0t = class {
    constructor() {
      this.a = new Map()
    }
    add(i, t) {
      Vi(_t(i)),
        Vi(Je(t)),
        Vi(!this.a.has(i), "There is already an extension with this id"),
        this.a.set(i, t)
    }
    knows(i) {
      return this.a.has(i)
    }
    as(i) {
      return this.a.get(i) || null
    }
  },
  Si = new i0t(),
  s0t = X("fileService")
function Rc(i) {
  return i.create === !0
}
var cs
;(function (i) {
  ;(i[(i.Unknown = 0)] = "Unknown"),
    (i[(i.File = 1)] = "File"),
    (i[(i.Directory = 2)] = "Directory"),
    (i[(i.SymbolicLink = 64)] = "SymbolicLink")
})(cs || (cs = {}))
var ia
;(function (i) {
  ;(i[(i.Readonly = 1)] = "Readonly"), (i[(i.Locked = 2)] = "Locked")
})(ia || (ia = {}))
var rK
;(function (i) {
  ;(i[(i.UPDATED = 2)] = "UPDATED"),
    (i[(i.ADDED = 4)] = "ADDED"),
    (i[(i.DELETED = 8)] = "DELETED")
})(rK || (rK = {}))
var nK
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.FileReadWrite = 2)] = "FileReadWrite"),
    (i[(i.FileOpenReadWriteClose = 4)] = "FileOpenReadWriteClose"),
    (i[(i.FileReadStream = 16)] = "FileReadStream"),
    (i[(i.FileFolderCopy = 8)] = "FileFolderCopy"),
    (i[(i.PathCaseSensitive = 1024)] = "PathCaseSensitive"),
    (i[(i.Readonly = 2048)] = "Readonly"),
    (i[(i.Trash = 4096)] = "Trash"),
    (i[(i.FileWriteUnlock = 8192)] = "FileWriteUnlock"),
    (i[(i.FileAtomicRead = 16384)] = "FileAtomicRead"),
    (i[(i.FileAtomicWrite = 32768)] = "FileAtomicWrite"),
    (i[(i.FileAtomicDelete = 65536)] = "FileAtomicDelete"),
    (i[(i.FileClone = 131072)] = "FileClone")
})(nK || (nK = {}))
var dt
;(function (i) {
  ;(i.FileExists = "EntryExists"),
    (i.FileNotFound = "EntryNotFound"),
    (i.FileNotADirectory = "EntryNotADirectory"),
    (i.FileIsADirectory = "EntryIsADirectory"),
    (i.FileExceedsStorageQuota = "EntryExceedsStorageQuota"),
    (i.FileTooLarge = "EntryTooLarge"),
    (i.FileWriteLocked = "EntryWriteLocked"),
    (i.NoPermissions = "NoPermissions"),
    (i.Unavailable = "Unavailable"),
    (i.Unknown = "Unknown")
})(dt || (dt = {}))
var f6 = class Zlt extends Error {
  static create(t, e) {
    const s = new Zlt(t.toString(), e)
    return aK(s, e), s
  }
  constructor(t, e) {
    super(t), (this.code = e)
  }
}
function ln(i, t) {
  return f6.create(i, t)
}
function r0t(i) {
  return i || ln(g(1922, null), dt.Unknown)
}
function aK(i, t) {
  return (i.name = t ? `${t} (FileSystemError)` : "FileSystemError"), i
}
function p6(i) {
  if (!i) return dt.Unknown
  if (i instanceof f6) return i.code
  const t = /^(.+) \(FileSystemError\)$/.exec(i.name)
  if (!t) return dt.Unknown
  switch (t[1]) {
    case dt.FileExists:
      return dt.FileExists
    case dt.FileIsADirectory:
      return dt.FileIsADirectory
    case dt.FileNotADirectory:
      return dt.FileNotADirectory
    case dt.FileNotFound:
      return dt.FileNotFound
    case dt.FileTooLarge:
      return dt.FileTooLarge
    case dt.FileWriteLocked:
      return dt.FileWriteLocked
    case dt.NoPermissions:
      return dt.NoPermissions
    case dt.Unavailable:
      return dt.Unavailable
  }
  return dt.Unknown
}
function n0t(i) {
  if (i instanceof n2) return i.fileOperationResult
  switch (p6(i)) {
    case dt.FileNotFound:
      return 1
    case dt.FileIsADirectory:
      return 0
    case dt.FileNotADirectory:
      return 9
    case dt.FileWriteLocked:
      return 5
    case dt.NoPermissions:
      return 6
    case dt.FileExists:
      return 4
    case dt.FileTooLarge:
      return 7
    default:
      return 10
  }
}
var oK
;(function (i) {
  ;(i[(i.CREATE = 0)] = "CREATE"),
    (i[(i.DELETE = 1)] = "DELETE"),
    (i[(i.MOVE = 2)] = "MOVE"),
    (i[(i.COPY = 3)] = "COPY"),
    (i[(i.WRITE = 4)] = "WRITE")
})(oK || (oK = {}))
var cK
;(function (i) {
  ;(i[(i.UPDATED = 0)] = "UPDATED"),
    (i[(i.ADDED = 1)] = "ADDED"),
    (i[(i.DELETED = 2)] = "DELETED")
})(cK || (cK = {}))
var AVt = class j3 {
  static {
    this.a = null
  }
  constructor(t, e) {
    ;(this.c = e),
      (this.b = void 0),
      (this.d = new as(() => {
        const s = ea.forUris(() => this.c)
        return s.fill(this.rawAdded.map((r) => [r, !0])), s
      })),
      (this.f = new as(() => {
        const s = ea.forUris(() => this.c)
        return s.fill(this.rawUpdated.map((r) => [r, !0])), s
      })),
      (this.g = new as(() => {
        const s = ea.forUris(() => this.c)
        return s.fill(this.rawDeleted.map((r) => [r, !0])), s
      })),
      (this.rawAdded = []),
      (this.rawUpdated = []),
      (this.rawDeleted = [])
    for (const s of t) {
      switch (s.type) {
        case 1:
          this.rawAdded.push(s.resource)
          break
        case 0:
          this.rawUpdated.push(s.resource)
          break
        case 2:
          this.rawDeleted.push(s.resource)
          break
      }
      this.b !== j3.a &&
        (typeof s.cId == "number"
          ? this.b === void 0
            ? (this.b = s.cId)
            : this.b !== s.cId && (this.b = j3.a)
          : this.b !== void 0 && (this.b = j3.a))
    }
  }
  contains(t, ...e) {
    return this.h(t, { includeChildren: !1 }, ...e)
  }
  affects(t, ...e) {
    return this.h(t, { includeChildren: !0 }, ...e)
  }
  h(t, e, ...s) {
    if (!t) return !1
    const r = s.length > 0
    return !!(
      ((!r || s.includes(1)) &&
        (this.d.value.get(t) ||
          (e.includeChildren && this.d.value.findSuperstr(t)))) ||
      ((!r || s.includes(0)) &&
        (this.f.value.get(t) ||
          (e.includeChildren && this.f.value.findSuperstr(t)))) ||
      ((!r || s.includes(2)) &&
        (this.g.value.findSubstr(t) ||
          (e.includeChildren && this.g.value.findSuperstr(t))))
    )
  }
  gotAdded() {
    return this.rawAdded.length > 0
  }
  gotDeleted() {
    return this.rawDeleted.length > 0
  }
  gotUpdated() {
    return this.rawUpdated.length > 0
  }
  correlates(t) {
    return this.b === t
  }
  hasCorrelation() {
    return typeof this.b == "number"
  }
}
function a0t(i, t, e) {
  return !i || !t || i === t || t.length > i.length
    ? !1
    : (t.charAt(t.length - 1) !== xe && (t += xe),
      e ? I_(i, t) : i.indexOf(t) === 0)
}
var n2 = class extends Error {
    constructor(i, t, e) {
      super(i), (this.fileOperationResult = t), (this.options = e)
    }
  },
  lK
;(function (i) {
  ;(i[(i.FILE_IS_DIRECTORY = 0)] = "FILE_IS_DIRECTORY"),
    (i[(i.FILE_NOT_FOUND = 1)] = "FILE_NOT_FOUND"),
    (i[(i.FILE_NOT_MODIFIED_SINCE = 2)] = "FILE_NOT_MODIFIED_SINCE"),
    (i[(i.FILE_MODIFIED_SINCE = 3)] = "FILE_MODIFIED_SINCE"),
    (i[(i.FILE_MOVE_CONFLICT = 4)] = "FILE_MOVE_CONFLICT"),
    (i[(i.FILE_WRITE_LOCKED = 5)] = "FILE_WRITE_LOCKED"),
    (i[(i.FILE_PERMISSION_DENIED = 6)] = "FILE_PERMISSION_DENIED"),
    (i[(i.FILE_TOO_LARGE = 7)] = "FILE_TOO_LARGE"),
    (i[(i.FILE_INVALID_PATH = 8)] = "FILE_INVALID_PATH"),
    (i[(i.FILE_NOT_DIRECTORY = 9)] = "FILE_NOT_DIRECTORY"),
    (i[(i.FILE_OTHER_ERROR = 10)] = "FILE_OTHER_ERROR")
})(lK || (lK = {}))
var uK
;(function (i) {
  ;(i[(i.FILE = 0)] = "FILE"),
    (i[(i.FOLDER = 1)] = "FOLDER"),
    (i[(i.ROOT_FOLDER = 2)] = "ROOT_FOLDER")
})(uK || (uK = {}))
var o0t = ""
function hK(i) {
  if (!(typeof i.size != "number" || typeof i.mtime != "number"))
    return i.mtime.toString(29) + i.size.toString(31)
}
var dK = class es {
    static {
      this.KB = 1024
    }
    static {
      this.MB = es.KB * es.KB
    }
    static {
      this.GB = es.MB * es.KB
    }
    static {
      this.TB = es.GB * es.KB
    }
    static formatSize(t) {
      return (
        ps(t) || (t = 0),
        t < es.KB
          ? g(1923, null, t.toFixed(0))
          : t < es.MB
            ? g(1924, null, (t / es.KB).toFixed(2))
            : t < es.GB
              ? g(1925, null, (t / es.MB).toFixed(2))
              : t < es.TB
                ? g(1926, null, (t / es.GB).toFixed(2))
                : g(1927, null, (t / es.TB).toFixed(2))
      )
    }
  },
  c0t = class extends at {
    constructor(i, t = "", e = "", s = !0, r) {
      super(),
        (this.j = this.D(new J())),
        (this.onDidChange = this.j.event),
        (this.w = !0),
        (this.m = i),
        (this.n = t),
        (this.u = e),
        (this.w = s),
        (this.C = r)
    }
    get id() {
      return this.m
    }
    get label() {
      return this.n
    }
    set label(i) {
      this.F(i)
    }
    F(i) {
      this.n !== i && ((this.n = i), this.j.fire({ label: i }))
    }
    get tooltip() {
      return this.q || ""
    }
    set tooltip(i) {
      this.G(i)
    }
    G(i) {
      this.q !== i && ((this.q = i), this.j.fire({ tooltip: i }))
    }
    get class() {
      return this.u
    }
    set class(i) {
      this.H(i)
    }
    H(i) {
      this.u !== i && ((this.u = i), this.j.fire({ class: i }))
    }
    get enabled() {
      return this.w
    }
    set enabled(i) {
      this.I(i)
    }
    I(i) {
      this.w !== i && ((this.w = i), this.j.fire({ enabled: i }))
    }
    get checked() {
      return this.z
    }
    set checked(i) {
      this.J(i)
    }
    J(i) {
      this.z !== i && ((this.z = i), this.j.fire({ checked: i }))
    }
    async run(i, t) {
      this.C && (await this.C(i))
    }
  },
  _Vt = class uV {
    constructor() {
      ;(this.id = uV.ID),
        (this.label = ""),
        (this.tooltip = ""),
        (this.class = "separator"),
        (this.enabled = !1),
        (this.checked = !1)
    }
    static join(...t) {
      let e = []
      for (const s of t)
        s.length && (e.length ? (e = [...e, new uV(), ...s]) : (e = s))
      return e
    }
    static {
      this.ID = "vs.actions.separator"
    }
    async run() {}
  },
  OVt = class tut extends c0t {
    static {
      this.ID = "vs.actions.empty"
    }
    constructor() {
      super(tut.ID, g(44, null), void 0, !1)
    }
  },
  l0t = {
    EditorPane: "workbench.contributions.editors",
    EditorFactory: "workbench.contributions.editor.inputFactories",
  },
  u0t = {
    id: "default",
    displayName: g(4149, null),
    providerDisplayName: g(4150, null),
  },
  mK
;(function (i) {
  ;(i[(i.PROGRAMMATIC = 1)] = "PROGRAMMATIC"),
    (i[(i.USER = 2)] = "USER"),
    (i[(i.EDIT = 3)] = "EDIT"),
    (i[(i.NAVIGATION = 4)] = "NAVIGATION"),
    (i[(i.JUMP = 5)] = "JUMP")
})(mK || (mK = {}))
var fK
;(function (i) {
  ;(i[(i.IDENTICAL = 1)] = "IDENTICAL"),
    (i[(i.SIMILAR = 2)] = "SIMILAR"),
    (i[(i.DIFFERENT = 3)] = "DIFFERENT")
})(fK || (fK = {}))
function g6(i) {
  if (un(i)) return !1
  const t = i
  return t?.original !== void 0 && t.modified !== void 0
}
function pK(i) {
  if (un(i)) return !1
  const t = i
  return !t || (t.resources && !Array.isArray(t.resources))
    ? !1
    : !!t.resources || !!t.multiDiffSource
}
function gK(i) {
  if (un(i)) return !1
  const t = i
  return Array.isArray(t?.resources) && t.resources.every((e) => S.isUri(e))
}
function a2(i) {
  if (un(i) || g6(i)) return !1
  const t = i
  return t?.primary !== void 0 && t.secondary !== void 0
}
function v6(i) {
  if (un(i)) return !1
  const t = i
  return (
    S.isUri(t?.base?.resource) &&
    S.isUri(t?.input1?.resource) &&
    S.isUri(t?.input2?.resource) &&
    S.isUri(t?.result?.resource)
  )
}
var vK
;(function (i) {
  ;(i[(i.SHORT = 0)] = "SHORT"),
    (i[(i.MEDIUM = 1)] = "MEDIUM"),
    (i[(i.LONG = 2)] = "LONG")
})(vK || (vK = {}))
var wK
;(function (i) {
  ;(i[(i.EXPLICIT = 1)] = "EXPLICIT"),
    (i[(i.AUTO = 2)] = "AUTO"),
    (i[(i.FOCUS_CHANGE = 3)] = "FOCUS_CHANGE"),
    (i[(i.WINDOW_CHANGE = 4)] = "WINDOW_CHANGE")
})(wK || (wK = {}))
var h0t = class {
    constructor() {
      this.a = new Map()
    }
    registerSource(i, t) {
      let e = this.a.get(i)
      return e || ((e = { source: i, label: t }), this.a.set(i, e)), e.source
    }
    getSourceLabel(i) {
      return this.a.get(i)?.label ?? i
    }
  },
  BVt = new h0t(),
  yK
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Readonly = 2)] = "Readonly"),
    (i[(i.Untitled = 4)] = "Untitled"),
    (i[(i.Singleton = 8)] = "Singleton"),
    (i[(i.RequiresTrust = 16)] = "RequiresTrust"),
    (i[(i.CanSplitInGroup = 32)] = "CanSplitInGroup"),
    (i[(i.ForceDescription = 64)] = "ForceDescription"),
    (i[(i.CanDropIntoEditor = 128)] = "CanDropIntoEditor"),
    (i[(i.MultipleEditors = 256)] = "MultipleEditors"),
    (i[(i.Scratchpad = 512)] = "Scratchpad")
})(yK || (yK = {}))
var d0t = class extends at {}
function un(i) {
  return i instanceof d0t
}
function m0t(i) {
  const t = i
  return S.isUri(t?.preferredResource)
}
function f0t(i) {
  const t = i
  return un(t?.primary) && un(t?.secondary)
}
function p0t(i) {
  const t = i
  return un(t?.modified) && un(t?.original)
}
var bK
;(function (i) {
  ;(i[(i.UNKNOWN = 0)] = "UNKNOWN"),
    (i[(i.REPLACE = 1)] = "REPLACE"),
    (i[(i.MOVE = 2)] = "MOVE"),
    (i[(i.UNPIN = 3)] = "UNPIN")
})(bK || (bK = {}))
var TK
;(function (i) {
  ;(i[(i.GROUP_ACTIVE = 0)] = "GROUP_ACTIVE"),
    (i[(i.GROUP_INDEX = 1)] = "GROUP_INDEX"),
    (i[(i.GROUP_LABEL = 2)] = "GROUP_LABEL"),
    (i[(i.GROUP_LOCKED = 3)] = "GROUP_LOCKED"),
    (i[(i.EDITORS_SELECTION = 4)] = "EDITORS_SELECTION"),
    (i[(i.EDITOR_OPEN = 5)] = "EDITOR_OPEN"),
    (i[(i.EDITOR_CLOSE = 6)] = "EDITOR_CLOSE"),
    (i[(i.EDITOR_MOVE = 7)] = "EDITOR_MOVE"),
    (i[(i.EDITOR_ACTIVE = 8)] = "EDITOR_ACTIVE"),
    (i[(i.EDITOR_LABEL = 9)] = "EDITOR_LABEL"),
    (i[(i.EDITOR_CAPABILITIES = 10)] = "EDITOR_CAPABILITIES"),
    (i[(i.EDITOR_PIN = 11)] = "EDITOR_PIN"),
    (i[(i.EDITOR_TRANSIENT = 12)] = "EDITOR_TRANSIENT"),
    (i[(i.EDITOR_STICKY = 13)] = "EDITOR_STICKY"),
    (i[(i.EDITOR_DIRTY = 14)] = "EDITOR_DIRTY"),
    (i[(i.EDITOR_WILL_DISPOSE = 15)] = "EDITOR_WILL_DISPOSE")
})(TK || (TK = {}))
var sa
;(function (i) {
  ;(i[(i.PRIMARY = 1)] = "PRIMARY"),
    (i[(i.SECONDARY = 2)] = "SECONDARY"),
    (i[(i.BOTH = 3)] = "BOTH"),
    (i[(i.ANY = 4)] = "ANY")
})(sa || (sa = {}))
var g0t = class {
    getOriginalUri(i, t) {
      if (!i) return
      if (v6(i)) return SK.getOriginalUri(i.result, t)
      if (t?.supportSideBySide) {
        const { primary: s, secondary: r } = this.a(i)
        if (s && r) {
          if (t?.supportSideBySide === sa.BOTH)
            return {
              primary: this.getOriginalUri(s, {
                filterByScheme: t.filterByScheme,
              }),
              secondary: this.getOriginalUri(r, {
                filterByScheme: t.filterByScheme,
              }),
            }
          if (t?.supportSideBySide === sa.ANY)
            return (
              this.getOriginalUri(s, { filterByScheme: t.filterByScheme }) ??
              this.getOriginalUri(r, { filterByScheme: t.filterByScheme })
            )
          i = t.supportSideBySide === sa.PRIMARY ? s : r
        }
      }
      if (g6(i) || pK(i) || a2(i) || v6(i) || gK(i)) return
      const e = m0t(i) ? i.preferredResource : i.resource
      return !e || !t || !t.filterByScheme ? e : this.b(e, t.filterByScheme)
    }
    a(i) {
      return f0t(i) || a2(i)
        ? { primary: i.primary, secondary: i.secondary }
        : p0t(i) || g6(i)
          ? { primary: i.modified, secondary: i.original }
          : { primary: void 0, secondary: void 0 }
    }
    getCanonicalUri(i, t) {
      if (!i) return
      if (v6(i)) return SK.getCanonicalUri(i.result, t)
      if (t?.supportSideBySide) {
        const { primary: s, secondary: r } = this.a(i)
        if (s && r) {
          if (t?.supportSideBySide === sa.BOTH)
            return {
              primary: this.getCanonicalUri(s, {
                filterByScheme: t.filterByScheme,
              }),
              secondary: this.getCanonicalUri(r, {
                filterByScheme: t.filterByScheme,
              }),
            }
          if (t?.supportSideBySide === sa.ANY)
            return (
              this.getCanonicalUri(s, { filterByScheme: t.filterByScheme }) ??
              this.getCanonicalUri(r, { filterByScheme: t.filterByScheme })
            )
          i = t.supportSideBySide === sa.PRIMARY ? s : r
        }
      }
      if (g6(i) || pK(i) || a2(i) || v6(i) || gK(i)) return
      const e = i.resource
      return !e || !t || !t.filterByScheme ? e : this.b(e, t.filterByScheme)
    }
    b(i, t) {
      if (Array.isArray(t)) {
        if (t.some((e) => i.scheme === e)) return i
      } else if (t === i.scheme) return i
    }
  },
  kK
;(function (i) {
  ;(i[(i.UNKNOWN = 0)] = "UNKNOWN"),
    (i[(i.KEYBOARD = 1)] = "KEYBOARD"),
    (i[(i.MOUSE = 2)] = "MOUSE")
})(kK || (kK = {}))
var SK = new g0t(),
  EK
;(function (i) {
  ;(i[(i.LEFT = 0)] = "LEFT"), (i[(i.RIGHT = 1)] = "RIGHT")
})(EK || (EK = {}))
var v0t = class {
  constructor() {
    ;(this.c = new Map()), (this.d = new Map())
  }
  start(i) {
    const t = (this.a = i.get(t6))
    for (const [e, s] of this.c) this.e(e, s, t)
    this.c.clear()
  }
  e(i, t, e) {
    const s = e.createInstance(t)
    this.d.set(i, s)
  }
  registerFileEditorFactory(i) {
    if (this.b) throw new Error("Can only register one file editor factory.")
    this.b = i
  }
  getFileEditorFactory() {
    return hc(this.b)
  }
  registerEditorSerializer(i, t) {
    if (this.c.has(i) || this.d.has(i))
      throw new Error(
        `A editor serializer with type ID '${i}' was already registered.`,
      )
    return (
      this.a ? this.e(i, t, this.a) : this.c.set(i, t),
      et(() => {
        this.c.delete(i), this.d.delete(i)
      })
    )
  }
  getEditorSerializer(i) {
    return this.d.get(typeof i == "string" ? i : i.typeId)
  }
}
Si.add(l0t.EditorFactory, new v0t())
var IK
;(function (i) {
  ;(i[(i.MOST_RECENTLY_ACTIVE = 0)] = "MOST_RECENTLY_ACTIVE"),
    (i[(i.SEQUENTIAL = 1)] = "SEQUENTIAL")
})(IK || (IK = {}))
var gh = class {
    constructor(i, t, e) {
      ;(this.owner = i), (this.debugNameSource = t), (this.referenceFn = e)
    }
    getDebugName(i) {
      return w0t(i, this)
    }
  },
  PK = new Map(),
  o2 = new WeakMap()
function w0t(i, t) {
  const e = o2.get(i)
  if (e) return e
  const s = y0t(i, t)
  if (s) {
    let r = PK.get(s) ?? 0
    r++, PK.set(s, r)
    const a = r === 1 ? s : `${s}#${r}`
    return o2.set(i, a), a
  }
}
function y0t(i, t) {
  const e = o2.get(i)
  if (e) return e
  const s = t.owner ? T0t(t.owner) + "." : ""
  let r
  const a = t.debugNameSource
  if (a !== void 0)
    if (typeof a == "function") {
      if (((r = a()), r !== void 0)) return s + r
    } else return s + a
  const o = t.referenceFn
  if (o !== void 0 && ((r = c2(o)), r !== void 0)) return s + r
  if (t.owner !== void 0) {
    const c = b0t(t.owner, i)
    if (c !== void 0) return s + c
  }
}
function b0t(i, t) {
  for (const e in i) if (i[e] === t) return e
}
var $K = new Map(),
  xK = new WeakMap()
function T0t(i) {
  const t = xK.get(i)
  if (t) return t
  const e = k0t(i)
  let s = $K.get(e) ?? 0
  s++, $K.set(e, s)
  const r = s === 1 ? e : `${e}#${s}`
  return xK.set(i, r), r
}
function k0t(i) {
  const t = i.constructor
  return t ? t.name : "Object"
}
function c2(i) {
  const t = i.toString(),
    s = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(t)
  return (s ? s[1] : void 0)?.trim()
}
var l2 = (i, t) => i === t
function u2(i, t) {
  if (i === t) return !0
  if (Array.isArray(i) && Array.isArray(t)) {
    if (i.length !== t.length) return !1
    for (let e = 0; e < i.length; e++) if (!u2(i[e], t[e])) return !1
    return !0
  }
  if (
    i &&
    typeof i == "object" &&
    t &&
    typeof t == "object" &&
    Object.getPrototypeOf(i) === Object.prototype &&
    Object.getPrototypeOf(t) === Object.prototype
  ) {
    const e = i,
      s = t,
      r = Object.keys(e),
      a = Object.keys(s),
      o = new Set(a)
    if (r.length !== a.length) return !1
    for (const c of r) if (!o.has(c) || !u2(e[c], s[c])) return !1
    return !0
  }
  return !1
}
var NK
function S0t(i) {
  NK = i
}
function Lr() {
  return NK
}
var E0t = class {
  constructor() {
    ;(this.a = 0), (this.d = new WeakMap())
  }
  b(i) {
    return I0t([Dc(x0t("|  ", this.a)), i])
  }
  c(i) {
    return i.hadValue
      ? i.didChange
        ? [
            Dc(" "),
            er(wh(i.oldValue, 70), { color: "red", strikeThrough: !0 }),
            Dc(" "),
            er(wh(i.newValue, 60), { color: "green" }),
          ]
        : [Dc(" (unchanged)")]
      : [Dc(" "), er(wh(i.newValue, 60), { color: "green" }), Dc(" (initial)")]
  }
  handleObservableChanged(i, t) {
    console.log(
      ...this.b([
        vh("observable value changed"),
        er(i.debugName, { color: "BlueViolet" }),
        ...this.c(t),
      ]),
    )
  }
  formatChanges(i) {
    if (i.size !== 0)
      return er(
        " (changed deps: " + [...i].map((t) => t.debugName).join(", ") + ")",
        { color: "gray" },
      )
  }
  handleDerivedCreated(i) {
    const t = i.handleChange
    this.d.set(i, new Set()),
      (i.handleChange = (e, s) => (this.d.get(i).add(e), t.apply(i, [e, s])))
  }
  handleDerivedRecomputed(i, t) {
    const e = this.d.get(i)
    console.log(
      ...this.b([
        vh("derived recomputed"),
        er(i.debugName, { color: "BlueViolet" }),
        ...this.c(t),
        this.formatChanges(e),
        { data: [{ fn: i._debugNameData.referenceFn ?? i._computeFn }] },
      ]),
    ),
      e.clear()
  }
  handleFromEventObservableTriggered(i, t) {
    console.log(
      ...this.b([
        vh("observable from event triggered"),
        er(i.debugName, { color: "BlueViolet" }),
        ...this.c(t),
        { data: [{ fn: i._getValue }] },
      ]),
    )
  }
  handleAutorunCreated(i) {
    const t = i.handleChange
    this.d.set(i, new Set()),
      (i.handleChange = (e, s) => (this.d.get(i).add(e), t.apply(i, [e, s])))
  }
  handleAutorunTriggered(i) {
    const t = this.d.get(i)
    console.log(
      ...this.b([
        vh("autorun"),
        er(i.debugName, { color: "BlueViolet" }),
        this.formatChanges(t),
        { data: [{ fn: i._debugNameData.referenceFn ?? i._runFn }] },
      ]),
    ),
      t.clear(),
      this.a++
  }
  handleAutorunFinished(i) {
    this.a--
  }
  handleBeginTransaction(i) {
    let t = i.getDebugName()
    t === void 0 && (t = ""),
      console.log(
        ...this.b([
          vh("transaction"),
          er(t, { color: "BlueViolet" }),
          { data: [{ fn: i._fn }] },
        ]),
      ),
      this.a++
  }
  handleEndTransaction() {
    this.a--
  }
}
function I0t(i) {
  const t = new Array(),
    e = []
  let s = ""
  function r(o) {
    if ("length" in o) for (const c of o) c && r(c)
    else
      "text" in o
        ? ((s += `%c${o.text}`), t.push(o.style), o.data && e.push(...o.data))
        : "data" in o && e.push(...o.data)
  }
  r(i)
  const a = [s, ...t]
  return a.push(...e), a
}
function Dc(i) {
  return er(i, { color: "black" })
}
function vh(i) {
  return er(N0t(`${i}: `, 10), { color: "black", bold: !0 })
}
function er(i, t = { color: "black" }) {
  function e(r) {
    return Object.entries(r).reduce((a, [o, c]) => `${a}${o}:${c};`, "")
  }
  const s = { color: t.color }
  return (
    t.strikeThrough && (s["text-decoration"] = "line-through"),
    t.bold && (s["font-weight"] = "bold"),
    { text: i, style: e(s) }
  )
}
function wh(i, t) {
  switch (typeof i) {
    case "number":
      return "" + i
    case "string":
      return i.length + 2 <= t ? `"${i}"` : `"${i.substr(0, t - 7)}"+...`
    case "boolean":
      return i ? "true" : "false"
    case "undefined":
      return "undefined"
    case "object":
      return i === null ? "null" : Array.isArray(i) ? P0t(i, t) : $0t(i, t)
    case "symbol":
      return i.toString()
    case "function":
      return `[[Function${i.name ? " " + i.name : ""}]]`
    default:
      return "" + i
  }
}
function P0t(i, t) {
  let e = "[ ",
    s = !0
  for (const r of i) {
    if ((s || (e += ", "), e.length - 5 > t)) {
      e += "..."
      break
    }
    ;(s = !1), (e += `${wh(r, t - e.length)}`)
  }
  return (e += " ]"), e
}
function $0t(i, t) {
  let e = "{ ",
    s = !0
  for (const [r, a] of Object.entries(i)) {
    if ((s || (e += ", "), e.length - 5 > t)) {
      e += "..."
      break
    }
    ;(s = !1), (e += `${r}: ${wh(a, t - e.length)}`)
  }
  return (e += " }"), e
}
function x0t(i, t) {
  let e = ""
  for (let s = 1; s <= t; s++) e += i
  return e
}
function N0t(i, t) {
  for (; i.length < t; ) i += " "
  return i
}
var CK
function C0t(i) {
  CK = i
}
var JK
function J0t(i) {
  JK = i
}
var h2
function L0t(i) {
  h2 = i
}
var R0t = class {
    get TChange() {
      return null
    }
    reportChanges() {
      this.get()
    }
    read(i) {
      return i ? i.readObservable(this) : this.get()
    }
    map(i, t) {
      const e = t === void 0 ? void 0 : i,
        s = t === void 0 ? i : t
      return h2(
        {
          owner: e,
          debugName: () => {
            const r = c2(s)
            if (r !== void 0) return r
            const o =
              /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(
                s.toString(),
              )
            if (o) return `${this.debugName}.${o[2]}`
            if (!e) return `${this.debugName} (mapped)`
          },
          debugReferenceFn: s,
        },
        (r) => s(this.read(r), r),
      )
    }
    flatten() {
      return h2(
        { owner: void 0, debugName: () => `${this.debugName} (flattened)` },
        (i) => this.read(i).read(i),
      )
    }
    recomputeInitiallyAndOnChange(i, t) {
      return i.add(CK(this, t)), this
    }
    keepObserved(i) {
      return i.add(JK(this)), this
    }
    get a() {
      return this.get()
    }
  },
  d2 = class extends R0t {
    constructor() {
      super(...arguments), (this.b = new Set())
    }
    addObserver(i) {
      const t = this.b.size
      this.b.add(i), t === 0 && this.c()
    }
    removeObserver(i) {
      this.b.delete(i) && this.b.size === 0 && this.f()
    }
    c() {}
    f() {}
  }
function D0t(i, t) {
  const e = new LK(i, t)
  try {
    i(e)
  } finally {
    e.finish()
  }
}
function F0t(i, t, e) {
  i ? t(i) : D0t(t, e)
}
var LK = class {
  constructor(i, t) {
    ;(this._fn = i),
      (this.b = t),
      (this.a = []),
      Lr()?.handleBeginTransaction(this)
  }
  getDebugName() {
    return this.b ? this.b() : c2(this._fn)
  }
  updateObserver(i, t) {
    this.a.push({ observer: i, observable: t }), i.beginUpdate(t)
  }
  finish() {
    const i = this.a
    for (let t = 0; t < i.length; t++) {
      const { observer: e, observable: s } = i[t]
      e.endUpdate(s)
    }
    ;(this.a = null), Lr()?.handleEndTransaction()
  }
}
function A0t(i, t) {
  let e
  return (
    typeof i == "string"
      ? (e = new gh(void 0, i, void 0))
      : (e = new gh(i, void 0, void 0)),
    new _0t(e, t, l2)
  )
}
var _0t = class extends d2 {
  get debugName() {
    return this.e.getDebugName(this) ?? "ObservableValue"
  }
  constructor(i, t, e) {
    super(), (this.e = i), (this.g = e), (this.d = t)
  }
  get() {
    return this.d
  }
  set(i, t, e) {
    if (e === void 0 && this.g(this.d, i)) return
    let s
    t ||
      (t = s =
        new LK(
          () => {},
          () => `Setting ${this.debugName}`,
        ))
    try {
      const r = this.d
      this.h(i),
        Lr()?.handleObservableChanged(this, {
          oldValue: r,
          newValue: i,
          change: e,
          didChange: !0,
          hadValue: !0,
        })
      for (const a of this.b) t.updateObserver(a, this), a.handleChange(this, e)
    } finally {
      s && s.finish()
    }
  }
  toString() {
    return `${this.debugName}: ${this.d}`
  }
  h(i) {
    this.d = i
  }
}
function RK(i) {
  return new FK(new gh(void 0, void 0, i), i, void 0, void 0)
}
var DK
;(function (i) {
  ;(i[(i.dependenciesMightHaveChanged = 1)] = "dependenciesMightHaveChanged"),
    (i[(i.stale = 2)] = "stale"),
    (i[(i.upToDate = 3)] = "upToDate")
})(DK || (DK = {}))
var FK = class {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)"
  }
  constructor(i, t, e, s) {
    ;(this._debugNameData = i),
      (this._runFn = t),
      (this.i = e),
      (this.j = s),
      (this.a = 2),
      (this.b = 0),
      (this.c = !1),
      (this.f = new Set()),
      (this.g = new Set()),
      (this.l = !1),
      (this.h = this.i?.()),
      Lr()?.handleAutorunCreated(this),
      this.k(),
      cc(this)
  }
  dispose() {
    this.c = !0
    for (const i of this.f) i.removeObserver(this)
    this.f.clear(), lc(this)
  }
  k() {
    if (this.a === 3) return
    const i = this.g
    ;(this.g = this.f), (this.f = i), (this.a = 3)
    const t = this.c
    try {
      if (!t) {
        Lr()?.handleAutorunTriggered(this)
        const e = this.h
        try {
          ;(this.h = this.i?.()), (this.l = !0), this._runFn(this, e)
        } catch (s) {
          u_(s)
        } finally {
          this.l = !1
        }
      }
    } finally {
      t || Lr()?.handleAutorunFinished(this)
      for (const e of this.g) e.removeObserver(this)
      this.g.clear()
    }
  }
  toString() {
    return `Autorun<${this.debugName}>`
  }
  beginUpdate() {
    this.a === 3 && (this.a = 1), this.b++
  }
  endUpdate() {
    try {
      if (this.b === 1)
        do {
          if (this.a === 1) {
            this.a = 3
            for (const i of this.f) if ((i.reportChanges(), this.a === 2)) break
          }
          this.k()
        } while (this.a !== 3)
    } finally {
      this.b--
    }
    sK(() => this.b >= 0)
  }
  handlePossibleChange(i) {
    this.a === 3 && this.f.has(i) && !this.g.has(i) && (this.a = 1)
  }
  handleChange(i, t) {
    if (this.f.has(i) && !this.g.has(i))
      try {
        ;(this.j
          ? this.j(
              { changedObservable: i, change: t, didChange: (s) => s === i },
              this.h,
            )
          : !0) && (this.a = 2)
      } catch (e) {
        u_(e)
      }
  }
  readObservable(i) {
    if (!this.l)
      throw new nc(
        "The reader object cannot be used outside its compute function!",
      )
    if (this.c) return i.get()
    i.addObserver(this)
    const t = i.get()
    return this.f.add(i), this.g.delete(i), t
  }
}
;(function (i) {
  i.Observer = FK
})(RK || (RK = {}))
function O0t(i, t) {
  return new B0t(
    new gh(i.owner, i.debugName, i.debugReferenceFn),
    t,
    void 0,
    void 0,
    i.onLastObserverRemoved,
    i.equalsFn ?? l2,
  )
}
L0t(O0t)
var AK
;(function (i) {
  ;(i[(i.initial = 0)] = "initial"),
    (i[(i.dependenciesMightHaveChanged = 1)] = "dependenciesMightHaveChanged"),
    (i[(i.stale = 2)] = "stale"),
    (i[(i.upToDate = 3)] = "upToDate")
})(AK || (AK = {}))
var B0t = class extends d2 {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)"
  }
  constructor(i, t, e, s, r = void 0, a) {
    super(),
      (this._debugNameData = i),
      (this._computeFn = t),
      (this.q = e),
      (this.s = s),
      (this.t = r),
      (this.u = a),
      (this.g = 0),
      (this.h = void 0),
      (this.j = 0),
      (this.k = new Set()),
      (this.l = new Set()),
      (this.m = void 0),
      (this.n = !1),
      (this.p = !1),
      (this.x = !1),
      (this.m = this.q?.()),
      Lr()?.handleDerivedCreated(this)
  }
  f() {
    ;(this.g = 0), (this.h = void 0)
    for (const i of this.k) i.removeObserver(this)
    this.k.clear(), this.t?.()
  }
  get() {
    if (this.p) throw new nc("Cyclic deriveds are not supported yet!")
    if (this.b.size === 0) {
      let i
      try {
        ;(this.x = !0), (i = this._computeFn(this, this.q?.()))
      } finally {
        this.x = !1
      }
      return this.f(), i
    } else {
      do {
        if (this.g === 1) {
          for (const i of this.k) if ((i.reportChanges(), this.g === 2)) break
        }
        this.g === 1 && (this.g = 3), this.w()
      } while (this.g !== 3)
      return this.h
    }
  }
  w() {
    if (this.g === 3) return
    const i = this.l
    ;(this.l = this.k), (this.k = i)
    const t = this.g !== 0,
      e = this.h
    this.g = 3
    let s = !1
    this.p = !1
    try {
      const r = this.m
      this.m = this.q?.()
      try {
        ;(this.x = !0), (this.h = this._computeFn(this, r))
      } finally {
        this.x = !1
        for (const a of this.l) a.removeObserver(this)
        this.l.clear()
      }
      ;(s = t && !this.u(e, this.h)),
        Lr()?.handleDerivedRecomputed(this, {
          oldValue: e,
          newValue: this.h,
          change: void 0,
          didChange: s,
          hadValue: t,
        })
    } catch (r) {
      u_(r)
    }
    if (((this.p = !1), s)) for (const r of this.b) r.handleChange(this, void 0)
  }
  toString() {
    return `LazyDerived<${this.debugName}>`
  }
  beginUpdate(i) {
    if (this.n) throw new nc("Cyclic deriveds are not supported yet!")
    this.j++, (this.n = !0)
    try {
      const t = this.j === 1
      if (this.g === 3 && ((this.g = 1), !t))
        for (const e of this.b) e.handlePossibleChange(this)
      if (t) for (const e of this.b) e.beginUpdate(this)
    } finally {
      this.n = !1
    }
  }
  endUpdate(i) {
    if ((this.j--, this.j === 0)) {
      const t = [...this.b]
      for (const e of t) e.endUpdate(this)
    }
    sK(() => this.j >= 0)
  }
  handlePossibleChange(i) {
    if (this.g === 3 && this.k.has(i) && !this.l.has(i)) {
      this.g = 1
      for (const t of this.b) t.handlePossibleChange(this)
    }
  }
  handleChange(i, t) {
    if (this.k.has(i) && !this.l.has(i)) {
      let e = !1
      try {
        e = this.s
          ? this.s(
              { changedObservable: i, change: t, didChange: (r) => r === i },
              this.m,
            )
          : !0
      } catch (r) {
        u_(r)
      }
      const s = this.g === 3
      if (e && (this.g === 1 || s) && ((this.g = 2), s))
        for (const r of this.b) r.handlePossibleChange(this)
    }
  }
  readObservable(i) {
    if (!this.x)
      throw new nc(
        "The reader object cannot be used outside its compute function!",
      )
    i.addObserver(this)
    const t = i.get()
    return this.k.add(i), this.l.delete(i), t
  }
  addObserver(i) {
    const t = !this.b.has(i) && this.j > 0
    super.addObserver(i), t && i.beginUpdate(this)
  }
  removeObserver(i) {
    const t = this.b.has(i) && this.j > 0
    super.removeObserver(i), t && i.endUpdate(this)
  }
}
function _K(...i) {
  let t, e, s
  return (
    i.length === 3 ? ([t, e, s] = i) : ([e, s] = i),
    new Fc(new gh(t, void 0, s), e, s, () => Fc.globalTransaction, l2)
  )
}
var Fc = class extends d2 {
  constructor(i, t, e, s, r) {
    super(),
      (this.k = i),
      (this.l = t),
      (this._getValue = e),
      (this.n = s),
      (this.p = r),
      (this.h = !1),
      (this.s = (a) => {
        const o = this._getValue(a),
          c = this.g,
          l = !this.h || !this.p(c, o)
        let u = !1
        l &&
          ((this.g = o),
          this.h &&
            ((u = !0),
            F0t(
              this.n(),
              (d) => {
                Lr()?.handleFromEventObservableTriggered(this, {
                  oldValue: c,
                  newValue: o,
                  change: void 0,
                  didChange: l,
                  hadValue: this.h,
                })
                for (const m of this.b)
                  d.updateObserver(m, this), m.handleChange(this, void 0)
              },
              () => {
                const d = this.q()
                return "Event fired" + (d ? `: ${d}` : "")
              },
            )),
          (this.h = !0)),
          u ||
            Lr()?.handleFromEventObservableTriggered(this, {
              oldValue: c,
              newValue: o,
              change: void 0,
              didChange: l,
              hadValue: this.h,
            })
      })
  }
  q() {
    return this.k.getDebugName(this)
  }
  get debugName() {
    const i = this.q()
    return "From Event" + (i ? `: ${i}` : "")
  }
  c() {
    this.j = this.l(this.s)
  }
  f() {
    this.j.dispose(), (this.j = void 0), (this.h = !1), (this.g = void 0)
  }
  get() {
    return this.j ? (this.h || this.s(void 0), this.g) : this._getValue(void 0)
  }
}
;(function (i) {
  i.Observer = Fc
  function t(e, s) {
    let r = !1
    Fc.globalTransaction === void 0 && ((Fc.globalTransaction = e), (r = !0))
    try {
      s()
    } finally {
      r && (Fc.globalTransaction = void 0)
    }
  }
  i.batchEventsGlobally = t
})(_K || (_K = {}))
function q0t(i) {
  const t = new OK(!1, void 0)
  return (
    i.addObserver(t),
    et(() => {
      i.removeObserver(t)
    })
  )
}
J0t(q0t)
function U0t(i, t) {
  const e = new OK(!0, t)
  return (
    i.addObserver(e),
    t ? t(i.get()) : i.reportChanges(),
    et(() => {
      i.removeObserver(e)
    })
  )
}
C0t(U0t)
var OK = class {
    constructor(i, t) {
      ;(this.b = i), (this.c = t), (this.a = 0)
    }
    beginUpdate(i) {
      this.a++
    }
    endUpdate(i) {
      this.a--,
        this.a === 0 && this.b && (this.c ? this.c(i.get()) : i.reportChanges())
    }
    handlePossibleChange(i) {}
    handleChange(i, t) {}
  },
  M0t = !1
M0t && S0t(new E0t())
function m2(i) {
  if (!i) return
  const t = i.indexOf("+")
  return t < 0 ? i : i.substr(0, t)
}
var H0t = [
    "AI",
    "Azure",
    "Chat",
    "Data Science",
    "Debuggers",
    "Extension Packs",
    "Education",
    "Formatters",
    "Keymaps",
    "Language Packs",
    "Linters",
    "Machine Learning",
    "Notebooks",
    "Programming Languages",
    "SCM Providers",
    "Snippets",
    "Testing",
    "Themes",
    "Visualization",
    "Other",
  ],
  BK
;(function (i) {
  ;(i[(i.System = 0)] = "System"), (i[(i.User = 1)] = "User")
})(BK || (BK = {}))
var qK
;(function (i) {
  ;(i.WIN32_X64 = "win32-x64"),
    (i.WIN32_ARM64 = "win32-arm64"),
    (i.LINUX_X64 = "linux-x64"),
    (i.LINUX_ARM64 = "linux-arm64"),
    (i.LINUX_ARMHF = "linux-armhf"),
    (i.ALPINE_X64 = "alpine-x64"),
    (i.ALPINE_ARM64 = "alpine-arm64"),
    (i.DARWIN_X64 = "darwin-x64"),
    (i.DARWIN_ARM64 = "darwin-arm64"),
    (i.WEB = "web"),
    (i.UNIVERSAL = "universal"),
    (i.UNKNOWN = "unknown"),
    (i.UNDEFINED = "undefined")
})(qK || (qK = {}))
var ae = class {
    constructor(i) {
      ;(this.value = i), (this._lower = i.toLowerCase())
    }
    static equals(i, t) {
      if (typeof i > "u" || i === null) return typeof t > "u" || t === null
      if (typeof t > "u" || t === null) return !1
      if (typeof i == "string" || typeof t == "string") {
        const e = typeof i == "string" ? i : i.value,
          s = typeof t == "string" ? t : t.value
        return Ws(e, s)
      }
      return i._lower === t._lower
    }
    static toKey(i) {
      return typeof i == "string" ? i.toLowerCase() : i._lower
    }
  },
  no = class {
    get size() {
      return this.c.size
    }
    constructor(i) {
      if (((this.c = new Set()), i)) for (const t of i) this.add(t)
    }
    add(i) {
      this.c.add(ae.toKey(i))
    }
    delete(i) {
      return this.c.delete(ae.toKey(i))
    }
    has(i) {
      return this.c.has(ae.toKey(i))
    }
  },
  hn = class {
    constructor() {
      this.c = new Map()
    }
    clear() {
      this.c.clear()
    }
    delete(i) {
      this.c.delete(ae.toKey(i))
    }
    get(i) {
      return this.c.get(ae.toKey(i))
    }
    has(i) {
      return this.c.has(ae.toKey(i))
    }
    set(i, t) {
      this.c.set(ae.toKey(i), t)
    }
    values() {
      return this.c.values()
    }
    forEach(i) {
      this.c.forEach(i)
    }
    [Symbol.iterator]() {
      return this.c[Symbol.iterator]()
    }
  },
  qVt = X("IBuiltinExtensionsScannerService"),
  w6 = X("productService"),
  W0t = "vscode://schemas/vscode-product",
  dn = X("configurationService"),
  UK
;(function (i) {
  ;(i[(i.APPLICATION = 1)] = "APPLICATION"),
    (i[(i.USER = 2)] = "USER"),
    (i[(i.USER_LOCAL = 3)] = "USER_LOCAL"),
    (i[(i.USER_REMOTE = 4)] = "USER_REMOTE"),
    (i[(i.WORKSPACE = 5)] = "WORKSPACE"),
    (i[(i.WORKSPACE_FOLDER = 6)] = "WORKSPACE_FOLDER"),
    (i[(i.DEFAULT = 7)] = "DEFAULT"),
    (i[(i.MEMORY = 8)] = "MEMORY")
})(UK || (UK = {}))
function f2(i, t) {
  const e = Object.create(null)
  for (const s in i) MK(e, s, i[s], t)
  return e
}
function MK(i, t, e, s) {
  const r = t.split("."),
    a = r.pop()
  let o = i
  for (let c = 0; c < r.length; c++) {
    const l = r[c]
    let u = o[l]
    switch (typeof u) {
      case "undefined":
        u = o[l] = Object.create(null)
        break
      case "object":
        if (u === null) {
          s(`Ignoring ${t} as ${r.slice(0, c + 1).join(".")} is null`)
          return
        }
        break
      default:
        s(
          `Ignoring ${t} as ${r.slice(0, c + 1).join(".")} is ${JSON.stringify(u)}`,
        )
        return
    }
    o = u
  }
  if (typeof o == "object" && o !== null)
    try {
      o[a] = e
    } catch {
      s(`Ignoring ${t} as ${r.join(".")} is ${JSON.stringify(o)}`)
    }
  else s(`Ignoring ${t} as ${r.join(".")} is ${JSON.stringify(o)}`)
}
function j0t(i, t) {
  const e = t.split(".")
  HK(i, e)
}
function HK(i, t) {
  const e = t.shift()
  if (t.length === 0) {
    delete i[e]
    return
  }
  if (Object.keys(i).indexOf(e) !== -1) {
    const s = i[e]
    typeof s == "object" &&
      !Array.isArray(s) &&
      (HK(s, t), Object.keys(s).length === 0 && delete i[e])
  }
}
function y6(i, t, e) {
  function s(o, c) {
    let l = o
    for (const u of c) {
      if (typeof l != "object" || l === null) return
      l = l[u]
    }
    return l
  }
  const r = t.split("."),
    a = s(i, r)
  return typeof a > "u" ? e : a
}
function V0t(i) {
  return i.replace(/[\[\]]/g, "")
}
function G0t(i) {
  let t = !1
  const e = new Map(),
    s = new Map()
  if (
    (z0t(i, (d) => {
      if (i === d) return !0
      const m = JSON.stringify(d)
      if (m.length < 30) return !0
      const f = e.get(m)
      if (!f) {
        const p = { schemas: [d] }
        return e.set(m, p), s.set(d, p), !0
      }
      return f.schemas.push(d), s.set(d, f), (t = !0), !1
    }),
    e.clear(),
    !t)
  )
    return JSON.stringify(i)
  let a = "$defs"
  for (; i.hasOwnProperty(a); ) a += "_"
  const o = []
  function c(d) {
    return JSON.stringify(d, (m, f) => {
      if (f !== d) {
        const p = s.get(f)
        if (p && p.schemas.length > 1)
          return (
            p.id || ((p.id = `_${o.length}`), o.push(p.schemas[0])),
            { $ref: `#/${a}/${p.id}` }
          )
      }
      return f
    })
  }
  const l = c(i),
    u = []
  for (let d = 0; d < o.length; d++) u.push(`"_${d}":${c(o[d])}`)
  return u.length
    ? `${l.substring(0, l.length - 1)},"${a}":{${u.join(",")}}}`
    : l
}
function Ac(i) {
  return typeof i == "object" && i !== null
}
function z0t(i, t) {
  if (!i || typeof i != "object") return
  const e = (...l) => {
      for (const u of l) Ac(u) && o.push(u)
    },
    s = (...l) => {
      for (const u of l)
        if (Ac(u))
          for (const d in u) {
            const m = u[d]
            Ac(m) && o.push(m)
          }
    },
    r = (...l) => {
      for (const u of l)
        if (Array.isArray(u)) for (const d of u) Ac(d) && o.push(d)
    },
    a = (l) => {
      if (Array.isArray(l)) for (const u of l) Ac(u) && o.push(u)
      else Ac(l) && o.push(l)
    },
    o = [i]
  let c = o.pop()
  for (; c; )
    t(c) &&
      (e(
        c.additionalItems,
        c.additionalProperties,
        c.not,
        c.contains,
        c.propertyNames,
        c.if,
        c.then,
        c.else,
        c.unevaluatedItems,
        c.unevaluatedProperties,
      ),
      s(
        c.definitions,
        c.$defs,
        c.properties,
        c.patternProperties,
        c.dependencies,
        c.dependentSchemas,
      ),
      r(c.anyOf, c.allOf, c.oneOf, c.prefixItems),
      a(c.items)),
      (c = o.pop())
}
var b6 = { JSONContribution: "base.contributions.json" }
function Y0t(i) {
  return i.length > 0 && i.charAt(i.length - 1) === "#"
    ? i.substring(0, i.length - 1)
    : i
}
var Q0t = class {
    constructor() {
      ;(this.b = new J()),
        (this.onDidChangeSchema = this.b.event),
        (this.a = {})
    }
    registerSchema(i, t) {
      ;(this.a[Y0t(i)] = t), this.b.fire(i)
    }
    notifySchemaChanged(i) {
      this.b.fire(i)
    }
    getSchemaContributions() {
      return { schemas: this.a }
    }
    getSchemaContent(i) {
      const t = this.a[i]
      return t ? G0t(t) : void 0
    }
    hasSchemaContent(i) {
      return !!this.a[i]
    }
  },
  X0t = new Q0t()
Si.add(b6.JSONContribution, X0t)
var WK
;(function (i) {
  ;(i.Multiline = "multilineText"), (i.Singleline = "singlelineText")
})(WK || (WK = {}))
var _c = { Configuration: "base.contributions.configuration" },
  jK
;(function (i) {
  ;(i[(i.APPLICATION = 1)] = "APPLICATION"),
    (i[(i.MACHINE = 2)] = "MACHINE"),
    (i[(i.WINDOW = 3)] = "WINDOW"),
    (i[(i.RESOURCE = 4)] = "RESOURCE"),
    (i[(i.LANGUAGE_OVERRIDABLE = 5)] = "LANGUAGE_OVERRIDABLE"),
    (i[(i.MACHINE_OVERRIDABLE = 6)] = "MACHINE_OVERRIDABLE")
})(jK || (jK = {}))
var T6 = { properties: {}, patternProperties: {} },
  k6 = { properties: {}, patternProperties: {} },
  S6 = { properties: {}, patternProperties: {} },
  E6 = { properties: {}, patternProperties: {} },
  I6 = { properties: {}, patternProperties: {} },
  yh = { properties: {}, patternProperties: {} },
  ao = "vscode://schemas/settings/resourceLanguage",
  P6 = Si.as(b6.JSONContribution),
  K0t = class {
    constructor() {
      ;(this.a = []),
        (this.i = new Set()),
        (this.j = new J()),
        (this.onDidSchemaChange = this.j.event),
        (this.k = new J()),
        (this.onDidUpdateConfiguration = this.k.event),
        (this.b = new Map()),
        (this.c = {
          id: "defaultOverrides",
          title: g(1705, null),
          properties: {},
        }),
        (this.d = [this.c]),
        (this.h = {
          properties: {},
          patternProperties: {},
          additionalProperties: !0,
          allowTrailingCommas: !0,
          allowComments: !0,
        }),
        (this.e = {}),
        (this.f = new Map()),
        (this.g = {}),
        P6.registerSchema(ao, this.h),
        this.z()
    }
    registerConfiguration(i, t = !0) {
      this.registerConfigurations([i], t)
    }
    registerConfigurations(i, t = !0) {
      const e = new Set()
      this.r(i, t, e),
        P6.registerSchema(ao, this.h),
        this.j.fire(),
        this.k.fire({ properties: e })
    }
    deregisterConfigurations(i) {
      const t = new Set()
      this.s(i, t),
        P6.registerSchema(ao, this.h),
        this.j.fire(),
        this.k.fire({ properties: t })
    }
    updateConfigurations({ add: i, remove: t }) {
      const e = new Set()
      this.s(t, e),
        this.r(i, !1, e),
        P6.registerSchema(ao, this.h),
        this.j.fire(),
        this.k.fire({ properties: e })
    }
    registerDefaultConfigurations(i) {
      const t = new Set()
      this.l(i, t),
        this.j.fire(),
        this.k.fire({ properties: t, defaultsOverrides: !0 })
    }
    l(i, t) {
      this.a.push(...i)
      const e = []
      for (const { overrides: s, source: r } of i)
        for (const a in s) {
          t.add(a)
          const o =
              this.b.get(a) ??
              this.b.set(a, { configurationDefaultOverrides: [] }).get(a),
            c = s[a]
          if (
            (o.configurationDefaultOverrides.push({ value: c, source: r }),
            Rr.test(a))
          ) {
            const l = this.o(a, c, r, o.configurationDefaultOverrideValue)
            if (!l) continue
            ;(o.configurationDefaultOverrideValue = l),
              this.n(a, l, r),
              e.push(...bh(a))
          } else {
            const l = this.p(a, c, r, o.configurationDefaultOverrideValue)
            if (!l) continue
            o.configurationDefaultOverrideValue = l
            const u = this.e[a]
            u && (this.A(a, u), this.w(a, u))
          }
        }
      this.q(e)
    }
    deregisterDefaultConfigurations(i) {
      const t = new Set()
      this.m(i, t),
        this.j.fire(),
        this.k.fire({ properties: t, defaultsOverrides: !0 })
    }
    m(i, t) {
      for (const e of i) {
        const s = this.a.indexOf(e)
        s !== -1 && this.a.splice(s, 1)
      }
      for (const { overrides: e, source: s } of i)
        for (const r in e) {
          const a = this.b.get(r)
          if (!a) continue
          const o = a.configurationDefaultOverrides.findIndex((c) =>
            s ? c.source?.id === s.id : c.value === e[r],
          )
          if (o !== -1) {
            if (
              (a.configurationDefaultOverrides.splice(o, 1),
              a.configurationDefaultOverrides.length === 0 && this.b.delete(r),
              Rr.test(r))
            ) {
              let c
              for (const l of a.configurationDefaultOverrides)
                c = this.o(r, l.value, l.source, c)
              c && !xG(c.value)
                ? ((a.configurationDefaultOverrideValue = c), this.n(r, c, s))
                : (this.b.delete(r),
                  delete this.e[r],
                  delete this.c.properties[r])
            } else {
              let c
              for (const u of a.configurationDefaultOverrides)
                c = this.p(r, u.value, u.source, c)
              a.configurationDefaultOverrideValue = c
              const l = this.e[r]
              l && (this.A(r, l), this.w(r, l))
            }
            t.add(r)
          }
        }
      this.y()
    }
    n(i, t, e) {
      const s = {
        type: "object",
        default: t.value,
        description: g(1706, null, V0t(i)),
        $ref: ao,
        defaultDefaultValue: t.value,
        source: e,
        defaultValueSource: e,
      }
      ;(this.e[i] = s), (this.c.properties[i] = s)
    }
    o(i, t, e, s) {
      const r = s?.value || {},
        a = s?.source ?? new Map()
      if (!(a instanceof Map)) {
        console.error("objectConfigurationSources is not a Map")
        return
      }
      for (const o of Object.keys(t)) {
        const c = t[o]
        if (Je(c) && (qu(r[o]) || Je(r[o]))) {
          if (((r[o] = { ...(r[o] ?? {}), ...c }), e))
            for (const u in c) a.set(`${o}.${u}`, e)
        } else (r[o] = c), e ? a.set(o, e) : a.delete(o)
      }
      return { value: r, source: a }
    }
    p(i, t, e, s) {
      const r = this.e[i],
        a = s?.value ?? r?.defaultDefaultValue
      let o = e
      if (
        Je(t) &&
        ((r !== void 0 && r.type === "object") ||
          (r === void 0 && (qu(a) || Je(a))))
      ) {
        if (((o = s?.source ?? new Map()), !(o instanceof Map))) {
          console.error("defaultValueSource is not a Map")
          return
        }
        for (const l in t) e && o.set(`${i}.${l}`, e)
        t = { ...(Je(a) ? a : {}), ...t }
      }
      return { value: t, source: o }
    }
    deltaConfiguration(i) {
      let t = !1
      const e = new Set()
      i.removedDefaults && (this.m(i.removedDefaults, e), (t = !0)),
        i.addedDefaults && (this.l(i.addedDefaults, e), (t = !0)),
        i.removedConfigurations && this.s(i.removedConfigurations, e),
        i.addedConfigurations && this.r(i.addedConfigurations, !1, e),
        this.j.fire(),
        this.k.fire({ properties: e, defaultsOverrides: t })
    }
    notifyConfigurationSchemaUpdated(...i) {
      this.j.fire()
    }
    registerOverrideIdentifiers(i) {
      this.q(i), this.j.fire()
    }
    q(i) {
      for (const t of i) this.i.add(t)
      this.y()
    }
    r(i, t, e) {
      i.forEach((s) => {
        this.u(s, t, s.extensionInfo, s.restrictedProperties, void 0, e),
          this.d.push(s),
          this.v(s)
      })
    }
    s(i, t) {
      const e = (s) => {
        if (s.properties)
          for (const r in s.properties) {
            t.add(r)
            const a = this.e[r]
            a?.policy?.name && this.f.delete(a.policy.name),
              delete this.e[r],
              this.x(r, s.properties[r])
          }
        s.allOf?.forEach((r) => e(r))
      }
      for (const s of i) {
        e(s)
        const r = this.d.indexOf(s)
        r !== -1 && this.d.splice(r, 1)
      }
    }
    u(i, t = !0, e, s, r = 3, a) {
      r = Fe(i.scope) ? r : i.scope
      const o = i.properties
      if (o)
        for (const l in o) {
          const u = o[l]
          if (t && tbt(l, u)) {
            delete o[l]
            continue
          }
          if (
            ((u.source = e),
            (u.defaultDefaultValue = o[l].default),
            this.A(l, u),
            Rr.test(l)
              ? (u.scope = void 0)
              : ((u.scope = Fe(u.scope) ? r : u.scope),
                (u.restricted = Fe(u.restricted)
                  ? !!s?.includes(l)
                  : u.restricted)),
            o[l].hasOwnProperty("included") && !o[l].included)
          ) {
            ;(this.g[l] = o[l]), delete o[l]
            continue
          } else
            (this.e[l] = o[l]),
              o[l].policy?.name && this.f.set(o[l].policy.name, l)
          !o[l].deprecationMessage &&
            o[l].markdownDeprecationMessage &&
            (o[l].deprecationMessage = o[l].markdownDeprecationMessage),
            a.add(l)
        }
      const c = i.allOf
      if (c) for (const l of c) this.u(l, t, e, s, r, a)
    }
    getConfigurations() {
      return this.d
    }
    getConfigurationProperties() {
      return this.e
    }
    getPolicyConfigurations() {
      return this.f
    }
    getExcludedConfigurationProperties() {
      return this.g
    }
    getRegisteredDefaultConfigurations() {
      return [...this.a]
    }
    getConfigurationDefaultsOverrides() {
      const i = new Map()
      for (const [t, e] of this.b)
        e.configurationDefaultOverrideValue &&
          i.set(t, e.configurationDefaultOverrideValue)
      return i
    }
    v(i) {
      const t = (e) => {
        const s = e.properties
        if (s) for (const a in s) this.w(a, s[a])
        e.allOf?.forEach(t)
      }
      t(i)
    }
    w(i, t) {
      switch (((T6.properties[i] = t), t.scope)) {
        case 1:
          k6.properties[i] = t
          break
        case 2:
          S6.properties[i] = t
          break
        case 6:
          E6.properties[i] = t
          break
        case 3:
          I6.properties[i] = t
          break
        case 4:
          yh.properties[i] = t
          break
        case 5:
          ;(yh.properties[i] = t), (this.h.properties[i] = t)
          break
      }
    }
    x(i, t) {
      switch ((delete T6.properties[i], t.scope)) {
        case 1:
          delete k6.properties[i]
          break
        case 2:
          delete S6.properties[i]
          break
        case 6:
          delete E6.properties[i]
          break
        case 3:
          delete I6.properties[i]
          break
        case 4:
        case 5:
          delete yh.properties[i], delete this.h.properties[i]
          break
      }
    }
    y() {
      for (const i of this.i.values()) {
        const t = `[${i}]`,
          e = {
            type: "object",
            description: g(1707, null),
            errorMessage: g(1708, null),
            $ref: ao,
          }
        this.A(t, e),
          (T6.properties[t] = e),
          (k6.properties[t] = e),
          (S6.properties[t] = e),
          (E6.properties[t] = e),
          (I6.properties[t] = e),
          (yh.properties[t] = e)
      }
    }
    z() {
      const i = {
        type: "object",
        description: g(1709, null),
        errorMessage: g(1710, null),
        $ref: ao,
      }
      ;(T6.patternProperties[oo] = i),
        (k6.patternProperties[oo] = i),
        (S6.patternProperties[oo] = i),
        (E6.patternProperties[oo] = i),
        (I6.patternProperties[oo] = i),
        (yh.patternProperties[oo] = i),
        this.j.fire()
    }
    A(i, t) {
      const e = this.b.get(i)?.configurationDefaultOverrideValue
      let s, r
      e &&
        (!t.disallowConfigurationDefault || !e.source) &&
        ((s = e.value), (r = e.source)),
        qu(s) && ((s = t.defaultDefaultValue), (r = void 0)),
        qu(s) && (s = Z0t(t.type)),
        (t.default = s),
        (t.defaultValueSource = r)
    }
  },
  VK = "\\[([^\\]]+)\\]",
  GK = new RegExp(VK, "g"),
  oo = `^(${VK})+$`,
  Rr = new RegExp(oo)
function bh(i) {
  const t = []
  if (Rr.test(i)) {
    let e = GK.exec(i)
    for (; e?.length; ) {
      const s = e[1].trim()
      s && t.push(s), (e = GK.exec(i))
    }
  }
  return ac(t)
}
function Z0t(i) {
  switch (Array.isArray(i) ? i[0] : i) {
    case "boolean":
      return !1
    case "integer":
    case "number":
      return 0
    case "string":
      return ""
    case "array":
      return []
    case "object":
      return {}
    default:
      return null
  }
}
var $6 = new K0t()
Si.add(_c.Configuration, $6)
function tbt(i, t) {
  return i.trim()
    ? Rr.test(i)
      ? g(1712, null, i)
      : $6.getConfigurationProperties()[i] !== void 0
        ? g(1713, null, i)
        : t.policy?.name &&
            $6.getPolicyConfigurations().get(t.policy?.name) !== void 0
          ? g(
              1714,
              null,
              i,
              t.policy?.name,
              $6.getPolicyConfigurations().get(t.policy?.name),
            )
          : null
    : g(1711, null)
}
var ebt = X("requestService"),
  ibt = class {
    constructor(i) {
      this.b = i
    }
    toJSON() {
      if (!this.a) {
        const i = Object.create(null)
        for (const t in this.b)
          t.toLowerCase() === "authorization" ||
          t.toLowerCase() === "proxy-authorization"
            ? (i[t] = "*****")
            : (i[t] = this.b[t])
        this.a = i
      }
      return this.a
    }
  },
  sbt = class extends at {
    constructor(i) {
      super(), (this.b = i), (this.a = 0)
    }
    async c(i, t) {
      const e = `[network] #${++this.a}: ${i.url}`
      this.b.trace(`${e} - begin`, i.type, new ibt(i.headers ?? {}))
      try {
        const s = await t()
        return (
          this.b.trace(`${e} - end`, i.type, s.res.statusCode, s.res.headers), s
        )
      } catch (s) {
        throw (this.b.error(`${e} - error`, i.type, CV(s)), s)
      }
    }
  }
function rbt(i) {
  return (
    (i.res.statusCode && i.res.statusCode >= 200 && i.res.statusCode < 300) ||
    i.res.statusCode === 1223
  )
}
function nbt(i) {
  return i.res.statusCode === 204
}
async function abt(i) {
  if (!rbt(i)) throw new Error("Server returned " + i.res.statusCode)
  if (nbt(i)) return null
  const e = (await ovt(i.stream)).toString()
  try {
    return JSON.parse(e)
  } catch (s) {
    throw (
      ((s.message +=
        `:
` + e),
      s)
    )
  }
}
var p2
function obt(i) {
  const t = Si.as(_c.Configuration),
    e = p2
  ;(p2 = {
    id: "http",
    order: 15,
    title: g(2107, null),
    type: "object",
    scope: i,
    properties: {
      "http.proxy": {
        type: "string",
        pattern:
          "^(https?|socks|socks4a?|socks5h?)://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$",
        markdownDescription: g(2108, null),
        restricted: !0,
      },
      "http.proxyStrictSSL": {
        type: "boolean",
        default: !0,
        description: g(2109, null),
        restricted: !0,
      },
      "http.proxyKerberosServicePrincipal": {
        type: "string",
        markdownDescription: g(2110, null),
        restricted: !0,
      },
      "http.noProxy": {
        type: "array",
        items: { type: "string" },
        markdownDescription: g(2111, null),
        restricted: !0,
      },
      "http.proxyAuthorization": {
        type: ["null", "string"],
        default: null,
        markdownDescription: g(2112, null),
        restricted: !0,
      },
      "http.proxySupport": {
        type: "string",
        enum: ["off", "on", "fallback", "override"],
        enumDescriptions: [
          g(2113, null),
          g(2114, null),
          g(2115, null),
          g(2116, null),
        ],
        default: "override",
        description: g(2117, null),
        restricted: !0,
      },
      "http.systemCertificates": {
        type: "boolean",
        default: !0,
        description: g(2118, null),
        restricted: !0,
      },
      "http.experimental.systemCertificatesV2": {
        type: "boolean",
        tags: ["experimental"],
        default: !1,
        description: g(2119, null),
        restricted: !0,
      },
      "http.electronFetch": {
        type: "boolean",
        default: !1,
        description: g(2120, null),
        restricted: !0,
      },
      "http.fetchAdditionalSupport": {
        type: "boolean",
        default: !0,
        markdownDescription: g(
          2121,
          null,
          "`#http.proxySupport#`",
          "`#http.systemCertificates#`",
        ),
        restricted: !0,
      },
    },
  }),
    t.updateConfigurations({ add: [p2], remove: e ? [e] : [] })
}
obt(1)
var Th
;(function (i) {
  ;(i[(i.STORAGE_DOES_NOT_EXIST = 0)] = "STORAGE_DOES_NOT_EXIST"),
    (i[(i.STORAGE_IN_MEMORY = 1)] = "STORAGE_IN_MEMORY")
})(Th || (Th = {}))
var ir
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Initialized = 1)] = "Initialized"),
    (i[(i.Closed = 2)] = "Closed")
})(ir || (ir = {}))
var UVt = class eut extends at {
    static {
      this.a = 100
    }
    constructor(t, e = Object.create(null)) {
      super(),
        (this.q = t),
        (this.r = e),
        (this.b = this.D(new Fu())),
        (this.onDidChangeStorage = this.b.event),
        (this.c = ir.None),
        (this.f = new Map()),
        (this.g = this.D(new J_(eut.a))),
        (this.h = new Set()),
        (this.j = new Map()),
        (this.m = void 0),
        (this.n = []),
        this.s()
    }
    s() {
      this.D(this.q.onDidChangeItemsExternal((t) => this.t(t)))
    }
    t(t) {
      this.b.pause()
      try {
        t.changed?.forEach((e, s) => this.u(s, e)),
          t.deleted?.forEach((e) => this.u(e, void 0))
      } finally {
        this.b.resume()
      }
    }
    u(t, e) {
      if (this.c === ir.Closed) return
      let s = !1
      Fe(e)
        ? (s = this.f.delete(t))
        : this.f.get(t) !== e && (this.f.set(t, e), (s = !0)),
        s && this.b.fire({ key: t, external: !0 })
    }
    get items() {
      return this.f
    }
    get size() {
      return this.f.size
    }
    async init() {
      this.c === ir.None &&
        ((this.c = ir.Initialized),
        this.r.hint !== Th.STORAGE_DOES_NOT_EXIST &&
          (this.f = await this.q.getItems()))
    }
    cursorDiskKVGet(t) {
      return this.q.cursorDiskKVGet(t)
    }
    cursorDiskKVSet(t, e) {
      return this.q.cursorDiskKVSet(t, e)
    }
    get(t, e) {
      const s = this.f.get(t)
      return Fe(s) ? e : s
    }
    getBoolean(t, e) {
      const s = this.get(t)
      return Fe(s) ? e : s === "true"
    }
    getNumber(t, e) {
      const s = this.get(t)
      return Fe(s) ? e : parseInt(s, 10)
    }
    getObject(t, e) {
      const s = this.get(t)
      return Fe(s) ? e : EY(s)
    }
    async set(t, e, s = !1) {
      if (this.c === ir.Closed) return
      if (Fe(e)) return this.delete(t, s)
      const r = Je(e) || Array.isArray(e) ? Fvt(e) : String(e)
      if (this.f.get(t) !== r)
        return (
          this.f.set(t, r),
          this.j.set(t, r),
          this.h.delete(t),
          this.b.fire({ key: t, external: s }),
          this.C()
        )
    }
    async delete(t, e = !1) {
      if (!(this.c === ir.Closed || !this.f.delete(t)))
        return (
          this.h.has(t) || this.h.add(t),
          this.j.delete(t),
          this.b.fire({ key: t, external: e }),
          this.C()
        )
    }
    async optimize() {
      if (this.c !== ir.Closed) return await this.flush(0), this.q.optimize()
    }
    async close() {
      return this.m || (this.m = this.w()), this.m
    }
    async w() {
      this.c = ir.Closed
      try {
        await this.C(0)
      } catch {}
      await this.q.close(() => this.f)
    }
    get y() {
      return this.j.size > 0 || this.h.size > 0
    }
    async z() {
      if (!this.y) return
      const t = { insert: this.j, delete: this.h }
      return (
        (this.h = new Set()),
        (this.j = new Map()),
        this.q.updateItems(t).finally(() => {
          if (!this.y) for (; this.n.length; ) this.n.pop()?.()
        })
      )
    }
    async flush(t) {
      if (!(this.c === ir.Closed || this.m)) return this.C(t)
    }
    async C(t) {
      return this.r.hint === Th.STORAGE_IN_MEMORY
        ? this.z()
        : this.g.trigger(() => this.z(), t)
    }
    async whenFlushed() {
      if (this.y) return new Promise((t) => this.n.push(t))
    }
    isInMemory() {
      return this.r.hint === Th.STORAGE_IN_MEMORY
    }
  },
  g2 = X("environmentService"),
  cbt = g2,
  zK = X("IUriIdentityService"),
  YK
;(function (i) {
  ;(i.Settings = "settings"),
    (i.Keybindings = "keybindings"),
    (i.Snippets = "snippets"),
    (i.Tasks = "tasks"),
    (i.Extensions = "extensions"),
    (i.GlobalState = "globalState")
})(YK || (YK = {}))
function lbt(i) {
  const t = i
  return !!(
    t &&
    typeof t == "object" &&
    typeof t.id == "string" &&
    typeof t.isDefault == "boolean" &&
    typeof t.name == "string" &&
    S.isUri(t.location) &&
    S.isUri(t.globalStorageHome) &&
    S.isUri(t.settingsResource) &&
    S.isUri(t.keybindingsResource) &&
    S.isUri(t.tasksResource) &&
    S.isUri(t.snippetsHome) &&
    S.isUri(t.extensionsResource)
  )
}
var ubt = X("IUserDataProfilesService")
function x6(i, t, e, s, r, a) {
  return {
    id: i,
    name: t,
    location: e,
    isDefault: !1,
    icon: r?.icon,
    globalStorageHome:
      a && r?.useDefaultFlags?.globalState
        ? a.globalStorageHome
        : He(e, "globalStorage"),
    settingsResource:
      a && r?.useDefaultFlags?.settings
        ? a.settingsResource
        : He(e, "settings.json"),
    keybindingsResource:
      a && r?.useDefaultFlags?.keybindings
        ? a.keybindingsResource
        : He(e, "keybindings.json"),
    tasksResource:
      a && r?.useDefaultFlags?.tasks ? a.tasksResource : He(e, "tasks.json"),
    snippetsHome:
      a && r?.useDefaultFlags?.snippets ? a.snippetsHome : He(e, "snippets"),
    extensionsResource:
      a && r?.useDefaultFlags?.extensions
        ? a.extensionsResource
        : He(e, "extensions.json"),
    cacheHome: He(s, i),
    useDefaultFlags: r?.useDefaultFlags,
    isTransient: r?.transient,
    workspaces: r?.workspaces,
  }
}
var QK = class extends at {
  static {
    this.b = "userDataProfiles"
  }
  static {
    this.c = "profileAssociations"
  }
  get defaultProfile() {
    return this.profiles[0]
  }
  get profiles() {
    return [...this.z.profiles, ...this.q.profiles]
  }
  constructor(t, e, s, r) {
    super(),
      (this.r = t),
      (this.s = e),
      (this.t = s),
      (this.u = r),
      (this.g = this.D(new J())),
      (this.onDidChangeProfiles = this.g.event),
      (this.h = this.D(new J())),
      (this.onWillCreateProfile = this.h.event),
      (this.j = this.D(new J())),
      (this.onWillRemoveProfile = this.j.event),
      (this.m = this.D(new J())),
      (this.onDidResetWorkspaces = this.m.event),
      (this.n = new Map()),
      (this.q = { profiles: [], emptyWindows: new Map() }),
      (this.profilesHome = He(this.r.userRoamingDataHome, "profiles")),
      (this.f = He(this.r.cacheHome, "CachedProfilesData"))
  }
  init() {
    this.y = void 0
  }
  get z() {
    if (!this.y) {
      const t = this.C(),
        e = [t]
      try {
        for (const r of this.N()) {
          if (!r.name || !_t(r.name) || !r.location) {
            this.u.warn(
              "Skipping the invalid stored profile",
              r.location || r.name,
            )
            continue
          }
          e.push(
            x6(
              xr(r.location),
              r.name,
              r.location,
              this.f,
              { icon: r.icon, useDefaultFlags: r.useDefaultFlags },
              t,
            ),
          )
        }
      } catch (r) {
        this.u.error(r)
      }
      const s = new Map()
      if (e.length)
        try {
          const r = this.P()
          if (r.workspaces)
            for (const [a, o] of Object.entries(r.workspaces)) {
              const c = S.parse(a),
                l = e.find((u) => u.id === o)
              if (l) {
                const u = l.workspaces ? l.workspaces.slice(0) : []
                u.push(c), (l.workspaces = u)
              }
            }
          if (r.emptyWindows)
            for (const [a, o] of Object.entries(r.emptyWindows)) {
              const c = e.find((l) => l.id === o)
              c && s.set(a, c)
            }
        } catch (r) {
          this.u.error(r)
        }
      this.y = { profiles: e, emptyWindows: s }
    }
    return this.y
  }
  C() {
    const t = x6(
      "__default__profile__",
      g(2493, null),
      this.r.userRoamingDataHome,
      this.f,
    )
    return {
      ...t,
      extensionsResource: this.R() ?? t.extensionsResource,
      isDefault: !0,
    }
  }
  async createTransientProfile(t) {
    const e = "Temp",
      s = new RegExp(`${Vn(e)}\\s(\\d+)`)
    let r = 0
    for (const o of this.profiles) {
      const c = s.exec(o.name),
        l = c ? parseInt(c[1]) : 0
      r = l > r ? l : r
    }
    const a = `${e} ${r + 1}`
    return this.createProfile(nn(Ze()).toString(16), a, { transient: !0 }, t)
  }
  async createNamedProfile(t, e, s) {
    return this.createProfile(nn(Ze()).toString(16), t, e, s)
  }
  async createProfile(t, e, s, r) {
    return await this.F(t, e, s, r)
  }
  async F(t, e, s, r) {
    if (!_t(e) || !e)
      throw new Error(
        "Name of the profile is mandatory and must be of type `string`",
      )
    let a = this.n.get(e)
    return (
      a ||
        ((a = (async () => {
          try {
            if (
              this.profiles.find(
                (d) =>
                  d.id === t ||
                  (!d.isTransient && !s?.transient && d.name === e),
              )
            )
              throw new Error(`Profile with ${e} name already exists`)
            const c = r ? this.G(r) : void 0
            S.isUri(c) && (s = { ...s, workspaces: [c] })
            const l = x6(
              t,
              e,
              He(this.profilesHome, t),
              this.f,
              s,
              this.defaultProfile,
            )
            await this.s.createFolder(l.location)
            const u = []
            return (
              this.h.fire({
                profile: l,
                join(d) {
                  u.push(d)
                },
              }),
              await Qn.settled(u),
              c && !S.isUri(c) && this.L(c, l, !!l.isTransient),
              this.I([l], [], []),
              l
            )
          } finally {
            this.n.delete(e)
          }
        })()),
        this.n.set(e, a)),
      a
    )
  }
  async updateProfile(t, e) {
    const s = []
    for (const a of this.profiles) {
      let o
      if (t.id === a.id)
        a.isDefault
          ? e.workspaces && ((o = a), (o.workspaces = e.workspaces))
          : (o = x6(
              a.id,
              e.name ?? a.name,
              a.location,
              this.f,
              {
                icon: e.icon === null ? void 0 : (e.icon ?? a.icon),
                transient: e.transient ?? a.isTransient,
                useDefaultFlags: e.useDefaultFlags ?? a.useDefaultFlags,
                workspaces: e.workspaces ?? a.workspaces,
              },
              this.defaultProfile,
            ))
      else if (e.workspaces) {
        const c = a.workspaces?.filter(
          (l) => !e.workspaces?.some((u) => this.t.extUri.isEqual(l, u)),
        )
        a.workspaces?.length !== c?.length && ((o = a), (o.workspaces = c))
      }
      o && s.push(o)
    }
    if (!s.length)
      throw t.isDefault
        ? new Error("Cannot update default profile")
        : new Error(`Profile '${t.name}' does not exist`)
    this.I([], [], s)
    const r = this.profiles.find((a) => a.id === t.id)
    if (!r) throw new Error(`Profile '${t.name}' was not updated`)
    return r
  }
  async removeProfile(t) {
    if (t.isDefault) throw new Error("Cannot remove default profile")
    const e = this.profiles.find((r) => r.id === t.id)
    if (!e) throw new Error(`Profile '${t.name}' does not exist`)
    const s = []
    this.j.fire({
      profile: e,
      join(r) {
        s.push(r)
      },
    })
    try {
      await Promise.allSettled(s)
    } catch (r) {
      this.u.error(r)
    }
    this.I([], [e], [])
    try {
      await this.s.del(e.cacheHome, { recursive: !0 })
    } catch (r) {
      n0t(r) !== 1 && this.u.error(r)
    }
  }
  async setProfileForWorkspace(t, e) {
    const s = this.profiles.find((a) => a.id === e.id)
    if (!s) throw new Error(`Profile '${e.name}' does not exist`)
    const r = this.G(t)
    if (S.isUri(r)) {
      const a = s.workspaces ? [...s.workspaces] : []
      a.some((o) => this.t.extUri.isEqual(o, r)) ||
        (a.push(r), await this.updateProfile(s, { workspaces: a }))
    } else this.L(r, s, !1), this.M(this.profiles)
  }
  unsetWorkspace(t, e = !1) {
    const s = this.G(t)
    if (S.isUri(s)) {
      const r = this.getProfileForWorkspace(t)
      r &&
        this.updateProfile(r, {
          workspaces: r.workspaces?.filter((a) => !this.t.extUri.isEqual(a, s)),
        })
    } else this.L(s, void 0, e), this.M(this.profiles)
  }
  async resetWorkspaces() {
    this.q.emptyWindows.clear(), this.z.emptyWindows.clear()
    for (const t of this.profiles) t.workspaces = void 0
    this.I([], [], this.profiles), this.m.fire()
  }
  async cleanUp() {
    if (await this.s.exists(this.profilesHome)) {
      const t = await this.s.resolve(this.profilesHome)
      await Promise.all(
        (t.children || [])
          .filter(
            (e) =>
              e.isDirectory &&
              this.profiles.every(
                (s) => !this.t.extUri.isEqual(s.location, e.resource),
              ),
          )
          .map((e) => this.s.del(e.resource, { recursive: !0 })),
      )
    }
  }
  async cleanUpTransientProfiles() {
    const t = this.q.profiles.filter((e) => !this.H(e))
    await Promise.allSettled(t.map((e) => this.removeProfile(e)))
  }
  getProfileForWorkspace(t) {
    const e = this.G(t)
    return S.isUri(e)
      ? this.profiles.find((s) =>
          s.workspaces?.some((r) => this.t.extUri.isEqual(r, e)),
        )
      : (this.z.emptyWindows.get(e) ?? this.q.emptyWindows.get(e))
  }
  G(t) {
    return Qwt(t) ? t.uri : Xwt(t) ? t.configPath : t.id
  }
  H(t) {
    return !!(
      t.workspaces?.length ||
      [...this.z.emptyWindows.values()].some((e) =>
        this.t.extUri.isEqual(e.location, t.location),
      ) ||
      [...this.q.emptyWindows.values()].some((e) =>
        this.t.extUri.isEqual(e.location, t.location),
      )
    )
  }
  I(t, e, s) {
    const r = [...this.profiles, ...t],
      a = this.q.profiles
    this.q.profiles = []
    const o = []
    for (let c of r) {
      if (e.some((l) => c.id === l.id)) {
        for (const l of [...this.z.emptyWindows.keys()])
          c.id === this.z.emptyWindows.get(l)?.id &&
            this.z.emptyWindows.delete(l)
        continue
      }
      if (!c.isDefault) {
        c = s.find((u) => c.id === u.id) ?? c
        const l = a.find((u) => c.id === u.id)
        if (c.isTransient) this.q.profiles.push(c)
        else if (l) {
          for (const [u, d] of this.q.emptyWindows.entries())
            if (c.id === d.id) {
              this.q.emptyWindows.delete(u), this.z.emptyWindows.set(u, c)
              break
            }
        }
      }
      c.workspaces?.length === 0 && (c.workspaces = void 0), o.push(c)
    }
    this.M(o), this.J(t, e, s)
  }
  J(t, e, s) {
    this.g.fire({ added: t, removed: e, updated: s, all: this.profiles })
  }
  L(t, e, s) {
    ;(s = e?.isTransient ? !0 : s),
      s
        ? e
          ? this.q.emptyWindows.set(t, e)
          : this.q.emptyWindows.delete(t)
        : (this.q.emptyWindows.delete(t),
          e ? this.z.emptyWindows.set(t, e) : this.z.emptyWindows.delete(t))
  }
  M(t) {
    const e = [],
      s = {},
      r = {}
    for (const a of t)
      if (
        !a.isTransient &&
        (a.isDefault ||
          e.push({
            location: a.location,
            name: a.name,
            icon: a.icon,
            useDefaultFlags: a.useDefaultFlags,
          }),
        a.workspaces)
      )
        for (const o of a.workspaces) s[o.toString()] = a.id
    for (const [a, o] of this.z.emptyWindows.entries()) r[a.toString()] = o.id
    this.Q({ workspaces: s, emptyWindows: r }), this.O(e), (this.y = void 0)
  }
  N() {
    return []
  }
  O(t) {
    throw new Error("not implemented")
  }
  P() {
    return {}
  }
  Q(t) {
    throw new Error("not implemented")
  }
  R() {}
}
QK = __decorate(
  [__param(0, g2), __param(1, s0t), __param(2, zK), __param(3, Rt)],
  QK,
)
var hbt = "__$__isNewStorageMarker",
  N6 = "__$__targetStorageMarker",
  XK = X("storageService"),
  Oc
;(function (i) {
  ;(i[(i.NONE = 0)] = "NONE"), (i[(i.SHUTDOWN = 1)] = "SHUTDOWN")
})(Oc || (Oc = {}))
var KK
;(function (i) {
  ;(i[(i.APPLICATION = -1)] = "APPLICATION"),
    (i[(i.PROFILE = 0)] = "PROFILE"),
    (i[(i.WORKSPACE = 1)] = "WORKSPACE")
})(KK || (KK = {}))
var ZK
;(function (i) {
  ;(i[(i.USER = 0)] = "USER"), (i[(i.MACHINE = 1)] = "MACHINE")
})(ZK || (ZK = {}))
function dbt(i) {
  const t = i.get(N6)
  if (t)
    try {
      return JSON.parse(t)
    } catch {}
  return Object.create(null)
}
var HVt = class iut extends at {
  static {
    this.a = 60 * 1e3
  }
  constructor(t = { flushInterval: iut.a }) {
    super(),
      (this.n = t),
      (this.b = this.D(new Fu())),
      (this.f = this.D(new Fu())),
      (this.onDidChangeTarget = this.f.event),
      (this.g = this.D(new J())),
      (this.onWillSaveState = this.g.event),
      (this.j = this.D(new tn(() => this.q(), this.n.flushInterval))),
      (this.m = this.D(new zr())),
      (this.C = void 0),
      (this.G = void 0),
      (this.I = void 0),
      (this.N = [])
  }
  onDidChangeValue(t, e, s) {
    return Qt.filter(
      this.b.event,
      (r) => r.scope === t && (e === void 0 || r.key === e),
      s,
    )
  }
  q() {
    this.m.value = ez(() => {
      this.r() && this.flush(), this.j.schedule()
    })
  }
  r() {
    return !0
  }
  t() {
    Hs([this.m, this.j])
  }
  initialize() {
    return (
      this.h ||
        (this.h = (async () => {
          Ae("code/willInitStorage")
          try {
            await this.Q()
          } finally {
            Ae("code/didInitStorage")
          }
          this.j.schedule()
        })()),
      this.h
    )
  }
  u(t, e) {
    const { key: s, external: r } = e
    if (s === N6) {
      switch (t) {
        case -1:
          this.I = void 0
          break
        case 0:
          this.G = void 0
          break
        case 1:
          this.C = void 0
          break
      }
      this.f.fire({ scope: t })
    } else this.b.fire({ scope: t, key: s, target: this.L(t)[s], external: r })
  }
  w(t) {
    this.g.fire({ reason: t })
  }
  get(t, e, s) {
    return this.R(e)?.get(t, s)
  }
  getBoolean(t, e, s) {
    return this.R(e)?.getBoolean(t, s)
  }
  getNumber(t, e, s) {
    return this.R(e)?.getNumber(t, s)
  }
  getObject(t, e, s) {
    return this.R(e)?.getObject(t, s)
  }
  storeAll(t, e) {
    this.y(() => {
      for (const s of t) this.store(s.key, s.value, s.scope, s.target, e)
    })
  }
  store(t, e, s, r, a = !1) {
    if (Fe(e)) {
      this.remove(t, s, a)
      return
    }
    this.y(() => {
      this.z(t, s, r), this.R(s)?.set(t, e, a)
    })
  }
  remove(t, e, s = !1) {
    this.y(() => {
      this.z(t, e, void 0), this.R(e)?.delete(t, s)
    })
  }
  y(t) {
    this.b.pause(), this.f.pause()
    try {
      t()
    } finally {
      this.b.resume(), this.f.resume()
    }
  }
  keys(t, e) {
    const s = [],
      r = this.L(t)
    for (const a of Object.keys(r)) r[a] === e && s.push(a)
    return s
  }
  z(t, e, s, r = !1) {
    const a = this.L(e)
    typeof s == "number"
      ? a[t] !== s && ((a[t] = s), this.R(e)?.set(N6, JSON.stringify(a), r))
      : typeof a[t] == "number" &&
        (delete a[t], this.R(e)?.set(N6, JSON.stringify(a), r))
  }
  get F() {
    return this.C || (this.C = this.M(1)), this.C
  }
  get H() {
    return this.G || (this.G = this.M(0)), this.G
  }
  get J() {
    return this.I || (this.I = this.M(-1)), this.I
  }
  L(t) {
    switch (t) {
      case -1:
        return this.J
      case 0:
        return this.H
      default:
        return this.F
    }
  }
  M(t) {
    const e = this.R(t)
    return e ? dbt(e) : Object.create(null)
  }
  isNew(t) {
    return this.getBoolean(hbt, t) === !0
  }
  async cursorDiskKVGet(t) {
    return this.R(-1)?.cursorDiskKVGet(t)
  }
  async cursorDiskKVSet(t, e) {
    return this.R(-1)?.cursorDiskKVSet(t, e)
  }
  cursorDiskKVOnShouldSave(t) {
    return (
      this.N.push(t),
      {
        dispose: () => {
          this.N = this.N.filter((e) => e !== t)
        },
      }
    )
  }
  async flush(t = Oc.NONE) {
    this.g.fire({ reason: t })
    const e = this.R(-1),
      s = this.R(0),
      r = this.R(1)
    switch (t) {
      case Oc.NONE:
        for (const a of this.N)
          try {
            a().catch(console.error)
          } catch {}
        await Qn.settled([
          e?.whenFlushed() ?? Promise.resolve(),
          s?.whenFlushed() ?? Promise.resolve(),
          r?.whenFlushed() ?? Promise.resolve(),
        ])
        break
      case Oc.SHUTDOWN:
        for (const a of this.N)
          try {
            await a()
          } catch (o) {
            console.error(o)
          }
        await Qn.settled([
          e?.flush(0) ?? Promise.resolve(),
          s?.flush(0) ?? Promise.resolve(),
          r?.flush(0) ?? Promise.resolve(),
        ])
        break
    }
  }
  async log() {
    const t = this.R(-1)?.items ?? new Map(),
      e = this.R(0)?.items ?? new Map(),
      s = this.R(1)?.items ?? new Map()
    return mbt(t, e, s, this.S(-1) ?? "", this.S(0) ?? "", this.S(1) ?? "")
  }
  async optimize(t) {
    return await this.flush(), this.R(t)?.optimize()
  }
  async switch(t, e) {
    return this.w(Oc.NONE), lbt(t) ? this.U(t, e) : this.W(t, e)
  }
  O(t, e) {
    return !(t.id === e.id || (tZ(e) && tZ(t)))
  }
  P(t, e, s) {
    this.y(() => {
      const r = new Set()
      for (const [a, o] of t)
        r.add(a), e.get(a) !== o && this.u(s, { key: a, external: !0 })
      for (const [a] of e.items) r.has(a) || this.u(s, { key: a, external: !0 })
    })
  }
}
function tZ(i) {
  return i.isDefault || !!i.useDefaultFlags?.globalState
}
async function mbt(i, t, e, s, r, a) {
  const o = (b) => {
      try {
        return JSON.parse(b)
      } catch {
        return b
      }
    },
    c = new Map(),
    l = new Map()
  i.forEach((b, k) => {
    c.set(k, b), l.set(k, o(b))
  })
  const u = new Map(),
    d = new Map()
  t.forEach((b, k) => {
    u.set(k, b), d.set(k, o(b))
  })
  const m = new Map(),
    f = new Map()
  e.forEach((b, k) => {
    m.set(k, b), f.set(k, o(b))
  }),
    console.group(
      s !== r
        ? `Storage: Application (path: ${s})`
        : `Storage: Application & Profile (path: ${s}, default profile)`,
    )
  const p = []
  if (
    (c.forEach((b, k) => {
      p.push({ key: k, value: b })
    }),
    console.table(p),
    console.groupEnd(),
    console.log(l),
    s !== r)
  ) {
    console.group(`Storage: Profile (path: ${r}, profile specific)`)
    const b = []
    u.forEach((k, E) => {
      b.push({ key: E, value: k })
    }),
      console.table(b),
      console.groupEnd(),
      console.log(d)
  }
  console.group(`Storage: Workspace (path: ${a})`)
  const v = []
  m.forEach((b, k) => {
    v.push({ key: k, value: b })
  }),
    console.table(v),
    console.groupEnd(),
    console.log(f)
}
var kh
;(function (i) {
  ;(i.responseVote = new W("chatSessionResponseVote", "", {
    type: "string",
    description: g(5103, null),
  })),
    (i.responseDetectedAgentCommand = new W(
      "chatSessionResponseDetectedAgentOrCommand",
      !1,
      { type: "boolean", description: g(5104, null) },
    )),
    (i.responseSupportsIssueReporting = new W(
      "chatResponseSupportsIssueReporting",
      !1,
      { type: "boolean", description: g(5105, null) },
    )),
    (i.responseIsFiltered = new W("chatSessionResponseFiltered", !1, {
      type: "boolean",
      description: g(5106, null),
    })),
    (i.responseHasError = new W("chatSessionResponseError", !1, {
      type: "boolean",
      description: g(5107, null),
    })),
    (i.requestInProgress = new W("chatSessionRequestInProgress", !1, {
      type: "boolean",
      description: g(5108, null),
    })),
    (i.isResponse = new W("chatResponse", !1, {
      type: "boolean",
      description: g(5109, null),
    })),
    (i.isRequest = new W("chatRequest", !1, {
      type: "boolean",
      description: g(5110, null),
    })),
    (i.itemId = new W("chatItemId", "", {
      type: "string",
      description: g(5111, null),
    })),
    (i.lastItemId = new W("chatLastItemId", [], {
      type: "string",
      description: g(5112, null),
    })),
    (i.editApplied = new W("chatEditApplied", !1, {
      type: "boolean",
      description: g(5113, null),
    })),
    (i.inputHasText = new W("chatInputHasText", !1, {
      type: "boolean",
      description: g(5114, null),
    })),
    (i.inputHasFocus = new W("chatInputHasFocus", !1, {
      type: "boolean",
      description: g(5115, null),
    })),
    (i.inChatInput = new W("inChatInput", !1, {
      type: "boolean",
      description: g(5116, null),
    })),
    (i.inChatSession = new W("inChat", !1, {
      type: "boolean",
      description: g(5117, null),
    })),
    (i.enabled = new W("chatIsEnabled", !1, {
      type: "boolean",
      description: g(5118, null),
    })),
    (i.panelParticipantRegistered = new W(
      "chatPanelParticipantRegistered",
      !1,
      { type: "boolean", description: g(5119, null) },
    )),
    (i.editingParticipantRegistered = new W(
      "chatEditingParticipantRegistered",
      !1,
      { type: "boolean", description: g(5120, null) },
    )),
    (i.chatEditingCanUndo = new W("chatEditingCanUndo", !1, {
      type: "boolean",
      description: g(5121, null),
    })),
    (i.chatEditingCanRedo = new W("chatEditingCanRedo", !1, {
      type: "boolean",
      description: g(5122, null),
    })),
    (i.extensionInvalid = new W("chatExtensionInvalid", !1, {
      type: "boolean",
      description: g(5123, null),
    })),
    (i.inputCursorAtTop = new W("chatCursorAtTop", !1)),
    (i.inputHasAgent = new W("chatInputHasAgent", !1)),
    (i.location = new W("chatLocation", void 0)),
    (i.inQuickChat = new W("quickChatHasFocus", !1, {
      type: "boolean",
      description: g(5124, null),
    })),
    (i.hasFileAttachments = new W("chatHasFileAttachments", !1, {
      type: "boolean",
      description: g(5125, null),
    })),
    (i.languageModelsAreUserSelectable = new W(
      "chatModelsAreUserSelectable",
      !1,
      { type: "boolean", description: g(5126, null) },
    )),
    (i.Setup = {
      canSignUp: new W("chatSetupCanSignUp", !1, !0),
      signedOut: new W("chatSetupSignedOut", !1, !0),
      limited: new W("chatSetupLimited", !1, !0),
      triggered: new W("chatSetupTriggered", !1, !0),
      installed: new W("chatSetupInstalled", !1, !0),
    }),
    (i.chatQuotaExceeded = new W("chatQuotaExceeded", !1, !0)),
    (i.completionsQuotaExceeded = new W("completionsQuotaExceeded", !1, !0))
})(kh || (kh = {}))
var Sh, Ei
;(function (i) {
  ;(i.Panel = "panel"),
    (i.Terminal = "terminal"),
    (i.Notebook = "notebook"),
    (i.Editor = "editor"),
    (i.EditingSession = "editing-session")
})(Ei || (Ei = {})),
  (function (i) {
    function t(e) {
      switch (e) {
        case "panel":
          return i.Panel
        case "terminal":
          return i.Terminal
        case "notebook":
          return i.Notebook
        case "editor":
          return i.Editor
        case "editing-session":
          return i.EditingSession
      }
      return i.Panel
    }
    i.fromRaw = t
  })(Ei || (Ei = {}))
var WVt = X("chatAgentService"),
  eZ = class extends at {
    static {
      this.AGENT_LEADER = "@"
    }
    constructor(t) {
      super(),
        (this.q = t),
        (this.b = new Map()),
        (this.f = new J()),
        (this.onDidChangeAgents = this.f.event),
        (this.g = new Set()),
        (this.n = new Map()),
        (this.t = new Map()),
        (this.h = kh.enabled.bindTo(this.q)),
        (this.j = kh.panelParticipantRegistered.bindTo(this.q)),
        (this.m = kh.editingParticipantRegistered.bindTo(this.q)),
        this.D(
          t.onDidChangeContext((e) => {
            e.affectsSome(this.g) && this.s()
          }),
        )
    }
    registerAgent(t, e) {
      if (this.getAgent(t))
        throw new Error(`Agent already registered: ${JSON.stringify(t)}`)
      const r = this,
        a = e.slashCommands
      e = {
        ...e,
        get slashCommands() {
          return a.filter(
            (c) => !c.when || r.q.contextMatchesRules(ui.deserialize(c.when)),
          )
        },
      }
      const o = { data: e }
      return (
        this.b.set(t, o),
        this.r(),
        this.s(),
        this.f.fire(void 0),
        et(() => {
          this.b.delete(t), this.r(), this.s(), this.f.fire(void 0)
        })
      )
    }
    r() {
      this.g.clear()
      for (const t of this.b.values())
        if (t.data.when) {
          const e = ui.deserialize(t.data.when)
          for (const s of e?.keys() || []) this.g.add(s)
        }
    }
    s() {
      let t = !1,
        e = !1
      for (const s of this.getAgents())
        s.isDefault && s.locations.includes(Ei.EditingSession)
          ? (t = !0)
          : s.isDefault && (e = !0)
      this.m.set(t), this.j.set(e)
    }
    registerAgentImplementation(t, e) {
      const s = this.b.get(t)
      if (!s) throw new Error(`Unknown agent: ${JSON.stringify(t)}`)
      if (s.impl)
        throw new Error(
          `Agent already has implementation: ${JSON.stringify(t)}`,
        )
      return (
        s.data.isDefault && this.h.set(!0),
        (s.impl = e),
        this.f.fire(new C6(s.data, e)),
        et(() => {
          ;(s.impl = void 0),
            this.f.fire(void 0),
            s.data.isDefault && this.h.set(!1)
        })
      )
    }
    registerDynamicAgent(t, e) {
      t.isDynamic = !0
      const s = { data: t, impl: e }
      return (
        this.b.set(t.id, s),
        this.f.fire(new C6(t, e)),
        et(() => {
          this.b.delete(t.id), this.f.fire(void 0)
        })
      )
    }
    registerAgentCompletionProvider(t, e) {
      return (
        this.t.set(t, e),
        {
          dispose: () => {
            this.t.delete(t)
          },
        }
      )
    }
    async getAgentCompletionItems(t, e, s) {
      return (await this.t.get(t)?.(e, s)) ?? []
    }
    updateAgent(t, e) {
      const s = this.b.get(t)
      if (!s?.impl)
        throw new Error(
          `No activated agent with id ${JSON.stringify(t)} registered`,
        )
      ;(s.data.metadata = { ...s.data.metadata, ...e }),
        this.f.fire(new C6(s.data, s.impl))
    }
    getDefaultAgent(t) {
      return $ht(
        this.getActivatedAgents(),
        (e) => !!e.isDefault && e.locations.includes(t),
      )
    }
    getContributedDefaultAgent(t) {
      return this.getAgents().find(
        (e) => !!e.isDefault && e.locations.includes(t),
      )
    }
    getSecondaryAgent() {
      return ms.find(this.b.values(), (t) => !!t.data.metadata.isSecondary)
        ?.data
    }
    getAgent(t, e = !1) {
      if (!(!this.u(t) && !e)) return this.b.get(t)?.data
    }
    u(t) {
      const e = this.b.get(t)
      return (
        !e?.data.when || this.q.contextMatchesRules(ui.deserialize(e.data.when))
      )
    }
    getAgentByFullyQualifiedId(t) {
      const e = ms.find(this.b.values(), (s) => fbt(s.data) === t)?.data
      if (!(e && !this.u(e.id))) return e
    }
    getAgents() {
      return Array.from(this.b.values())
        .map((t) => t.data)
        .filter((t) => this.u(t.id))
    }
    getActivatedAgents() {
      return Array.from(this.b.values())
        .filter((t) => !!t.impl)
        .filter((t) => this.u(t.data.id))
        .map((t) => new C6(t.data, t.impl))
    }
    getAgentsByName(t) {
      return this.getAgents().filter((e) => e.name === t)
    }
    agentHasDupeName(t) {
      const e = this.getAgent(t)
      return e
        ? this.getAgentsByName(e.name).filter(
            (s) => s.extensionId.value !== e.extensionId.value,
          ).length > 0
        : !1
    }
    async invokeAgent(t, e, s, r, a) {
      const o = this.b.get(t)
      if (!o?.impl) throw new Error(`No activated agent with id "${t}"`)
      return await o.impl.invoke(e, s, r, a)
    }
    async getFollowups(t, e, s, r, a) {
      const o = this.b.get(t)
      if (!o?.impl) throw new Error(`No activated agent with id "${t}"`)
      return o.impl?.provideFollowups ? o.impl.provideFollowups(e, s, r, a) : []
    }
    async getChatTitle(t, e, s) {
      const r = this.b.get(t)
      if (!r?.impl) throw new Error(`No activated agent with id "${t}"`)
      if (r.impl?.provideChatTitle) return r.impl.provideChatTitle(e, s)
    }
    registerChatParticipantDetectionProvider(t, e) {
      return (
        this.n.set(t, e),
        et(() => {
          this.n.delete(t)
        })
      )
    }
    hasChatParticipantDetectionProviders() {
      return this.n.size > 0
    }
    async detectAgentOrCommand(t, e, s, r) {
      const a = ms.first(this.n.values())
      if (!a) return
      const o = this.getAgents().reduce((d, m) => {
          if (m.locations.includes(s.location)) {
            d.push({
              participant: m.id,
              disambiguation: m.disambiguation ?? [],
            })
            for (const f of m.slashCommands)
              d.push({
                participant: m.id,
                command: f.name,
                disambiguation: f.disambiguation ?? [],
              })
          }
          return d
        }, []),
        c = await a.provideParticipantDetection(
          t,
          e,
          { ...s, participants: o },
          r,
        )
      if (!c) return
      const l = this.getAgent(c.participant)
      if (!l) return
      if (!c.command) return { agent: l }
      const u = l?.slashCommands.find((d) => d.name === c.command)
      if (u) return { agent: l, command: u }
    }
  }
eZ = __decorate([__param(0, qQ)], eZ)
var C6 = class {
    constructor(i, t) {
      ;(this.b = i), (this.d = t)
    }
    get id() {
      return this.b.id
    }
    get name() {
      return this.b.name ?? ""
    }
    get fullName() {
      return this.b.fullName ?? ""
    }
    get description() {
      return this.b.description ?? ""
    }
    get extensionId() {
      return this.b.extensionId
    }
    get extensionPublisherId() {
      return this.b.extensionPublisherId
    }
    get extensionPublisherDisplayName() {
      return this.b.publisherDisplayName
    }
    get extensionDisplayName() {
      return this.b.extensionDisplayName
    }
    get isDefault() {
      return this.b.isDefault
    }
    get metadata() {
      return this.b.metadata
    }
    get slashCommands() {
      return this.b.slashCommands
    }
    get locations() {
      return this.b.locations
    }
    get disambiguation() {
      return this.b.disambiguation
    }
    async invoke(i, t, e, s) {
      return this.d.invoke(i, t, e, s)
    }
    async provideFollowups(i, t, e, s) {
      return this.d.provideFollowups ? this.d.provideFollowups(i, t, e, s) : []
    }
    provideWelcomeMessage(i) {
      if (this.d.provideWelcomeMessage) return this.d.provideWelcomeMessage(i)
    }
    provideSampleQuestions(i, t) {
      if (this.d.provideSampleQuestions)
        return this.d.provideSampleQuestions(i, t)
    }
    toJSON() {
      return this.b
    }
  },
  VVt = X("chatAgentNameService"),
  iZ = class {
    static {
      Sh = this
    }
    static {
      this.b = "chat.participantNameRegistry"
    }
    constructor(t, e, s, r) {
      if (
        ((this.h = e),
        (this.i = s),
        (this.j = r),
        (this.f = A0t(this, Object.create(null))),
        (this.g = !1),
        !t.chatParticipantRegistry)
      )
        return
      this.d = t.chatParticipantRegistry
      const a = r.get(Sh.b, -1)
      try {
        this.f.set(JSON.parse(a ?? "{}"), void 0)
      } catch {
        r.remove(Sh.b, -1)
      }
      this.k()
    }
    k() {
      this.g ||
        this.l()
          .catch((t) =>
            this.i.warn("Failed to fetch chat participant registry", t),
          )
          .then(() => Fi(5 * 60 * 1e3))
          .then(() => this.k())
    }
    async l() {
      const t = await this.h.request({ type: "GET", url: this.d }, ce.None)
      if (t.res.statusCode !== 200)
        throw new Error("Could not get extensions report.")
      const e = await abt(t)
      if (!e || e.version !== 1)
        throw new Error("Unexpected chat participant registry response.")
      const s = e.restrictedChatParticipants
      this.f.set(s, void 0), this.j.store(Sh.b, JSON.stringify(s), -1, 1)
    }
    getAgentNameRestriction(t) {
      const e = this.m(t.name, t).get(),
        s = !t.fullName || this.m(t.fullName.replace(/\s/g, ""), t).get()
      return e && s
    }
    m(t, e) {
      return this.f
        .map((r) => r[t.toLowerCase()])
        .map((r) =>
          r
            ? r.some((a) =>
                Ws(
                  a,
                  a.includes(".")
                    ? e.extensionId.value
                    : e.extensionPublisherId,
                ),
              )
            : !0,
        )
    }
    dispose() {
      this.g = !0
    }
  }
iZ = Sh = __decorate(
  [__param(0, w6), __param(1, ebt), __param(2, Rt), __param(3, XK)],
  iZ,
)
function fbt(i) {
  return `${i.extensionId.value}.${i.id}`
}
function sZ() {
  return Object.create(null)
}
var co = "**",
  v2 = "/",
  J6 = "[/\\\\]",
  L6 = "[^/\\\\]",
  pbt = /\//g
function rZ(i, t) {
  switch (i) {
    case 0:
      return ""
    case 1:
      return `${L6}*?`
    default:
      return `(?:${J6}|${L6}+${J6}${t ? `|${J6}${L6}+` : ""})*?`
  }
}
function Eh(i, t) {
  if (!i) return []
  const e = []
  let s = !1,
    r = !1,
    a = ""
  for (const o of i) {
    switch (o) {
      case t:
        if (!s && !r) {
          e.push(a), (a = "")
          continue
        }
        break
      case "{":
        s = !0
        break
      case "}":
        s = !1
        break
      case "[":
        r = !0
        break
      case "]":
        r = !1
        break
    }
    a += o
  }
  return a && e.push(a), e
}
function nZ(i) {
  if (!i) return ""
  let t = ""
  const e = Eh(i, v2)
  if (e.every((s) => s === co)) t = ".*"
  else {
    let s = !1
    e.forEach((r, a) => {
      if (r === co) {
        if (s) return
        t += rZ(2, a === e.length - 1)
      } else {
        let o = !1,
          c = "",
          l = !1,
          u = ""
        for (const d of r) {
          if (d !== "}" && o) {
            c += d
            continue
          }
          if (l && (d !== "]" || !u)) {
            let m
            d === "-"
              ? (m = d)
              : (d === "^" || d === "!") && !u
                ? (m = "^")
                : d === v2
                  ? (m = "")
                  : (m = Vn(d)),
              (u += m)
            continue
          }
          switch (d) {
            case "{":
              o = !0
              continue
            case "[":
              l = !0
              continue
            case "}": {
              const f = `(?:${Eh(c, ",")
                .map((p) => nZ(p))
                .join("|")})`
              ;(t += f), (o = !1), (c = "")
              break
            }
            case "]": {
              ;(t += "[" + u + "]"), (l = !1), (u = "")
              break
            }
            case "?":
              t += L6
              continue
            case "*":
              t += rZ(1)
              continue
            default:
              t += Vn(d)
          }
        }
        a < e.length - 1 && (e[a + 1] !== co || a + 2 < e.length) && (t += J6)
      }
      s = r === co
    })
  }
  return t
}
var gbt = /^\*\*\/\*\.[\w\.-]+$/,
  vbt = /^\*\*\/([\w\.-]+)\/?$/,
  wbt = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/,
  ybt = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/,
  bbt = /^\*\*((\/[\w\.-]+)+)\/?$/,
  Tbt = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/,
  aZ = new Ju(1e4),
  oZ = function () {
    return !1
  },
  Dr = function () {
    return null
  }
function w2(i, t) {
  if (!i) return Dr
  let e
  typeof i != "string" ? (e = i.pattern) : (e = i), (e = e.trim())
  const s = `${e}_${!!t.trimForExclusions}`
  let r = aZ.get(s)
  if (r) return cZ(r, i)
  let a
  return (
    gbt.test(e)
      ? (r = kbt(e.substr(4), e))
      : (a = vbt.exec(y2(e, t)))
        ? (r = Sbt(a[1], e))
        : (t.trimForExclusions ? ybt : wbt).test(e)
          ? (r = Ebt(e, t))
          : (a = bbt.exec(y2(e, t)))
            ? (r = lZ(a[1].substr(1), e, !0))
            : (a = Tbt.exec(y2(e, t)))
              ? (r = lZ(a[1], e, !1))
              : (r = Ibt(e)),
    aZ.set(s, r),
    cZ(r, i)
  )
}
function cZ(i, t) {
  if (typeof t == "string") return i
  const e = function (s, r) {
    return ja(s, t.base, !De) ? i(Ddt(s.substr(t.base.length), xe), r) : null
  }
  return (
    (e.allBasenames = i.allBasenames),
    (e.allPaths = i.allPaths),
    (e.basenames = i.basenames),
    (e.patterns = i.patterns),
    e
  )
}
function y2(i, t) {
  return t.trimForExclusions && i.endsWith("/**")
    ? i.substr(0, i.length - 2)
    : i
}
function kbt(i, t) {
  return function (e, s) {
    return typeof e == "string" && e.endsWith(i) ? t : null
  }
}
function Sbt(i, t) {
  const e = `/${i}`,
    s = `\\${i}`,
    r = function (o, c) {
      return typeof o != "string"
        ? null
        : c
          ? c === i
            ? t
            : null
          : o === i || o.endsWith(e) || o.endsWith(s)
            ? t
            : null
    },
    a = [i]
  return (r.basenames = a), (r.patterns = [t]), (r.allBasenames = a), r
}
function Ebt(i, t) {
  const e = dZ(
      i
        .slice(1, -1)
        .split(",")
        .map((c) => w2(c, t))
        .filter((c) => c !== Dr),
      i,
    ),
    s = e.length
  if (!s) return Dr
  if (s === 1) return e[0]
  const r = function (c, l) {
      for (let u = 0, d = e.length; u < d; u++) if (e[u](c, l)) return i
      return null
    },
    a = e.find((c) => !!c.allBasenames)
  a && (r.allBasenames = a.allBasenames)
  const o = e.reduce((c, l) => (l.allPaths ? c.concat(l.allPaths) : c), [])
  return o.length && (r.allPaths = o), r
}
function lZ(i, t, e) {
  const s = xe === Wt.sep,
    r = s ? i : i.replace(pbt, xe),
    a = xe + r,
    o = Wt.sep + i
  let c
  return (
    e
      ? (c = function (l, u) {
          return typeof l == "string" &&
            (l === r || l.endsWith(a) || (!s && (l === i || l.endsWith(o))))
            ? t
            : null
        })
      : (c = function (l, u) {
          return typeof l == "string" && (l === r || (!s && l === i)) ? t : null
        }),
    (c.allPaths = [(e ? "*/" : "./") + i]),
    c
  )
}
function Ibt(i) {
  try {
    const t = new RegExp(`^${nZ(i)}$`)
    return function (e) {
      return (t.lastIndex = 0), typeof e == "string" && t.test(e) ? i : null
    }
  } catch {
    return Dr
  }
}
function Bc(i, t, e) {
  return !i || typeof t != "string" ? !1 : sr(i)(t, void 0, e)
}
function sr(i, t = {}) {
  if (!i) return oZ
  if (typeof i == "string" || Pbt(i)) {
    const e = w2(i, t)
    if (e === Dr) return oZ
    const s = function (r, a) {
      return !!e(r, a)
    }
    return (
      e.allBasenames && (s.allBasenames = e.allBasenames),
      e.allPaths && (s.allPaths = e.allPaths),
      s
    )
  }
  return $bt(i, t)
}
function Pbt(i) {
  const t = i
  return t ? typeof t.base == "string" && typeof t.pattern == "string" : !1
}
function uZ(i) {
  return i.allBasenames || []
}
function hZ(i) {
  return i.allPaths || []
}
function $bt(i, t) {
  const e = dZ(
      Object.getOwnPropertyNames(i)
        .map((c) => xbt(c, i[c], t))
        .filter((c) => c !== Dr),
    ),
    s = e.length
  if (!s) return Dr
  if (!e.some((c) => !!c.requiresSiblings)) {
    if (s === 1) return e[0]
    const c = function (d, m) {
        let f
        for (let p = 0, v = e.length; p < v; p++) {
          const b = e[p](d, m)
          if (typeof b == "string") return b
          Kr(b) && (f || (f = []), f.push(b))
        }
        return f
          ? (async () => {
              for (const p of f) {
                const v = await p
                if (typeof v == "string") return v
              }
              return null
            })()
          : null
      },
      l = e.find((d) => !!d.allBasenames)
    l && (c.allBasenames = l.allBasenames)
    const u = e.reduce((d, m) => (m.allPaths ? d.concat(m.allPaths) : d), [])
    return u.length && (c.allPaths = u), c
  }
  const r = function (c, l, u) {
      let d, m
      for (let f = 0, p = e.length; f < p; f++) {
        const v = e[f]
        v.requiresSiblings &&
          u &&
          (l || (l = ke(c)), d || (d = l.substr(0, l.length - S_(c).length)))
        const b = v(c, l, d, u)
        if (typeof b == "string") return b
        Kr(b) && (m || (m = []), m.push(b))
      }
      return m
        ? (async () => {
            for (const f of m) {
              const p = await f
              if (typeof p == "string") return p
            }
            return null
          })()
        : null
    },
    a = e.find((c) => !!c.allBasenames)
  a && (r.allBasenames = a.allBasenames)
  const o = e.reduce((c, l) => (l.allPaths ? c.concat(l.allPaths) : c), [])
  return o.length && (r.allPaths = o), r
}
function xbt(i, t, e) {
  if (t === !1) return Dr
  const s = w2(i, e)
  if (s === Dr) return Dr
  if (typeof t == "boolean") return s
  if (t) {
    const r = t.when
    if (typeof r == "string") {
      const a = (o, c, l, u) => {
        if (!u || !s(o, c)) return null
        const d = r.replace("$(basename)", () => l),
          m = u(d)
        return Kr(m) ? m.then((f) => (f ? i : null)) : m ? i : null
      }
      return (a.requiresSiblings = !0), a
    }
  }
  return s
}
function dZ(i, t) {
  const e = i.filter((c) => !!c.basenames)
  if (e.length < 2) return i
  const s = e.reduce((c, l) => {
    const u = l.basenames
    return u ? c.concat(u) : c
  }, [])
  let r
  if (t) {
    r = []
    for (let c = 0, l = s.length; c < l; c++) r.push(t)
  } else
    r = e.reduce((c, l) => {
      const u = l.patterns
      return u ? c.concat(u) : c
    }, [])
  const a = function (c, l) {
    if (typeof c != "string") return null
    if (!l) {
      let d
      for (d = c.length; d > 0; d--) {
        const m = c.charCodeAt(d - 1)
        if (m === 47 || m === 92) break
      }
      l = c.substr(d)
    }
    const u = s.indexOf(l)
    return u !== -1 ? r[u] : null
  }
  ;(a.basenames = s), (a.patterns = r), (a.allBasenames = s)
  const o = i.filter((c) => !c.basenames)
  return o.push(a), o
}
function mZ(i, t) {
  return Er(i, t, (e, s) =>
    typeof e == "string" && typeof s == "string"
      ? e === s
      : typeof e != "string" && typeof s != "string"
        ? e.base === s.base && e.pattern === s.pattern
        : !1,
  )
}
var Nbt = X("notebookDocumentService"),
  b2 = ["W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f"],
  Cbt = new RegExp(`^[${b2.join("")}]+`),
  fZ = 7
function pZ(i) {
  if (i.scheme !== G.vscodeNotebookCell) return
  const t = i.fragment.indexOf("s")
  if (t < 0) return
  const e = parseInt(i.fragment.substring(0, t).replace(Cbt, ""), fZ),
    s = W_(i.fragment.substring(t + 1)).toString()
  if (!isNaN(e))
    return { handle: e, notebook: i.with({ scheme: s, fragment: null }) }
}
function Jbt(i, t) {
  const e = t.toString(fZ),
    r = `${e.length < b2.length ? b2[e.length - 1] : "z"}${e}s${Yu(Q.fromString(i.scheme), !0, !0)}`
  return i.with({ scheme: G.vscodeNotebookCell, fragment: r })
}
function Lbt(i) {
  if (i.scheme !== G.vscodeNotebookMetadata) return
  const t = W_(i.fragment).toString()
  return i.with({ scheme: t, fragment: null })
}
function Rbt(i) {
  const t = `${Yu(Q.fromString(i.scheme), !0, !0)}`
  return i.with({ scheme: G.vscodeNotebookMetadata, fragment: t })
}
var Dbt = class {
  constructor() {
    this.a = new oi()
  }
  getNotebook(i) {
    if (i.scheme === G.vscodeNotebookCell) {
      const t = pZ(i)
      if (t) {
        const e = this.a.get(t.notebook)
        if (e) return e
      }
    }
    return this.a.get(i)
  }
  addNotebookDocument(i) {
    this.a.set(i.uri, i)
  }
  removeNotebookDocument(i) {
    this.a.delete(i.uri)
  }
}
Ut(Nbt, Dbt, 1)
var qc
;(function (i) {
  ;(i[(i.Markup = 1)] = "Markup"), (i[(i.Code = 2)] = "Code")
})(qc || (qc = {}))
var zVt = [
    "application/json",
    "application/javascript",
    "text/html",
    "image/svg+xml",
    cn.latex,
    cn.markdown,
    "image/png",
    "image/jpeg",
    cn.text,
  ],
  YVt = [
    cn.latex,
    cn.markdown,
    "application/json",
    "text/html",
    "image/svg+xml",
    "image/png",
    "image/jpeg",
    cn.text,
  ],
  gZ
;(function (i) {
  ;(i[(i.Running = 1)] = "Running"), (i[(i.Idle = 2)] = "Idle")
})(gZ || (gZ = {}))
var Ih
;(function (i) {
  ;(i[(i.Unconfirmed = 1)] = "Unconfirmed"),
    (i[(i.Pending = 2)] = "Pending"),
    (i[(i.Executing = 3)] = "Executing")
})(Ih || (Ih = {}))
var vZ
;(function (i) {
  ;(i[(i.Unconfirmed = 1)] = "Unconfirmed"),
    (i[(i.Pending = 2)] = "Pending"),
    (i[(i.Executing = 3)] = "Executing")
})(vZ || (vZ = {}))
var wZ
;(function (i) {
  ;(i[(i.WithHardKernelDependency = 0)] = "WithHardKernelDependency"),
    (i[(i.WithOptionalKernelDependency = 1)] = "WithOptionalKernelDependency"),
    (i[(i.Pure = 2)] = "Pure"),
    (i[(i.Never = 3)] = "Never")
})(wZ || (wZ = {}))
var yZ
;(function (i) {
  ;(i.Always = "always"), (i.Never = "never"), (i.Optional = "optional")
})(yZ || (yZ = {}))
var rr
;(function (i) {
  ;(i[(i.ModelChange = 1)] = "ModelChange"),
    (i[(i.Move = 2)] = "Move"),
    (i[(i.ChangeCellLanguage = 5)] = "ChangeCellLanguage"),
    (i[(i.Initialize = 6)] = "Initialize"),
    (i[(i.ChangeCellMetadata = 7)] = "ChangeCellMetadata"),
    (i[(i.Output = 8)] = "Output"),
    (i[(i.OutputItem = 9)] = "OutputItem"),
    (i[(i.ChangeCellContent = 10)] = "ChangeCellContent"),
    (i[(i.ChangeDocumentMetadata = 11)] = "ChangeDocumentMetadata"),
    (i[(i.ChangeCellInternalMetadata = 12)] = "ChangeCellInternalMetadata"),
    (i[(i.ChangeCellMime = 13)] = "ChangeCellMime"),
    (i[(i.Unknown = 100)] = "Unknown")
})(rr || (rr = {}))
var bZ
;(function (i) {
  ;(i[(i.Handle = 0)] = "Handle"), (i[(i.Index = 1)] = "Index")
})(bZ || (bZ = {}))
var TZ
;(function (i) {
  ;(i[(i.Replace = 1)] = "Replace"),
    (i[(i.Output = 2)] = "Output"),
    (i[(i.Metadata = 3)] = "Metadata"),
    (i[(i.CellLanguage = 4)] = "CellLanguage"),
    (i[(i.DocumentMetadata = 5)] = "DocumentMetadata"),
    (i[(i.Move = 6)] = "Move"),
    (i[(i.OutputItems = 7)] = "OutputItems"),
    (i[(i.PartialMetadata = 8)] = "PartialMetadata"),
    (i[(i.PartialInternalMetadata = 9)] = "PartialInternalMetadata")
})(TZ || (TZ = {}))
var kZ
;(function (i) {
  i.scheme = G.vscodeNotebookMetadata
  function t(s) {
    return Rbt(s)
  }
  i.generate = t
  function e(s) {
    return Lbt(s)
  }
  i.parse = e
})(kZ || (kZ = {}))
var SZ
;(function (i) {
  i.scheme = G.vscodeNotebookCell
  function t(c, l) {
    return Jbt(c, l)
  }
  i.generate = t
  function e(c) {
    return pZ(c)
  }
  i.parse = e
  function s(c, l) {
    return c.with({
      scheme: G.vscodeNotebookCellOutput,
      fragment: `op${l ?? ""},${c.scheme !== G.file ? c.scheme : ""}`,
    })
  }
  i.generateCellOutputUri = s
  function r(c) {
    if (c.scheme !== G.vscodeNotebookCellOutput) return
    const l =
      /^op([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?\,(.*)$/i.exec(
        c.fragment,
      )
    if (!l) return
    const u = l[1] && l[1] !== "" ? l[1] : void 0,
      d = l[2]
    return {
      outputId: u,
      notebook: c.with({ scheme: d || G.file, fragment: null }),
    }
  }
  i.parseCellOutputUri = r
  function a(c, l, u) {
    return i.generate(c, l).with({ scheme: u })
  }
  i.generateCellPropertyUri = a
  function o(c, l) {
    if (c.scheme === l) return i.parse(c.with({ scheme: i.scheme }))
  }
  i.parseCellPropertyUri = o
})(SZ || (SZ = {}))
var QVt = new W("notebookEditorCursorAtBoundary", "none"),
  XVt = new W("notebookEditorCursorAtLineBoundary", "none"),
  EZ
;(function (i) {
  ;(i.default = "default"), (i.option = "option")
})(EZ || (EZ = {}))
var IZ
;(function (i) {
  ;(i.Cells = "cells"), (i.Text = "text"), (i.None = "none")
})(IZ || (IZ = {}))
var PZ
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"), (i[(i.Right = 2)] = "Right")
})(PZ || (PZ = {}))
var KVt = class V3 {
  static {
    this.d = "notebook/"
  }
  static create(t, e) {
    return `${V3.d}${t}/${e ?? t}`
  }
  static parse(t) {
    if (t.startsWith(V3.d)) {
      const e = t.substring(V3.d.length).split("/")
      if (e.length === 2) return { notebookType: e[0], viewType: e[1] }
    }
  }
}
function $Z(i) {
  return [
    "application/vnd.code.notebook.stdout",
    "application/vnd.code.notebook.stderr",
  ].includes(i)
}
var Fbt = new TextDecoder()
function Abt(i) {
  const t = []
  let e = !1
  for (const o of i) (t.length === 0 || e) && (t.push(o), (e = !0))
  let s = Obt(t)
  const r = Q.concat(t.map((o) => Q.wrap(o))),
    a = Hbt(r)
  return (
    (s = s || a.byteLength !== r.byteLength), { data: a, didCompression: s }
  )
}
var R6 = "\x1B[A",
  T2 = R6.split("").map((i) => i.charCodeAt(0)),
  _bt = 10
function Obt(i) {
  let t = !1
  return (
    i.forEach((e, s) => {
      if (s === 0 || e.length < R6.length) return
      const r = i[s - 1],
        a = e.subarray(0, R6.length)
      if (a[0] === T2[0] && a[1] === T2[1] && a[2] === T2[2]) {
        const o = r.lastIndexOf(_bt)
        if (o === -1) return
        ;(t = !0), (i[s - 1] = r.subarray(0, o)), (i[s] = e.subarray(R6.length))
      }
    }),
    t
  )
}
function Bbt(i) {
  let t = i
  do (i = t), (t = i.replace(/[^\n]\x08/gm, ""))
  while (t.length < i.length)
  return i
}
function qbt(i) {
  for (
    i = i.replace(
      /\r+\n/gm,
      `
`,
    );
    i.search(/\r[^$]/g) > -1;

  ) {
    const t = i.match(/^(.*)\r+/m)[1]
    let e = i.match(/\r+(.*)$/m)[1]
    ;(e = e + t.slice(e.length, t.length)),
      (i = i.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, e))
  }
  return i
}
var Ubt = 8,
  Mbt = 13
function Hbt(i) {
  return !i.buffer.includes(Ubt) && !i.buffer.includes(Mbt)
    ? i
    : Q.fromString(qbt(Bbt(Fbt.decode(i.buffer))))
}
var xZ
;(function (i) {
  i.Delimiter = "\0"
})(xZ || (xZ = {}))
var NZ
;(function (i) {
  ;(i[(i.IsSame = 0)] = "IsSame"),
    (i[(i.Disconnected = 1)] = "Disconnected"),
    (i[(i.IsChild = 2)] = "IsChild"),
    (i[(i.IsParent = 3)] = "IsParent")
})(NZ || (NZ = {}))
var jt = class Bs {
    static fromExtHostTestItem(t, e, s = t.parent) {
      if (t._isRoot) return new Bs([e])
      const r = [t.id]
      for (let a = s; a && a.id !== e; a = a.parent) r.push(a.id)
      return r.push(e), new Bs(r.reverse())
    }
    static isRoot(t) {
      return !t.includes("\0")
    }
    static root(t) {
      const e = t.indexOf("\0")
      return e === -1 ? t : t.slice(0, e)
    }
    static fromString(t) {
      return new Bs(t.split("\0"))
    }
    static join(t, e) {
      return new Bs([...t.path, e])
    }
    static joinToString(t, e) {
      return t.toString() + "\0" + e
    }
    static parentId(t) {
      const e = t.lastIndexOf("\0")
      return e === -1 ? void 0 : t.slice(0, e)
    }
    static localId(t) {
      const e = t.lastIndexOf("\0")
      return e === -1 ? t : t.slice(e + 1)
    }
    static isChild(t, e) {
      return e[t.length] === "\0" && e.startsWith(t)
    }
    static compare(t, e) {
      return t === e ? 0 : Bs.isChild(t, e) ? 2 : Bs.isChild(e, t) ? 3 : 1
    }
    static getLengthOfCommonPrefix(t, e) {
      if (t === 0) return 0
      let s = 0
      for (; s < t - 1; ) {
        for (let r = 1; r < t; r++) {
          const a = e(r - 1),
            o = e(r)
          if (a.path[s] !== o.path[s]) return s
        }
        s++
      }
      return s
    }
    constructor(t, e = t.length) {
      if (((this.path = t), (this.d = e), t.length === 0 || e < 1))
        throw new Error("cannot create test with empty path")
    }
    get rootId() {
      return new Bs(this.path, 1)
    }
    get parentId() {
      return this.d > 1 ? new Bs(this.path, this.d - 1) : void 0
    }
    get localId() {
      return this.path[this.d - 1]
    }
    get controllerId() {
      return this.path[0]
    }
    get isRoot() {
      return this.d === 1
    }
    *idsFromRoot() {
      for (let t = 1; t <= this.d; t++) yield new Bs(this.path, t)
    }
    *idsToRoot() {
      for (let t = this.d; t > 0; t--) yield new Bs(this.path, t)
    }
    compare(t) {
      if (typeof t == "string") return Bs.compare(this.toString(), t)
      for (let e = 0; e < t.d && e < this.d; e++)
        if (t.path[e] !== this.path[e]) return 1
      return t.d > this.d ? 2 : t.d < this.d ? 3 : 0
    }
    toJSON() {
      return this.toString()
    }
    toString() {
      if (!this.c) {
        this.c = this.path[0]
        for (let t = 1; t < this.d; t++)
          (this.c += "\0"), (this.c += this.path[t])
      }
      return this.c
    }
  },
  CZ
;(function (i) {
  ;(i[(i.Unset = 0)] = "Unset"),
    (i[(i.Queued = 1)] = "Queued"),
    (i[(i.Running = 2)] = "Running"),
    (i[(i.Passed = 3)] = "Passed"),
    (i[(i.Failed = 4)] = "Failed"),
    (i[(i.Skipped = 5)] = "Skipped"),
    (i[(i.Errored = 6)] = "Errored")
})(CZ || (CZ = {}))
var JZ
;(function (i) {
  ;(i[(i.Run = 1)] = "Run"),
    (i[(i.Debug = 2)] = "Debug"),
    (i[(i.Coverage = 3)] = "Coverage")
})(JZ || (JZ = {}))
var LZ
;(function (i) {
  ;(i[(i.Refresh = 2)] = "Refresh"),
    (i[(i.CodeRelatedToTest = 4)] = "CodeRelatedToTest"),
    (i[(i.TestRelatedToCode = 8)] = "TestRelatedToCode")
})(LZ || (LZ = {}))
var RZ
;(function (i) {
  ;(i[(i.Run = 2)] = "Run"),
    (i[(i.Debug = 4)] = "Debug"),
    (i[(i.Coverage = 8)] = "Coverage"),
    (i[(i.HasNonDefaultProfile = 16)] = "HasNonDefaultProfile"),
    (i[(i.HasConfigurable = 32)] = "HasConfigurable"),
    (i[(i.SupportsContinuousRun = 64)] = "SupportsContinuousRun")
})(RZ || (RZ = {}))
var ZVt = { 2: g(11434, null), 4: g(11435, null), 8: g(11436, null) },
  Wbt = (i) => "runId" in i,
  Uc
;(function (i) {
  ;(i.serialize = (t) => ({ range: t.range.toJSON(), uri: t.uri.toJSON() })),
    (i.deserialize = (t, e) => ({
      range: ue.lift(e.range),
      uri: t.asCanonicalUri(S.revive(e.uri)),
    }))
})(Uc || (Uc = {}))
var DZ
;(function (i) {
  ;(i[(i.Error = 0)] = "Error"), (i[(i.Output = 1)] = "Output")
})(DZ || (DZ = {}))
var D6
;(function (i) {
  ;(i.serialize = (t) => ({
    label: t.label,
    uri: t.uri?.toJSON(),
    position: t.position?.toJSON(),
  })),
    (i.deserialize = (t, e) => ({
      label: e.label,
      uri: e.uri ? t.asCanonicalUri(S.revive(e.uri)) : void 0,
      position: e.position ? ws.lift(e.position) : void 0,
    }))
})(D6 || (D6 = {}))
var F6
;(function (i) {
  ;(i.serialize = (t) => ({
    message: t.message,
    type: 0,
    expected: t.expected,
    actual: t.actual,
    contextValue: t.contextValue,
    location: t.location && Uc.serialize(t.location),
    stackTrace: t.stackTrace?.map(D6.serialize),
  })),
    (i.deserialize = (t, e) => ({
      message: e.message,
      type: 0,
      expected: e.expected,
      actual: e.actual,
      contextValue: e.contextValue,
      location: e.location && Uc.deserialize(t, e.location),
      stackTrace: e.stackTrace && e.stackTrace.map((s) => D6.deserialize(t, s)),
    }))
})(F6 || (F6 = {}))
var A6
;(function (i) {
  ;(i.serialize = (t) => ({
    message: t.message,
    type: 1,
    offset: t.offset,
    length: t.length,
    location: t.location && Uc.serialize(t.location),
  })),
    (i.deserialize = (t, e) => ({
      message: e.message,
      type: 1,
      offset: e.offset,
      length: e.length,
      location: e.location && Uc.deserialize(t, e.location),
    }))
})(A6 || (A6 = {}))
var _6
;(function (i) {
  ;(i.serialize = (t) => (t.type === 0 ? F6.serialize(t) : A6.serialize(t))),
    (i.deserialize = (t, e) =>
      e.type === 0 ? F6.deserialize(t, e) : A6.deserialize(t, e)),
    (i.isDiffable = (t) =>
      t.type === 0 && t.actual !== void 0 && t.expected !== void 0)
})(_6 || (_6 = {}))
var Ph
;(function (i) {
  ;(i.serializeWithoutMessages = (t) => ({
    state: t.state,
    duration: t.duration,
    messages: [],
  })),
    (i.serialize = (t) => ({
      state: t.state,
      duration: t.duration,
      messages: t.messages.map(_6.serialize),
    })),
    (i.deserialize = (t, e) => ({
      state: e.state,
      duration: e.duration,
      messages: e.messages.map((s) => _6.deserialize(t, s)),
    }))
})(Ph || (Ph = {}))
var FZ = "\0",
  O6 = (i, t) => i + FZ + t,
  AZ = (i) => {
    const t = i.indexOf(FZ)
    return { ctrlId: i.slice(0, t), tagId: i.slice(t + 1) }
  },
  B6
;(function (i) {
  ;(i.serialize = (t) => ({
    extId: t.extId,
    label: t.label,
    tags: t.tags,
    busy: t.busy,
    children: void 0,
    uri: t.uri?.toJSON(),
    range: t.range?.toJSON() || null,
    description: t.description,
    error: t.error,
    sortText: t.sortText,
  })),
    (i.deserialize = (t, e) => ({
      extId: e.extId,
      label: e.label,
      tags: e.tags,
      busy: e.busy,
      children: void 0,
      uri: e.uri ? t.asCanonicalUri(S.revive(e.uri)) : void 0,
      range: e.range ? ue.lift(e.range) : null,
      description: e.description,
      error: e.error,
      sortText: e.sortText,
    }))
})(B6 || (B6 = {}))
var _Z
;(function (i) {
  ;(i[(i.NotExpandable = 0)] = "NotExpandable"),
    (i[(i.Expandable = 1)] = "Expandable"),
    (i[(i.BusyExpanding = 2)] = "BusyExpanding"),
    (i[(i.Expanded = 3)] = "Expanded")
})(_Z || (_Z = {}))
var ra
;(function (i) {
  ;(i.serialize = (t) => ({ expand: t.expand, item: B6.serialize(t.item) })),
    (i.deserialize = (t, e) => ({
      controllerId: jt.root(e.item.extId),
      expand: e.expand,
      item: B6.deserialize(t, e.item),
    }))
})(ra || (ra = {}))
var $h
;(function (i) {
  ;(i.serialize = (t) => {
    let e
    return (
      t.item &&
        ((e = {}),
        t.item.label !== void 0 && (e.label = t.item.label),
        t.item.tags !== void 0 && (e.tags = t.item.tags),
        t.item.busy !== void 0 && (e.busy = t.item.busy),
        t.item.uri !== void 0 && (e.uri = t.item.uri?.toJSON()),
        t.item.range !== void 0 && (e.range = t.item.range?.toJSON()),
        t.item.description !== void 0 && (e.description = t.item.description),
        t.item.error !== void 0 && (e.error = t.item.error),
        t.item.sortText !== void 0 && (e.sortText = t.item.sortText)),
      { extId: t.extId, expand: t.expand, item: e }
    )
  }),
    (i.deserialize = (t) => {
      let e
      return (
        t.item &&
          ((e = {}),
          t.item.label !== void 0 && (e.label = t.item.label),
          t.item.tags !== void 0 && (e.tags = t.item.tags),
          t.item.busy !== void 0 && (e.busy = t.item.busy),
          t.item.range !== void 0 &&
            (e.range = t.item.range ? ue.lift(t.item.range) : null),
          t.item.description !== void 0 && (e.description = t.item.description),
          t.item.error !== void 0 && (e.error = t.item.error),
          t.item.sortText !== void 0 && (e.sortText = t.item.sortText)),
        { extId: t.extId, expand: t.expand, item: e }
      )
    })
})($h || ($h = {}))
var k2 = (i, t) => {
    t.expand !== void 0 && (i.expand = t.expand),
      t.item !== void 0 &&
        (i.item = i.item ? Object.assign(i.item, t.item) : t.item)
  },
  OZ
;(function (i) {
  ;(i.serializeWithoutMessages = (t) => ({
    ...ra.serialize(t),
    ownComputedState: t.ownComputedState,
    computedState: t.computedState,
    tasks: t.tasks.map(Ph.serializeWithoutMessages),
  })),
    (i.serialize = (t) => ({
      ...ra.serialize(t),
      ownComputedState: t.ownComputedState,
      computedState: t.computedState,
      tasks: t.tasks.map(Ph.serialize),
    })),
    (i.deserialize = (t, e) => ({
      ...ra.deserialize(t, e),
      ownComputedState: e.ownComputedState,
      computedState: e.computedState,
      tasks: e.tasks.map((s) => Ph.deserialize(t, s)),
      retired: !0,
    }))
})(OZ || (OZ = {}))
var S2
;(function (i) {
  ;(i.empty = () => ({ covered: 0, total: 0 })),
    (i.sum = (t, e) => {
      ;(t.covered += e.covered), (t.total += e.total)
    })
})(S2 || (S2 = {}))
var BZ
;(function (i) {
  ;(i.serialize = (t) => ({
    id: t.id,
    statement: t.statement,
    branch: t.branch,
    declaration: t.declaration,
    testIds: t.testIds,
    uri: t.uri.toJSON(),
  })),
    (i.deserialize = (t, e) => ({
      id: e.id,
      statement: e.statement,
      branch: e.branch,
      declaration: e.declaration,
      testIds: e.testIds,
      uri: t.asCanonicalUri(S.revive(e.uri)),
    })),
    (i.empty = (t, e) => ({ id: t, uri: e, statement: S2.empty() }))
})(BZ || (BZ = {}))
function E2(i) {
  return { ...i, location: i.location?.toJSON() }
}
function I2(i) {
  return (
    (i.location = i.location
      ? ws.isIPosition(i.location)
        ? ws.lift(i.location)
        : ue.lift(i.location)
      : void 0),
    i
  )
}
var qZ
;(function (i) {
  ;(i[(i.Declaration = 0)] = "Declaration"),
    (i[(i.Statement = 1)] = "Statement"),
    (i[(i.Branch = 2)] = "Branch")
})(qZ || (qZ = {}))
var UZ
;(function (i) {
  ;(i.serialize = (t) => (t.type === 0 ? U6.serialize(t) : M6.serialize(t))),
    (i.deserialize = (t) =>
      t.type === 0 ? U6.deserialize(t) : M6.deserialize(t))
})(UZ || (UZ = {}))
var q6
;(function (i) {
  ;(i.serialize = E2), (i.deserialize = I2)
})(q6 || (q6 = {}))
var U6
;(function (i) {
  ;(i.serialize = E2), (i.deserialize = I2)
})(U6 || (U6 = {}))
var M6
;(function (i) {
  ;(i.serialize = (t) => ({
    ...E2(t),
    branches: t.branches?.map(q6.serialize),
  })),
    (i.deserialize = (t) => ({
      ...I2(t),
      branches: t.branches?.map(q6.deserialize),
    }))
})(M6 || (M6 = {}))
var MZ
;(function (i) {
  ;(i[(i.Add = 0)] = "Add"),
    (i[(i.Update = 1)] = "Update"),
    (i[(i.DocumentSynced = 2)] = "DocumentSynced"),
    (i[(i.Remove = 3)] = "Remove"),
    (i[(i.IncrementPendingExtHosts = 4)] = "IncrementPendingExtHosts"),
    (i[(i.Retire = 5)] = "Retire"),
    (i[(i.AddTag = 6)] = "AddTag"),
    (i[(i.RemoveTag = 7)] = "RemoveTag")
})(MZ || (MZ = {}))
var H6
;(function (i) {
  ;(i.deserialize = (t, e) =>
    e.op === 0
      ? { op: e.op, item: ra.deserialize(t, e.item) }
      : e.op === 1
        ? { op: e.op, item: $h.deserialize(e.item) }
        : e.op === 2
          ? { op: e.op, uri: t.asCanonicalUri(S.revive(e.uri)), docv: e.docv }
          : e),
    (i.serialize = (t) =>
      t.op === 0
        ? { op: t.op, item: ra.serialize(t.item) }
        : t.op === 1
          ? { op: t.op, item: $h.serialize(t.item) }
          : t)
})(H6 || (H6 = {}))
var jbt = class {
    constructor(i) {
      ;(this.l = i),
        (this.f = new Map()),
        (this.g = new Map()),
        (this.h = new Set()),
        (this.j = 0),
        (this.k = 0),
        (this.tags = this.f)
    }
    apply(i) {
      const t = this.x()
      for (const e of i)
        switch (e.op) {
          case 0:
            this.p(ra.deserialize(this.l, e.item), t)
            break
          case 1:
            this.q($h.deserialize(e.item), t)
            break
          case 3:
            this.v(e.itemId, t)
            break
          case 5:
            this.w(e.itemId)
            break
          case 4:
            this.updatePendingRoots(e.amount)
            break
          case 6:
            this.f.set(e.tag.id, e.tag)
            break
          case 7:
            this.f.delete(e.id)
            break
        }
      t.complete?.()
    }
    p(i, t) {
      const e = jt.parentId(i.item.extId)?.toString()
      let s
      if (!e) (s = this.y(i)), this.h.add(s), this.g.set(i.item.extId, s)
      else if (this.g.has(e)) {
        const r = this.g.get(e)
        r.children.add(i.item.extId),
          (s = this.y(i, r)),
          this.g.set(i.item.extId, s)
      } else {
        console.error(`Test with unknown parent ID: ${JSON.stringify(i)}`)
        return
      }
      return t.add?.(s), i.expand === 2 && this.j++, s
    }
    q(i, t) {
      const e = this.g.get(i.extId)
      if (e)
        return (
          i.expand !== void 0 &&
            (e.expand === 2 && this.j--, i.expand === 2 && this.j++),
          k2(e, i),
          t.update?.(e),
          e
        )
    }
    v(i, t) {
      const e = this.g.get(i)
      if (!e) return
      const s = jt.parentId(e.item.extId)?.toString()
      s ? this.g.get(s).children.delete(e.item.extId) : this.h.delete(e)
      const r = [[i]]
      for (; r.length; )
        for (const a of r.pop()) {
          const o = this.g.get(a)
          o &&
            (r.push(o.children),
            this.g.delete(a),
            t.remove?.(o, o !== e),
            o.expand === 2 && this.j--)
        }
    }
    w(i) {}
    updatePendingRoots(i) {
      this.k += i
    }
    x() {
      return {}
    }
  },
  Vbt = X("editorGroupsService"),
  HZ
;(function (i) {
  ;(i[(i.UP = 0)] = "UP"),
    (i[(i.DOWN = 1)] = "DOWN"),
    (i[(i.LEFT = 2)] = "LEFT"),
    (i[(i.RIGHT = 3)] = "RIGHT")
})(HZ || (HZ = {}))
var WZ
;(function (i) {
  ;(i[(i.HORIZONTAL = 0)] = "HORIZONTAL"), (i[(i.VERTICAL = 1)] = "VERTICAL")
})(WZ || (WZ = {}))
var jZ
;(function (i) {
  ;(i[(i.FIRST = 0)] = "FIRST"),
    (i[(i.LAST = 1)] = "LAST"),
    (i[(i.NEXT = 2)] = "NEXT"),
    (i[(i.PREVIOUS = 3)] = "PREVIOUS")
})(jZ || (jZ = {}))
var VZ
;(function (i) {
  ;(i[(i.MAXIMIZE = 0)] = "MAXIMIZE"),
    (i[(i.EXPAND = 1)] = "EXPAND"),
    (i[(i.EVEN = 2)] = "EVEN")
})(VZ || (VZ = {}))
var GZ
;(function (i) {
  ;(i[(i.COPY_EDITORS = 0)] = "COPY_EDITORS"),
    (i[(i.MOVE_EDITORS = 1)] = "MOVE_EDITORS")
})(GZ || (GZ = {}))
var zZ
;(function (i) {
  ;(i[(i.CREATION_TIME = 0)] = "CREATION_TIME"),
    (i[(i.MOST_RECENTLY_ACTIVE = 1)] = "MOST_RECENTLY_ACTIVE"),
    (i[(i.GRID_APPEARANCE = 2)] = "GRID_APPEARANCE")
})(zZ || (zZ = {}))
var YZ
;(function (i) {
  ;(i[(i.NEW_EDITOR = 1)] = "NEW_EDITOR"),
    (i[(i.MOVE_EDITOR = 2)] = "MOVE_EDITOR"),
    (i[(i.COPY_EDITOR = 3)] = "COPY_EDITOR")
})(YZ || (YZ = {}))
var tGt = X("editorService"),
  Gbt = -1,
  zbt = -2,
  QZ
;(function (i) {
  ;(i[(i.Upsert = 0)] = "Upsert"),
    (i[(i.SetTags = 1)] = "SetTags"),
    (i[(i.UpdateCanResolveChildren = 2)] = "UpdateCanResolveChildren"),
    (i[(i.RemoveChild = 3)] = "RemoveChild"),
    (i[(i.SetProp = 4)] = "SetProp"),
    (i[(i.Bulk = 5)] = "Bulk"),
    (i[(i.DocumentSynced = 6)] = "DocumentSynced")
})(QZ || (QZ = {}))
var xh = (i, t) => i === t,
  Ybt = {
    range: (i, t) => (i === t ? !0 : !i || !t ? !1 : i.equalsRange(t)),
    busy: xh,
    label: xh,
    description: xh,
    error: xh,
    sortText: xh,
    tags: (i, t) => !(i.length !== t.length || i.some((e) => !t.includes(e))),
  },
  Qbt = Object.entries(Ybt),
  Xbt = (i, t) => {
    let e
    for (const [s, r] of Qbt)
      r(i[s], t[s]) || (e ? (e[s] = t[s]) : (e = { [s]: t[s] }))
    return e
  },
  Kbt = class extends at {
    get root() {
      return this.q.root
    }
    constructor(i) {
      super(),
        (this.q = i),
        (this.f = this.D(new tn(() => this.flushDiff(), 200))),
        (this.g = this.D(new J())),
        (this.tree = new Map()),
        (this.j = new Map()),
        (this.m = []),
        (this.onDidGenerateDiff = this.g.event),
        (this.root.canResolveChildren = !0),
        this.y(this.root, void 0)
    }
    set resolveHandler(i) {
      this.h = i
      for (const t of this.tree.values()) this.J(t)
    }
    get resolveHandler() {
      return this.h
    }
    collectDiff() {
      const i = this.m
      return (this.m = []), i
    }
    pushDiff(i) {
      switch (i.op) {
        case 2: {
          for (const t of this.m)
            if (t.op === 2 && t.uri === i.uri) {
              t.docv = i.docv
              return
            }
          break
        }
        case 1: {
          const t = this.m[this.m.length - 1]
          if (t) {
            if (t.op === 1 && t.item.extId === i.item.extId) {
              k2(t.item, i.item)
              return
            }
            if (t.op === 0 && t.item.item.extId === i.item.extId) {
              k2(t.item, i.item)
              return
            }
          }
          break
        }
      }
      this.m.push(i), this.f.isScheduled() || this.f.schedule()
    }
    expand(i, t) {
      const e = this.tree.get(i)
      if (e) {
        if (
          ((e.expandLevels === void 0 || t > e.expandLevels) &&
            (e.expandLevels = t),
          e.expand === 1)
        ) {
          const s = this.M(e)
          return s.isOpen()
            ? this.L(e, t - 1)
            : s.wait().then(() => this.L(e, t - 1))
        } else if (e.expand === 3)
          return e.resolveBarrier?.isOpen() === !1
            ? e.resolveBarrier.wait().then(() => this.L(e, t - 1))
            : this.L(e, t - 1)
      }
    }
    dispose() {
      for (const i of this.tree.values())
        this.q.getApiFor(i.actual).listener = void 0
      this.tree.clear(), (this.m = []), super.dispose()
    }
    s(i, t) {
      switch (t.op) {
        case 3:
          this.O(jt.joinToString(i.fullId, t.id))
          break
        case 0:
          this.y(t.item, i)
          break
        case 5:
          for (const e of t.ops) this.s(i, e)
          break
        case 1:
          this.z(t.new, t.old, i.fullId.toString())
          break
        case 2:
          this.J(i)
          break
        case 4:
          this.pushDiff({
            op: 1,
            item: { extId: i.fullId.toString(), item: t.update },
          })
          break
        case 6:
          this.w(i.actual.uri)
          break
        default:
          e0t(t)
      }
    }
    w(i) {
      i && this.pushDiff({ op: 2, uri: i, docv: this.q.getDocumentVersion(i) })
    }
    y(i, t) {
      const e = jt.fromExtHostTestItem(i, this.root.id, t?.actual),
        s = this.q.getApiFor(i)
      s.parent &&
        s.parent !== t?.actual &&
        this.q.getChildren(s.parent).delete(i.id)
      let r = this.tree.get(e.toString())
      if (!r) {
        ;(r = {
          fullId: e,
          actual: i,
          expandLevels: t?.expandLevels ? t.expandLevels - 1 : void 0,
          expand: 0,
        }),
          i.tags.forEach(this.C, this),
          this.tree.set(r.fullId.toString(), r),
          this.G(i, t),
          this.pushDiff({
            op: 0,
            item: {
              controllerId: this.q.controllerId,
              expand: r.expand,
              item: this.q.toITestItem(i),
            },
          }),
          this.I(i, r, t)
        return
      }
      if (r.actual === i) {
        this.H(i, r, t)
        return
      }
      if (r.actual.uri?.toString() !== i.uri?.toString())
        return this.O(e.toString()), this.y(i, t)
      const a = this.q.getChildren(r.actual),
        o = r.actual,
        c = Xbt(this.q.toITestItem(o), this.q.toITestItem(i))
      ;(this.q.getApiFor(o).listener = void 0),
        (r.actual = i),
        (r.resolveBarrier = void 0),
        (r.expand = 0),
        c &&
          (c.hasOwnProperty("tags") &&
            (this.z(i.tags, o.tags, e.toString()), delete c.tags),
          this.s(r, { op: 4, update: c })),
        this.I(i, r, t)
      for (const [u, d] of a)
        this.q.getChildren(i).get(d.id) || this.O(jt.joinToString(e, d.id))
      const l = r.expandLevels
      l !== void 0 &&
        queueMicrotask(() => {
          r.expand === 1 &&
            ((r.expandLevels = void 0), this.expand(e.toString(), l))
        }),
        this.w(r.actual.uri)
    }
    z(i, t, e) {
      const s = new Set(t.map((r) => r.id))
      for (const r of i) s.delete(r.id) || this.C(r)
      this.pushDiff({
        op: 1,
        item: {
          extId: e,
          item: { tags: i.map((r) => O6(this.q.controllerId, r.id)) },
        },
      }),
        s.forEach(this.F, this)
    }
    C(i) {
      const t = this.j.get(i.id)
      t
        ? t.refCount++
        : (this.j.set(i.id, { refCount: 1 }),
          this.pushDiff({ op: 6, tag: { id: O6(this.q.controllerId, i.id) } }))
    }
    F(i) {
      const t = this.j.get(i)
      t &&
        !--t.refCount &&
        (this.j.delete(i),
        this.pushDiff({ op: 7, id: O6(this.q.controllerId, i) }))
    }
    G(i, t) {
      this.q.getApiFor(i).parent =
        t && t.actual !== this.root ? t.actual : void 0
    }
    H(i, t, e) {
      this.G(i, e)
      const s = this.q.getApiFor(i)
      ;(s.parent = e?.actual), (s.listener = (r) => this.s(t, r)), this.J(t)
    }
    I(i, t, e) {
      this.H(i, t, e)
      for (const [s, r] of this.q.getChildren(i)) this.y(r, t)
    }
    J(i) {
      let t
      this.h
        ? i.resolveBarrier
          ? (t = i.resolveBarrier.isOpen() ? 3 : 2)
          : (t = i.actual.canResolveChildren ? 1 : 0)
        : (t = 0),
        t !== i.expand &&
          ((i.expand = t),
          this.pushDiff({
            op: 1,
            item: { extId: i.fullId.toString(), expand: t },
          }),
          t === 1 && i.expandLevels !== void 0 && this.M(i))
    }
    L(i, t) {
      if (t < 0) return
      const e = []
      for (const [s, r] of this.q.getChildren(i.actual)) {
        const a = this.expand(jt.joinToString(i.fullId, r.id), t)
        Kr(a) && e.push(a)
      }
      if (e.length) return Promise.all(e).then(() => {})
    }
    M(i) {
      if (i.resolveBarrier) return i.resolveBarrier
      if (!this.h) {
        const r = new Ns()
        return r.open(), r
      }
      ;(i.expand = 2), this.N(i)
      const t = (i.resolveBarrier = new Ns()),
        e = (r) => {
          console.error(
            `Unhandled error in resolveHandler of test controller "${this.q.controllerId}"`,
            r,
          )
        }
      let s
      try {
        s = this.h(i.actual === this.root ? void 0 : i.actual)
      } catch (r) {
        e(r)
      }
      return (
        Kr(s)
          ? s.catch(e).then(() => {
              t.open(), this.J(i)
            })
          : (t.open(), this.J(i)),
        i.resolveBarrier
      )
    }
    N(i) {
      this.pushDiff({
        op: 1,
        item: { extId: i.fullId.toString(), expand: i.expand },
      })
    }
    O(i) {
      const t = this.tree.get(i)
      if (!t) throw new Error("attempting to remove non-existent child")
      this.pushDiff({ op: 3, itemId: i })
      const e = [t]
      for (; e.length; ) {
        const s = e.pop()
        if (s) {
          this.q.getApiFor(s.actual).listener = void 0
          for (const r of s.actual.tags) this.F(r.id)
          this.tree.delete(s.fullId.toString())
          for (const [r, a] of this.q.getChildren(s.actual))
            e.push(this.tree.get(jt.joinToString(s.fullId, a.id)))
        }
      }
    }
    flushDiff() {
      const i = this.collectDiff()
      i.length && this.g.fire(i)
    }
  },
  Zbt = class extends Error {
    constructor(i) {
      super(`Attempted to insert a duplicate test item ID ${i}`)
    }
  },
  W6 = class extends Error {
    constructor(i) {
      super(
        `TestItem with ID "${i}" is invalid. Make sure to create it from the createTestItem method.`,
      )
    }
  },
  tTt = class extends Error {
    constructor(i, t, e) {
      super(
        `TestItem with ID "${i}" is from controller "${t}" and cannot be added as a child of an item from controller "${e}".`,
      )
    }
  },
  eTt = (i, t, e) => {
    let s = new Map()
    return {
      get size() {
        return s.size
      },
      forEach(r, a) {
        for (const o of s.values()) r.call(a, o, this)
      },
      [Symbol.iterator]() {
        return s.entries()
      },
      replace(r) {
        const a = new Map(),
          o = new Set(s.keys()),
          c = { op: 5, ops: [] }
        for (const l of r) {
          if (!(l instanceof e)) throw new W6(l.id)
          const u = t(l).controllerId
          if (u !== i.controllerId) throw new tTt(l.id, u, i.controllerId)
          if (a.has(l.id)) throw new Zbt(l.id)
          a.set(l.id, l), o.delete(l.id), c.ops.push({ op: 0, item: l })
        }
        for (const l of o.keys()) c.ops.push({ op: 3, id: l })
        i.listener?.(c), (s = a)
      },
      add(r) {
        if (!(r instanceof e)) throw new W6(r.id)
        s.set(r.id, r), i.listener?.({ op: 0, item: r })
      },
      delete(r) {
        s.delete(r) && i.listener?.({ op: 3, id: r })
      },
      get(r) {
        return s.get(r)
      },
      toJSON() {
        return Array.from(s.values())
      },
    }
  },
  XZ = new WeakMap(),
  iTt = (i, t) => {
    const e = { controllerId: t }
    return XZ.set(i, e), e
  },
  j6 = (i) => {
    const t = XZ.get(i)
    if (!t) throw new W6(i?.id || "<unknown>")
    return t
  },
  sTt = X("remoteAuthorityResolverService"),
  KZ
;(function (i) {
  ;(i[(i.WebSocket = 0)] = "WebSocket"), (i[(i.Managed = 1)] = "Managed")
})(KZ || (KZ = {}))
var ZZ = class {
    constructor(i) {
      ;(this.id = i), (this.type = 1)
    }
    toString() {
      return `Managed(${this.id})`
    }
  },
  rTt = class {
    constructor(i, t) {
      ;(this.host = i), (this.port = t), (this.type = 0)
    }
    toString() {
      return `WebSocket(${this.host}:${this.port})`
    }
  },
  Gi
;(function (i) {
  ;(i.Unknown = "Unknown"),
    (i.NotAvailable = "NotAvailable"),
    (i.TemporarilyNotAvailable = "TemporarilyNotAvailable"),
    (i.NoResolverFound = "NoResolverFound"),
    (i.InvalidAuthority = "InvalidAuthority")
})(Gi || (Gi = {}))
var P2 = class Qo extends xs {
  static isNotAvailable(t) {
    return t instanceof Qo && t._code === Gi.NotAvailable
  }
  static isTemporarilyNotAvailable(t) {
    return t instanceof Qo && t._code === Gi.TemporarilyNotAvailable
  }
  static isNoResolverFound(t) {
    return t instanceof Qo && t._code === Gi.NoResolverFound
  }
  static isInvalidAuthority(t) {
    return t instanceof Qo && t._code === Gi.InvalidAuthority
  }
  static isHandled(t) {
    return t instanceof Qo && t.isHandled
  }
  constructor(t, e = Gi.Unknown, s) {
    super(t),
      (this._message = t),
      (this._code = e),
      (this._detail = s),
      (this.isHandled = e === Gi.NotAvailable && s === !0),
      Object.setPrototypeOf(this, Qo.prototype)
  }
}
function ttt(i) {
  const t = i.indexOf("+")
  return t === -1 ? i : i.substring(0, t)
}
var $2, lo, mn, x2, uo, na, ho, N2, C2, V6, Nh, J2, Fr, Ar, L2, zi, R2
function ht(i) {
  return Object.assign(i, {
    apply: function (...e) {
      if (e.length === 0) return Reflect.construct(i, [])
      {
        const s = e.length === 1 ? [] : e[1]
        return Reflect.construct(i, s, e[0].constructor)
      }
    },
    call: function (...e) {
      if (e.length === 0) return Reflect.construct(i, [])
      {
        const [s, ...r] = e
        return Reflect.construct(i, r, s.constructor)
      }
    },
  })
}
var D2
;(function (i) {
  ;(i[(i.Top = 0)] = "Top"), (i[(i.Bottom = 1)] = "Bottom")
})(D2 || (D2 = {}))
var ett
;(function (i) {
  ;(i[(i.TerminalCommand = 0)] = "TerminalCommand"),
    (i[(i.Opener = 1)] = "Opener"),
    (i[(i.Command = 3)] = "Command")
})(ett || (ett = {}))
var Ht = ($2 = class {
  static from(...t) {
    let e = t
    return new $2(function () {
      if (e) {
        for (const s of e) s && typeof s.dispose == "function" && s.dispose()
        e = void 0
      }
    })
  }
  #t
  constructor(t) {
    this.#t = t
  }
  dispose() {
    typeof this.#t == "function" && (this.#t(), (this.#t = void 0))
  }
})
Ht = $2 = __decorate([ht], Ht)
var Ft = (lo = class {
  static Min(...t) {
    if (t.length === 0) throw new TypeError()
    let e = t[0]
    for (let s = 1; s < t.length; s++) {
      const r = t[s]
      r.isBefore(e) && (e = r)
    }
    return e
  }
  static Max(...t) {
    if (t.length === 0) throw new TypeError()
    let e = t[0]
    for (let s = 1; s < t.length; s++) {
      const r = t[s]
      r.isAfter(e) && (e = r)
    }
    return e
  }
  static isPosition(t) {
    if (!t) return !1
    if (t instanceof lo) return !0
    const { line: e, character: s } = t
    return typeof e == "number" && typeof s == "number"
  }
  static of(t) {
    if (t instanceof lo) return t
    if (this.isPosition(t)) return new lo(t.line, t.character)
    throw new Error("Invalid argument, is NOT a position-like object")
  }
  get line() {
    return this.c
  }
  get character() {
    return this.e
  }
  constructor(t, e) {
    if (t < 0) throw Lt("line must be non-negative")
    if (e < 0) throw Lt("character must be non-negative")
    ;(this.c = t), (this.e = e)
  }
  isBefore(t) {
    return this.c < t.c ? !0 : t.c < this.c ? !1 : this.e < t.e
  }
  isBeforeOrEqual(t) {
    return this.c < t.c ? !0 : t.c < this.c ? !1 : this.e <= t.e
  }
  isAfter(t) {
    return !this.isBeforeOrEqual(t)
  }
  isAfterOrEqual(t) {
    return !this.isBefore(t)
  }
  isEqual(t) {
    return this.c === t.c && this.e === t.e
  }
  compareTo(t) {
    return this.c < t.c
      ? -1
      : this.c > t.line
        ? 1
        : this.e < t.e
          ? -1
          : this.e > t.e
            ? 1
            : 0
  }
  translate(t, e = 0) {
    if (t === null || e === null) throw Lt()
    let s
    return (
      typeof t > "u"
        ? (s = 0)
        : typeof t == "number"
          ? (s = t)
          : ((s = typeof t.lineDelta == "number" ? t.lineDelta : 0),
            (e = typeof t.characterDelta == "number" ? t.characterDelta : 0)),
      s === 0 && e === 0 ? this : new lo(this.line + s, this.character + e)
    )
  }
  with(t, e = this.character) {
    if (t === null || e === null) throw Lt()
    let s
    return (
      typeof t > "u"
        ? (s = this.line)
        : typeof t == "number"
          ? (s = t)
          : ((s = typeof t.line == "number" ? t.line : this.line),
            (e =
              typeof t.character == "number" ? t.character : this.character)),
      s === this.line && e === this.character ? this : new lo(s, e)
    )
  }
  toJSON() {
    return { line: this.line, character: this.character }
  }
  [Symbol.for("debug.description")]() {
    return `(${this.line}:${this.character})`
  }
})
Ft = lo = __decorate([ht], Ft)
var Nt = (mn = class {
  static isRange(t) {
    return t instanceof mn
      ? !0
      : t
        ? Ft.isPosition(t.start) && Ft.isPosition(t.end)
        : !1
  }
  static of(t) {
    if (t instanceof mn) return t
    if (this.isRange(t)) return new mn(t.start, t.end)
    throw new Error("Invalid argument, is NOT a range-like object")
  }
  get start() {
    return this.c
  }
  get end() {
    return this.e
  }
  constructor(t, e, s, r) {
    let a, o
    if (
      (typeof t == "number" &&
      typeof e == "number" &&
      typeof s == "number" &&
      typeof r == "number"
        ? ((a = new Ft(t, e)), (o = new Ft(s, r)))
        : Ft.isPosition(t) &&
          Ft.isPosition(e) &&
          ((a = Ft.of(t)), (o = Ft.of(e))),
      !a || !o)
    )
      throw new Error("Invalid arguments")
    a.isBefore(o) ? ((this.c = a), (this.e = o)) : ((this.c = o), (this.e = a))
  }
  contains(t) {
    return mn.isRange(t)
      ? this.contains(t.start) && this.contains(t.end)
      : Ft.isPosition(t)
        ? !(Ft.of(t).isBefore(this.c) || this.e.isBefore(t))
        : !1
  }
  isEqual(t) {
    return this.c.isEqual(t.c) && this.e.isEqual(t.e)
  }
  intersection(t) {
    const e = Ft.Max(t.start, this.c),
      s = Ft.Min(t.end, this.e)
    if (!e.isAfter(s)) return new mn(e, s)
  }
  union(t) {
    if (this.contains(t)) return this
    if (t.contains(this)) return t
    const e = Ft.Min(t.start, this.c),
      s = Ft.Max(t.end, this.end)
    return new mn(e, s)
  }
  get isEmpty() {
    return this.c.isEqual(this.e)
  }
  get isSingleLine() {
    return this.c.line === this.e.line
  }
  with(t, e = this.end) {
    if (t === null || e === null) throw Lt()
    let s
    return (
      t
        ? Ft.isPosition(t)
          ? (s = t)
          : ((s = t.start || this.start), (e = t.end || this.end))
        : (s = this.start),
      s.isEqual(this.c) && e.isEqual(this.end) ? this : new mn(s, e)
    )
  }
  toJSON() {
    return [this.start, this.end]
  }
  [Symbol.for("debug.description")]() {
    return itt(this)
  }
})
Nt = mn = __decorate([ht], Nt)
var fn = (x2 = class extends Nt {
  static isSelection(t) {
    return t instanceof x2
      ? !0
      : t
        ? Nt.isRange(t) &&
          Ft.isPosition(t.anchor) &&
          Ft.isPosition(t.active) &&
          typeof t.isReversed == "boolean"
        : !1
  }
  get anchor() {
    return this.f
  }
  get active() {
    return this.g
  }
  constructor(t, e, s, r) {
    let a, o
    if (
      (typeof t == "number" &&
      typeof e == "number" &&
      typeof s == "number" &&
      typeof r == "number"
        ? ((a = new Ft(t, e)), (o = new Ft(s, r)))
        : Ft.isPosition(t) &&
          Ft.isPosition(e) &&
          ((a = Ft.of(t)), (o = Ft.of(e))),
      !a || !o)
    )
      throw new Error("Invalid arguments")
    super(a, o), (this.f = a), (this.g = o)
  }
  get isReversed() {
    return this.f === this.e
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end,
      active: this.active,
      anchor: this.anchor,
    }
  }
  [Symbol.for("debug.description")]() {
    return nTt(this)
  }
})
fn = x2 = __decorate([ht], fn)
function itt(i) {
  return i.isEmpty
    ? `[${i.start.line}:${i.start.character})`
    : `[${i.start.line}:${i.start.character} -> ${i.end.line}:${i.end.character})`
}
function nTt(i) {
  let t = itt(i)
  return (
    i.isEmpty || (i.active.isEqual(i.start) ? (t = `|${t}`) : (t = `${t}|`)), t
  )
}
var stt = (i) => {
    if (typeof i != "string" || i.length === 0 || !/^[0-9A-Za-z_\-]+$/.test(i))
      throw Lt("connectionToken")
  },
  aTt = class {
    static isResolvedAuthority(i) {
      return (
        i &&
        typeof i == "object" &&
        typeof i.host == "string" &&
        typeof i.port == "number" &&
        (i.connectionToken === void 0 || typeof i.connectionToken == "string")
      )
    }
    constructor(i, t, e) {
      if (typeof i != "string" || i.length === 0) throw Lt("host")
      if (typeof t != "number" || t === 0 || Math.round(t) !== t)
        throw Lt("port")
      typeof e < "u" && stt(e),
        (this.host = i),
        (this.port = Math.round(t)),
        (this.connectionToken = e)
    }
  },
  G6 = class {
    static isManagedResolvedAuthority(i) {
      return (
        i &&
        typeof i == "object" &&
        typeof i.makeConnection == "function" &&
        (i.connectionToken === void 0 || typeof i.connectionToken == "string")
      )
    }
    constructor(i, t) {
      ;(this.makeConnection = i),
        (this.connectionToken = t),
        typeof t < "u" && stt(t)
    }
  },
  Mc = class G3 extends Error {
    static NotAvailable(t, e) {
      return new G3(t, Gi.NotAvailable, e)
    }
    static TemporarilyNotAvailable(t) {
      return new G3(t, Gi.TemporarilyNotAvailable)
    }
    constructor(t, e = Gi.Unknown, s) {
      super(t),
        (this._message = t),
        (this._code = e),
        (this._detail = s),
        Object.setPrototypeOf(this, G3.prototype)
    }
  },
  nr
;(function (i) {
  ;(i[(i.LF = 1)] = "LF"), (i[(i.CRLF = 2)] = "CRLF")
})(nr || (nr = {}))
var Hc
;(function (i) {
  ;(i[(i.Replace = 1)] = "Replace"),
    (i[(i.Append = 2)] = "Append"),
    (i[(i.Prepend = 3)] = "Prepend")
})(Hc || (Hc = {}))
var aa = (uo = class {
  static isTextEdit(t) {
    return t instanceof uo
      ? !0
      : t
        ? Nt.isRange(t) && typeof t.newText == "string"
        : !1
  }
  static replace(t, e) {
    return new uo(t, e)
  }
  static insert(t, e) {
    return uo.replace(new Nt(t, t), e)
  }
  static delete(t) {
    return uo.replace(t, "")
  }
  static setEndOfLine(t) {
    const e = new uo(new Nt(new Ft(0, 0), new Ft(0, 0)), "")
    return (e.newEol = t), e
  }
  get range() {
    return this.c
  }
  set range(t) {
    if (t && !Nt.isRange(t)) throw Lt("range")
    this.c = t
  }
  get newText() {
    return this.e || ""
  }
  set newText(t) {
    if (t && typeof t != "string") throw Lt("newText")
    this.e = t
  }
  get newEol() {
    return this.f
  }
  set newEol(t) {
    if (t && typeof t != "number") throw Lt("newEol")
    this.f = t
  }
  constructor(t, e) {
    ;(this.c = t), (this.e = e)
  }
  toJSON() {
    return { range: this.range, newText: this.newText, newEol: this.f }
  }
})
aa = uo = __decorate([ht], aa)
var z6 = (na = class {
  static isNotebookCellEdit(t) {
    return t instanceof na
      ? !0
      : t
        ? gn.isNotebookRange(t) && Array.isArray(t.newCells)
        : !1
  }
  static replaceCells(t, e) {
    return new na(t, e)
  }
  static insertCells(t, e) {
    return new na(new gn(t, t), e)
  }
  static deleteCells(t) {
    return new na(t, [])
  }
  static updateCellMetadata(t, e) {
    const s = new na(new gn(t, t), [])
    return (s.newCellMetadata = e), s
  }
  static updateNotebookMetadata(t) {
    const e = new na(new gn(0, 0), [])
    return (e.newNotebookMetadata = t), e
  }
  constructor(t, e) {
    ;(this.range = t), (this.newCells = e)
  }
})
z6 = na = __decorate([ht], z6)
var F2 = class z3 {
    static isSnippetTextEdit(t) {
      return t instanceof z3
        ? !0
        : t
          ? Nt.isRange(t.range) && fo.isSnippetString(t.snippet)
          : !1
    }
    static replace(t, e) {
      return new z3(t, e)
    }
    static insert(t, e) {
      return z3.replace(new Nt(t, t), e)
    }
    constructor(t, e) {
      ;(this.range = t), (this.snippet = e)
    }
  },
  rtt
;(function (i) {
  ;(i[(i.File = 1)] = "File"),
    (i[(i.Text = 2)] = "Text"),
    (i[(i.Cell = 3)] = "Cell"),
    (i[(i.CellReplace = 5)] = "CellReplace"),
    (i[(i.Snippet = 6)] = "Snippet")
})(rtt || (rtt = {}))
var mo = class {
  constructor() {
    this.c = []
  }
  _allEntries() {
    return this.c
  }
  renameFile(t, e, s, r) {
    this.c.push({ _type: 1, from: t, to: e, options: s, metadata: r })
  }
  createFile(t, e, s) {
    this.c.push({ _type: 1, from: void 0, to: t, options: e, metadata: s })
  }
  deleteFile(t, e, s) {
    this.c.push({ _type: 1, from: t, to: void 0, options: e, metadata: s })
  }
  e(t, e, s) {
    this.c.push({
      _type: 3,
      metadata: s,
      uri: t,
      edit: { editType: 5, metadata: e },
    })
  }
  f(t, e, s, r) {
    const a = e.start,
      o = e.end
    ;(a !== o || s.length > 0) &&
      this.c.push({
        _type: 5,
        uri: t,
        index: a,
        count: o - a,
        cells: s,
        metadata: r,
      })
  }
  g(t, e, s, r) {
    this.c.push({
      _type: 3,
      metadata: r,
      uri: t,
      edit: { editType: 3, index: e, metadata: s },
    })
  }
  replace(t, e, s, r) {
    this.c.push({ _type: 2, uri: t, edit: new aa(e, s), metadata: r })
  }
  insert(t, e, s, r) {
    this.replace(t, new Nt(e, e), s, r)
  }
  delete(t, e, s) {
    this.replace(t, e, "", s)
  }
  has(t) {
    return this.c.some(
      (e) => e._type === 2 && e.uri.toString() === t.toString(),
    )
  }
  set(t, e) {
    if (e)
      for (const s of e) {
        if (!s) continue
        let r, a
        Array.isArray(s) ? ((r = s[0]), (a = s[1])) : (r = s),
          z6.isNotebookCellEdit(r)
            ? r.newCellMetadata
              ? this.g(t, r.range.start, r.newCellMetadata, a)
              : r.newNotebookMetadata
                ? this.e(t, r.newNotebookMetadata, a)
                : this.f(t, r.range, r.newCells, a)
            : F2.isSnippetTextEdit(r)
              ? this.c.push({
                  _type: 6,
                  uri: t,
                  range: r.range,
                  edit: r.snippet,
                  metadata: a,
                })
              : this.c.push({ _type: 2, uri: t, edit: r, metadata: a })
      }
    else {
      for (let s = 0; s < this.c.length; s++) {
        const r = this.c[s]
        switch (r._type) {
          case 2:
          case 6:
          case 3:
          case 5:
            r.uri.toString() === t.toString() && (this.c[s] = void 0)
            break
        }
      }
      Fht(this.c)
    }
  }
  get(t) {
    const e = []
    for (const s of this.c)
      s._type === 2 && s.uri.toString() === t.toString() && e.push(s.edit)
    return e
  }
  entries() {
    const t = new oi()
    for (const e of this.c)
      if (e._type === 2) {
        let s = t.get(e.uri)
        s || ((s = [e.uri, []]), t.set(e.uri, s)), s[1].push(e.edit)
      }
    return [...t.values()]
  }
  get size() {
    return this.entries().length
  }
  toJSON() {
    return this.entries()
  }
}
mo = __decorate([ht], mo)
var fo = (ho = class {
  static isSnippetString(t) {
    return t instanceof ho ? !0 : t ? typeof t.value == "string" : !1
  }
  static c(t) {
    return t.replace(/\$|}|\\/g, "\\$&")
  }
  constructor(t) {
    ;(this.e = 1), (this.value = t || "")
  }
  appendText(t) {
    return (this.value += ho.c(t)), this
  }
  appendTabstop(t = this.e++) {
    return (this.value += "$"), (this.value += t), this
  }
  appendPlaceholder(t, e = this.e++) {
    if (typeof t == "function") {
      const s = new ho()
      ;(s.e = this.e), t(s), (this.e = s.e), (t = s.value)
    } else t = ho.c(t)
    return (
      (this.value += "${"),
      (this.value += e),
      (this.value += ":"),
      (this.value += t),
      (this.value += "}"),
      this
    )
  }
  appendChoice(t, e = this.e++) {
    const s = t.map((r) => r.replaceAll(/[|\\,]/g, "\\$&")).join(",")
    return (
      (this.value += "${"),
      (this.value += e),
      (this.value += "|"),
      (this.value += s),
      (this.value += "|}"),
      this
    )
  }
  appendVariable(t, e) {
    if (typeof e == "function") {
      const s = new ho()
      ;(s.e = this.e), e(s), (this.e = s.e), (e = s.value)
    } else typeof e == "string" && (e = e.replace(/\$|}/g, "\\$&"))
    return (
      (this.value += "${"),
      (this.value += t),
      e && ((this.value += ":"), (this.value += e)),
      (this.value += "}"),
      this
    )
  }
})
fo = ho = __decorate([ht], fo)
var po
;(function (i) {
  ;(i[(i.Unnecessary = 1)] = "Unnecessary"),
    (i[(i.Deprecated = 2)] = "Deprecated")
})(po || (po = {}))
var Ii
;(function (i) {
  ;(i[(i.Hint = 3)] = "Hint"),
    (i[(i.Information = 2)] = "Information"),
    (i[(i.Warning = 1)] = "Warning"),
    (i[(i.Error = 0)] = "Error")
})(Ii || (Ii = {}))
var ys = (N2 = class {
  static isLocation(t) {
    return t instanceof N2 ? !0 : t ? Nt.isRange(t.range) && S.isUri(t.uri) : !1
  }
  constructor(t, e) {
    if (((this.uri = t), e))
      if (Nt.isRange(e)) this.range = Nt.of(e)
      else if (Ft.isPosition(e)) this.range = new Nt(e, e)
      else throw new Error("Illegal argument")
  }
  toJSON() {
    return { uri: this.uri, range: this.range }
  }
})
ys = N2 = __decorate([ht], ys)
var Ch = class {
  static is(t) {
    return t
      ? typeof t.message == "string" &&
          t.location &&
          Nt.isRange(t.location.range) &&
          S.isUri(t.location.uri)
      : !1
  }
  constructor(t, e) {
    ;(this.location = t), (this.message = e)
  }
  static isEqual(t, e) {
    return t === e
      ? !0
      : !t || !e
        ? !1
        : t.message === e.message &&
          t.location.range.isEqual(e.location.range) &&
          t.location.uri.toString() === e.location.uri.toString()
  }
}
Ch = __decorate([ht], Ch)
var Y6 = class {
  constructor(t, e, s = Ii.Error) {
    if (!Nt.isRange(t)) throw new TypeError("range must be set")
    if (!e) throw new TypeError("message must be set")
    ;(this.range = t), (this.message = e), (this.severity = s)
  }
  toJSON() {
    return {
      severity: Ii[this.severity],
      message: this.message,
      range: this.range,
      source: this.source,
      code: this.code,
    }
  }
  static isEqual(t, e) {
    return t === e
      ? !0
      : !t || !e
        ? !1
        : t.message === e.message &&
          t.severity === e.severity &&
          t.code === e.code &&
          t.severity === e.severity &&
          t.source === e.source &&
          t.range.isEqual(e.range) &&
          Er(t.tags, e.tags) &&
          Er(t.relatedInformation, e.relatedInformation, Ch.isEqual)
  }
}
Y6 = __decorate([ht], Y6)
var Q6 = class {
  constructor(t, e) {
    if (!t) throw new Error("Illegal argument, contents must be defined")
    Array.isArray(t) ? (this.contents = t) : (this.contents = [t]),
      (this.range = e)
  }
}
Q6 = __decorate([ht], Q6)
var X6 = class extends Q6 {
  constructor(t, e, s, r) {
    super(t, e),
      (this.canIncreaseVerbosity = s),
      (this.canDecreaseVerbosity = r)
  }
}
X6 = __decorate([ht], X6)
var A2
;(function (i) {
  ;(i[(i.Increase = 0)] = "Increase"), (i[(i.Decrease = 1)] = "Decrease")
})(A2 || (A2 = {}))
var Jh
;(function (i) {
  ;(i[(i.Text = 0)] = "Text"),
    (i[(i.Read = 1)] = "Read"),
    (i[(i.Write = 2)] = "Write")
})(Jh || (Jh = {}))
var K6 = class {
  constructor(t, e = Jh.Text) {
    ;(this.range = t), (this.kind = e)
  }
  toJSON() {
    return { range: this.range, kind: Jh[this.kind] }
  }
}
K6 = __decorate([ht], K6)
var Z6 = class {
  constructor(t, e) {
    ;(this.uri = t), (this.highlights = e)
  }
  toJSON() {
    return { uri: this.uri, highlights: this.highlights.map((t) => t.toJSON()) }
  }
}
Z6 = __decorate([ht], Z6)
var de
;(function (i) {
  ;(i[(i.File = 0)] = "File"),
    (i[(i.Module = 1)] = "Module"),
    (i[(i.Namespace = 2)] = "Namespace"),
    (i[(i.Package = 3)] = "Package"),
    (i[(i.Class = 4)] = "Class"),
    (i[(i.Method = 5)] = "Method"),
    (i[(i.Property = 6)] = "Property"),
    (i[(i.Field = 7)] = "Field"),
    (i[(i.Constructor = 8)] = "Constructor"),
    (i[(i.Enum = 9)] = "Enum"),
    (i[(i.Interface = 10)] = "Interface"),
    (i[(i.Function = 11)] = "Function"),
    (i[(i.Variable = 12)] = "Variable"),
    (i[(i.Constant = 13)] = "Constant"),
    (i[(i.String = 14)] = "String"),
    (i[(i.Number = 15)] = "Number"),
    (i[(i.Boolean = 16)] = "Boolean"),
    (i[(i.Array = 17)] = "Array"),
    (i[(i.Object = 18)] = "Object"),
    (i[(i.Key = 19)] = "Key"),
    (i[(i.Null = 20)] = "Null"),
    (i[(i.EnumMember = 21)] = "EnumMember"),
    (i[(i.Struct = 22)] = "Struct"),
    (i[(i.Event = 23)] = "Event"),
    (i[(i.Operator = 24)] = "Operator"),
    (i[(i.TypeParameter = 25)] = "TypeParameter")
})(de || (de = {}))
var Lh
;(function (i) {
  i[(i.Deprecated = 1)] = "Deprecated"
})(Lh || (Lh = {}))
var Rh = (C2 = class {
  static validate(t) {
    if (!t.name) throw new Error("name must not be falsy")
  }
  constructor(t, e, s, r, a) {
    ;(this.name = t),
      (this.kind = e),
      (this.containerName = a),
      typeof s == "string" && (this.containerName = s),
      r instanceof ys
        ? (this.location = r)
        : s instanceof Nt && (this.location = new ys(r, s)),
      C2.validate(this)
  }
  toJSON() {
    return {
      name: this.name,
      kind: de[this.kind],
      location: this.location,
      containerName: this.containerName,
    }
  }
})
Rh = C2 = __decorate([ht], Rh)
var Dh = (V6 = class {
  static validate(t) {
    if (!t.name) throw new Error("name must not be falsy")
    if (!t.range.contains(t.selectionRange))
      throw new Error("selectionRange must be contained in fullRange")
    t.children?.forEach(V6.validate)
  }
  constructor(t, e, s, r, a) {
    ;(this.name = t),
      (this.detail = e),
      (this.kind = s),
      (this.range = r),
      (this.selectionRange = a),
      (this.children = []),
      V6.validate(this)
  }
})
Dh = V6 = __decorate([ht], Dh)
var Fh
;(function (i) {
  ;(i[(i.Invoke = 1)] = "Invoke"), (i[(i.Automatic = 2)] = "Automatic")
})(Fh || (Fh = {}))
var tO = class {
  constructor(t, e) {
    ;(this.title = t), (this.kind = e)
  }
}
tO = __decorate([ht], tO)
var Ie = class {
  static {
    Nh = this
  }
  static {
    this.c = "."
  }
  constructor(t) {
    this.value = t
  }
  append(t) {
    return new Nh(this.value ? this.value + Nh.c + t : t)
  }
  intersects(t) {
    return this.contains(t) || t.contains(this)
  }
  contains(t) {
    return this.value === t.value || t.value.startsWith(this.value + Nh.c)
  }
}
;(Ie = Nh = __decorate([ht], Ie)),
  (Ie.Empty = new Ie("")),
  (Ie.QuickFix = Ie.Empty.append("quickfix")),
  (Ie.Refactor = Ie.Empty.append("refactor")),
  (Ie.RefactorExtract = Ie.Refactor.append("extract")),
  (Ie.RefactorInline = Ie.Refactor.append("inline")),
  (Ie.RefactorMove = Ie.Refactor.append("move")),
  (Ie.RefactorRewrite = Ie.Refactor.append("rewrite")),
  (Ie.Source = Ie.Empty.append("source")),
  (Ie.SourceOrganizeImports = Ie.Source.append("organizeImports")),
  (Ie.SourceFixAll = Ie.Source.append("fixAll")),
  (Ie.Notebook = Ie.Empty.append("notebook"))
var Ah = class {
  constructor(t, e) {
    if (
      ((this.range = t), (this.parent = e), e && !e.range.contains(this.range))
    )
      throw new Error("Invalid argument: parent must contain this range")
  }
}
Ah = __decorate([ht], Ah)
var _2 = class {
    constructor(i, t, e, s, r, a) {
      ;(this.kind = i),
        (this.name = t),
        (this.detail = e),
        (this.uri = s),
        (this.range = r),
        (this.selectionRange = a)
    }
  },
  ntt = class {
    constructor(i, t) {
      ;(this.fromRanges = t), (this.from = i)
    }
  },
  att = class {
    constructor(i, t) {
      ;(this.fromRanges = t), (this.to = i)
    }
  },
  Wc
;(function (i) {
  ;(i[(i.Information = 0)] = "Information"),
    (i[(i.Warning = 1)] = "Warning"),
    (i[(i.Error = 2)] = "Error")
})(Wc || (Wc = {}))
var eO = class {
  constructor(t, e) {
    ;(this.range = t), (this.command = e)
  }
  get isResolved() {
    return !!this.command
  }
}
eO = __decorate([ht], eO)
var ls = (J2 = class {
  #t
  static isMarkdownString(t) {
    return t instanceof J2
      ? !0
      : t &&
          t.appendCodeblock &&
          t.appendMarkdown &&
          t.appendText &&
          t.value !== void 0
  }
  constructor(t, e = !1) {
    this.#t = new vX(t, { supportThemeIcons: e })
  }
  get value() {
    return this.#t.value
  }
  set value(t) {
    this.#t.value = t
  }
  get isTrusted() {
    return this.#t.isTrusted
  }
  set isTrusted(t) {
    this.#t.isTrusted = t
  }
  get supportThemeIcons() {
    return this.#t.supportThemeIcons
  }
  set supportThemeIcons(t) {
    this.#t.supportThemeIcons = t
  }
  get supportHtml() {
    return this.#t.supportHtml
  }
  set supportHtml(t) {
    this.#t.supportHtml = t
  }
  get baseUri() {
    return this.#t.baseUri
  }
  set baseUri(t) {
    this.#t.baseUri = t
  }
  appendText(t) {
    return this.#t.appendText(t), this
  }
  appendMarkdown(t) {
    return this.#t.appendMarkdown(t), this
  }
  appendCodeblock(t, e) {
    return this.#t.appendCodeblock(e ?? "", t), this
  }
})
ls = J2 = __decorate([ht], ls)
var O2 = class {
  constructor(t, e) {
    ;(this.label = t), (this.documentation = e)
  }
}
O2 = __decorate([ht], O2)
var B2 = class {
  constructor(t, e) {
    ;(this.label = t), (this.documentation = e), (this.parameters = [])
  }
}
B2 = __decorate([ht], B2)
var q2 = class {
  constructor() {
    ;(this.activeSignature = 0),
      (this.activeParameter = 0),
      (this.signatures = [])
  }
}
q2 = __decorate([ht], q2)
var U2
;(function (i) {
  ;(i[(i.Invoke = 1)] = "Invoke"),
    (i[(i.TriggerCharacter = 2)] = "TriggerCharacter"),
    (i[(i.ContentChange = 3)] = "ContentChange")
})(U2 || (U2 = {}))
var M2
;(function (i) {
  ;(i[(i.Type = 1)] = "Type"), (i[(i.Parameter = 2)] = "Parameter")
})(M2 || (M2 = {}))
var iO = class {
  constructor(t) {
    this.value = t
  }
}
iO = __decorate([ht], iO)
var sO = class {
  constructor(t, e, s) {
    ;(this.position = t), (this.label = e), (this.kind = s)
  }
}
sO = __decorate([ht], sO)
var jc
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"),
    (i[(i.TriggerCharacter = 1)] = "TriggerCharacter"),
    (i[(i.TriggerForIncompleteCompletions = 2)] =
      "TriggerForIncompleteCompletions")
})(jc || (jc = {}))
var wt
;(function (i) {
  ;(i[(i.Text = 0)] = "Text"),
    (i[(i.Method = 1)] = "Method"),
    (i[(i.Function = 2)] = "Function"),
    (i[(i.Constructor = 3)] = "Constructor"),
    (i[(i.Field = 4)] = "Field"),
    (i[(i.Variable = 5)] = "Variable"),
    (i[(i.Class = 6)] = "Class"),
    (i[(i.Interface = 7)] = "Interface"),
    (i[(i.Module = 8)] = "Module"),
    (i[(i.Property = 9)] = "Property"),
    (i[(i.Unit = 10)] = "Unit"),
    (i[(i.Value = 11)] = "Value"),
    (i[(i.Enum = 12)] = "Enum"),
    (i[(i.Keyword = 13)] = "Keyword"),
    (i[(i.Snippet = 14)] = "Snippet"),
    (i[(i.Color = 15)] = "Color"),
    (i[(i.File = 16)] = "File"),
    (i[(i.Reference = 17)] = "Reference"),
    (i[(i.Folder = 18)] = "Folder"),
    (i[(i.EnumMember = 19)] = "EnumMember"),
    (i[(i.Constant = 20)] = "Constant"),
    (i[(i.Struct = 21)] = "Struct"),
    (i[(i.Event = 22)] = "Event"),
    (i[(i.Operator = 23)] = "Operator"),
    (i[(i.TypeParameter = 24)] = "TypeParameter"),
    (i[(i.User = 25)] = "User"),
    (i[(i.Issue = 26)] = "Issue")
})(wt || (wt = {}))
var _h
;(function (i) {
  i[(i.Deprecated = 1)] = "Deprecated"
})(_h || (_h = {}))
var rO = class {
  constructor(t, e) {
    ;(this.label = t), (this.kind = e)
  }
  toJSON() {
    return {
      label: this.label,
      kind: this.kind && wt[this.kind],
      detail: this.detail,
      documentation: this.documentation,
      sortText: this.sortText,
      filterText: this.filterText,
      preselect: this.preselect,
      insertText: this.insertText,
      textEdit: this.textEdit,
    }
  }
}
rO = __decorate([ht], rO)
var Vc = class {
  constructor(t = [], e = !1) {
    ;(this.items = t), (this.isIncomplete = e)
  }
}
Vc = __decorate([ht], Vc)
var H2 = class {
  constructor(t, e, s) {
    ;(this.insertText = t), (this.range = e), (this.command = s)
  }
}
H2 = __decorate([ht], H2)
var W2 = class {
  constructor(t) {
    ;(this.commands = void 0),
      (this.suppressSuggestions = void 0),
      (this.items = t)
  }
}
W2 = __decorate([ht], W2)
var go
;(function (i) {
  ;(i[(i.Unknown = 0)] = "Unknown"),
    (i[(i.Word = 1)] = "Word"),
    (i[(i.Line = 2)] = "Line"),
    (i[(i.Suggest = 3)] = "Suggest")
})(go || (go = {}))
var Oh
;(function (i) {
  ;(i[(i.Active = -1)] = "Active"),
    (i[(i.Beside = -2)] = "Beside"),
    (i[(i.One = 1)] = "One"),
    (i[(i.Two = 2)] = "Two"),
    (i[(i.Three = 3)] = "Three"),
    (i[(i.Four = 4)] = "Four"),
    (i[(i.Five = 5)] = "Five"),
    (i[(i.Six = 6)] = "Six"),
    (i[(i.Seven = 7)] = "Seven"),
    (i[(i.Eight = 8)] = "Eight"),
    (i[(i.Nine = 9)] = "Nine")
})(Oh || (Oh = {}))
var oa
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"), (i[(i.Right = 2)] = "Right")
})(oa || (oa = {}))
function oTt(i, t) {
  return `${ae.toKey(i)}.${t}`
}
var ar
;(function (i) {
  ;(i[(i.Off = 0)] = "Off"),
    (i[(i.On = 1)] = "On"),
    (i[(i.Relative = 2)] = "Relative"),
    (i[(i.Interval = 3)] = "Interval")
})(ar || (ar = {}))
var Gc
;(function (i) {
  ;(i[(i.Manual = 1)] = "Manual"),
    (i[(i.AfterDelay = 2)] = "AfterDelay"),
    (i[(i.FocusOut = 3)] = "FocusOut")
})(Gc || (Gc = {}))
var nO
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.InCenter = 1)] = "InCenter"),
    (i[(i.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
    (i[(i.AtTop = 3)] = "AtTop")
})(nO || (nO = {}))
var zc
;(function (i) {
  ;(i[(i.Keyboard = 1)] = "Keyboard"),
    (i[(i.Mouse = 2)] = "Mouse"),
    (i[(i.Command = 3)] = "Command")
})(zc || (zc = {}))
var Yc
;(function (i) {
  ;(i[(i.Addition = 1)] = "Addition"),
    (i[(i.Deletion = 2)] = "Deletion"),
    (i[(i.Modification = 3)] = "Modification")
})(Yc || (Yc = {}))
var Bh
;(function (i) {
  ;(i[(i.Undo = 1)] = "Undo"), (i[(i.Redo = 2)] = "Redo")
})(Bh || (Bh = {}))
var vo
;(function (i) {
  ;(i[(i.OpenOpen = 0)] = "OpenOpen"),
    (i[(i.ClosedClosed = 1)] = "ClosedClosed"),
    (i[(i.OpenClosed = 2)] = "OpenClosed"),
    (i[(i.ClosedOpen = 3)] = "ClosedOpen")
})(vo || (vo = {})),
  (function (i) {
    function t(e) {
      switch (e) {
        case "keyboard":
          return i.Keyboard
        case "mouse":
          return i.Mouse
        case "api":
          return i.Command
      }
    }
    i.fromValue = t
  })(zc || (zc = {}))
var Qc
;(function (i) {
  ;(i[(i.Other = 0)] = "Other"),
    (i[(i.Comment = 1)] = "Comment"),
    (i[(i.String = 2)] = "String"),
    (i[(i.RegEx = 3)] = "RegEx")
})(Qc || (Qc = {})),
  (function (i) {
    function t(e) {
      switch (e) {
        case i.Other:
          return "other"
        case i.Comment:
          return "comment"
        case i.String:
          return "string"
        case i.RegEx:
          return "regex"
      }
      return "other"
    }
    i.toString = t
  })(Qc || (Qc = {}))
var aO = class {
  constructor(t, e) {
    if (e && !S.isUri(e)) throw Lt("target")
    if (!Nt.isRange(t) || t.isEmpty) throw Lt("range")
    ;(this.range = t), (this.target = e)
  }
}
aO = __decorate([ht], aO)
var Xc = class {
  constructor(t, e, s, r) {
    ;(this.red = t), (this.green = e), (this.blue = s), (this.alpha = r)
  }
}
Xc = __decorate([ht], Xc)
var oO = class {
  constructor(t, e) {
    if (e && !(e instanceof Xc)) throw Lt("color")
    if (!Nt.isRange(t) || t.isEmpty) throw Lt("range")
    ;(this.range = t), (this.color = e)
  }
}
oO = __decorate([ht], oO)
var cO = class {
  constructor(t) {
    if (!t || typeof t != "string") throw Lt("label")
    this.label = t
  }
}
cO = __decorate([ht], cO)
var ott
;(function (i) {
  ;(i[(i.RGB = 0)] = "RGB"), (i[(i.HEX = 1)] = "HEX"), (i[(i.HSL = 2)] = "HSL")
})(ott || (ott = {}))
var j2
;(function (i) {
  ;(i[(i.Error = 0)] = "Error"),
    (i[(i.Warning = 1)] = "Warning"),
    (i[(i.Information = 2)] = "Information")
})(j2 || (j2 = {}))
var V2
;(function (i) {
  ;(i[(i.Unknown = 0)] = "Unknown"),
    (i[(i.Shutdown = 1)] = "Shutdown"),
    (i[(i.Process = 2)] = "Process"),
    (i[(i.User = 3)] = "User"),
    (i[(i.Extension = 4)] = "Extension")
})(V2 || (V2 = {}))
var lO
;(function (i) {
  ;(i[(i.Low = 0)] = "Low"),
    (i[(i.Medium = 1)] = "Medium"),
    (i[(i.High = 2)] = "High")
})(lO || (lO = {}))
var cTt = class {
    constructor(i, t, e) {
      if (
        ((this.startIndex = i),
        (this.length = t),
        (this.tooltip = e),
        typeof i != "number" || i < 0)
      )
        throw Lt("startIndex")
      if (typeof t != "number" || t < 1) throw Lt("length")
      if (e !== void 0 && typeof e != "string") throw Lt("tooltip")
    }
  },
  lTt = class {
    constructor(i) {
      this.uri = i
    }
  },
  uTt = class {
    constructor(i) {
      this.terminalCommand = i
    }
  },
  G2
;(function (i) {
  ;(i[(i.Panel = 1)] = "Panel"), (i[(i.Editor = 2)] = "Editor")
})(G2 || (G2 = {}))
var hTt = class {
    constructor(i) {
      if (((this.options = i), typeof i != "object")) throw Lt("options")
    }
  },
  z2
;(function (i) {
  ;(i[(i.File = 0)] = "File"),
    (i[(i.Folder = 1)] = "Folder"),
    (i[(i.Flag = 2)] = "Flag"),
    (i[(i.Method = 3)] = "Method"),
    (i[(i.Argument = 4)] = "Argument")
})(z2 || (z2 = {}))
var dTt = class {
    constructor(i, t, e, s, r, a, o, c) {
      ;(this.label = i),
        (this.icon = t),
        (this.detail = e),
        (this.isFile = s),
        (this.isDirectory = r),
        (this.isKeyword = a),
        (this.replacementIndex = o ?? 0),
        (this.replacementLength = c ?? 0)
    }
  },
  mTt = class {
    constructor(i, t) {
      ;(this.items = i ?? []), (this.resourceRequestConfig = t)
    }
  },
  Y2
;(function (i) {
  ;(i[(i.Always = 1)] = "Always"),
    (i[(i.Silent = 2)] = "Silent"),
    (i[(i.Never = 3)] = "Never")
})(Y2 || (Y2 = {}))
var Q2
;(function (i) {
  ;(i[(i.Shared = 1)] = "Shared"),
    (i[(i.Dedicated = 2)] = "Dedicated"),
    (i[(i.New = 3)] = "New")
})(Q2 || (Q2 = {}))
var qh = class {
  static {
    Fr = this
  }
  static {
    this.Clean = new Fr("clean", "Clean")
  }
  static {
    this.Build = new Fr("build", "Build")
  }
  static {
    this.Rebuild = new Fr("rebuild", "Rebuild")
  }
  static {
    this.Test = new Fr("test", "Test")
  }
  static from(t) {
    switch (t) {
      case "clean":
        return Fr.Clean
      case "build":
        return Fr.Build
      case "rebuild":
        return Fr.Rebuild
      case "test":
        return Fr.Test
      default:
        return
    }
  }
  constructor(t, e) {
    if (((this.label = e), typeof t != "string" || typeof e != "string"))
      throw Lt("name")
    this.c = t
  }
  get id() {
    return this.c
  }
}
qh = Fr = __decorate([ht], qh)
function ctt(i) {
  let t = ""
  for (let e = 0; e < i.length; e++) t += i[e].replace(/,/g, ",,") + ","
  return t
}
var Kc = class {
  constructor(t, e, s) {
    if (typeof t != "string") throw Lt("process")
    ;(this.e = []),
      (this.c = t),
      e !== void 0 &&
        (Array.isArray(e) ? ((this.e = e), (this.f = s)) : (this.f = e))
  }
  get process() {
    return this.c
  }
  set process(t) {
    if (typeof t != "string") throw Lt("process")
    this.c = t
  }
  get args() {
    return this.e
  }
  set args(t) {
    Array.isArray(t) || (t = []), (this.e = t)
  }
  get options() {
    return this.f
  }
  set options(t) {
    this.f = t
  }
  computeId() {
    const t = []
    if (
      (t.push("process"),
      this.c !== void 0 && t.push(this.c),
      this.e && this.e.length > 0)
    )
      for (const e of this.e) t.push(e)
    return ctt(t)
  }
}
Kc = __decorate([ht], Kc)
var wo = class {
  constructor(t, e, s) {
    if (((this.f = []), Array.isArray(e))) {
      if (!t) throw Lt("command can't be undefined or null")
      if (typeof t != "string" && typeof t.value != "string")
        throw Lt("command")
      ;(this.e = t), (this.f = e), (this.g = s)
    } else {
      if (typeof t != "string") throw Lt("commandLine")
      ;(this.c = t), (this.g = e)
    }
  }
  get commandLine() {
    return this.c
  }
  set commandLine(t) {
    if (typeof t != "string") throw Lt("commandLine")
    this.c = t
  }
  get command() {
    return this.e ? this.e : ""
  }
  set command(t) {
    if (typeof t != "string" && typeof t.value != "string") throw Lt("command")
    this.e = t
  }
  get args() {
    return this.f
  }
  set args(t) {
    this.f = t || []
  }
  get options() {
    return this.g
  }
  set options(t) {
    this.g = t
  }
  computeId() {
    const t = []
    if (
      (t.push("shell"),
      this.c !== void 0 && t.push(this.c),
      this.e !== void 0 &&
        t.push(typeof this.e == "string" ? this.e : this.e.value),
      this.f && this.f.length > 0)
    )
      for (const e of this.f) t.push(typeof e == "string" ? e : e.value)
    return ctt(t)
  }
}
wo = __decorate([ht], wo)
var X2
;(function (i) {
  ;(i[(i.Escape = 1)] = "Escape"),
    (i[(i.Strong = 2)] = "Strong"),
    (i[(i.Weak = 3)] = "Weak")
})(X2 || (X2 = {}))
var ca
;(function (i) {
  ;(i[(i.Global = 1)] = "Global"), (i[(i.Workspace = 2)] = "Workspace")
})(ca || (ca = {}))
var K2 = class {
    constructor(i) {
      this.c = i
    }
    computeId() {
      return "customExecution" + Ze()
    }
    set callback(i) {
      this.c = i
    }
    get callback() {
      return this.c
    }
  },
  uO = class {
    static {
      Ar = this
    }
    static {
      this.c = "customExecution"
    }
    static {
      this.e = "process"
    }
    static {
      this.f = "shell"
    }
    static {
      this.g = "$empty"
    }
    constructor(t, e, s, r, a, o) {
      ;(this.k = !1), (this.l = this.definition = t)
      let c
      typeof e == "string"
        ? ((this.o = this.name = e),
          (this.w = this.source = s),
          (this.execution = r),
          (c = a),
          (this.k = !0))
        : e === ca.Global || e === ca.Workspace
          ? ((this.target = e),
            (this.o = this.name = s),
            (this.w = this.source = r),
            (this.execution = a),
            (c = o))
          : ((this.target = e),
            (this.o = this.name = s),
            (this.w = this.source = r),
            (this.execution = a),
            (c = o)),
        typeof c == "string"
          ? ((this.r = [c]), (this.t = !0))
          : Array.isArray(c)
            ? ((this.r = c), (this.t = !0))
            : ((this.r = []), (this.t = !1)),
        (this.u = !1),
        (this.y = Object.create(null)),
        (this.z = Object.create(null))
    }
    get _id() {
      return this.j
    }
    set _id(t) {
      this.j = t
    }
    get _deprecated() {
      return this.k
    }
    B() {
      this.j !== void 0 && ((this.j = void 0), (this.m = void 0), this.C())
    }
    C() {
      this.q instanceof Kc
        ? (this.l = { type: Ar.e, id: this.q.computeId() })
        : this.q instanceof wo
          ? (this.l = { type: Ar.f, id: this.q.computeId() })
          : this.q instanceof K2
            ? (this.l = { type: Ar.c, id: this.q.computeId() })
            : (this.l = { type: Ar.g, id: Ze() })
    }
    get definition() {
      return this.l
    }
    set definition(t) {
      if (t == null) throw Lt("Kind can't be undefined or null")
      this.B(), (this.l = t)
    }
    get scope() {
      return this.m
    }
    set target(t) {
      this.B(), (this.m = t)
    }
    get name() {
      return this.o
    }
    set name(t) {
      if (typeof t != "string") throw Lt("name")
      this.B(), (this.o = t)
    }
    get execution() {
      return this.q
    }
    set execution(t) {
      t === null && (t = void 0), this.B(), (this.q = t)
      const e = this.l.type
      ;(Ar.g === e || Ar.e === e || Ar.f === e || Ar.c === e) && this.C()
    }
    get problemMatchers() {
      return this.r
    }
    set problemMatchers(t) {
      if (Array.isArray(t)) this.B(), (this.r = t), (this.t = !0)
      else {
        this.B(), (this.r = []), (this.t = !1)
        return
      }
    }
    get hasDefinedMatchers() {
      return this.t
    }
    get isBackground() {
      return this.u
    }
    set isBackground(t) {
      t !== !0 && t !== !1 && (t = !1), this.B(), (this.u = t)
    }
    get source() {
      return this.w
    }
    set source(t) {
      if (typeof t != "string" || t.length === 0)
        throw Lt("source must be a string of length > 0")
      this.B(), (this.w = t)
    }
    get group() {
      return this.x
    }
    set group(t) {
      t === null && (t = void 0), this.B(), (this.x = t)
    }
    get detail() {
      return this.A
    }
    set detail(t) {
      t === null && (t = void 0), (this.A = t)
    }
    get presentationOptions() {
      return this.y
    }
    set presentationOptions(t) {
      t == null && (t = Object.create(null)), this.B(), (this.y = t)
    }
    get runOptions() {
      return this.z
    }
    set runOptions(t) {
      t == null && (t = Object.create(null)), this.B(), (this.z = t)
    }
  }
uO = Ar = __decorate([ht], uO)
var yo
;(function (i) {
  ;(i[(i.SourceControl = 1)] = "SourceControl"),
    (i[(i.Window = 10)] = "Window"),
    (i[(i.Notification = 15)] = "Notification")
})(yo || (yo = {}))
var Z2
;(function (i) {
  function t(e) {
    const s = e
    return ps(s.value)
      ? s.tooltip && !_t(s.tooltip)
        ? (console.log("INVALID view badge, invalid tooltip", s.tooltip), !1)
        : !0
      : (console.log("INVALID view badge, invalid value", s.value), !1)
  }
  i.isViewBadge = t
})(Z2 || (Z2 = {}))
var hO = (L2 = class {
  static isTreeItem(t, e) {
    const s = t
    if (s.checkboxState !== void 0) {
      const r = ps(s.checkboxState)
          ? s.checkboxState
          : Je(s.checkboxState) && ps(s.checkboxState.state)
            ? s.checkboxState.state
            : void 0,
        a =
          !ps(s.checkboxState) && Je(s.checkboxState)
            ? s.checkboxState.tooltip
            : void 0
      if (
        r === void 0 ||
        (r !== _r.Checked && r !== _r.Unchecked) ||
        (a !== void 0 && !_t(a))
      )
        return (
          console.log(
            "INVALID tree item, invalid checkboxState",
            s.checkboxState,
          ),
          !1
        )
    }
    if (t instanceof L2) return !0
    if (s.label !== void 0 && !_t(s.label) && !s.label?.label)
      return console.log("INVALID tree item, invalid label", s.label), !1
    if (s.id !== void 0 && !_t(s.id))
      return console.log("INVALID tree item, invalid id", s.id), !1
    if (
      s.iconPath !== void 0 &&
      !_t(s.iconPath) &&
      !S.isUri(s.iconPath) &&
      (!s.iconPath || !_t(s.iconPath.id))
    ) {
      const r = s.iconPath
      if (
        !r ||
        (!_t(r.light) && !S.isUri(r.light) && !_t(r.dark) && !S.isUri(r.dark))
      )
        return (
          console.log("INVALID tree item, invalid iconPath", s.iconPath), !1
        )
    }
    return s.description !== void 0 &&
      !_t(s.description) &&
      typeof s.description != "boolean"
      ? (console.log("INVALID tree item, invalid description", s.description),
        !1)
      : s.resourceUri !== void 0 && !S.isUri(s.resourceUri)
        ? (console.log("INVALID tree item, invalid resourceUri", s.resourceUri),
          !1)
        : s.tooltip !== void 0 && !_t(s.tooltip) && !(s.tooltip instanceof ls)
          ? (console.log("INVALID tree item, invalid tooltip", s.tooltip), !1)
          : s.command !== void 0 && !s.command.command
            ? (console.log("INVALID tree item, invalid command", s.command), !1)
            : s.collapsibleState !== void 0 &&
                s.collapsibleState < bo.None &&
                s.collapsibleState > bo.Expanded
              ? (console.log(
                  "INVALID tree item, invalid collapsibleState",
                  s.collapsibleState,
                ),
                !1)
              : s.contextValue !== void 0 && !_t(s.contextValue)
                ? (console.log(
                    "INVALID tree item, invalid contextValue",
                    s.contextValue,
                  ),
                  !1)
                : s.accessibilityInformation !== void 0 &&
                    !s.accessibilityInformation?.label
                  ? (console.log(
                      "INVALID tree item, invalid accessibilityInformation",
                      s.accessibilityInformation,
                    ),
                    !1)
                  : !0
  }
  constructor(t, e = bo.None) {
    ;(this.collapsibleState = e),
      S.isUri(t) ? (this.resourceUri = t) : (this.label = t)
  }
})
hO = L2 = __decorate([ht], hO)
var bo
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Collapsed = 1)] = "Collapsed"),
    (i[(i.Expanded = 2)] = "Expanded")
})(bo || (bo = {}))
var _r
;(function (i) {
  ;(i[(i.Unchecked = 0)] = "Unchecked"), (i[(i.Checked = 1)] = "Checked")
})(_r || (_r = {}))
var dO = class {
  async asString() {
    return typeof this.value == "string"
      ? this.value
      : JSON.stringify(this.value)
  }
  asFile() {}
  constructor(t) {
    this.value = t
  }
}
dO = __decorate([ht], dO)
var mO = class extends dO {},
  fTt = class extends mO {
    #t
    constructor(i) {
      super(""), (this.#t = i)
    }
    asFile() {
      return this.#t
    }
  },
  pTt = class {
    constructor(i, t, e, s) {
      ;(this.name = i), (this.uri = t), (this._itemId = e), (this.c = s)
    }
    data() {
      return this.c()
    }
  },
  Uh = class {
    #t = new Map()
    constructor(t) {
      for (const [e, s] of t ?? []) {
        const r = this.#t.get(this.#e(e))
        r ? r.push(s) : this.#t.set(this.#e(e), [s])
      }
    }
    get(t) {
      return this.#t.get(this.#e(t))?.[0]
    }
    set(t, e) {
      this.#t.set(this.#e(t), [e])
    }
    forEach(t, e) {
      for (const [s, r] of this.#t) for (const a of r) t.call(e, a, s, this)
    }
    *[Symbol.iterator]() {
      for (const [t, e] of this.#t) for (const s of e) yield [t, s]
    }
    #e(t) {
      return t.toLowerCase()
    }
  }
Uh = __decorate([ht], Uh)
var tU = class {
  constructor(t, e, s) {
    ;(this.insertText = t), (this.title = e), (this.kind = s)
  }
}
tU = __decorate([ht], tU)
var eU
;(function (i) {
  ;(i[(i.Automatic = 0)] = "Automatic"), (i[(i.PasteAs = 1)] = "PasteAs")
})(eU || (eU = {}))
var Zc = class Y3 {
  static {
    this.c = "."
  }
  constructor(t) {
    this.value = t
  }
  append(...t) {
    return new Y3((this.value ? [this.value, ...t] : t).join(Y3.c))
  }
  intersects(t) {
    return this.contains(t) || t.contains(this)
  }
  contains(t) {
    return this.value === t.value || t.value.startsWith(this.value + Y3.c)
  }
}
;(Zc.Empty = new Zc("")), (Zc.Text = new Zc("text"))
var gTt = class {
    constructor(i, t, e) {
      ;(this.title = t), (this.insertText = i), (this.kind = e)
    }
  },
  Ji = class {
    constructor(t, e) {
      ;(this.id = t), (this.color = e)
    }
    static isThemeIcon(t) {
      return typeof t.id != "string"
        ? (console.log("INVALID ThemeIcon, invalid id", t.id), !1)
        : !0
    }
  }
;(Ji = __decorate([ht], Ji)),
  (Ji.File = new Ji("file")),
  (Ji.Folder = new Ji("folder"))
var Mh = class {
  constructor(t) {
    this.id = t
  }
}
Mh = __decorate([ht], Mh)
var tl
;(function (i) {
  ;(i[(i.Global = 1)] = "Global"),
    (i[(i.Workspace = 2)] = "Workspace"),
    (i[(i.WorkspaceFolder = 3)] = "WorkspaceFolder")
})(tl || (tl = {}))
var el = class {
  get base() {
    return this.c
  }
  set base(t) {
    ;(this.c = t), (this.e = S.file(t))
  }
  get baseUri() {
    return this.e
  }
  set baseUri(t) {
    ;(this.e = t), (this.c = t.fsPath)
  }
  constructor(t, e) {
    if (typeof t != "string" && (!t || (!S.isUri(t) && !S.isUri(t.uri))))
      throw Lt("base")
    if (typeof e != "string") throw Lt("pattern")
    typeof t == "string"
      ? (this.baseUri = S.file(t))
      : S.isUri(t)
        ? (this.baseUri = t)
        : (this.baseUri = t.uri),
      (this.pattern = e)
  }
  toJSON() {
    return {
      pattern: this.pattern,
      base: this.base,
      baseUri: this.baseUri.toJSON(),
    }
  }
}
el = __decorate([ht], el)
var ltt = new WeakMap()
function vTt(i, t) {
  ltt.set(i, t)
}
var il = class {
  constructor(t, e, s, r, a) {
    ;(this.enabled = typeof t == "boolean" ? t : !0),
      typeof e == "string" && (this.condition = e),
      typeof s == "string" && (this.hitCondition = s),
      typeof r == "string" && (this.logMessage = r),
      typeof a == "string" && (this.mode = a)
  }
  get id() {
    return this.c || (this.c = ltt.get(this) ?? Ze()), this.c
  }
}
il = __decorate([ht], il)
var To = class extends il {
  constructor(t, e, s, r, a, o) {
    if ((super(e, s, r, a, o), t === null)) throw Lt("location")
    this.location = t
  }
}
To = __decorate([ht], To)
var ko = class extends il {
  constructor(t, e, s, r, a, o) {
    super(e, s, r, a, o), (this.functionName = t)
  }
}
ko = __decorate([ht], ko)
var fO = class extends il {
  constructor(t, e, s, r, a, o, c, l) {
    if ((super(r, a, o, c, l), !e)) throw Lt("dataId")
    ;(this.label = t), (this.dataId = e), (this.canPersist = s)
  }
}
fO = __decorate([ht], fO)
var sl = class {
  constructor(t, e, s) {
    ;(this.command = t), (this.args = e || []), (this.options = s)
  }
}
sl = __decorate([ht], sl)
var rl = class {
  constructor(t, e) {
    ;(this.port = t), (this.host = e)
  }
}
rl = __decorate([ht], rl)
var Hh = class {
  constructor(t) {
    this.path = t
  }
}
Hh = __decorate([ht], Hh)
var Wh = class {
  constructor(t) {
    this.implementation = t
  }
}
Wh = __decorate([ht], Wh)
var utt = class {
    constructor(i, t, e) {
      ;(this.session = i), (this.threadId = t), (this.frameId = e)
    }
  },
  htt = class {
    constructor(i, t) {
      ;(this.session = i), (this.threadId = t)
    }
  },
  pO = class {
    constructor(t, e) {
      ;(this.range = t), (this.expression = e)
    }
  }
pO = __decorate([ht], pO)
var jh
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})(jh || (jh = {}))
var gO = class {
  constructor(t, e) {
    ;(this.range = t), (this.text = e)
  }
}
gO = __decorate([ht], gO)
var vO = class {
  constructor(t, e, s = !0) {
    ;(this.range = t), (this.variableName = e), (this.caseSensitiveLookup = s)
  }
}
vO = __decorate([ht], vO)
var wO = class {
  constructor(t, e) {
    ;(this.range = t), (this.expression = e)
  }
}
wO = __decorate([ht], wO)
var iU = class {
  constructor(t, e) {
    ;(this.frameId = t), (this.stoppedLocation = e)
  }
}
iU = __decorate([ht], iU)
var sU
;(function (i) {
  i[(i.AIGenerated = 1)] = "AIGenerated"
})(sU || (sU = {}))
var Vh
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})(Vh || (Vh = {}))
var wTt = class {
    constructor(i, t) {
      ;(this.newSymbolName = i), (this.tags = t)
    }
  },
  nl
;(function (i) {
  ;(i[(i.Changed = 1)] = "Changed"),
    (i[(i.Created = 2)] = "Created"),
    (i[(i.Deleted = 3)] = "Deleted")
})(nl || (nl = {}))
var ei = (zi = class extends Error {
  static FileExists(t) {
    return new zi(t, dt.FileExists, zi.FileExists)
  }
  static FileNotFound(t) {
    return new zi(t, dt.FileNotFound, zi.FileNotFound)
  }
  static FileNotADirectory(t) {
    return new zi(t, dt.FileNotADirectory, zi.FileNotADirectory)
  }
  static FileIsADirectory(t) {
    return new zi(t, dt.FileIsADirectory, zi.FileIsADirectory)
  }
  static NoPermissions(t) {
    return new zi(t, dt.NoPermissions, zi.NoPermissions)
  }
  static Unavailable(t) {
    return new zi(t, dt.Unavailable, zi.Unavailable)
  }
  constructor(t, e = dt.Unknown, s) {
    super(S.isUri(t) ? t.toString(!0) : t),
      (this.code = s?.name ?? "Unknown"),
      aK(this, e),
      Object.setPrototypeOf(this, zi.prototype),
      typeof Error.captureStackTrace == "function" &&
        typeof s == "function" &&
        Error.captureStackTrace(this, s)
  }
})
ei = zi = __decorate([ht], ei)
var rU = class {
  constructor(t, e, s) {
    ;(this.start = t), (this.end = e), (this.kind = s)
  }
}
rU = __decorate([ht], rU)
var pn
;(function (i) {
  ;(i[(i.Comment = 1)] = "Comment"),
    (i[(i.Imports = 2)] = "Imports"),
    (i[(i.Region = 3)] = "Region")
})(pn || (pn = {}))
var Gh
;(function (i) {
  ;(i[(i.Collapsed = 0)] = "Collapsed"), (i[(i.Expanded = 1)] = "Expanded")
})(Gh || (Gh = {}))
var nU
;(function (i) {
  ;(i[(i.Editing = 0)] = "Editing"), (i[(i.Preview = 1)] = "Preview")
})(nU || (nU = {}))
var aU
;(function (i) {
  ;(i[(i.Published = 0)] = "Published"), (i[(i.Draft = 1)] = "Draft")
})(aU || (aU = {}))
var zh
;(function (i) {
  ;(i[(i.Unresolved = 0)] = "Unresolved"), (i[(i.Resolved = 1)] = "Resolved")
})(zh || (zh = {}))
var Yh
;(function (i) {
  ;(i[(i.Current = 0)] = "Current"), (i[(i.Outdated = 1)] = "Outdated")
})(Yh || (Yh = {}))
var Qh
;(function (i) {
  ;(i[(i.Reply = 1)] = "Reply"), (i[(i.Comment = 2)] = "Comment")
})(Qh || (Qh = {}))
var oU = class {
  constructor(i, t = []) {
    ;(this.tokenTypes = i), (this.tokenModifiers = t)
  }
}
function yTt(i) {
  return typeof i > "u" || Kdt(i)
}
var bTt = class sut {
    constructor(t) {
      if (
        ((this.c = 0),
        (this.e = 0),
        (this.f = !0),
        (this.g = []),
        (this.j = 0),
        (this.k = new Map()),
        (this.l = new Map()),
        (this.m = !1),
        t)
      ) {
        this.m = !0
        for (let e = 0, s = t.tokenTypes.length; e < s; e++)
          this.k.set(t.tokenTypes[e], e)
        for (let e = 0, s = t.tokenModifiers.length; e < s; e++)
          this.l.set(t.tokenModifiers[e], e)
      }
    }
    push(t, e, s, r, a) {
      if (
        typeof t == "number" &&
        typeof e == "number" &&
        typeof s == "number" &&
        typeof r == "number" &&
        (typeof a == "number" || typeof a > "u")
      )
        return typeof a > "u" && (a = 0), this.q(t, e, s, r, a)
      if (Nt.isRange(t) && typeof e == "string" && yTt(s))
        return this.o(t, e, s)
      throw Lt()
    }
    o(t, e, s) {
      if (!this.m) throw new Error("Legend must be provided in constructor")
      if (t.start.line !== t.end.line)
        throw new Error("`range` cannot span multiple lines")
      if (!this.k.has(e))
        throw new Error("`tokenType` is not in the provided legend")
      const r = t.start.line,
        a = t.start.character,
        o = t.end.character - t.start.character,
        c = this.k.get(e)
      let l = 0
      if (s)
        for (const u of s) {
          if (!this.l.has(u))
            throw new Error("`tokenModifier` is not in the provided legend")
          const d = this.l.get(u)
          l |= (1 << d) >>> 0
        }
      this.q(r, a, o, c, l)
    }
    q(t, e, s, r, a) {
      if (this.f && (t < this.c || (t === this.c && e < this.e))) {
        this.f = !1
        const l = (this.g.length / 5) | 0
        let u = 0,
          d = 0
        for (let m = 0; m < l; m++) {
          let f = this.g[5 * m],
            p = this.g[5 * m + 1]
          f === 0 ? ((f = u), (p += d)) : (f += u),
            (this.g[5 * m] = f),
            (this.g[5 * m + 1] = p),
            (u = f),
            (d = p)
        }
      }
      let o = t,
        c = e
      this.f && this.j > 0 && ((o -= this.c), o === 0 && (c -= this.e)),
        (this.g[this.j++] = o),
        (this.g[this.j++] = c),
        (this.g[this.j++] = s),
        (this.g[this.j++] = r),
        (this.g[this.j++] = a),
        (this.c = t),
        (this.e = e)
    }
    static r(t) {
      const e = [],
        s = (t.length / 5) | 0
      for (let c = 0; c < s; c++) e[c] = c
      e.sort((c, l) => {
        const u = t[5 * c],
          d = t[5 * l]
        if (u === d) {
          const m = t[5 * c + 1],
            f = t[5 * l + 1]
          return m - f
        }
        return u - d
      })
      const r = new Uint32Array(t.length)
      let a = 0,
        o = 0
      for (let c = 0; c < s; c++) {
        const l = 5 * e[c],
          u = t[l + 0],
          d = t[l + 1],
          m = t[l + 2],
          f = t[l + 3],
          p = t[l + 4],
          v = u - a,
          b = v === 0 ? d - o : d,
          k = 5 * c
        ;(r[k + 0] = v),
          (r[k + 1] = b),
          (r[k + 2] = m),
          (r[k + 3] = f),
          (r[k + 4] = p),
          (a = u),
          (o = d)
      }
      return r
    }
    build(t) {
      return this.f
        ? new al(new Uint32Array(this.g), t)
        : new al(sut.r(this.g), t)
    }
  },
  al = class {
    constructor(i, t) {
      ;(this.resultId = t), (this.data = i)
    }
  },
  dtt = class {
    constructor(i, t, e) {
      ;(this.start = i), (this.deleteCount = t), (this.data = e)
    }
  },
  yO = class {
    constructor(i, t) {
      ;(this.resultId = t), (this.edits = i)
    }
  },
  bO
;(function (i) {
  ;(i[(i.Separate = 0)] = "Separate"),
    (i[(i.MergeWithParent = 1)] = "MergeWithParent")
})(bO || (bO = {}))
var TTt = class {
    constructor(i) {
      this.name = i
    }
  },
  cU
;(function (i) {
  ;(i[(i.Title = 1)] = "Title"), (i[(i.Inline = 2)] = "Inline")
})(cU || (cU = {}))
var Xh = class {
  static {
    this.Back = { iconPath: new Ji("arrow-left") }
  }
  constructor() {}
}
Xh = __decorate([ht], Xh)
var Kh
;(function (i) {
  ;(i[(i.Separator = -1)] = "Separator"), (i[(i.Default = 0)] = "Default")
})(Kh || (Kh = {}))
var ol
;(function (i) {
  ;(i[(i.Info = 1)] = "Info"),
    (i[(i.Warning = 2)] = "Warning"),
    (i[(i.Error = 3)] = "Error")
})(ol || (ol = {}))
var So
;(function (i) {
  ;(i[(i.UI = 1)] = "UI"), (i[(i.Workspace = 2)] = "Workspace")
})(So || (So = {}))
var lU = class {
    static validate(i) {
      if (typeof i.badge == "string") {
        let t = wG(i.badge, 0)
        if ((t < i.badge.length && (t += wG(i.badge, t)), i.badge.length > t))
          throw new Error(
            "The 'badge'-property must be undefined or a short character",
          )
      } else if (i.badge && !Ji.isThemeIcon(i.badge))
        throw new Error("The 'badge'-property is not a valid ThemeIcon")
      if (!i.color && !i.badge && !i.tooltip)
        throw new Error("The decoration is empty")
      return !0
    }
    constructor(i, t, e) {
      ;(this.badge = i), (this.tooltip = t), (this.color = e)
    }
  },
  TO = class {
    constructor(t) {
      this.kind = t
    }
  }
TO = __decorate([ht], TO)
var la
;(function (i) {
  ;(i[(i.Light = 1)] = "Light"),
    (i[(i.Dark = 2)] = "Dark"),
    (i[(i.HighContrast = 3)] = "HighContrast"),
    (i[(i.HighContrastLight = 4)] = "HighContrastLight")
})(la || (la = {}))
var gn = class hV {
    static isNotebookRange(t) {
      return t instanceof hV
        ? !0
        : t
          ? typeof t.start == "number" && typeof t.end == "number"
          : !1
    }
    get start() {
      return this.c
    }
    get end() {
      return this.e
    }
    get isEmpty() {
      return this.c === this.e
    }
    constructor(t, e) {
      if (t < 0) throw Lt("start must be positive")
      if (e < 0) throw Lt("end must be positive")
      t <= e ? ((this.c = t), (this.e = e)) : ((this.c = e), (this.e = t))
    }
    with(t) {
      let e = this.c,
        s = this.e
      return (
        t.start !== void 0 && (e = t.start),
        t.end !== void 0 && (s = t.end),
        e === this.c && s === this.e ? this : new hV(e, s)
      )
    }
  },
  kO = class dV {
    static validate(t) {
      if (typeof t.kind != "number")
        throw new Error("NotebookCellData MUST have 'kind' property")
      if (typeof t.value != "string")
        throw new Error("NotebookCellData MUST have 'value' property")
      if (typeof t.languageId != "string")
        throw new Error("NotebookCellData MUST have 'languageId' property")
    }
    static isNotebookCellDataArray(t) {
      return Array.isArray(t) && t.every((e) => dV.isNotebookCellData(e))
    }
    static isNotebookCellData(t) {
      return !0
    }
    constructor(t, e, s, r, a, o, c) {
      ;(this.kind = t),
        (this.value = e),
        (this.languageId = s),
        (this.mime = r),
        (this.outputs = a ?? []),
        (this.metadata = o),
        (this.executionSummary = c),
        dV.validate(this)
    }
  },
  mtt = class {
    constructor(i) {
      this.cells = i
    }
  },
  ftt = class _n {
    static isNotebookCellOutputItem(t) {
      return t instanceof _n
        ? !0
        : t
          ? typeof t.mime == "string" && t.data instanceof Uint8Array
          : !1
    }
    static error(t) {
      const e = { name: t.name, message: t.message, stack: t.stack }
      return _n.json(e, "application/vnd.code.notebook.error")
    }
    static stdout(t) {
      return _n.text(t, "application/vnd.code.notebook.stdout")
    }
    static stderr(t) {
      return _n.text(t, "application/vnd.code.notebook.stderr")
    }
    static bytes(t, e = "application/octet-stream") {
      return new _n(t, e)
    }
    static #t = new TextEncoder()
    static text(t, e = cn.text) {
      const s = _n.#t.encode(String(t))
      return new _n(s, e)
    }
    static json(t, e = "text/x-json") {
      const s = JSON.stringify(t, void 0, "	")
      return _n.text(s, e)
    }
    constructor(t, e) {
      ;(this.data = t), (this.mime = e)
      const s = RX(e, !0)
      if (!s)
        throw new Error(
          `INVALID mime type: ${e}. Must be in the format "type/subtype[;optionalparameter]"`,
        )
      this.mime = s
    }
  },
  SO = class mV {
    static isNotebookCellOutput(t) {
      return t instanceof mV
        ? !0
        : !t || typeof t != "object"
          ? !1
          : typeof t.id == "string" && Array.isArray(t.items)
    }
    static ensureUniqueMimeTypes(t, e = !1) {
      const s = new Set(),
        r = new Set()
      for (let a = 0; a < t.length; a++) {
        const o = t[a],
          c = RX(o.mime)
        if (!s.has(c) || $Z(c)) {
          s.add(c)
          continue
        }
        r.add(a),
          e && console.warn(`DUPLICATED mime type '${o.mime}' will be dropped`)
      }
      return r.size === 0 ? t : t.filter((a, o) => !r.has(o))
    }
    constructor(t, e, s) {
      ;(this.items = mV.ensureUniqueMimeTypes(t, !0)),
        typeof e == "string"
          ? ((this.id = e), (this.metadata = s))
          : ((this.id = Ze()), (this.metadata = e ?? s))
    }
  },
  kTt = class {
    constructor(i, t, e) {
      ;(this.label = i), (this.uri = t), (this.position = e)
    }
  },
  Eo
;(function (i) {
  ;(i[(i.Markup = 1)] = "Markup"), (i[(i.Code = 2)] = "Code")
})(Eo || (Eo = {}))
var cl
;(function (i) {
  ;(i[(i.Idle = 1)] = "Idle"),
    (i[(i.Pending = 2)] = "Pending"),
    (i[(i.Executing = 3)] = "Executing")
})(cl || (cl = {}))
var EO
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"), (i[(i.Right = 2)] = "Right")
})(EO || (EO = {}))
var IO
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.InCenter = 1)] = "InCenter"),
    (i[(i.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
    (i[(i.AtTop = 3)] = "AtTop")
})(IO || (IO = {}))
var STt = class {
    constructor(i, t) {
      ;(this.text = i), (this.alignment = t)
    }
  },
  uU
;(function (i) {
  ;(i[(i.Default = 1)] = "Default"), (i[(i.Preferred = 2)] = "Preferred")
})(uU || (uU = {}))
var PO
;(function (i) {
  ;(i[(i.Default = 1)] = "Default"),
    (i[(i.Preferred = 2)] = "Preferred"),
    (i[(i.Hidden = -1)] = "Hidden")
})(PO || (PO = {}))
var ptt = class {
    constructor(i, t = []) {
      ;(this.uri = i), (this.provides = Ir(t))
    }
  },
  ETt = class {
    constructor(i) {
      this.label = i
    }
  },
  Zh
;(function (i) {
  ;(i[(i.Named = 1)] = "Named"), (i[(i.Indexed = 2)] = "Indexed")
})(Zh || (Zh = {}))
var hU = class {
  constructor(t, e) {
    ;(this.label = t), (this.timestamp = e)
  }
}
hU = __decorate([ht], hU)
var ll
;(function (i) {
  ;(i[(i.Production = 1)] = "Production"),
    (i[(i.Development = 2)] = "Development"),
    (i[(i.Test = 3)] = "Test")
})(ll || (ll = {}))
var $O
;(function (i) {
  ;(i[(i.Node = 1)] = "Node"), (i[(i.Webworker = 2)] = "Webworker")
})($O || ($O = {}))
var ua
;(function (i) {
  ;(i[(i.Other = 0)] = "Other"),
    (i[(i.Comment = 1)] = "Comment"),
    (i[(i.String = 2)] = "String"),
    (i[(i.RegEx = 3)] = "RegEx")
})(ua || (ua = {}))
var ITt = class {
    constructor(i, t) {
      ;(this.ranges = i), (this.wordPattern = t)
    }
  },
  PTt = class {
    constructor(i) {
      this.c = i
    }
    get autoForwardAction() {
      return this.c
    }
  },
  dU
;(function (i) {
  ;(i[(i.Queued = 1)] = "Queued"),
    (i[(i.Running = 2)] = "Running"),
    (i[(i.Passed = 3)] = "Passed"),
    (i[(i.Failed = 4)] = "Failed"),
    (i[(i.Skipped = 5)] = "Skipped"),
    (i[(i.Errored = 6)] = "Errored")
})(dU || (dU = {}))
var ul
;(function (i) {
  ;(i[(i.Run = 1)] = "Run"),
    (i[(i.Debug = 2)] = "Debug"),
    (i[(i.Coverage = 3)] = "Coverage")
})(ul || (ul = {}))
var gtt = class {
    constructor(i, t, e) {
      ;(this.controllerId = i), (this.profileId = t), (this.kind = e)
    }
  },
  xO = class {
    constructor(t = void 0, e = void 0, s = void 0, r = !1, a = !0) {
      ;(this.include = t),
        (this.exclude = e),
        (this.profile = s),
        (this.continuous = r),
        (this.preserveFocus = a)
    }
  }
xO = __decorate([ht], xO)
var NO = (R2 = class {
  static diff(t, e, s) {
    const r = new R2(t)
    return (r.expectedOutput = e), (r.actualOutput = s), r
  }
  constructor(t) {
    this.message = t
  }
})
NO = R2 = __decorate([ht], NO)
var td = class {
  constructor(t) {
    this.id = t
  }
}
td = __decorate([ht], td)
var $Tt = class {
    constructor(i, t, e) {
      ;(this.label = i), (this.uri = t), (this.position = e)
    }
  },
  CO = class {
    constructor(i, t) {
      ;(this.covered = i), (this.total = t), JO(this)
    }
  }
function JO(i) {
  if (i) {
    if (i.covered > i.total)
      throw new Error(
        `The total number of covered items (${i.covered}) cannot be greater than the total (${i.total})`,
      )
    if (i.total < 0)
      throw new Error(
        `The number of covered items (${i.total}) cannot be negative`,
      )
  }
}
var LO = class rut {
    static fromDetails(t, e) {
      const s = new CO(0, 0),
        r = new CO(0, 0),
        a = new CO(0, 0)
      for (const c of e)
        if ("branches" in c) {
          ;(s.total += 1), (s.covered += c.executed ? 1 : 0)
          for (const l of c.branches)
            (r.total += 1), (r.covered += l.executed ? 1 : 0)
        } else (a.total += 1), (a.covered += c.executed ? 1 : 0)
      const o = new rut(
        t,
        s,
        r.total > 0 ? r : void 0,
        a.total > 0 ? a : void 0,
      )
      return (o.detailedCoverage = e), o
    }
    constructor(t, e, s, r, a = []) {
      ;(this.uri = t),
        (this.statementCoverage = e),
        (this.branchCoverage = s),
        (this.declarationCoverage = r),
        (this.includesTests = a)
    }
  },
  vtt = class {
    get executionCount() {
      return +this.executed
    }
    set executionCount(i) {
      this.executed = i
    }
    constructor(i, t, e = []) {
      ;(this.executed = i), (this.location = t), (this.branches = e)
    }
  },
  wtt = class {
    get executionCount() {
      return +this.executed
    }
    set executionCount(i) {
      this.executed = i
    }
    constructor(i, t, e) {
      ;(this.executed = i), (this.location = t), (this.label = e)
    }
  },
  ytt = class {
    get executionCount() {
      return +this.executed
    }
    set executionCount(i) {
      this.executed = i
    }
    constructor(i, t, e) {
      ;(this.name = i), (this.executed = t), (this.location = e)
    }
  },
  mU
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Option = 1)] = "Option"),
    (i[(i.Default = 2)] = "Default"),
    (i[(i.Preferred = 3)] = "Preferred")
})(mU || (mU = {}))
var fU
;(function (i) {
  ;(i[(i.Untrusted = 0)] = "Untrusted"),
    (i[(i.Trusted = 1)] = "Trusted"),
    (i[(i.Unspecified = 2)] = "Unspecified")
})(fU || (fU = {}))
var pU
;(function (i) {
  ;(i[(i.Notify = 1)] = "Notify"),
    (i[(i.OpenBrowser = 2)] = "OpenBrowser"),
    (i[(i.OpenPreview = 3)] = "OpenPreview"),
    (i[(i.Silent = 4)] = "Silent"),
    (i[(i.Ignore = 5)] = "Ignore"),
    (i[(i.OpenBrowserOnce = 6)] = "OpenBrowserOnce")
})(pU || (pU = {}))
var gU = class {
    constructor(i, t, e, s, r, a) {
      ;(this.kind = i),
        (this.name = t),
        (this.detail = e),
        (this.uri = s),
        (this.range = r),
        (this.selectionRange = a)
    }
  },
  vU = class {
    constructor(i) {
      this.uri = i
    }
  },
  RO = class {
    constructor(i, t) {
      ;(this.original = i), (this.modified = t)
    }
  },
  btt = class {
    constructor(i, t, e, s) {
      ;(this.base = i), (this.input1 = t), (this.input2 = e), (this.result = s)
    }
  },
  wU = class {
    constructor(i, t) {
      ;(this.uri = i), (this.viewType = t)
    }
  },
  Ttt = class {
    constructor(i) {
      this.viewType = i
    }
  },
  yU = class {
    constructor(i, t) {
      ;(this.uri = i), (this.notebookType = t)
    }
  },
  bU = class {
    constructor(i, t, e) {
      ;(this.original = i), (this.modified = t), (this.notebookType = e)
    }
  },
  ktt = class {
    constructor() {}
  },
  Stt = class {
    constructor(i, t) {
      ;(this.uri = i), (this.inputBoxUri = t)
    }
  },
  Ett = class {
    constructor() {}
  },
  Itt = class {
    constructor(i) {
      this.textDiffs = i
    }
  },
  TU
;(function (i) {
  ;(i[(i.Down = 0)] = "Down"), (i[(i.Up = 1)] = "Up")
})(TU || (TU = {}))
var kU
;(function (i) {
  ;(i[(i.Action = 1)] = "Action"), (i[(i.Toolbar = 2)] = "Toolbar")
})(kU || (kU = {}))
var SU
;(function (i) {
  ;(i[(i.Short = 1)] = "Short"),
    (i[(i.Medium = 2)] = "Medium"),
    (i[(i.Full = 3)] = "Full")
})(SU || (SU = {}))
var xTt = class {
    constructor(i, t, e) {
      ;(this.id = i), (this.label = t), (this.values = e)
    }
  },
  Io
;(function (i) {
  ;(i[(i.Accepted = 1)] = "Accepted"),
    (i[(i.Rejected = 2)] = "Rejected"),
    (i[(i.Saved = 3)] = "Saved")
})(Io || (Io = {}))
var EU
;(function (i) {
  ;(i[(i.Unhelpful = 0)] = "Unhelpful"),
    (i[(i.Helpful = 1)] = "Helpful"),
    (i[(i.Undone = 2)] = "Undone"),
    (i[(i.Accepted = 3)] = "Accepted"),
    (i[(i.Bug = 4)] = "Bug")
})(EU || (EU = {}))
var ed
;(function (i) {
  ;(i[(i.Unhelpful = 0)] = "Unhelpful"), (i[(i.Helpful = 1)] = "Helpful")
})(ed || (ed = {}))
var DO = class {
    constructor(i) {
      if (typeof i != "string" && i.isTrusted === !0)
        throw new Error(
          "The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.",
        )
      this.value = typeof i == "string" ? new ls(i) : i
    }
  },
  id = class {
    constructor(i, t) {
      if (typeof i != "string" && i.isTrusted === !0)
        throw new Error(
          "The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.",
        )
      ;(this.value = typeof i == "string" ? new ls(i) : i),
        (this.vulnerabilities = t)
    }
  },
  sd = class {
    constructor(i, t) {
      ;(this.participant = i), (this.command = t)
    }
  },
  FO = class {
    constructor(i, t, e, s) {
      ;(this.title = i), (this.message = t), (this.data = e), (this.buttons = s)
    }
  },
  AO = class {
    constructor(i, t) {
      ;(this.value = i), (this.baseUri = t)
    }
  },
  rd = class {
    constructor(i, t) {
      ;(this.value = i), (this.value2 = i), (this.title = t)
    }
  },
  nd = class {
    constructor(i) {
      this.value = i
    }
  },
  _O = class {
    constructor(i, t) {
      ;(this.value = i), (this.task = t)
    }
  },
  ad = class {
    constructor(i) {
      if (typeof i != "string" && i.isTrusted === !0)
        throw new Error(
          "The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.",
        )
      this.value = typeof i == "string" ? new ls(i) : i
    }
  },
  OO = class {
    constructor(i) {
      this.value = i
    }
  },
  vn = class {
    constructor(i, t, e) {
      ;(this.value = i), (this.iconPath = t), (this.options = e)
    }
  },
  BO = class {
    constructor(i) {
      this.value = i
    }
  },
  qO = class {
    constructor(i, t, e) {
      ;(this.value = i), (this.license = t), (this.snippet = e)
    }
  },
  UO = class {
    constructor(i, t) {
      ;(this.uri = i), (this.range = t)
    }
  },
  od = class {
    constructor(i, t) {
      ;(this.uri = i),
        t === !0
          ? ((this.isDone = !0), (this.edits = []))
          : (this.edits = Array.isArray(t) ? t : [t])
    }
  },
  Ptt = class {
    constructor(i, t, e, s, r) {
      ;(this.prompt = i),
        (this.command = t),
        (this.references = e),
        (this.participant = s),
        (this.toolReferences = r)
    }
  },
  $tt = class {
    constructor(i, t, e, s) {
      ;(this.response = i),
        (this.result = t),
        (this.participant = e),
        (this.command = s)
    }
  },
  bs
;(function (i) {
  ;(i[(i.Panel = 1)] = "Panel"),
    (i[(i.Terminal = 2)] = "Terminal"),
    (i[(i.Notebook = 3)] = "Notebook"),
    (i[(i.Editor = 4)] = "Editor"),
    (i[(i.EditingSession = 5)] = "EditingSession")
})(bs || (bs = {}))
var IU
;(function (i) {
  ;(i[(i.Complete = 1)] = "Complete"),
    (i[(i.Partial = 2)] = "Partial"),
    (i[(i.Omitted = 3)] = "Omitted")
})(IU || (IU = {}))
var xtt = class {
    constructor(i, t, e) {
      ;(this.document = i), (this.selection = t), (this.wholeRange = e)
    }
  },
  Ntt = class {
    constructor(i) {
      this.cell = i
    }
  },
  Ctt = class {
    constructor(i, t) {
      ;(this.mimeType = i), (this.data = t)
    }
  },
  Js
;(function (i) {
  ;(i[(i.User = 1)] = "User"),
    (i[(i.Assistant = 2)] = "Assistant"),
    (i[(i.System = 3)] = "System")
})(Js || (Js = {}))
var PU = class {
    constructor(i, t, e) {
      ;(this.callId = i), (this.content = t), (this.isError = e ?? !1)
    }
  },
  Jtt = class fV {
    static User(t, e) {
      return new fV(Js.User, t, e)
    }
    static Assistant(t, e) {
      return new fV(Js.Assistant, t, e)
    }
    set content(t) {
      typeof t == "string" ? (this.c = [new Yi(t)]) : (this.c = t)
    }
    get content() {
      return this.c
    }
    set content2(t) {
      t && (this.content = t.map((e) => (typeof e == "string" ? new Yi(e) : e)))
    }
    get content2() {
      return this.content.map((t) => (t instanceof Yi ? t.value : t))
    }
    constructor(t, e, s) {
      ;(this.c = []), (this.role = t), (this.content = e), (this.name = s)
    }
  },
  cd = class {
    constructor(i, t, e) {
      ;(this.callId = i), (this.name = t), (this.input = e)
    }
  },
  Yi = class {
    constructor(i) {
      this.value = i
    }
    toJSON() {
      return { $mid: 21, value: this.value }
    }
  },
  hl = class {
    constructor(i) {
      this.value = i
    }
    toJSON() {
      return { $mid: 22, value: this.value }
    }
  },
  wn = class Xo extends Error {
    static NotFound(t) {
      return new Xo(t, Xo.NotFound.name)
    }
    static NoPermissions(t) {
      return new Xo(t, Xo.NoPermissions.name)
    }
    static Blocked(t) {
      return new Xo(t, Xo.Blocked.name)
    }
    constructor(t, e, s) {
      super(t, { cause: s }),
        (this.name = "LanguageModelError"),
        (this.code = e ?? "")
    }
  },
  $U = class {
    constructor(i) {
      this.content = i
    }
    toJSON() {
      return { $mid: 20, content: this.content }
    }
  },
  xU
;(function (i) {
  ;(i[(i.Auto = 1)] = "Auto"), (i[(i.Required = 2)] = "Required")
})(xU || (xU = {}))
var NU
;(function (i) {
  ;(i[(i.SymbolInformation = 1)] = "SymbolInformation"),
    (i[(i.CommandInformation = 2)] = "CommandInformation"),
    (i[(i.SearchInformation = 3)] = "SearchInformation"),
    (i[(i.SettingInformation = 4)] = "SettingInformation")
})(NU || (NU = {}))
var CU
;(function (i) {
  ;(i[(i.Started = 1)] = "Started"),
    (i[(i.Recognizing = 2)] = "Recognizing"),
    (i[(i.Recognized = 3)] = "Recognized"),
    (i[(i.Stopped = 4)] = "Stopped"),
    (i[(i.Error = 5)] = "Error")
})(CU || (CU = {}))
var JU
;(function (i) {
  ;(i[(i.Started = 1)] = "Started"),
    (i[(i.Stopped = 2)] = "Stopped"),
    (i[(i.Error = 3)] = "Error")
})(JU || (JU = {}))
var LU
;(function (i) {
  ;(i[(i.Recognized = 1)] = "Recognized"), (i[(i.Stopped = 2)] = "Stopped")
})(LU || (LU = {}))
var NTt = class {
    constructor(i, t) {
      ;(this.text = i), (this.range = t)
    }
  },
  ld
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})(ld || (ld = {}))
var or
;(function (i) {
  function t(s) {
    const {
        selectionStartLineNumber: r,
        selectionStartColumn: a,
        positionLineNumber: o,
        positionColumn: c,
      } = s,
      l = new Ft(r - 1, a - 1),
      u = new Ft(o - 1, c - 1)
    return new fn(l, u)
  }
  i.to = t
  function e(s) {
    const { anchor: r, active: a } = s
    return {
      selectionStartLineNumber: r.line + 1,
      selectionStartColumn: r.character + 1,
      positionLineNumber: a.line + 1,
      positionColumn: a.character + 1,
    }
  }
  i.from = e
})(or || (or = {}))
var U
;(function (i) {
  function t(s) {
    if (!s) return
    const { start: r, end: a } = s
    return {
      startLineNumber: r.line + 1,
      startColumn: r.character + 1,
      endLineNumber: a.line + 1,
      endColumn: a.character + 1,
    }
  }
  i.from = t
  function e(s) {
    if (!s) return
    const {
      startLineNumber: r,
      startColumn: a,
      endLineNumber: o,
      endColumn: c,
    } = s
    return new Nt(r - 1, a - 1, o - 1, c - 1)
  }
  i.to = e
})(U || (U = {}))
var ha
;(function (i) {
  function t(s) {
    return { uri: s.uri, range: U.from(s.range) }
  }
  i.from = t
  function e(s) {
    return new ys(S.revive(s.uri), U.to(s.range))
  }
  i.to = e
})(ha || (ha = {}))
var RU
;(function (i) {
  function t(e) {
    switch (e) {
      case 1:
        return ua.Comment
      case 0:
        return ua.Other
      case 3:
        return ua.RegEx
      case 2:
        return ua.String
    }
  }
  i.to = t
})(RU || (RU = {}))
var Kt
;(function (i) {
  function t(s) {
    return new Ft(s.lineNumber - 1, s.column - 1)
  }
  i.to = t
  function e(s) {
    return { lineNumber: s.line + 1, column: s.character + 1 }
  }
  i.from = e
})(Kt || (Kt = {}))
var dl
;(function (i) {
  function t(r, a, o) {
    return Ue(Ir(r).map((c) => e(c, a, o)))
  }
  i.from = t
  function e(r, a, o) {
    if (typeof r == "string")
      return { $serialized: !0, language: r, isBuiltin: o?.isBuiltin }
    if (r)
      return {
        $serialized: !0,
        language: r.language,
        scheme: s(r.scheme, a),
        pattern: us.from(r.pattern) ?? void 0,
        exclusive: r.exclusive,
        notebookType: r.notebookType,
        isBuiltin: o?.isBuiltin,
      }
  }
  function s(r, a) {
    return a && typeof r == "string" ? a.transformOutgoingScheme(r) : r
  }
})(dl || (dl = {}))
var MO
;(function (i) {
  function t(s) {
    switch (s) {
      case po.Unnecessary:
        return 1
      case po.Deprecated:
        return 2
    }
  }
  i.from = t
  function e(s) {
    switch (s) {
      case 1:
        return po.Unnecessary
      case 2:
        return po.Deprecated
      default:
        return
    }
  }
  i.to = e
})(MO || (MO = {}))
var ml
;(function (i) {
  function t(s) {
    let r
    return (
      s.code &&
        (_t(s.code) || ps(s.code)
          ? (r = String(s.code))
          : (r = { value: String(s.code.value), target: s.code.target })),
      {
        ...U.from(s.range),
        message: s.message,
        source: s.source,
        code: r,
        severity: WO.from(s.severity),
        relatedInformation:
          s.relatedInformation && s.relatedInformation.map(HO.from),
        tags: Array.isArray(s.tags) ? Ue(s.tags.map(MO.from)) : void 0,
      }
    )
  }
  i.from = t
  function e(s) {
    const r = new Y6(U.to(s), s.message, WO.to(s.severity))
    return (
      (r.source = s.source),
      (r.code = _t(s.code) ? s.code : s.code?.value),
      (r.relatedInformation =
        s.relatedInformation && s.relatedInformation.map(HO.to)),
      (r.tags = s.tags && Ue(s.tags.map(MO.to))),
      r
    )
  }
  i.to = e
})(ml || (ml = {}))
var HO
;(function (i) {
  function t(s) {
    return {
      ...U.from(s.location.range),
      message: s.message,
      resource: s.location.uri,
    }
  }
  i.from = t
  function e(s) {
    return new Ch(new ys(s.resource, U.to(s)), s.message)
  }
  i.to = e
})(HO || (HO = {}))
var WO
;(function (i) {
  function t(s) {
    switch (s) {
      case Ii.Error:
        return ji.Error
      case Ii.Warning:
        return ji.Warning
      case Ii.Information:
        return ji.Info
      case Ii.Hint:
        return ji.Hint
    }
    return ji.Error
  }
  i.from = t
  function e(s) {
    switch (s) {
      case ji.Info:
        return Ii.Information
      case ji.Warning:
        return Ii.Warning
      case ji.Error:
        return Ii.Error
      case ji.Hint:
        return Ii.Hint
      default:
        return Ii.Error
    }
  }
  i.to = e
})(WO || (WO = {}))
var ii
;(function (i) {
  function t(s) {
    return typeof s == "number" && s >= Oh.One
      ? s - 1
      : s === Oh.Beside
        ? zbt
        : Gbt
  }
  i.from = t
  function e(s) {
    if (typeof s == "number" && s >= 0) return s + 1
    throw new Error("invalid 'EditorGroupColumn'")
  }
  i.to = e
})(ii || (ii = {}))
function CTt(i) {
  return typeof i.range < "u"
}
function Ltt(i) {
  return i.length === 0 ? !0 : !!CTt(i[0])
}
var Dt
;(function (i) {
  function t(c) {
    return c.map(i.from)
  }
  i.fromMany = t
  function e(c) {
    return (
      c &&
      typeof c == "object" &&
      typeof c.language == "string" &&
      typeof c.value == "string"
    )
  }
  function s(c) {
    let l
    if (e(c)) {
      const { language: m, value: f } = c
      l = {
        value:
          "```" +
          m +
          `
` +
          f +
          "\n```\n",
      }
    } else
      ls.isMarkdownString(c)
        ? (l = {
            value: c.value,
            isTrusted: c.isTrusted,
            supportThemeIcons: c.supportThemeIcons,
            supportHtml: c.supportHtml,
            baseUri: c.baseUri,
          })
        : typeof c == "string"
          ? (l = { value: c })
          : (l = { value: "" })
    const u = Object.create(null)
    l.uris = u
    const d = ({ href: m }) => {
      try {
        let f = S.parse(m, !0)
        ;(f = f.with({ query: r(f.query, u) })), (u[m] = f)
      } catch {}
      return ""
    }
    return (
      ve.walkTokens(ve.lexer(l.value), (m) => {
        m.type === "link"
          ? d({ href: m.href })
          : m.type === "image" && typeof m.href == "string" && d(vyt(m.href))
      }),
      l
    )
  }
  i.from = s
  function r(c, l) {
    if (!c) return c
    let u
    try {
      u = EY(c)
    } catch {}
    if (!u) return c
    let d = !1
    return (
      (u = Sc(u, (m) => {
        if (S.isUri(m)) {
          const f = `__uri_${Math.random().toString(16).slice(2, 8)}`
          return (l[f] = m), (d = !0), f
        } else return
      })),
      d ? JSON.stringify(u) : c
    )
  }
  function a(c) {
    const l = new ls(c.value, c.supportThemeIcons)
    return (
      (l.isTrusted = c.isTrusted),
      (l.supportHtml = c.supportHtml),
      (l.baseUri = c.baseUri ? S.from(c.baseUri) : void 0),
      l
    )
  }
  i.to = a
  function o(c) {
    if (c) return typeof c == "string" ? c : i.from(c)
  }
  i.fromStrict = o
})(Dt || (Dt = {}))
function JTt(i) {
  return Ltt(i)
    ? i.map((t) => ({
        range: U.from(t.range),
        hoverMessage: Array.isArray(t.hoverMessage)
          ? Dt.fromMany(t.hoverMessage)
          : t.hoverMessage
            ? Dt.from(t.hoverMessage)
            : void 0,
        renderOptions: t.renderOptions,
      }))
    : i.map((t) => ({ range: U.from(t) }))
}
function jO(i) {
  return typeof i > "u" ? i : typeof i == "string" ? S.file(i) : i
}
var fl
;(function (i) {
  function t(e) {
    return typeof e > "u"
      ? e
      : {
          contentText: e.contentText,
          contentIconPath: e.contentIconPath ? jO(e.contentIconPath) : void 0,
          border: e.border,
          borderColor: e.borderColor,
          fontStyle: e.fontStyle,
          fontWeight: e.fontWeight,
          textDecoration: e.textDecoration,
          color: e.color,
          backgroundColor: e.backgroundColor,
          margin: e.margin,
          width: e.width,
          height: e.height,
        }
  }
  i.from = t
})(fl || (fl = {}))
var VO
;(function (i) {
  function t(e) {
    return typeof e > "u"
      ? e
      : {
          backgroundColor: e.backgroundColor,
          outline: e.outline,
          outlineColor: e.outlineColor,
          outlineStyle: e.outlineStyle,
          outlineWidth: e.outlineWidth,
          border: e.border,
          borderColor: e.borderColor,
          borderRadius: e.borderRadius,
          borderSpacing: e.borderSpacing,
          borderStyle: e.borderStyle,
          borderWidth: e.borderWidth,
          fontStyle: e.fontStyle,
          fontWeight: e.fontWeight,
          textDecoration: e.textDecoration,
          cursor: e.cursor,
          color: e.color,
          opacity: e.opacity,
          letterSpacing: e.letterSpacing,
          gutterIconPath: e.gutterIconPath ? jO(e.gutterIconPath) : void 0,
          gutterIconSize: e.gutterIconSize,
          overviewRulerColor: e.overviewRulerColor,
          before: e.before ? fl.from(e.before) : void 0,
          after: e.after ? fl.from(e.after) : void 0,
        }
  }
  i.from = t
})(VO || (VO = {}))
var DU
;(function (i) {
  function t(e) {
    if (typeof e > "u") return e
    switch (e) {
      case vo.OpenOpen:
        return 0
      case vo.ClosedClosed:
        return 1
      case vo.OpenClosed:
        return 2
      case vo.ClosedOpen:
        return 3
    }
  }
  i.from = t
})(DU || (DU = {}))
var FU
;(function (i) {
  function t(e) {
    return {
      isWholeLine: e.isWholeLine,
      rangeBehavior: e.rangeBehavior ? DU.from(e.rangeBehavior) : void 0,
      overviewRulerLane: e.overviewRulerLane,
      light: e.light ? VO.from(e.light) : void 0,
      dark: e.dark ? VO.from(e.dark) : void 0,
      backgroundColor: e.backgroundColor,
      outline: e.outline,
      outlineColor: e.outlineColor,
      outlineStyle: e.outlineStyle,
      outlineWidth: e.outlineWidth,
      border: e.border,
      borderColor: e.borderColor,
      borderRadius: e.borderRadius,
      borderSpacing: e.borderSpacing,
      borderStyle: e.borderStyle,
      borderWidth: e.borderWidth,
      fontStyle: e.fontStyle,
      fontWeight: e.fontWeight,
      textDecoration: e.textDecoration,
      cursor: e.cursor,
      color: e.color,
      opacity: e.opacity,
      letterSpacing: e.letterSpacing,
      gutterIconPath: e.gutterIconPath ? jO(e.gutterIconPath) : void 0,
      gutterIconSize: e.gutterIconSize,
      overviewRulerColor: e.overviewRulerColor,
      before: e.before ? fl.from(e.before) : void 0,
      after: e.after ? fl.from(e.after) : void 0,
    }
  }
  i.from = t
})(FU || (FU = {}))
var si
;(function (i) {
  function t(s) {
    return {
      text: s.newText,
      eol: s.newEol && wl.from(s.newEol),
      range: U.from(s.range),
    }
  }
  i.from = t
  function e(s) {
    const r = new aa(U.to(s.range), s.text)
    return (r.newEol = typeof s.eol > "u" ? void 0 : wl.to(s.eol)), r
  }
  i.to = e
})(si || (si = {}))
var Oi
;(function (i) {
  function t(s, r) {
    const a = { edits: [] }
    if (s instanceof mo) {
      const o = new _V()
      for (const c of s._allEntries())
        c._type === 1 && S.isUri(c.to) && c.from === void 0 && o.add(c.to)
      for (const c of s._allEntries())
        if (c._type === 1) {
          let l
          c.options?.contents &&
            (ArrayBuffer.isView(c.options.contents)
              ? (l = { type: "base64", value: Yu(Q.wrap(c.options.contents)) })
              : (l = {
                  type: "dataTransferItem",
                  id: c.options.contents._itemId,
                })),
            a.edits.push({
              oldResource: c.from,
              newResource: c.to,
              options: { ...c.options, contents: l },
              metadata: c.metadata,
            })
        } else
          c._type === 2
            ? a.edits.push({
                resource: c.uri,
                textEdit: si.from(c.edit),
                versionId: o.has(c.uri)
                  ? void 0
                  : r?.getTextDocumentVersion(c.uri),
                metadata: c.metadata,
              })
            : c._type === 6
              ? a.edits.push({
                  resource: c.uri,
                  textEdit: {
                    range: U.from(c.range),
                    text: c.edit.value,
                    insertAsSnippet: !0,
                  },
                  versionId: o.has(c.uri)
                    ? void 0
                    : r?.getTextDocumentVersion(c.uri),
                  metadata: c.metadata,
                })
              : c._type === 3
                ? a.edits.push({
                    metadata: c.metadata,
                    resource: c.uri,
                    cellEdit: c.edit,
                    notebookVersionId: r?.getNotebookDocumentVersion(c.uri),
                  })
                : c._type === 5 &&
                  a.edits.push({
                    metadata: c.metadata,
                    resource: c.uri,
                    notebookVersionId: r?.getNotebookDocumentVersion(c.uri),
                    cellEdit: {
                      editType: 1,
                      index: c.index,
                      count: c.count,
                      cells: c.cells.map(pd.from),
                    },
                  })
    }
    return a
  }
  i.from = t
  function e(s) {
    const r = new mo(),
      a = new oi()
    for (const o of s.edits)
      if (o.textEdit) {
        const c = o,
          l = S.revive(c.resource),
          u = U.to(c.textEdit.range),
          d = c.textEdit.text,
          m = c.textEdit.insertAsSnippet
        let f
        m ? (f = F2.replace(u, new fo(d))) : (f = aa.replace(u, d))
        const p = a.get(l)
        p ? p.push(f) : a.set(l, [f])
      } else
        r.renameFile(
          S.revive(o.oldResource),
          S.revive(o.newResource),
          o.options,
        )
    for (const [o, c] of a) r.set(o, c)
    return r
  }
  i.to = e
})(Oi || (Oi = {}))
var Ls
;(function (i) {
  const t = Object.create(null)
  ;(t[de.File] = 0),
    (t[de.Module] = 1),
    (t[de.Namespace] = 2),
    (t[de.Package] = 3),
    (t[de.Class] = 4),
    (t[de.Method] = 5),
    (t[de.Property] = 6),
    (t[de.Field] = 7),
    (t[de.Constructor] = 8),
    (t[de.Enum] = 9),
    (t[de.Interface] = 10),
    (t[de.Function] = 11),
    (t[de.Variable] = 12),
    (t[de.Constant] = 13),
    (t[de.String] = 14),
    (t[de.Number] = 15),
    (t[de.Boolean] = 16),
    (t[de.Array] = 17),
    (t[de.Object] = 18),
    (t[de.Key] = 19),
    (t[de.Null] = 20),
    (t[de.EnumMember] = 21),
    (t[de.Struct] = 22),
    (t[de.Event] = 23),
    (t[de.Operator] = 24),
    (t[de.TypeParameter] = 25)
  function e(r) {
    return typeof t[r] == "number" ? t[r] : 6
  }
  i.from = e
  function s(r) {
    for (const a in t) if (t[a] === r) return Number(a)
    return de.Property
  }
  i.to = s
})(Ls || (Ls = {}))
var yn
;(function (i) {
  function t(s) {
    switch (s) {
      case Lh.Deprecated:
        return 1
    }
  }
  i.from = t
  function e(s) {
    switch (s) {
      case 1:
        return Lh.Deprecated
    }
  }
  i.to = e
})(yn || (yn = {}))
var Po
;(function (i) {
  function t(s) {
    return {
      name: s.name,
      kind: Ls.from(s.kind),
      tags: s.tags && s.tags.map(yn.from),
      containerName: s.containerName,
      location: Qi.from(s.location),
    }
  }
  i.from = t
  function e(s) {
    const r = new Rh(s.name, Ls.to(s.kind), s.containerName, Qi.to(s.location))
    return (r.tags = s.tags && s.tags.map(yn.to)), r
  }
  i.to = e
})(Po || (Po = {}))
var AU
;(function (i) {
  function t(s) {
    const r = {
      name: s.name || "!!MISSING: name!!",
      detail: s.detail,
      range: U.from(s.range),
      selectionRange: U.from(s.selectionRange),
      kind: Ls.from(s.kind),
      tags: s.tags?.map(yn.from) ?? [],
    }
    return s.children && (r.children = s.children.map(t)), r
  }
  i.from = t
  function e(s) {
    const r = new Dh(
      s.name,
      s.detail,
      Ls.to(s.kind),
      U.to(s.range),
      U.to(s.selectionRange),
    )
    return (
      Cu(s.tags) && (r.tags = s.tags.map(yn.to)),
      s.children && (r.children = s.children.map(e)),
      r
    )
  }
  i.to = e
})(AU || (AU = {}))
var $o
;(function (i) {
  function t(s) {
    const r = new _2(
      Ls.to(s.kind),
      s.name,
      s.detail || "",
      S.revive(s.uri),
      U.to(s.range),
      U.to(s.selectionRange),
    )
    return (r._sessionId = s._sessionId), (r._itemId = s._itemId), r
  }
  i.to = t
  function e(s, r, a) {
    if (
      ((r = r ?? s._sessionId),
      (a = a ?? s._itemId),
      r === void 0 || a === void 0)
    )
      throw new Error("invalid item")
    return {
      _sessionId: r,
      _itemId: a,
      name: s.name,
      detail: s.detail,
      kind: Ls.from(s.kind),
      uri: s.uri,
      range: U.from(s.range),
      selectionRange: U.from(s.selectionRange),
      tags: s.tags?.map(yn.from),
    }
  }
  i.from = e
})($o || ($o = {}))
var _U
;(function (i) {
  function t(e) {
    return new ntt(
      $o.to(e.from),
      e.fromRanges.map((s) => U.to(s)),
    )
  }
  i.to = t
})(_U || (_U = {}))
var OU
;(function (i) {
  function t(e) {
    return new att(
      $o.to(e.to),
      e.fromRanges.map((s) => U.to(s)),
    )
  }
  i.to = t
})(OU || (OU = {}))
var Qi
;(function (i) {
  function t(s) {
    return { range: s.range && U.from(s.range), uri: s.uri }
  }
  i.from = t
  function e(s) {
    return new ys(S.revive(s.uri), U.to(s.range))
  }
  i.to = e
})(Qi || (Qi = {}))
var ud
;(function (i) {
  function t(s) {
    const r = s,
      a = s
    return {
      originSelectionRange: r.originSelectionRange
        ? U.from(r.originSelectionRange)
        : void 0,
      uri: r.targetUri ? r.targetUri : a.uri,
      range: U.from(r.targetRange ? r.targetRange : a.range),
      targetSelectionRange: r.targetSelectionRange
        ? U.from(r.targetSelectionRange)
        : void 0,
    }
  }
  i.from = t
  function e(s) {
    return {
      targetUri: S.revive(s.uri),
      targetRange: U.to(s.range),
      targetSelectionRange: s.targetSelectionRange
        ? U.to(s.targetSelectionRange)
        : void 0,
      originSelectionRange: s.originSelectionRange
        ? U.to(s.originSelectionRange)
        : void 0,
    }
  }
  i.to = e
})(ud || (ud = {}))
var hd
;(function (i) {
  function t(s) {
    return {
      range: U.from(s.range),
      contents: Dt.fromMany(s.contents),
      canIncreaseVerbosity: s.canIncreaseVerbosity,
      canDecreaseVerbosity: s.canDecreaseVerbosity,
    }
  }
  i.from = t
  function e(s) {
    const r = s.contents.map(Dt.to),
      a = U.to(s.range),
      o = s.canIncreaseVerbosity,
      c = s.canDecreaseVerbosity
    return new X6(r, a, o, c)
  }
  i.to = e
})(hd || (hd = {}))
var BU
;(function (i) {
  function t(s) {
    return { range: U.from(s.range), expression: s.expression }
  }
  i.from = t
  function e(s) {
    return new pO(U.to(s.range), s.expression)
  }
  i.to = e
})(BU || (BU = {}))
var GO
;(function (i) {
  function t(s) {
    if (s instanceof gO)
      return { type: "text", range: U.from(s.range), text: s.text }
    if (s instanceof vO)
      return {
        type: "variable",
        range: U.from(s.range),
        variableName: s.variableName,
        caseSensitiveLookup: s.caseSensitiveLookup,
      }
    if (s instanceof wO)
      return {
        type: "expression",
        range: U.from(s.range),
        expression: s.expression,
      }
    throw new Error("Unknown 'InlineValue' type")
  }
  i.from = t
  function e(s) {
    switch (s.type) {
      case "text":
        return { range: U.to(s.range), text: s.text }
      case "variable":
        return {
          range: U.to(s.range),
          variableName: s.variableName,
          caseSensitiveLookup: s.caseSensitiveLookup,
        }
      case "expression":
        return { range: U.to(s.range), expression: s.expression }
    }
  }
  i.to = e
})(GO || (GO = {}))
var zO
;(function (i) {
  function t(s) {
    return { frameId: s.frameId, stoppedLocation: U.from(s.stoppedLocation) }
  }
  i.from = t
  function e(s) {
    return new iU(s.frameId, U.to(s.stoppedLocation))
  }
  i.to = e
})(zO || (zO = {}))
var pl
;(function (i) {
  function t(s) {
    return { range: U.from(s.range), kind: s.kind }
  }
  i.from = t
  function e(s) {
    return new K6(U.to(s.range), s.kind)
  }
  i.to = e
})(pl || (pl = {}))
var qU
;(function (i) {
  function t(s) {
    return { uri: s.uri, highlights: s.highlights.map(pl.from) }
  }
  i.from = t
  function e(s) {
    return new Z6(S.revive(s.uri), s.highlights.map(pl.to))
  }
  i.to = e
})(qU || (qU = {}))
var UU
;(function (i) {
  function t(e) {
    switch (e) {
      case 1:
        return jc.TriggerCharacter
      case 2:
        return jc.TriggerForIncompleteCompletions
      case 0:
      default:
        return jc.Invoke
    }
  }
  i.to = t
})(UU || (UU = {}))
var MU
;(function (i) {
  function t(e) {
    return {
      triggerKind: UU.to(e.triggerKind),
      triggerCharacter: e.triggerCharacter,
    }
  }
  i.to = t
})(MU || (MU = {}))
var YO
;(function (i) {
  function t(s) {
    switch (s) {
      case _h.Deprecated:
        return 1
    }
  }
  i.from = t
  function e(s) {
    switch (s) {
      case 1:
        return _h.Deprecated
    }
  }
  i.to = e
})(YO || (YO = {}))
var QO
;(function (i) {
  const t = new Map([
    [wt.Method, 0],
    [wt.Function, 1],
    [wt.Constructor, 2],
    [wt.Field, 3],
    [wt.Variable, 4],
    [wt.Class, 5],
    [wt.Interface, 7],
    [wt.Struct, 6],
    [wt.Module, 8],
    [wt.Property, 9],
    [wt.Unit, 12],
    [wt.Value, 13],
    [wt.Constant, 14],
    [wt.Enum, 15],
    [wt.EnumMember, 16],
    [wt.Keyword, 17],
    [wt.Snippet, 27],
    [wt.Text, 18],
    [wt.Color, 19],
    [wt.File, 20],
    [wt.Reference, 21],
    [wt.Folder, 23],
    [wt.Event, 10],
    [wt.Operator, 11],
    [wt.TypeParameter, 24],
    [wt.Issue, 26],
    [wt.User, 25],
  ])
  function e(a) {
    return t.get(a) ?? 9
  }
  i.from = e
  const s = new Map([
    [0, wt.Method],
    [1, wt.Function],
    [2, wt.Constructor],
    [3, wt.Field],
    [4, wt.Variable],
    [5, wt.Class],
    [7, wt.Interface],
    [6, wt.Struct],
    [8, wt.Module],
    [9, wt.Property],
    [12, wt.Unit],
    [13, wt.Value],
    [14, wt.Constant],
    [15, wt.Enum],
    [16, wt.EnumMember],
    [17, wt.Keyword],
    [27, wt.Snippet],
    [18, wt.Text],
    [19, wt.Color],
    [20, wt.File],
    [21, wt.Reference],
    [23, wt.Folder],
    [10, wt.Event],
    [11, wt.Operator],
    [24, wt.TypeParameter],
    [25, wt.User],
    [26, wt.Issue],
  ])
  function r(a) {
    return s.get(a) ?? wt.Property
  }
  i.to = r
})(QO || (QO = {}))
var HU
;(function (i) {
  function t(e, s) {
    const r = new rO(e.label)
    return (
      (r.insertText = e.insertText),
      (r.kind = QO.to(e.kind)),
      (r.tags = e.tags?.map(YO.to)),
      (r.detail = e.detail),
      (r.documentation = to(e.documentation)
        ? Dt.to(e.documentation)
        : e.documentation),
      (r.sortText = e.sortText),
      (r.filterText = e.filterText),
      (r.preselect = e.preselect),
      (r.commitCharacters = e.commitCharacters),
      ue.isIRange(e.range)
        ? (r.range = U.to(e.range))
        : typeof e.range == "object" &&
          (r.range = {
            inserting: U.to(e.range.insert),
            replacing: U.to(e.range.replace),
          }),
      (r.keepWhitespace =
        typeof e.insertTextRules > "u" ? !1 : !!(e.insertTextRules & 1)),
      typeof e.insertTextRules < "u" && e.insertTextRules & 4
        ? (r.insertText = new fo(e.insertText))
        : ((r.insertText = e.insertText),
          (r.textEdit =
            r.range instanceof Nt ? new aa(r.range, r.insertText) : void 0)),
      e.additionalTextEdits &&
        e.additionalTextEdits.length > 0 &&
        (r.additionalTextEdits = e.additionalTextEdits.map((a) => si.to(a))),
      (r.command = s && e.command ? s.fromInternal(e.command) : void 0),
      r
    )
  }
  i.to = t
})(HU || (HU = {}))
var XO
;(function (i) {
  function t(s) {
    if (typeof s.label != "string" && !Array.isArray(s.label))
      throw new TypeError("Invalid label")
    return { label: s.label, documentation: Dt.fromStrict(s.documentation) }
  }
  i.from = t
  function e(s) {
    return {
      label: s.label,
      documentation: to(s.documentation)
        ? Dt.to(s.documentation)
        : s.documentation,
    }
  }
  i.to = e
})(XO || (XO = {}))
var KO
;(function (i) {
  function t(s) {
    return {
      label: s.label,
      documentation: Dt.fromStrict(s.documentation),
      parameters: Array.isArray(s.parameters) ? s.parameters.map(XO.from) : [],
      activeParameter: s.activeParameter,
    }
  }
  i.from = t
  function e(s) {
    return {
      label: s.label,
      documentation: to(s.documentation)
        ? Dt.to(s.documentation)
        : s.documentation,
      parameters: Array.isArray(s.parameters) ? s.parameters.map(XO.to) : [],
      activeParameter: s.activeParameter,
    }
  }
  i.to = e
})(KO || (KO = {}))
var dd
;(function (i) {
  function t(s) {
    return {
      activeSignature: s.activeSignature,
      activeParameter: s.activeParameter,
      signatures: Array.isArray(s.signatures) ? s.signatures.map(KO.from) : [],
    }
  }
  i.from = t
  function e(s) {
    return {
      activeSignature: s.activeSignature,
      activeParameter: s.activeParameter,
      signatures: Array.isArray(s.signatures) ? s.signatures.map(KO.to) : [],
    }
  }
  i.to = e
})(dd || (dd = {}))
var WU
;(function (i) {
  function t(e, s) {
    const r = new sO(
      Kt.to(s.position),
      typeof s.label == "string" ? s.label : s.label.map(jU.to.bind(void 0, e)),
      s.kind && ZO.to(s.kind),
    )
    return (
      (r.textEdits = s.textEdits && s.textEdits.map(si.to)),
      (r.tooltip = to(s.tooltip) ? Dt.to(s.tooltip) : s.tooltip),
      (r.paddingLeft = s.paddingLeft),
      (r.paddingRight = s.paddingRight),
      r
    )
  }
  i.to = t
})(WU || (WU = {}))
var jU
;(function (i) {
  function t(e, s) {
    const r = new iO(s.label)
    return (
      (r.tooltip = to(s.tooltip) ? Dt.to(s.tooltip) : s.tooltip),
      r2.is(s.command) && (r.command = e.fromInternal(s.command)),
      s.location && (r.location = Qi.to(s.location)),
      r
    )
  }
  i.to = t
})(jU || (jU = {}))
var ZO
;(function (i) {
  function t(s) {
    return s
  }
  i.from = t
  function e(s) {
    return s
  }
  i.to = e
})(ZO || (ZO = {}))
var xo
;(function (i) {
  function t(s) {
    return { range: U.from(s.range), url: s.target, tooltip: s.tooltip }
  }
  i.from = t
  function e(s) {
    let r
    if (s.url)
      try {
        r = typeof s.url == "string" ? S.parse(s.url, !0) : S.revive(s.url)
      } catch {}
    const a = new aO(U.to(s.range), r)
    return (a.tooltip = s.tooltip), a
  }
  i.to = e
})(xo || (xo = {}))
var t8
;(function (i) {
  function t(s) {
    const r = new cO(s.label)
    return (
      s.textEdit && (r.textEdit = si.to(s.textEdit)),
      s.additionalTextEdits &&
        (r.additionalTextEdits = s.additionalTextEdits.map((a) => si.to(a))),
      r
    )
  }
  i.to = t
  function e(s) {
    return {
      label: s.label,
      textEdit: s.textEdit ? si.from(s.textEdit) : void 0,
      additionalTextEdits: s.additionalTextEdits
        ? s.additionalTextEdits.map((r) => si.from(r))
        : void 0,
    }
  }
  i.from = e
})(t8 || (t8 = {}))
var gl
;(function (i) {
  function t(s) {
    return new Xc(s[0], s[1], s[2], s[3])
  }
  i.to = t
  function e(s) {
    return [s.red, s.green, s.blue, s.alpha]
  }
  i.from = e
})(gl || (gl = {}))
var VU
;(function (i) {
  function t(s) {
    return { range: U.from(s.range) }
  }
  i.from = t
  function e(s) {
    return new Ah(U.to(s.range))
  }
  i.to = e
})(VU || (VU = {}))
var e8
;(function (i) {
  function t(e) {
    switch (e) {
      case 2:
        return Gc.AfterDelay
      case 1:
        return Gc.Manual
      case 3:
      case 4:
        return Gc.FocusOut
    }
  }
  i.to = t
})(e8 || (e8 = {}))
var vl
;(function (i) {
  function t(s) {
    switch (s) {
      case ar.Off:
        return 0
      case ar.Relative:
        return 2
      case ar.Interval:
        return 3
      case ar.On:
      default:
        return 1
    }
  }
  i.from = t
  function e(s) {
    switch (s) {
      case 0:
        return ar.Off
      case 2:
        return ar.Relative
      case 3:
        return ar.Interval
      case 1:
      default:
        return ar.On
    }
  }
  i.to = e
})(vl || (vl = {}))
var wl
;(function (i) {
  function t(s) {
    if (s === nr.CRLF) return 1
    if (s === nr.LF) return 0
  }
  i.from = t
  function e(s) {
    if (s === 1) return nr.CRLF
    if (s === 0) return nr.LF
  }
  i.to = e
})(wl || (wl = {}))
var GU
;(function (i) {
  function t(e) {
    if (typeof e == "object") return e.viewId
    switch (e) {
      case yo.SourceControl:
        return 3
      case yo.Window:
        return 10
      case yo.Notification:
        return 15
    }
    throw new Error("Unknown 'ProgressLocation'")
  }
  i.from = t
})(GU || (GU = {}))
var i8
;(function (i) {
  function t(s) {
    const r = { start: s.start + 1, end: s.end + 1 }
    return s.kind && (r.kind = s8.from(s.kind)), r
  }
  i.from = t
  function e(s) {
    const r = { start: s.start - 1, end: s.end - 1 }
    return s.kind && (r.kind = s8.to(s.kind)), r
  }
  i.to = e
})(i8 || (i8 = {}))
var s8
;(function (i) {
  function t(s) {
    if (s)
      switch (s) {
        case pn.Comment:
          return Jc.Comment
        case pn.Imports:
          return Jc.Imports
        case pn.Region:
          return Jc.Region
      }
  }
  i.from = t
  function e(s) {
    if (s)
      switch (s.value) {
        case Jc.Comment.value:
          return pn.Comment
        case Jc.Imports.value:
          return pn.Imports
        case Jc.Region.value:
          return pn.Region
      }
  }
  i.to = e
})(s8 || (s8 = {}))
var md
;(function (i) {
  function t(e) {
    if (e)
      return {
        pinned: typeof e.preview == "boolean" ? !e.preview : void 0,
        inactive: e.background,
        preserveFocus: e.preserveFocus,
        selection:
          typeof e.selection == "object" ? U.from(e.selection) : void 0,
        override: typeof e.override == "boolean" ? u0t.id : void 0,
      }
  }
  i.from = t
})(md || (md = {}))
var us
;(function (i) {
  function t(a) {
    return a instanceof el
      ? a.toJSON()
      : typeof a == "string"
        ? a
        : e(a) || s(a)
          ? new el(a.baseUri ?? a.base, a.pattern).toJSON()
          : a
  }
  i.from = t
  function e(a) {
    const o = a
    return o ? S.isUri(o.baseUri) && typeof o.pattern == "string" : !1
  }
  function s(a) {
    const o = a
    return o ? typeof o.base == "string" && typeof o.pattern == "string" : !1
  }
  function r(a) {
    return typeof a == "string" ? a : new el(S.revive(a.baseUri), a.pattern)
  }
  i.to = r
})(us || (us = {}))
var zU
;(function (i) {
  function t(e) {
    if (e) {
      if (Array.isArray(e)) return e.map(t)
      if (typeof e == "string") return e
      {
        const s = e
        return {
          language: s.language,
          scheme: s.scheme,
          pattern: us.from(s.pattern) ?? void 0,
          exclusive: s.exclusive,
          notebookType: s.notebookType,
        }
      }
    } else return
  }
  i.from = t
})(zU || (zU = {}))
var r8
;(function (i) {
  function t(s) {
    return (
      !!s &&
      typeof s == "object" &&
      "documents" in s &&
      Array.isArray(s.documents) &&
      s.documents.every((r) => Array.isArray(r) && r.every(yl.is))
    )
  }
  i.is = t
  function e(s) {
    return {
      documents: s.documents.map((r) => r.map(yl.from)),
      conversation: s.conversation?.map((r) =>
        r.type === "request"
          ? { type: "request", message: r.message }
          : {
              type: "response",
              message: r.message,
              result: r.result ? ga.from(r.result) : void 0,
              references: r.references?.map(yl.from),
            },
      ),
    }
  }
  i.from = e
})(r8 || (r8 = {}))
var yl
;(function (i) {
  function t(r) {
    return (
      typeof r == "object" &&
      r !== null &&
      "uri" in r &&
      S.isUri(r.uri) &&
      "version" in r &&
      typeof r.version == "number" &&
      "ranges" in r &&
      Array.isArray(r.ranges) &&
      r.ranges.every((a) => a instanceof Nt)
    )
  }
  i.is = t
  function e(r) {
    return {
      uri: r.uri,
      version: r.version,
      ranges: r.ranges.map((a) => U.from(a)),
    }
  }
  i.from = e
  function s(r) {
    return {
      uri: S.revive(r.uri),
      version: r.version,
      ranges: r.ranges.map((a) => U.to(a)),
    }
  }
  i.to = s
})(yl || (yl = {}))
var Or
;(function (i) {
  function t(s) {
    return { start: s.start, end: s.end }
  }
  i.from = t
  function e(s) {
    return new gn(s.start, s.end)
  }
  i.to = e
})(Or || (Or = {}))
var bl
;(function (i) {
  function t(s) {
    return {
      timing:
        typeof s.runStartTime == "number" && typeof s.runEndTime == "number"
          ? { startTime: s.runStartTime, endTime: s.runEndTime }
          : void 0,
      executionOrder: s.executionOrder,
      success: s.lastRunSuccess,
    }
  }
  i.to = t
  function e(s) {
    return {
      lastRunSuccess: s.success,
      runStartTime: s.timing?.startTime,
      runEndTime: s.timing?.endTime,
      executionOrder: s.executionOrder,
    }
  }
  i.from = e
})(bl || (bl = {}))
var YU
;(function (i) {
  function t(e) {
    if (e === Ih.Unconfirmed) return cl.Pending
    if (e === Ih.Pending) return
    if (e === Ih.Executing) return cl.Executing
    throw new Error(`Unknown state: ${e}`)
  }
  i.to = t
})(YU || (YU = {}))
var fd
;(function (i) {
  function t(s) {
    switch (s) {
      case Eo.Markup:
        return qc.Markup
      case Eo.Code:
      default:
        return qc.Code
    }
  }
  i.from = t
  function e(s) {
    switch (s) {
      case qc.Markup:
        return Eo.Markup
      case qc.Code:
      default:
        return Eo.Code
    }
  }
  i.to = e
})(fd || (fd = {}))
var da
;(function (i) {
  function t(s) {
    const r = { metadata: s.metadata ?? Object.create(null), cells: [] }
    for (const a of s.cells) kO.validate(a), r.cells.push(pd.from(a))
    return r
  }
  i.from = t
  function e(s) {
    const r = new mtt(s.cells.map(pd.to))
    return xG(s.metadata) || (r.metadata = s.metadata), r
  }
  i.to = e
})(da || (da = {}))
var pd
;(function (i) {
  function t(s) {
    return {
      cellKind: fd.from(s.kind),
      language: s.languageId,
      mime: s.mime,
      source: s.value,
      metadata: s.metadata,
      internalMetadata: bl.from(s.executionSummary ?? {}),
      outputs: s.outputs ? s.outputs.map(ma.from) : [],
    }
  }
  i.from = t
  function e(s) {
    return new kO(
      fd.to(s.cellKind),
      s.source,
      s.language,
      s.mime,
      s.outputs ? s.outputs.map(ma.to) : void 0,
      s.metadata,
      s.internalMetadata ? bl.to(s.internalMetadata) : void 0,
    )
  }
  i.to = e
})(pd || (pd = {}))
var Tl
;(function (i) {
  function t(s) {
    return { mime: s.mime, valueBytes: Q.wrap(s.data) }
  }
  i.from = t
  function e(s) {
    return new ftt(s.valueBytes.buffer, s.mime)
  }
  i.to = e
})(Tl || (Tl = {}))
var ma
;(function (i) {
  function t(s) {
    return { outputId: s.id, items: s.items.map(Tl.from), metadata: s.metadata }
  }
  i.from = t
  function e(s) {
    const r = s.items.map(Tl.to)
    return new SO(r, s.outputId, s.metadata)
  }
  i.to = e
})(ma || (ma = {}))
var n8
;(function (i) {
  function t(r) {
    return s(r)
      ? {
          include: us.from(r.include) ?? void 0,
          exclude: us.from(r.exclude) ?? void 0,
        }
      : (us.from(r) ?? void 0)
  }
  i.from = t
  function e(r) {
    return s(r)
      ? { include: us.to(r.include), exclude: us.to(r.exclude) }
      : us.to(r)
  }
  i.to = e
  function s(r) {
    const a = r
    return a ? !Fe(a.include) && !Fe(a.exclude) : !1
  }
})(n8 || (n8 = {}))
var QU
;(function (i) {
  function t(e, s, r) {
    const a =
      typeof e.command == "string"
        ? { title: "", command: e.command }
        : e.command
    return {
      alignment: e.alignment === EO.Left ? 1 : 2,
      command: s.toInternal(a, r),
      text: e.text,
      tooltip: e.tooltip,
      accessibilityInformation: e.accessibilityInformation,
      priority: e.priority,
    }
  }
  i.from = t
})(QU || (QU = {}))
var XU
;(function (i) {
  function t(e, s, r) {
    const a =
      typeof e.command == "string"
        ? { title: "", command: e.command }
        : e.command
    return {
      command: s.toInternal(a, r),
      label: e.label,
      description: e.description,
      detail: e.detail,
      documentation: e.documentation,
    }
  }
  i.from = t
})(XU || (XU = {}))
var KU
;(function (i) {
  function t(e) {
    return {
      transientOutputs: e?.transientOutputs ?? !1,
      transientCellMetadata: e?.transientCellMetadata ?? {},
      transientDocumentMetadata: e?.transientDocumentMetadata ?? {},
      cellContentMetadata: e?.cellContentMetadata ?? {},
    }
  }
  i.from = t
})(KU || (KU = {}))
var a8
;(function (i) {
  function t(s) {
    return { uri: s.uri, provides: s.provides }
  }
  i.from = t
  function e(s) {
    return new ptt(S.revive(s.uri), s.provides)
  }
  i.to = e
})(a8 || (a8 = {}))
var kl
;(function (i) {
  function t(s) {
    return {
      message: Dt.fromStrict(s.message) || "",
      type: 0,
      expected: s.expectedOutput,
      actual: s.actualOutput,
      contextValue: s.contextValue,
      location: s.location && {
        range: U.from(s.location.range),
        uri: s.location.uri,
      },
      stackTrace: s.stackTrace?.map((r) => ({
        label: r.label,
        position: r.position && Kt.from(r.position),
        uri: r.uri && S.revive(r.uri).toJSON(),
      })),
    }
  }
  i.from = t
  function e(s) {
    const r = new NO(
      typeof s.message == "string" ? s.message : Dt.to(s.message),
    )
    return (
      (r.actualOutput = s.actual),
      (r.expectedOutput = s.expected),
      (r.contextValue = s.contextValue),
      (r.location = s.location ? Qi.to(s.location) : void 0),
      r
    )
  }
  i.to = e
})(kl || (kl = {}))
var cr
;(function (i) {
  ;(i.namespace = O6), (i.denamespace = AZ)
})(cr || (cr = {}))
var ZU
;(function (i) {
  function t(e) {
    return {
      controllerId: e.controllerId,
      profileId: e.profileId,
      group: Sl.from(e.kind),
    }
  }
  i.from = t
})(ZU || (ZU = {}))
var Sl
;(function (i) {
  const t = { [ul.Coverage]: 8, [ul.Debug]: 4, [ul.Run]: 2 }
  function e(s) {
    return t.hasOwnProperty(s) ? t[s] : 2
  }
  i.from = e
})(Sl || (Sl = {}))
var fa
;(function (i) {
  function t(s) {
    const r = j6(s).controllerId
    return {
      extId: jt.fromExtHostTestItem(s, r).toString(),
      label: s.label,
      uri: S.revive(s.uri),
      busy: s.busy,
      tags: s.tags.map((a) => cr.namespace(r, a.id)),
      range: ue.lift(U.from(s.range)),
      description: s.description || null,
      sortText: s.sortText || null,
      error: (s.error && Dt.fromStrict(s.error)) || null,
    }
  }
  i.from = t
  function e(s) {
    return {
      parent: void 0,
      error: void 0,
      id: jt.fromString(s.extId).localId,
      label: s.label,
      uri: S.revive(s.uri),
      tags: (s.tags || []).map((r) => {
        const { tagId: a } = cr.denamespace(r)
        return new td(a)
      }),
      children: {
        add: () => {},
        delete: () => {},
        forEach: () => {},
        *[Symbol.iterator]() {},
        get: () => {},
        replace: () => {},
        size: 0,
      },
      range: U.to(s.range || void 0),
      canResolveChildren: !1,
      busy: s.busy,
      description: s.description || void 0,
      sortText: s.sortText || void 0,
    }
  }
  i.toPlain = e
})(fa || (fa = {})),
  (function (i) {
    function t(s) {
      return { id: s.id }
    }
    i.from = t
    function e(s) {
      return new td(s.id)
    }
    i.to = e
  })(cr || (cr = {}))
var tM
;(function (i) {
  const t = (s, r) => {
    const a = s.value
    if (!a) return
    const o = {
      ...fa.toPlain(a.item),
      parent: r,
      taskStates: a.tasks.map((c) => ({
        state: c.state,
        duration: c.duration,
        messages: c.messages.filter((l) => l.type === 0).map(kl.to),
      })),
      children: [],
    }
    if (s.children)
      for (const c of s.children.values()) {
        const l = t(c, o)
        l && o.children.push(l)
      }
    return o
  }
  function e(s) {
    const r = new Kyt()
    for (const c of s.items) r.insert(jt.fromString(c.item.extId).path, c)
    const a = [r.nodes],
      o = []
    for (; a.length; )
      for (const c of a.pop())
        c.value ? o.push(c) : c.children && a.push(c.children.values())
    return {
      completedAt: s.completedAt,
      results: o.map((c) => t(c)).filter(Wa),
    }
  }
  i.to = e
})(tM || (tM = {}))
var gd
;(function (i) {
  function t(c) {
    return { covered: c.covered, total: c.total }
  }
  function e(c) {
    return "line" in c ? Kt.from(c) : U.from(c)
  }
  function s(c) {
    if (c) return "endLineNumber" in c ? U.to(c) : Kt.to(c)
  }
  function r(c) {
    if (c.type === 1) {
      const l = []
      if (c.branches)
        for (const u of c.branches)
          l.push({ executed: u.count, location: s(u.location), label: u.label })
      return new vtt(
        c.count,
        s(c.location),
        c.branches?.map((u) => new wtt(u.count, s(u.location), u.label)),
      )
    } else return new ytt(c.name, c.count, s(c.location))
  }
  i.to = r
  function a(c) {
    if (typeof c.executed == "number" && c.executed < 0)
      throw new Error(`Invalid coverage count ${c.executed}`)
    return "branches" in c
      ? {
          count: c.executed,
          location: e(c.location),
          type: 1,
          branches: c.branches.length
            ? c.branches.map((l) => ({
                count: l.executed,
                location: l.location && e(l.location),
                label: l.label,
              }))
            : void 0,
        }
      : { type: 0, name: c.name, count: c.executed, location: e(c.location) }
  }
  i.fromDetails = a
  function o(c, l, u) {
    return (
      JO(u.statementCoverage),
      JO(u.branchCoverage),
      JO(u.declarationCoverage),
      {
        id: l,
        uri: u.uri,
        statement: t(u.statementCoverage),
        branch: u.branchCoverage && t(u.branchCoverage),
        declaration: u.declarationCoverage && t(u.declarationCoverage),
        testIds:
          u instanceof LO && u.includesTests.length
            ? u.includesTests.map((d) =>
                jt.fromExtHostTestItem(d, c).toString(),
              )
            : void 0,
      }
    )
  }
  i.fromFile = o
})(gd || (gd = {}))
var eM
;(function (i) {
  function t(e) {
    switch (e) {
      case 1:
        return Fh.Invoke
      case 2:
        return Fh.Automatic
    }
  }
  i.to = t
})(eM || (eM = {}))
var No
;(function (i) {
  function t(s) {
    const r = new gU(
      Ls.to(s.kind),
      s.name,
      s.detail || "",
      S.revive(s.uri),
      U.to(s.range),
      U.to(s.selectionRange),
    )
    return (r._sessionId = s._sessionId), (r._itemId = s._itemId), r
  }
  i.to = t
  function e(s, r, a) {
    if (
      ((r = r ?? s._sessionId),
      (a = a ?? s._itemId),
      r === void 0 || a === void 0)
    )
      throw new Error("invalid item")
    return {
      _sessionId: r,
      _itemId: a,
      kind: Ls.from(s.kind),
      name: s.name,
      detail: s.detail ?? "",
      uri: s.uri,
      range: U.from(s.range),
      selectionRange: U.from(s.selectionRange),
      tags: s.tags?.map(yn.from),
    }
  }
  i.from = e
})(No || (No = {}))
var o8
;(function (i) {
  function t(e) {
    if (e) return { value: e.value, tooltip: e.tooltip }
  }
  i.from = t
})(o8 || (o8 = {}))
var c8
;(function (i) {
  function t(a, o, c) {
    const l = o.fileData
    return l
      ? new fTt(
          new pTt(
            l.name,
            S.revive(l.uri),
            l.id,
            d_(() => c(l.id)),
          ),
        )
      : a === cn.uriList && o.uriListData
        ? new mO(r(o.uriListData))
        : new mO(o.asString)
  }
  i.to = t
  async function e(a, o) {
    const c = await o.asString()
    if (a === cn.uriList)
      return { asString: c, fileData: void 0, uriListData: s(c) }
    const l = o.asFile()
    return {
      asString: c,
      fileData: l
        ? { name: l.name, uri: l.uri, id: l._itemId ?? l.id }
        : void 0,
    }
  }
  i.from = e
  function s(a) {
    return qq.split(a).map((o) => {
      if (o.startsWith("#")) return o
      try {
        return S.parse(o)
      } catch {}
      return o
    })
  }
  function r(a) {
    return qq.create(a.map((o) => (typeof o == "string" ? o : S.revive(o))))
  }
})(c8 || (c8 = {}))
var pa
;(function (i) {
  function t(s, r) {
    const a = s.items.map(([o, c]) => [o, c8.to(o, c, r)])
    return new Uh(a)
  }
  i.toDataTransfer = t
  async function e(s) {
    const r = { items: [] },
      a = []
    for (const [o, c] of s)
      a.push(
        (async () => {
          r.items.push([o, await c8.from(o, c)])
        })(),
      )
    return await Promise.all(a), r
  }
  i.from = e
})(pa || (pa = {}))
var vd
;(function (i) {
  function t(s, r) {
    return {
      kind: "reply",
      agentId: s.participant ?? r?.agentId ?? "",
      subCommand: s.command ?? r?.command,
      message: s.prompt,
      title: s.label,
    }
  }
  i.from = t
  function e(s) {
    return {
      prompt: s.message,
      label: s.title,
      participant: s.agentId,
      command: s.subCommand,
    }
  }
  i.to = e
})(vd || (vd = {}))
var l8
;(function (i) {
  function t(s) {
    switch (s) {
      case 0:
        return Js.System
      case 1:
        return Js.User
      case 2:
        return Js.Assistant
    }
  }
  i.to = t
  function e(s) {
    switch (s) {
      case Js.System:
        return 0
      case Js.User:
        return 1
      case Js.Assistant:
        return 2
    }
    return 1
  }
  i.from = e
})(l8 || (l8 = {}))
var El
;(function (i) {
  function t(s) {
    const r = s.content.map((c) => {
        if (c.type === "text") return new Yi(c.value)
        if (c.type === "tool_result") {
          const l = c.value.map((u) =>
            u.type === "text" ? new Yi(u.value) : new hl(u.value),
          )
          return new PU(c.toolCallId, l, c.isError)
        } else return new cd(c.toolCallId, c.name, c.parameters)
      }),
      a = l8.to(s.role)
    return new Jtt(a, r, s.name)
  }
  i.to = t
  function e(s) {
    const r = l8.from(s.role),
      a = s.name
    let o = s.content
    typeof o == "string" && (o = [new Yi(o)])
    const c = o.map((l) => {
      if (l instanceof PU)
        return {
          type: "tool_result",
          toolCallId: l.callId,
          value: Ue(
            l.content.map((u) =>
              u instanceof Yi
                ? { type: "text", value: u.value }
                : u instanceof hl
                  ? { type: "prompt_tsx", value: u.value }
                  : void 0,
            ),
          ),
          isError: l.isError,
        }
      if (l instanceof cd)
        return {
          type: "tool_use",
          toolCallId: l.callId,
          name: l.name,
          parameters: l.input,
        }
      if (l instanceof Yi) return { type: "text", value: l.value }
      if (typeof l != "string")
        throw new Error("Unexpected chat message content type")
      return { type: "text", value: l }
    })
    return { role: r, name: a, content: c }
  }
  i.from = e
})(El || (El = {}))
var wd
;(function (i) {
  function t(s) {
    return { kind: "markdownContent", content: Dt.from(s.value) }
  }
  i.from = t
  function e(s) {
    return new DO(Dt.to(s.content))
  }
  i.to = e
})(wd || (wd = {}))
var u8
;(function (i) {
  function t(s) {
    return { kind: "codeblockUri", uri: s.value }
  }
  i.from = t
  function e(s) {
    return new BO(S.revive(s.uri))
  }
  i.to = e
})(u8 || (u8 = {}))
var h8
;(function (i) {
  function t(s) {
    return {
      kind: "markdownVuln",
      content: Dt.from(s.value),
      vulnerabilities: s.vulnerabilities,
    }
  }
  i.from = t
  function e(s) {
    return new id(Dt.to(s.content), s.vulnerabilities)
  }
  i.to = e
})(h8 || (h8 = {}))
var d8
;(function (i) {
  function t(s) {
    return {
      kind: "agentDetection",
      agentId: s.participant,
      command: s.command,
    }
  }
  i.from = t
  function e(s) {
    return new sd(s.agentId, s.command)
  }
  i.to = e
})(d8 || (d8 = {}))
var m8
;(function (i) {
  function t(e) {
    return {
      kind: "confirmation",
      title: e.title,
      message: e.message,
      data: e.data,
      buttons: e.buttons,
    }
  }
  i.from = t
})(m8 || (m8 = {}))
var yd
;(function (i) {
  function t(s) {
    const { value: r, baseUri: a } = s
    function o(c, l) {
      return c.map((u) => {
        const d = S.joinPath(l, u.name)
        return {
          label: u.name,
          uri: d,
          children: u.children && o(u.children, d),
        }
      })
    }
    return {
      kind: "treeData",
      treeData: { label: xr(a), uri: a, children: o(r, a) },
    }
  }
  i.from = t
  function e(s) {
    const r = ki(s.treeData)
    function a(l) {
      return l.map((u) => ({
        name: u.label,
        children: u.children && a(u.children),
      }))
    }
    const o = r.uri,
      c = r.children ? a(r.children) : []
    return new AO(c, o)
  }
  i.to = e
})(yd || (yd = {}))
var Il
;(function (i) {
  function t(s) {
    const r = (o) => S.isUri(o),
      a = (o) => "name" in o
    return {
      kind: "inlineReference",
      name: s.title,
      inlineReference: r(s.value)
        ? s.value
        : a(s.value)
          ? Po.from(s.value)
          : ha.from(s.value),
    }
  }
  i.from = t
  function e(s) {
    const r = ki(s)
    return new rd(
      S.isUri(r.inlineReference)
        ? r.inlineReference
        : "location" in r.inlineReference
          ? Po.to(r.inlineReference)
          : ha.to(r.inlineReference),
      s.name,
    )
  }
  i.to = e
})(Il || (Il = {}))
var Co
;(function (i) {
  function t(s) {
    return { kind: "progressMessage", content: Dt.from(s.value) }
  }
  i.from = t
  function e(s) {
    return new nd(s.content.value)
  }
  i.to = e
})(Co || (Co = {}))
var bd
;(function (i) {
  function t(s) {
    return { kind: "warning", content: Dt.from(s.value) }
  }
  i.from = t
  function e(s) {
    return new ad(s.content.value)
  }
  i.to = e
})(bd || (bd = {}))
var iM
;(function (i) {
  function t(s) {
    return { kind: "move", uri: s.uri, range: U.from(s.range) }
  }
  i.from = t
  function e(s) {
    return new UO(S.revive(s.uri), U.to(s.range))
  }
  i.to = e
})(iM || (iM = {}))
var f8
;(function (i) {
  function t(e) {
    return { kind: "progressTask", content: Dt.from(e.value) }
  }
  i.from = t
})(f8 || (f8 = {}))
var sM
;(function (i) {
  function t(e) {
    return {
      kind: "progressTaskResult",
      content: typeof e == "string" ? Dt.from(e) : void 0,
    }
  }
  i.from = t
})(sM || (sM = {}))
var Td
;(function (i) {
  function t(s, r, a) {
    return {
      kind: "command",
      command: r.toInternal(s.value, a) ?? {
        command: s.value.command,
        title: s.value.title,
      },
    }
  }
  i.from = t
  function e(s, r) {
    return new OO(
      r.fromInternal(s.command) ?? {
        command: s.command.id,
        title: s.command.title,
      },
    )
  }
  i.to = e
})(Td || (Td = {}))
var p8
;(function (i) {
  function t(s) {
    return {
      kind: "textEdit",
      uri: s.uri,
      edits: s.edits.map((r) => si.from(r)),
      done: s.isDone,
    }
  }
  i.from = t
  function e(s) {
    const r = new od(
      S.revive(s.uri),
      s.edits.map((a) => si.to(a)),
    )
    return (r.isDone = s.done), r
  }
  i.to = e
})(p8 || (p8 = {}))
var bn
;(function (i) {
  function t(s) {
    const r = gi.isThemeIcon(s.iconPath)
      ? s.iconPath
      : S.isUri(s.iconPath)
        ? { light: S.revive(s.iconPath) }
        : s.iconPath &&
            "light" in s.iconPath &&
            "dark" in s.iconPath &&
            S.isUri(s.iconPath.light) &&
            S.isUri(s.iconPath.dark)
          ? {
              light: S.revive(s.iconPath.light),
              dark: S.revive(s.iconPath.dark),
            }
          : void 0
    return typeof s.value == "object" && "variableName" in s.value
      ? {
          kind: "reference",
          reference: {
            variableName: s.value.variableName,
            value:
              S.isUri(s.value.value) || !s.value.value
                ? s.value.value
                : ha.from(s.value.value),
          },
          iconPath: r,
          options: s.options,
        }
      : {
          kind: "reference",
          reference:
            S.isUri(s.value) || typeof s.value == "string"
              ? s.value
              : ha.from(s.value),
          iconPath: r,
          options: s.options,
        }
  }
  i.from = t
  function e(s) {
    const r = ki(s),
      a = (o) => (S.isUri(o) ? o : ha.to(o))
    return new vn(
      typeof r.reference == "string"
        ? r.reference
        : "variableName" in r.reference
          ? {
              variableName: r.reference.variableName,
              value: r.reference.value && a(r.reference.value),
            }
          : a(r.reference),
    )
  }
  i.to = e
})(bn || (bn = {}))
var g8
;(function (i) {
  function t(e) {
    return {
      kind: "codeCitation",
      value: e.value,
      license: e.license,
      snippet: e.snippet,
    }
  }
  i.from = t
})(g8 || (g8 = {}))
var v8
;(function (i) {
  function t(r, a, o) {
    return r instanceof DO
      ? wd.from(r)
      : r instanceof rd
        ? Il.from(r)
        : r instanceof vn
          ? bn.from(r)
          : r instanceof nd
            ? Co.from(r)
            : r instanceof AO
              ? yd.from(r)
              : r instanceof OO
                ? Td.from(r, a, o)
                : r instanceof od
                  ? p8.from(r)
                  : r instanceof id
                    ? h8.from(r)
                    : r instanceof BO
                      ? u8.from(r)
                      : r instanceof sd
                        ? d8.from(r)
                        : r instanceof ad
                          ? bd.from(r)
                          : r instanceof FO
                            ? m8.from(r)
                            : r instanceof qO
                              ? g8.from(r)
                              : r instanceof UO
                                ? iM.from(r)
                                : {
                                    kind: "markdownContent",
                                    content: Dt.from(""),
                                  }
  }
  i.from = t
  function e(r, a) {
    switch (r.kind) {
      case "reference":
        return bn.to(r)
      case "markdownContent":
      case "inlineReference":
      case "progressMessage":
      case "treeData":
      case "command":
        return s(r, a)
    }
  }
  i.to = e
  function s(r, a) {
    switch (r.kind) {
      case "markdownContent":
        return wd.to(r)
      case "inlineReference":
        return Il.to(r)
      case "progressMessage":
        return
      case "treeData":
        return yd.to(r)
      case "command":
        return Td.to(r, a)
    }
  }
  i.toContent = s
})(v8 || (v8 = {}))
var w8
;(function (i) {
  function t(e, s, r) {
    const a = e.variables.variables.filter((c) => c.isTool),
      o = e.variables.variables.filter((c) => !c.isTool)
    return {
      prompt: e.message,
      command: e.command,
      attempt: e.attempt ?? 0,
      enableCommandDetection: e.enableCommandDetection ?? !0,
      isParticipantDetected: e.isParticipantDetected ?? !1,
      references: o.map(y8.to),
      toolReferences: a.map(b8.to),
      location: kd.to(e.location),
      acceptedConfirmationData: e.acceptedConfirmationData,
      rejectedConfirmationData: e.rejectedConfirmationData,
      location2: s,
      toolInvocationToken: Object.freeze({ sessionId: e.sessionId }),
      model: r,
    }
  }
  i.to = t
})(w8 || (w8 = {}))
var rM
;(function (i) {
  function t(e) {
    return { prompt: e.prompt, files: e.files.map((s) => S.revive(s)) }
  }
  i.to = t
})(rM || (rM = {}))
var kd
;(function (i) {
  function t(s) {
    switch (s) {
      case Ei.Notebook:
        return bs.Notebook
      case Ei.Terminal:
        return bs.Terminal
      case Ei.Panel:
        return bs.Panel
      case Ei.Editor:
        return bs.Editor
      case Ei.EditingSession:
        return bs.EditingSession
    }
  }
  i.to = t
  function e(s) {
    switch (s) {
      case bs.Notebook:
        return Ei.Notebook
      case bs.Terminal:
        return Ei.Terminal
      case bs.Panel:
        return Ei.Panel
      case bs.Editor:
        return Ei.Editor
      case bs.EditingSession:
        return Ei.EditingSession
    }
  }
  i.from = e
})(kd || (kd = {}))
var y8
;(function (i) {
  function t(e) {
    const s = e.value
    if (!s) throw new Error("Invalid value reference")
    return {
      id: e.id,
      name: e.name,
      range: e.range && [e.range.start, e.range.endExclusive],
      value: RG(s)
        ? S.revive(s)
        : s && typeof s == "object" && "uri" in s && "range" in s && RG(s.uri)
          ? ha.to(ki(s))
          : e.isImage
            ? new Ctt(e.mimeType ?? "image/png", () =>
                Promise.resolve(new Uint8Array(Object.values(s))),
              )
            : s,
      modelDescription: e.modelDescription,
    }
  }
  i.to = t
})(y8 || (y8 = {}))
var b8
;(function (i) {
  function t(e) {
    if (e.value) throw new Error("Invalid tool reference")
    return {
      name: e.id,
      range: e.range && [e.range.start, e.range.endExclusive],
    }
  }
  i.to = t
})(b8 || (b8 = {}))
var nM
;(function (i) {
  function t(e, s, r) {
    return {
      id: e.id,
      label: e.label,
      fullName: e.fullName,
      icon: e.icon?.id,
      value: e.values[0].value,
      insertText: e.insertText,
      detail: e.detail,
      documentation: e.documentation,
      command: s.toInternal(e.command, r),
    }
  }
  i.from = t
})(nM || (nM = {}))
var ga
;(function (i) {
  function t(r) {
    return {
      errorDetails: r.errorDetails,
      metadata: s(r.metadata),
      nextQuestion: r.nextQuestion,
    }
  }
  i.to = t
  function e(r) {
    return {
      errorDetails: r.errorDetails,
      metadata: r.metadata,
      nextQuestion: r.nextQuestion,
    }
  }
  i.from = e
  function s(r) {
    return Sc(r, (a) => {
      if (a.$mid === 20) return new $U(Sc(a.content, s))
      if (a.$mid === 21) return new Yi(a.value)
      if (a.$mid === 22) return new hl(a.value)
    })
  }
})(ga || (ga = {}))
var aM
;(function (i) {
  function t(e, s, r) {
    if (s.action.kind === "vote") return
    const a = ga.to(e)
    if (s.action.kind === "command") {
      const o = s.action.commandButton.command
      return {
        action: {
          kind: "command",
          commandButton: {
            command: r.fromInternal(o) ?? { command: o.id, title: o.title },
          },
        },
        result: a,
      }
    } else
      return s.action.kind === "followUp"
        ? {
            action: { kind: "followUp", followup: vd.to(s.action.followup) },
            result: a,
          }
        : s.action.kind === "inlineChat"
          ? {
              action: {
                kind: "editor",
                accepted: s.action.action === "accepted",
              },
              result: a,
            }
          : s.action.kind === "chatEditingSessionAction"
            ? {
                action: {
                  kind: "chatEditingSessionAction",
                  outcome:
                    new Map([
                      ["accepted", Io.Accepted],
                      ["rejected", Io.Rejected],
                      ["saved", Io.Saved],
                    ]).get(s.action.outcome) ?? Io.Rejected,
                  uri: S.revive(s.action.uri),
                  hasRemainingEdits: s.action.hasRemainingEdits,
                },
                result: a,
              }
            : { action: s.action, result: a }
  }
  i.to = t
})(aM || (aM = {}))
var T8
;(function (i) {
  function t(e, s, r) {
    return "terminalCommand" in e
      ? { terminalCommand: e.terminalCommand, shouldExecute: e.shouldExecute }
      : "uri" in e
        ? { uri: e.uri }
        : s.toInternal(e, r)
  }
  i.from = t
})(T8 || (T8 = {}))
var oM
;(function (i) {
  function t(e) {
    return { kind: cM.to(e.kind) }
  }
  i.to = t
})(oM || (oM = {}))
var cM
;(function (i) {
  function t(e) {
    switch (e) {
      case 0:
        return go.Word
      case 1:
        return go.Line
      case 2:
        return go.Suggest
      default:
        return go.Unknown
    }
  }
  i.to = t
})(cM || (cM = {}))
var lM
;(function (i) {
  function t(e, s) {
    return {
      id: s,
      label: e.label,
      description: e.description,
      canEdit: e.canEdit,
      collapsibleState: e.collapsibleState || 0,
      contextValue: e.contextValue,
    }
  }
  i.from = t
})(lM || (lM = {}))
var uM
;(function (i) {
  function t(e) {
    return {
      name: e.id,
      description: e.modelDescription,
      inputSchema: e.inputSchema,
      tags: e.tags ?? [],
    }
  }
  i.to = t
})(uM || (uM = {}))
var hM
;(function (i) {
  function t(s) {
    return new $U(
      s.content.map((r) =>
        r.kind === "text" ? new Yi(r.value) : new hl(r.value),
      ),
    )
  }
  i.to = t
  function e(s) {
    return {
      content: s.content.map((r) => {
        if (r instanceof Yi) return { kind: "text", value: r.value }
        if (r instanceof hl) return { kind: "promptTsx", value: r.value }
        throw new Error("Unknown LanguageModelToolResult part type")
      }),
    }
  }
  i.from = e
})(hM || (hM = {}))
var Rtt = class pV {
    constructor(t, e) {
      ;(this.line = t), (this.character = e)
    }
    isBefore(t) {
      return !1
    }
    isBeforeOrEqual(t) {
      return !1
    }
    isAfter(t) {
      return !1
    }
    isAfterOrEqual(t) {
      return !1
    }
    isEqual(t) {
      return !1
    }
    compareTo(t) {
      return 0
    }
    translate(t, e) {
      return new pV(0, 0)
    }
    with(t) {
      return new pV(0, 0)
    }
  },
  Dtt = class gV {
    constructor(t, e, s, r) {
      ;(this.isEmpty = !1),
        (this.isSingleLine = !1),
        (this.start = new Rtt(t, e)),
        (this.end = new Rtt(s, r))
    }
    contains(t) {
      return !1
    }
    isEqual(t) {
      return !1
    }
    intersection(t) {}
    union(t) {
      return new gV(0, 0, 0, 0)
    }
    with(t) {
      return new gV(0, 0, 0, 0)
    }
  },
  Tn = class {
    constructor(i, t, e) {
      ;(this.uri = i), (this.ranges = t), (this.previewText = e)
    }
  },
  k8 = class {
    constructor(i, t, e) {
      ;(this.uri = i), (this.text = t), (this.lineNumber = e)
    }
  },
  kn
;(function (i) {
  ;(i[(i.None = 1)] = "None"),
    (i[(i.FilesExclude = 2)] = "FilesExclude"),
    (i[(i.SearchAndFilesExclude = 3)] = "SearchAndFilesExclude")
})(kn || (kn = {}))
var S8
;(function (i) {
  ;(i[(i.Information = 1)] = "Information"), (i[(i.Warning = 2)] = "Warning")
})(S8 || (S8 = {}))
var E8 = 2e4,
  Ftt = "\u27EA ",
  Att = " characters skipped \u27EB",
  LTt = (Ftt.length + Att.length + 5) * 2,
  fzt = X("searchService"),
  _tt
;(function (i) {
  ;(i[(i.file = 0)] = "file"),
    (i[(i.text = 1)] = "text"),
    (i[(i.aiText = 2)] = "aiText")
})(_tt || (_tt = {}))
var Ott
;(function (i) {
  ;(i[(i.File = 1)] = "File"),
    (i[(i.Text = 2)] = "Text"),
    (i[(i.aiText = 3)] = "aiText")
})(Ott || (Ott = {}))
function dM(i) {
  return !!i.rangeLocations && !!i.previewText
}
var Btt
;(function (i) {
  ;(i[(i.Normal = 0)] = "Normal"),
    (i[(i.NewSearchStarted = 1)] = "NewSearchStarted")
})(Btt || (Btt = {}))
var qtt = class {
  constructor(i, t, e, s) {
    ;(this.rangeLocations = []), (this.webviewIndex = s)
    const r = Array.isArray(t) ? t : [t]
    if (e && e.matchLines === 1 && RTt(r)) {
      i = Qdt(i, e.matchLines)
      let a = "",
        o = 0,
        c = 0
      const l = Math.floor(e.charsPerLine / 5)
      for (const u of r) {
        const d = Math.max(u.startColumn - l, 0),
          m = u.startColumn + e.charsPerLine
        if (d > c + l + LTt) {
          const f = Ftt + (d - c) + Att
          ;(a += f + i.slice(d, m)), (o += d - (c + f.length))
        } else a += i.slice(c, m)
        ;(c = m),
          this.rangeLocations.push({
            source: u,
            preview: new DTt(0, u.startColumn - o, u.endColumn - o),
          })
      }
      this.previewText = a
    } else {
      const a = Array.isArray(t) ? t[0].startLineNumber : t.startLineNumber,
        o = m_(t, (c) => ({
          preview: new mM(
            c.startLineNumber - a,
            c.startColumn,
            c.endLineNumber - a,
            c.endColumn,
          ),
          source: c,
        }))
      ;(this.rangeLocations = Array.isArray(o) ? o : [o]),
        (this.previewText = i)
    }
  }
}
function RTt(i) {
  const t = i[0].startLineNumber
  for (const e of i)
    if (e.startLineNumber !== t || e.endLineNumber !== t) return !1
  return !0
}
var mM = class {
    constructor(i, t, e, s) {
      ;(this.startLineNumber = i),
        (this.startColumn = t),
        (this.endLineNumber = e),
        (this.endColumn = s)
    }
  },
  DTt = class extends mM {
    constructor(i, t, e) {
      super(i, t, i, e)
    }
  },
  Utt
;(function (i) {
  ;(i.List = "list"), (i.Tree = "tree")
})(Utt || (Utt = {}))
var Mtt
;(function (i) {
  ;(i.Default = "default"),
    (i.FileNames = "fileNames"),
    (i.Type = "type"),
    (i.Modified = "modified"),
    (i.CountDescending = "countDescending"),
    (i.CountAscending = "countAscending")
})(Mtt || (Mtt = {}))
function FTt(i, t = !0) {
  const e = i && i.files && i.files.exclude,
    s = t && i && i.search && i.search.exclude
  if (!e && !s) return
  if (!e || !s) return e || s || void 0
  let r = Object.create(null)
  return (r = en(r, pe(e))), (r = en(r, pe(s), !0)), r
}
function Htt(i, t) {
  return i.excludePattern && Bc(i.excludePattern, t)
    ? !1
    : i.includePattern || i.usingSearchPaths
      ? i.includePattern && Bc(i.includePattern, t)
        ? !0
        : i.usingSearchPaths
          ? !!i.folderQueries &&
            i.folderQueries.some((e) => {
              const s = e.folder.fsPath
              if (ja(t, s)) {
                const r = uc(s, t)
                return !e.includePattern || !!Bc(e.includePattern, r)
              } else return !1
            })
          : !1
      : !0
}
var va
;(function (i) {
  ;(i[(i.unknownEncoding = 1)] = "unknownEncoding"),
    (i[(i.regexParseError = 2)] = "regexParseError"),
    (i[(i.globParseError = 3)] = "globParseError"),
    (i[(i.invalidLiteral = 4)] = "invalidLiteral"),
    (i[(i.rgProcessError = 5)] = "rgProcessError"),
    (i[(i.other = 6)] = "other"),
    (i[(i.canceled = 7)] = "canceled")
})(va || (va = {}))
var Jo = class extends Error {
  constructor(i, t) {
    super(i), (this.code = t)
  }
}
function Wtt(i) {
  const t = { message: i.message, code: i.code }
  return new Error(JSON.stringify(t))
}
function ATt(i) {
  return !!i.path
}
function fM(i, t, e = !0) {
  const s = i.searchPath ? i.searchPath : i.relativePath
  return e ? zdt(s, t) : Bc(t, s)
}
function Pl(i, t) {
  const e = { ...(i || {}), ...(t || {}) }
  return Object.keys(e).filter((s) => {
    const r = e[s]
    return typeof r == "boolean" && r
  })
}
var jtt = class {
  constructor(i, t) {
    ;(this.c = null),
      (this.a =
        t.excludePattern?.map((s) => ({
          ...(i.excludePattern || {}),
          ...(s.pattern || {}),
        })) ?? []),
      this.a.length === 0 && (this.a = [i.excludePattern || {}]),
      (this.b = this.a.map((s) => sr(s)))
    let e = i.includePattern
    t.includePattern &&
      (e ? (e = { ...e, ...t.includePattern }) : (e = t.includePattern)),
      e && (this.c = sr(e))
  }
  d(i, t, e) {
    let s = null
    for (const r of this.b) {
      const a = r(i, t, e)
      if (typeof a == "string") {
        s = a
        break
      }
    }
    return s
  }
  matchesExcludesSync(i, t, e) {
    return !!(this.b && this.d(i, t, e))
  }
  includedInQuerySync(i, t, e) {
    return !((this.b && this.d(i, t, e)) || (this.c && !this.c(i, t, e)))
  }
  includedInQuery(i, t, e) {
    const s = () => (this.c ? !!this.c(i, t, e) : !0)
    return Promise.all(
      this.b.map((r) => {
        const a = r(i, t, e)
        return Kr(a) ? a.then((o) => (o ? !1 : s())) : s()
      }),
    ).then((r) => r.some((a) => !!a))
  }
  hasSiblingExcludeClauses() {
    return this.a.reduce((i, t) => _Tt(t) || i, !1)
  }
}
function _Tt(i) {
  for (const t in i) if (typeof i[t] != "boolean") return !0
  return !1
}
function OTt(i) {
  if (!i) return
  let t
  return (e) => (
    t || (t = (i() || Promise.resolve([])).then((s) => (s ? Vtt(s) : {}))),
    t.then((s) => !!s[e])
  )
}
function pM(i) {
  if (!i) return
  let t
  return (e) => {
    if (!t) {
      const s = i()
      t = s ? Vtt(s) : {}
    }
    return !!t[e]
  }
}
function Vtt(i) {
  const t = {}
  for (const e of i) t[e] = !0
  return t
}
function Gtt(i) {
  return i.flatMap((t) =>
    t.patterns.map((e) => (t.baseUri ? { baseUri: t.baseUri, pattern: e } : e)),
  )
}
var gM = { matchLines: 100, charsPerLine: 1e4 }
function ze(i, t) {
  if (!i) throw new Error(t)
}
var BTt = 34028234663852886e22,
  qTt = -34028234663852886e22,
  UTt = 4294967295,
  MTt = 2147483647,
  HTt = -2147483648
function I8(i) {
  if (typeof i != "number") throw new Error("invalid int 32: " + typeof i)
  if (!Number.isInteger(i) || i > MTt || i < HTt)
    throw new Error("invalid int 32: " + i)
}
function vM(i) {
  if (typeof i != "number") throw new Error("invalid uint 32: " + typeof i)
  if (!Number.isInteger(i) || i > UTt || i < 0)
    throw new Error("invalid uint 32: " + i)
}
function ztt(i) {
  if (typeof i != "number") throw new Error("invalid float 32: " + typeof i)
  if (Number.isFinite(i) && (i > BTt || i < qTt))
    throw new Error("invalid float 32: " + i)
}
var Ytt = Symbol("@bufbuild/protobuf/enum-type")
function Qtt(i) {
  const t = i[Ytt]
  return ze(t, "missing enum type on enum object"), t
}
function Xtt(i, t, e, s) {
  i[Ytt] = Ktt(
    t,
    e.map((r) => ({ no: r.no, name: r.name, localName: i[r.no] })),
    s,
  )
}
function Ktt(i, t, e) {
  const s = Object.create(null),
    r = Object.create(null),
    a = []
  for (const o of t) {
    const c = Ztt(o)
    a.push(c), (s[o.name] = c), (r[o.no] = c)
  }
  return {
    typeName: i,
    values: a,
    findName(o) {
      return s[o]
    },
    findNumber(o) {
      return r[o]
    },
  }
}
function WTt(i, t, e) {
  const s = {}
  for (const r of t) {
    const a = Ztt(r)
    ;(s[a.localName] = a.no), (s[a.no] = a.localName)
  }
  return Xtt(s, i, t, e), s
}
function Ztt(i) {
  return "localName" in i ? i : { ...i, localName: i.name }
}
var h = class {
  equals(i) {
    return this.getType().runtime.util.equals(this.getType(), this, i)
  }
  clone() {
    return this.getType().runtime.util.clone(this)
  }
  fromBinary(i, t) {
    const e = this.getType(),
      s = e.runtime.bin,
      r = s.makeReadOptions(t)
    return s.readMessage(this, r.readerFactory(i), i.byteLength, r), this
  }
  fromJson(i, t) {
    const e = this.getType(),
      s = e.runtime.json,
      r = s.makeReadOptions(t)
    return s.readMessage(e, i, r, this), this
  }
  fromJsonString(i, t) {
    let e
    try {
      e = JSON.parse(i)
    } catch (s) {
      throw new Error(
        `cannot decode ${this.getType().typeName} from JSON: ${s instanceof Error ? s.message : String(s)}`,
      )
    }
    return this.fromJson(e, t)
  }
  toBinary(i) {
    const t = this.getType(),
      e = t.runtime.bin,
      s = e.makeWriteOptions(i),
      r = s.writerFactory()
    return e.writeMessage(this, r, s), r.finish()
  }
  toJson(i) {
    const t = this.getType(),
      e = t.runtime.json,
      s = e.makeWriteOptions(i)
    return e.writeMessage(this, s)
  }
  toJsonString(i) {
    const t = this.toJson(i)
    return JSON.stringify(t, null, i?.prettySpaces ?? 0)
  }
  toJSON() {
    return this.toJson({ emitDefaultValues: !0 })
  }
  getType() {
    return Object.getPrototypeOf(this).constructor
  }
}
function jTt(i, t, e, s) {
  const r = s?.localName ?? t.substring(t.lastIndexOf(".") + 1),
    a = {
      [r]: function (o) {
        i.util.initFields(this), i.util.initPartial(o, this)
      },
    }[r]
  return (
    Object.setPrototypeOf(a.prototype, new h()),
    Object.assign(a, {
      runtime: i,
      typeName: t,
      fields: i.util.newFieldList(e),
      fromBinary(o, c) {
        return new a().fromBinary(o, c)
      },
      fromJson(o, c) {
        return new a().fromJson(o, c)
      },
      fromJsonString(o, c) {
        return new a().fromJsonString(o, c)
      },
      equals(o, c) {
        return i.util.equals(a, o, c)
      },
    }),
    a
  )
}
function VTt() {
  let i = 0,
    t = 0
  for (let s = 0; s < 28; s += 7) {
    let r = this.buf[this.pos++]
    if (((i |= (r & 127) << s), !(r & 128))) return this.assertBounds(), [i, t]
  }
  let e = this.buf[this.pos++]
  if (((i |= (e & 15) << 28), (t = (e & 112) >> 4), !(e & 128)))
    return this.assertBounds(), [i, t]
  for (let s = 3; s <= 31; s += 7) {
    let r = this.buf[this.pos++]
    if (((t |= (r & 127) << s), !(r & 128))) return this.assertBounds(), [i, t]
  }
  throw new Error("invalid varint")
}
function wM(i, t, e) {
  for (let a = 0; a < 28; a = a + 7) {
    const o = i >>> a,
      c = !(!(o >>> 7) && t == 0),
      l = (c ? o | 128 : o) & 255
    if ((e.push(l), !c)) return
  }
  const s = ((i >>> 28) & 15) | ((t & 7) << 4),
    r = !!(t >> 3)
  if ((e.push((r ? s | 128 : s) & 255), !!r)) {
    for (let a = 3; a < 31; a = a + 7) {
      const o = t >>> a,
        c = !!(o >>> 7),
        l = (c ? o | 128 : o) & 255
      if ((e.push(l), !c)) return
    }
    e.push((t >>> 31) & 1)
  }
}
var P8 = 4294967296
function tet(i) {
  const t = i[0] === "-"
  t && (i = i.slice(1))
  const e = 1e6
  let s = 0,
    r = 0
  function a(o, c) {
    const l = Number(i.slice(o, c))
    ;(r *= e),
      (s = s * e + l),
      s >= P8 && ((r = r + ((s / P8) | 0)), (s = s % P8))
  }
  return a(-24, -18), a(-18, -12), a(-12, -6), a(-6), t ? iet(s, r) : yM(s, r)
}
function GTt(i, t) {
  let e = yM(i, t)
  const s = e.hi & 2147483648
  s && (e = iet(e.lo, e.hi))
  const r = eet(e.lo, e.hi)
  return s ? "-" + r : r
}
function eet(i, t) {
  if ((({ lo: i, hi: t } = zTt(i, t)), t <= 2097151)) return String(P8 * t + i)
  const e = i & 16777215,
    s = ((i >>> 24) | (t << 8)) & 16777215,
    r = (t >> 16) & 65535
  let a = e + s * 6777216 + r * 6710656,
    o = s + r * 8147497,
    c = r * 2
  const l = 1e7
  return (
    a >= l && ((o += Math.floor(a / l)), (a %= l)),
    o >= l && ((c += Math.floor(o / l)), (o %= l)),
    c.toString() + set(o) + set(a)
  )
}
function zTt(i, t) {
  return { lo: i >>> 0, hi: t >>> 0 }
}
function yM(i, t) {
  return { lo: i | 0, hi: t | 0 }
}
function iet(i, t) {
  return (t = ~t), i ? (i = ~i + 1) : (t += 1), yM(i, t)
}
var set = (i) => {
  const t = String(i)
  return "0000000".slice(t.length) + t
}
function ret(i, t) {
  if (i >= 0) {
    for (; i > 127; ) t.push((i & 127) | 128), (i = i >>> 7)
    t.push(i)
  } else {
    for (let e = 0; e < 9; e++) t.push((i & 127) | 128), (i = i >> 7)
    t.push(1)
  }
}
function YTt() {
  let i = this.buf[this.pos++],
    t = i & 127
  if (!(i & 128)) return this.assertBounds(), t
  if (((i = this.buf[this.pos++]), (t |= (i & 127) << 7), !(i & 128)))
    return this.assertBounds(), t
  if (((i = this.buf[this.pos++]), (t |= (i & 127) << 14), !(i & 128)))
    return this.assertBounds(), t
  if (((i = this.buf[this.pos++]), (t |= (i & 127) << 21), !(i & 128)))
    return this.assertBounds(), t
  ;(i = this.buf[this.pos++]), (t |= (i & 15) << 28)
  for (let e = 5; i & 128 && e < 10; e++) i = this.buf[this.pos++]
  if (i & 128) throw new Error("invalid varint")
  return this.assertBounds(), t >>> 0
}
function QTt() {
  const i = new DataView(new ArrayBuffer(8))
  if (
    typeof BigInt == "function" &&
    typeof i.getBigInt64 == "function" &&
    typeof i.getBigUint64 == "function" &&
    typeof i.setBigInt64 == "function" &&
    typeof i.setBigUint64 == "function" &&
    (typeof process != "object" ||
      typeof process.env != "object" ||
      process.env.BUF_BIGINT_DISABLE !== "1")
  ) {
    const r = BigInt("-9223372036854775808"),
      a = BigInt("9223372036854775807"),
      o = BigInt("0"),
      c = BigInt("18446744073709551615")
    return {
      zero: BigInt(0),
      supported: !0,
      parse(l) {
        const u = typeof l == "bigint" ? l : BigInt(l)
        if (u > a || u < r) throw new Error(`int64 invalid: ${l}`)
        return u
      },
      uParse(l) {
        const u = typeof l == "bigint" ? l : BigInt(l)
        if (u > c || u < o) throw new Error(`uint64 invalid: ${l}`)
        return u
      },
      enc(l) {
        return (
          i.setBigInt64(0, this.parse(l), !0),
          { lo: i.getInt32(0, !0), hi: i.getInt32(4, !0) }
        )
      },
      uEnc(l) {
        return (
          i.setBigInt64(0, this.uParse(l), !0),
          { lo: i.getInt32(0, !0), hi: i.getInt32(4, !0) }
        )
      },
      dec(l, u) {
        return i.setInt32(0, l, !0), i.setInt32(4, u, !0), i.getBigInt64(0, !0)
      },
      uDec(l, u) {
        return i.setInt32(0, l, !0), i.setInt32(4, u, !0), i.getBigUint64(0, !0)
      },
    }
  }
  const e = (r) => ze(/^-?[0-9]+$/.test(r), `int64 invalid: ${r}`),
    s = (r) => ze(/^[0-9]+$/.test(r), `uint64 invalid: ${r}`)
  return {
    zero: "0",
    supported: !1,
    parse(r) {
      return typeof r != "string" && (r = r.toString()), e(r), r
    },
    uParse(r) {
      return typeof r != "string" && (r = r.toString()), s(r), r
    },
    enc(r) {
      return typeof r != "string" && (r = r.toString()), e(r), tet(r)
    },
    uEnc(r) {
      return typeof r != "string" && (r = r.toString()), s(r), tet(r)
    },
    dec(r, a) {
      return GTt(r, a)
    },
    uDec(r, a) {
      return eet(r, a)
    },
  }
}
var _e = QTt(),
  B
;(function (i) {
  ;(i[(i.DOUBLE = 1)] = "DOUBLE"),
    (i[(i.FLOAT = 2)] = "FLOAT"),
    (i[(i.INT64 = 3)] = "INT64"),
    (i[(i.UINT64 = 4)] = "UINT64"),
    (i[(i.INT32 = 5)] = "INT32"),
    (i[(i.FIXED64 = 6)] = "FIXED64"),
    (i[(i.FIXED32 = 7)] = "FIXED32"),
    (i[(i.BOOL = 8)] = "BOOL"),
    (i[(i.STRING = 9)] = "STRING"),
    (i[(i.BYTES = 12)] = "BYTES"),
    (i[(i.UINT32 = 13)] = "UINT32"),
    (i[(i.SFIXED32 = 15)] = "SFIXED32"),
    (i[(i.SFIXED64 = 16)] = "SFIXED64"),
    (i[(i.SINT32 = 17)] = "SINT32"),
    (i[(i.SINT64 = 18)] = "SINT64")
})(B || (B = {}))
var wa
;(function (i) {
  ;(i[(i.BIGINT = 0)] = "BIGINT"), (i[(i.STRING = 1)] = "STRING")
})(wa || (wa = {}))
function ya(i, t, e) {
  if (t === e) return !0
  if (i == B.BYTES) {
    if (
      !(t instanceof Uint8Array) ||
      !(e instanceof Uint8Array) ||
      t.length !== e.length
    )
      return !1
    for (let s = 0; s < t.length; s++) if (t[s] !== e[s]) return !1
    return !0
  }
  switch (i) {
    case B.UINT64:
    case B.FIXED64:
    case B.INT64:
    case B.SFIXED64:
    case B.SINT64:
      return t == e
  }
  return !1
}
function $l(i, t) {
  switch (i) {
    case B.BOOL:
      return !1
    case B.UINT64:
    case B.FIXED64:
    case B.INT64:
    case B.SFIXED64:
    case B.SINT64:
      return t == 0 ? _e.zero : "0"
    case B.DOUBLE:
    case B.FLOAT:
      return 0
    case B.BYTES:
      return new Uint8Array(0)
    case B.STRING:
      return ""
    default:
      return 0
  }
}
function net(i, t) {
  switch (i) {
    case B.BOOL:
      return t === !1
    case B.STRING:
      return t === ""
    case B.BYTES:
      return t instanceof Uint8Array && !t.byteLength
    default:
      return t == 0
  }
}
function XTt(i, t, e, s) {
  let r
  return {
    typeName: t,
    extendee: e,
    get field() {
      if (!r) {
        const a = typeof s == "function" ? s() : s
        ;(a.name = t.split(".").pop()),
          (a.jsonName = `[${t}]`),
          (r = i.util.newFieldList([a]).list()[0])
      }
      return r
    },
    runtime: i,
  }
}
function aet(i) {
  const t = i.field.localName,
    e = Object.create(null)
  return (e[t] = KTt(i)), [e, () => e[t]]
}
function KTt(i) {
  const t = i.field
  if (t.repeated) return []
  if (t.default !== void 0) return t.default
  switch (t.kind) {
    case "enum":
      return t.T.values[0].no
    case "scalar":
      return $l(t.T, t.L)
    case "message":
      const e = t.T,
        s = new e()
      return e.fieldWrapper ? e.fieldWrapper.unwrapField(s) : s
    case "map":
      throw "map fields are not allowed to be extensions"
  }
}
function ZTt(i, t) {
  if (!t.repeated && (t.kind == "enum" || t.kind == "scalar")) {
    for (let e = i.length - 1; e >= 0; --e) if (i[e].no == t.no) return [i[e]]
    return []
  }
  return i.filter((e) => e.no === t.no)
}
var Sn =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
      "",
    ),
  $8 = []
for (let i = 0; i < Sn.length; i++) $8[Sn[i].charCodeAt(0)] = i
;($8[45] = Sn.indexOf("+")), ($8[95] = Sn.indexOf("/"))
var oet = {
  dec(i) {
    let t = (i.length * 3) / 4
    i[i.length - 2] == "=" ? (t -= 2) : i[i.length - 1] == "=" && (t -= 1)
    let e = new Uint8Array(t),
      s = 0,
      r = 0,
      a,
      o = 0
    for (let c = 0; c < i.length; c++) {
      if (((a = $8[i.charCodeAt(c)]), a === void 0))
        switch (i[c]) {
          case "=":
            r = 0
          case `
`:
          case "\r":
          case "	":
          case " ":
            continue
          default:
            throw Error("invalid base64 string.")
        }
      switch (r) {
        case 0:
          ;(o = a), (r = 1)
          break
        case 1:
          ;(e[s++] = (o << 2) | ((a & 48) >> 4)), (o = a), (r = 2)
          break
        case 2:
          ;(e[s++] = ((o & 15) << 4) | ((a & 60) >> 2)), (o = a), (r = 3)
          break
        case 3:
          ;(e[s++] = ((o & 3) << 6) | a), (r = 0)
          break
      }
    }
    if (r == 1) throw Error("invalid base64 string.")
    return e.subarray(0, s)
  },
  enc(i) {
    let t = "",
      e = 0,
      s,
      r = 0
    for (let a = 0; a < i.length; a++)
      switch (((s = i[a]), e)) {
        case 0:
          ;(t += Sn[s >> 2]), (r = (s & 3) << 4), (e = 1)
          break
        case 1:
          ;(t += Sn[r | (s >> 4)]), (r = (s & 15) << 2), (e = 2)
          break
        case 2:
          ;(t += Sn[r | (s >> 6)]), (t += Sn[s & 63]), (e = 0)
          break
      }
    return e && ((t += Sn[r]), (t += "="), e == 1 && (t += "=")), t
  },
}
function tkt(i, t, e) {
  uet(t, i)
  const s = t.runtime.bin.makeReadOptions(e),
    r = ZTt(i.getType().runtime.bin.listUnknownFields(i), t.field),
    [a, o] = aet(t)
  for (const c of r)
    t.runtime.bin.readField(a, s.readerFactory(c.data), t.field, c.wireType, s)
  return o()
}
function ekt(i, t, e, s) {
  uet(t, i)
  const r = t.runtime.bin.makeReadOptions(s),
    a = t.runtime.bin.makeWriteOptions(s)
  if (cet(i, t)) {
    const u = i
      .getType()
      .runtime.bin.listUnknownFields(i)
      .filter((d) => d.no != t.field.no)
    i.getType().runtime.bin.discardUnknownFields(i)
    for (const d of u)
      i.getType().runtime.bin.onUnknownField(i, d.no, d.wireType, d.data)
  }
  const o = a.writerFactory()
  let c = t.field
  !c.opt &&
    !c.repeated &&
    (c.kind == "enum" || c.kind == "scalar") &&
    (c = { ...t.field, opt: !0 }),
    t.runtime.bin.writeField(c, e, o, a)
  const l = r.readerFactory(o.finish())
  for (; l.pos < l.len; ) {
    const [u, d] = l.tag(),
      m = l.skip(d, u)
    i.getType().runtime.bin.onUnknownField(i, u, d, m)
  }
}
function cet(i, t) {
  const e = i.getType()
  return (
    t.extendee.typeName === e.typeName &&
    !!e.runtime.bin.listUnknownFields(i).find((s) => s.no == t.field.no)
  )
}
function uet(i, t) {
  ze(
    i.extendee.typeName == t.getType().typeName,
    `extension ${i.typeName} can only be applied to message ${i.extendee.typeName}`,
  )
}
function het(i, t) {
  const e = i.localName
  if (i.repeated) return t[e].length > 0
  if (i.oneof) return t[i.oneof.localName].case === e
  switch (i.kind) {
    case "enum":
    case "scalar":
      return i.opt || i.req
        ? t[e] !== void 0
        : i.kind == "enum"
          ? t[e] !== i.T.values[0].no
          : !net(i.T, t[e])
    case "message":
      return t[e] !== void 0
    case "map":
      return Object.keys(t[e]).length > 0
  }
}
function det(i, t) {
  const e = i.localName,
    s = !i.opt && !i.req
  if (i.repeated) t[e] = []
  else if (i.oneof) t[i.oneof.localName] = { case: void 0 }
  else
    switch (i.kind) {
      case "map":
        t[e] = {}
        break
      case "enum":
        t[e] = s ? i.T.values[0].no : void 0
        break
      case "scalar":
        t[e] = s ? $l(i.T, i.L) : void 0
        break
      case "message":
        t[e] = void 0
        break
    }
}
function Lo(i, t) {
  if (
    i === null ||
    typeof i != "object" ||
    !Object.getOwnPropertyNames(h.prototype).every(
      (s) => s in i && typeof i[s] == "function",
    )
  )
    return !1
  const e = i.getType()
  return e === null ||
    typeof e != "function" ||
    !("typeName" in e) ||
    typeof e.typeName != "string"
    ? !1
    : t === void 0
      ? !0
      : e.typeName == t.typeName
}
function met(i, t) {
  return Lo(t) || !i.fieldWrapper ? t : i.fieldWrapper.wrapField(t)
}
var pzt = {
    "google.protobuf.DoubleValue": B.DOUBLE,
    "google.protobuf.FloatValue": B.FLOAT,
    "google.protobuf.Int64Value": B.INT64,
    "google.protobuf.UInt64Value": B.UINT64,
    "google.protobuf.Int32Value": B.INT32,
    "google.protobuf.UInt32Value": B.UINT32,
    "google.protobuf.BoolValue": B.BOOL,
    "google.protobuf.StringValue": B.STRING,
    "google.protobuf.BytesValue": B.BYTES,
  },
  fet = { ignoreUnknownFields: !1 },
  pet = {
    emitDefaultValues: !1,
    enumAsInteger: !1,
    useProtoFieldName: !1,
    prettySpaces: 0,
  }
function ikt(i) {
  return i ? { ...fet, ...i } : fet
}
function skt(i) {
  return i ? { ...pet, ...i } : pet
}
var x8 = Symbol(),
  N8 = Symbol()
function rkt() {
  return {
    makeReadOptions: ikt,
    makeWriteOptions: skt,
    readMessage(i, t, e, s) {
      if (t == null || Array.isArray(t) || typeof t != "object")
        throw new Error(
          `cannot decode message ${i.typeName} from JSON: ${Br(t)}`,
        )
      s = s ?? new i()
      const r = new Map(),
        a = e.typeRegistry
      for (const [o, c] of Object.entries(t)) {
        const l = i.fields.findJsonName(o)
        if (l) {
          if (l.oneof) {
            if (c === null && l.kind == "scalar") continue
            const u = r.get(l.oneof)
            if (u !== void 0)
              throw new Error(
                `cannot decode message ${i.typeName} from JSON: multiple keys for oneof "${l.oneof.name}" present: "${u}", "${o}"`,
              )
            r.set(l.oneof, o)
          }
          get(s, c, l, e, i)
        } else {
          let u = !1
          if (a?.findExtension && o.startsWith("[") && o.endsWith("]")) {
            const d = a.findExtension(o.substring(1, o.length - 1))
            if (d && d.extendee.typeName == i.typeName) {
              u = !0
              const [m, f] = aet(d)
              get(m, c, d.field, e, d), ekt(s, d, f(), e)
            }
          }
          if (!u && !e.ignoreUnknownFields)
            throw new Error(
              `cannot decode message ${i.typeName} from JSON: key "${o}" is unknown`,
            )
        }
      }
      return s
    },
    writeMessage(i, t) {
      const e = i.getType(),
        s = {}
      let r
      try {
        for (r of e.fields.byNumber()) {
          if (!het(r, i)) {
            if (r.req) throw "required field not set"
            if (!t.emitDefaultValues || !akt(r)) continue
          }
          const o = r.oneof ? i[r.oneof.localName].value : i[r.localName],
            c = vet(r, o, t)
          c !== void 0 && (s[t.useProtoFieldName ? r.name : r.jsonName] = c)
        }
        const a = t.typeRegistry
        if (a?.findExtensionFor)
          for (const o of e.runtime.bin.listUnknownFields(i)) {
            const c = a.findExtensionFor(e.typeName, o.no)
            if (c && cet(i, c)) {
              const l = tkt(i, c, t),
                u = vet(c.field, l, t)
              u !== void 0 && (s[c.field.jsonName] = u)
            }
          }
      } catch (a) {
        const o = r
            ? `cannot encode field ${e.typeName}.${r.name} to JSON`
            : `cannot encode message ${e.typeName} to JSON`,
          c = a instanceof Error ? a.message : String(a)
        throw new Error(o + (c.length > 0 ? `: ${c}` : ""))
      }
      return s
    },
    readScalar(i, t, e) {
      return Sd(i, t, e ?? wa.BIGINT, !0)
    },
    writeScalar(i, t, e) {
      if (t !== void 0 && (e || net(i, t))) return C8(i, t)
    },
    debug: Br,
  }
}
function Br(i) {
  if (i === null) return "null"
  switch (typeof i) {
    case "object":
      return Array.isArray(i) ? "array" : "object"
    case "string":
      return i.length > 100 ? "string" : `"${i.split('"').join('\\"')}"`
    default:
      return String(i)
  }
}
function get(i, t, e, s, r) {
  let a = e.localName
  if (e.repeated) {
    if ((ze(e.kind != "map"), t === null)) return
    if (!Array.isArray(t))
      throw new Error(
        `cannot decode field ${r.typeName}.${e.name} from JSON: ${Br(t)}`,
      )
    const o = i[a]
    for (const c of t) {
      if (c === null)
        throw new Error(
          `cannot decode field ${r.typeName}.${e.name} from JSON: ${Br(c)}`,
        )
      switch (e.kind) {
        case "message":
          o.push(e.T.fromJson(c, s))
          break
        case "enum":
          const l = bM(e.T, c, s.ignoreUnknownFields, !0)
          l !== N8 && o.push(l)
          break
        case "scalar":
          try {
            o.push(Sd(e.T, c, e.L, !0))
          } catch (u) {
            let d = `cannot decode field ${r.typeName}.${e.name} from JSON: ${Br(c)}`
            throw (
              (u instanceof Error &&
                u.message.length > 0 &&
                (d += `: ${u.message}`),
              new Error(d))
            )
          }
          break
      }
    }
  } else if (e.kind == "map") {
    if (t === null) return
    if (typeof t != "object" || Array.isArray(t))
      throw new Error(
        `cannot decode field ${r.typeName}.${e.name} from JSON: ${Br(t)}`,
      )
    const o = i[a]
    for (const [c, l] of Object.entries(t)) {
      if (l === null)
        throw new Error(
          `cannot decode field ${r.typeName}.${e.name} from JSON: map value null`,
        )
      let u
      try {
        u = nkt(e.K, c)
      } catch (d) {
        let m = `cannot decode map key for field ${r.typeName}.${e.name} from JSON: ${Br(t)}`
        throw (
          (d instanceof Error &&
            d.message.length > 0 &&
            (m += `: ${d.message}`),
          new Error(m))
        )
      }
      switch (e.V.kind) {
        case "message":
          o[u] = e.V.T.fromJson(l, s)
          break
        case "enum":
          const d = bM(e.V.T, l, s.ignoreUnknownFields, !0)
          d !== N8 && (o[u] = d)
          break
        case "scalar":
          try {
            o[u] = Sd(e.V.T, l, wa.BIGINT, !0)
          } catch (m) {
            let f = `cannot decode map value for field ${r.typeName}.${e.name} from JSON: ${Br(t)}`
            throw (
              (m instanceof Error &&
                m.message.length > 0 &&
                (f += `: ${m.message}`),
              new Error(f))
            )
          }
          break
      }
    }
  } else
    switch (
      (e.oneof && ((i = i[e.oneof.localName] = { case: a }), (a = "value")),
      e.kind)
    ) {
      case "message":
        const o = e.T
        if (t === null && o.typeName != "google.protobuf.Value") return
        let c = i[a]
        Lo(c)
          ? c.fromJson(t, s)
          : ((i[a] = c = o.fromJson(t, s)),
            o.fieldWrapper &&
              !e.oneof &&
              (i[a] = o.fieldWrapper.unwrapField(c)))
        break
      case "enum":
        const l = bM(e.T, t, s.ignoreUnknownFields, !1)
        switch (l) {
          case x8:
            det(e, i)
            break
          case N8:
            break
          default:
            i[a] = l
            break
        }
        break
      case "scalar":
        try {
          const u = Sd(e.T, t, e.L, !1)
          switch (u) {
            case x8:
              det(e, i)
              break
            default:
              i[a] = u
              break
          }
        } catch (u) {
          let d = `cannot decode field ${r.typeName}.${e.name} from JSON: ${Br(t)}`
          throw (
            (u instanceof Error &&
              u.message.length > 0 &&
              (d += `: ${u.message}`),
            new Error(d))
          )
        }
        break
    }
}
function nkt(i, t) {
  if (i === B.BOOL)
    switch (t) {
      case "true":
        t = !0
        break
      case "false":
        t = !1
        break
    }
  return Sd(i, t, wa.BIGINT, !0).toString()
}
function Sd(i, t, e, s) {
  if (t === null) return s ? $l(i, e) : x8
  switch (i) {
    case B.DOUBLE:
    case B.FLOAT:
      if (t === "NaN") return Number.NaN
      if (t === "Infinity") return Number.POSITIVE_INFINITY
      if (t === "-Infinity") return Number.NEGATIVE_INFINITY
      if (
        t === "" ||
        (typeof t == "string" && t.trim().length !== t.length) ||
        (typeof t != "string" && typeof t != "number")
      )
        break
      const r = Number(t)
      if (Number.isNaN(r) || !Number.isFinite(r)) break
      return i == B.FLOAT && ztt(r), r
    case B.INT32:
    case B.FIXED32:
    case B.SFIXED32:
    case B.SINT32:
    case B.UINT32:
      let a
      if (
        (typeof t == "number"
          ? (a = t)
          : typeof t == "string" &&
            t.length > 0 &&
            t.trim().length === t.length &&
            (a = Number(t)),
        a === void 0)
      )
        break
      return i == B.UINT32 || i == B.FIXED32 ? vM(a) : I8(a), a
    case B.INT64:
    case B.SFIXED64:
    case B.SINT64:
      if (typeof t != "number" && typeof t != "string") break
      const o = _e.parse(t)
      return e ? o.toString() : o
    case B.FIXED64:
    case B.UINT64:
      if (typeof t != "number" && typeof t != "string") break
      const c = _e.uParse(t)
      return e ? c.toString() : c
    case B.BOOL:
      if (typeof t != "boolean") break
      return t
    case B.STRING:
      if (typeof t != "string") break
      try {
        encodeURIComponent(t)
      } catch {
        throw new Error("invalid UTF8")
      }
      return t
    case B.BYTES:
      if (t === "") return new Uint8Array(0)
      if (typeof t != "string") break
      return oet.dec(t)
  }
  throw new Error()
}
function bM(i, t, e, s) {
  if (t === null)
    return i.typeName == "google.protobuf.NullValue"
      ? 0
      : s
        ? i.values[0].no
        : x8
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t)) return t
      break
    case "string":
      const r = i.findName(t)
      if (r !== void 0) return r.no
      if (e) return N8
      break
  }
  throw new Error(`cannot decode enum ${i.typeName} from JSON: ${Br(t)}`)
}
function akt(i) {
  return i.repeated || i.kind == "map"
    ? !0
    : !(i.oneof || i.kind == "message" || i.opt || i.req)
}
function vet(i, t, e) {
  if (i.kind == "map") {
    ze(typeof t == "object" && t != null)
    const s = {},
      r = Object.entries(t)
    switch (i.V.kind) {
      case "scalar":
        for (const [o, c] of r) s[o.toString()] = C8(i.V.T, c)
        break
      case "message":
        for (const [o, c] of r) s[o.toString()] = c.toJson(e)
        break
      case "enum":
        const a = i.V.T
        for (const [o, c] of r) s[o.toString()] = TM(a, c, e.enumAsInteger)
        break
    }
    return e.emitDefaultValues || r.length > 0 ? s : void 0
  }
  if (i.repeated) {
    ze(Array.isArray(t))
    const s = []
    switch (i.kind) {
      case "scalar":
        for (let r = 0; r < t.length; r++) s.push(C8(i.T, t[r]))
        break
      case "enum":
        for (let r = 0; r < t.length; r++)
          s.push(TM(i.T, t[r], e.enumAsInteger))
        break
      case "message":
        for (let r = 0; r < t.length; r++) s.push(t[r].toJson(e))
        break
    }
    return e.emitDefaultValues || s.length > 0 ? s : void 0
  }
  switch (i.kind) {
    case "scalar":
      return C8(i.T, t)
    case "enum":
      return TM(i.T, t, e.enumAsInteger)
    case "message":
      return met(i.T, t).toJson(e)
  }
}
function TM(i, t, e) {
  return (
    ze(typeof t == "number"),
    i.typeName == "google.protobuf.NullValue"
      ? null
      : e
        ? t
        : (i.findNumber(t)?.name ?? t)
  )
}
function C8(i, t) {
  switch (i) {
    case B.INT32:
    case B.SFIXED32:
    case B.SINT32:
    case B.FIXED32:
    case B.UINT32:
      return ze(typeof t == "number"), t
    case B.FLOAT:
    case B.DOUBLE:
      return (
        ze(typeof t == "number"),
        Number.isNaN(t)
          ? "NaN"
          : t === Number.POSITIVE_INFINITY
            ? "Infinity"
            : t === Number.NEGATIVE_INFINITY
              ? "-Infinity"
              : t
      )
    case B.STRING:
      return ze(typeof t == "string"), t
    case B.BOOL:
      return ze(typeof t == "boolean"), t
    case B.UINT64:
    case B.FIXED64:
    case B.INT64:
    case B.SFIXED64:
    case B.SINT64:
      return (
        ze(
          typeof t == "bigint" || typeof t == "string" || typeof t == "number",
        ),
        t.toString()
      )
    case B.BYTES:
      return ze(t instanceof Uint8Array), oet.enc(t)
  }
}
var ri
;(function (i) {
  ;(i[(i.Varint = 0)] = "Varint"),
    (i[(i.Bit64 = 1)] = "Bit64"),
    (i[(i.LengthDelimited = 2)] = "LengthDelimited"),
    (i[(i.StartGroup = 3)] = "StartGroup"),
    (i[(i.EndGroup = 4)] = "EndGroup"),
    (i[(i.Bit32 = 5)] = "Bit32")
})(ri || (ri = {}))
var okt = class {
    constructor(i) {
      ;(this.stack = []),
        (this.textEncoder = i ?? new TextEncoder()),
        (this.chunks = []),
        (this.buf = [])
    }
    finish() {
      this.chunks.push(new Uint8Array(this.buf))
      let i = 0
      for (let s = 0; s < this.chunks.length; s++) i += this.chunks[s].length
      let t = new Uint8Array(i),
        e = 0
      for (let s = 0; s < this.chunks.length; s++)
        t.set(this.chunks[s], e), (e += this.chunks[s].length)
      return (this.chunks = []), t
    }
    fork() {
      return (
        this.stack.push({ chunks: this.chunks, buf: this.buf }),
        (this.chunks = []),
        (this.buf = []),
        this
      )
    }
    join() {
      let i = this.finish(),
        t = this.stack.pop()
      if (!t) throw new Error("invalid state, fork stack empty")
      return (
        (this.chunks = t.chunks),
        (this.buf = t.buf),
        this.uint32(i.byteLength),
        this.raw(i)
      )
    }
    tag(i, t) {
      return this.uint32(((i << 3) | t) >>> 0)
    }
    raw(i) {
      return (
        this.buf.length &&
          (this.chunks.push(new Uint8Array(this.buf)), (this.buf = [])),
        this.chunks.push(i),
        this
      )
    }
    uint32(i) {
      for (vM(i); i > 127; ) this.buf.push((i & 127) | 128), (i = i >>> 7)
      return this.buf.push(i), this
    }
    int32(i) {
      return I8(i), ret(i, this.buf), this
    }
    bool(i) {
      return this.buf.push(i ? 1 : 0), this
    }
    bytes(i) {
      return this.uint32(i.byteLength), this.raw(i)
    }
    string(i) {
      let t = this.textEncoder.encode(i)
      return this.uint32(t.byteLength), this.raw(t)
    }
    float(i) {
      ztt(i)
      let t = new Uint8Array(4)
      return new DataView(t.buffer).setFloat32(0, i, !0), this.raw(t)
    }
    double(i) {
      let t = new Uint8Array(8)
      return new DataView(t.buffer).setFloat64(0, i, !0), this.raw(t)
    }
    fixed32(i) {
      vM(i)
      let t = new Uint8Array(4)
      return new DataView(t.buffer).setUint32(0, i, !0), this.raw(t)
    }
    sfixed32(i) {
      I8(i)
      let t = new Uint8Array(4)
      return new DataView(t.buffer).setInt32(0, i, !0), this.raw(t)
    }
    sint32(i) {
      return I8(i), (i = ((i << 1) ^ (i >> 31)) >>> 0), ret(i, this.buf), this
    }
    sfixed64(i) {
      let t = new Uint8Array(8),
        e = new DataView(t.buffer),
        s = _e.enc(i)
      return e.setInt32(0, s.lo, !0), e.setInt32(4, s.hi, !0), this.raw(t)
    }
    fixed64(i) {
      let t = new Uint8Array(8),
        e = new DataView(t.buffer),
        s = _e.uEnc(i)
      return e.setInt32(0, s.lo, !0), e.setInt32(4, s.hi, !0), this.raw(t)
    }
    int64(i) {
      let t = _e.enc(i)
      return wM(t.lo, t.hi, this.buf), this
    }
    sint64(i) {
      let t = _e.enc(i),
        e = t.hi >> 31,
        s = (t.lo << 1) ^ e,
        r = ((t.hi << 1) | (t.lo >>> 31)) ^ e
      return wM(s, r, this.buf), this
    }
    uint64(i) {
      let t = _e.uEnc(i)
      return wM(t.lo, t.hi, this.buf), this
    }
  },
  ckt = class {
    constructor(i, t) {
      ;(this.varint64 = VTt),
        (this.uint32 = YTt),
        (this.buf = i),
        (this.len = i.length),
        (this.pos = 0),
        (this.view = new DataView(i.buffer, i.byteOffset, i.byteLength)),
        (this.textDecoder = t ?? new TextDecoder())
    }
    tag() {
      let i = this.uint32(),
        t = i >>> 3,
        e = i & 7
      if (t <= 0 || e < 0 || e > 5)
        throw new Error("illegal tag: field no " + t + " wire type " + e)
      return [t, e]
    }
    skip(i, t) {
      let e = this.pos
      switch (i) {
        case ri.Varint:
          for (; this.buf[this.pos++] & 128; );
          break
        case ri.Bit64:
          this.pos += 4
        case ri.Bit32:
          this.pos += 4
          break
        case ri.LengthDelimited:
          let s = this.uint32()
          this.pos += s
          break
        case ri.StartGroup:
          for (;;) {
            const [r, a] = this.tag()
            if (a === ri.EndGroup) {
              if (t !== void 0 && r !== t)
                throw new Error("invalid end group tag")
              break
            }
            this.skip(a, r)
          }
          break
        default:
          throw new Error("cant skip wire type " + i)
      }
      return this.assertBounds(), this.buf.subarray(e, this.pos)
    }
    assertBounds() {
      if (this.pos > this.len) throw new RangeError("premature EOF")
    }
    int32() {
      return this.uint32() | 0
    }
    sint32() {
      let i = this.uint32()
      return (i >>> 1) ^ -(i & 1)
    }
    int64() {
      return _e.dec(...this.varint64())
    }
    uint64() {
      return _e.uDec(...this.varint64())
    }
    sint64() {
      let [i, t] = this.varint64(),
        e = -(i & 1)
      return (
        (i = ((i >>> 1) | ((t & 1) << 31)) ^ e),
        (t = (t >>> 1) ^ e),
        _e.dec(i, t)
      )
    }
    bool() {
      let [i, t] = this.varint64()
      return i !== 0 || t !== 0
    }
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, !0)
    }
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, !0)
    }
    fixed64() {
      return _e.uDec(this.sfixed32(), this.sfixed32())
    }
    sfixed64() {
      return _e.dec(this.sfixed32(), this.sfixed32())
    }
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, !0)
    }
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, !0)
    }
    bytes() {
      let i = this.uint32(),
        t = this.pos
      return (this.pos += i), this.assertBounds(), this.buf.subarray(t, t + i)
    }
    string() {
      return this.textDecoder.decode(this.bytes())
    }
  },
  xl = Symbol("@bufbuild/protobuf/unknown-fields"),
  wet = { readUnknownFields: !0, readerFactory: (i) => new ckt(i) },
  yet = { writeUnknownFields: !0, writerFactory: () => new okt() }
function lkt(i) {
  return i ? { ...wet, ...i } : wet
}
function ukt(i) {
  return i ? { ...yet, ...i } : yet
}
function hkt() {
  return {
    makeReadOptions: lkt,
    makeWriteOptions: ukt,
    listUnknownFields(i) {
      return i[xl] ?? []
    },
    discardUnknownFields(i) {
      delete i[xl]
    },
    writeUnknownFields(i, t) {
      const s = i[xl]
      if (s) for (const r of s) t.tag(r.no, r.wireType).raw(r.data)
    },
    onUnknownField(i, t, e, s) {
      const r = i
      Array.isArray(r[xl]) || (r[xl] = []),
        r[xl].push({ no: t, wireType: e, data: s })
    },
    readMessage(i, t, e, s, r) {
      const a = i.getType(),
        o = r ? t.len : t.pos + e
      let c, l
      for (
        ;
        t.pos < o && (([c, l] = t.tag()), !(r === !0 && l == ri.EndGroup));

      ) {
        const u = a.fields.find(c)
        if (!u) {
          const d = t.skip(l, c)
          s.readUnknownFields && this.onUnknownField(i, c, l, d)
          continue
        }
        bet(i, t, u, l, s)
      }
      if (r && (l != ri.EndGroup || c !== e))
        throw new Error("invalid end group tag")
    },
    readField: bet,
    writeMessage(i, t, e) {
      const s = i.getType()
      for (const r of s.fields.byNumber()) {
        if (!het(r, i)) {
          if (r.req)
            throw new Error(
              `cannot encode field ${s.typeName}.${r.name} to binary: required field not set`,
            )
          continue
        }
        const a = r.oneof ? i[r.oneof.localName].value : i[r.localName]
        Tet(r, a, t, e)
      }
      return e.writeUnknownFields && this.writeUnknownFields(i, t), t
    },
    writeField(i, t, e, s) {
      t !== void 0 && Tet(i, t, e, s)
    },
  }
}
function bet(i, t, e, s, r) {
  let { repeated: a, localName: o } = e
  switch (
    (e.oneof &&
      ((i = i[e.oneof.localName]),
      i.case != o && delete i.value,
      (i.case = o),
      (o = "value")),
    e.kind)
  ) {
    case "scalar":
    case "enum":
      const c = e.kind == "enum" ? B.INT32 : e.T
      let l = L8
      if ((e.kind == "scalar" && e.L > 0 && (l = mkt), a)) {
        let f = i[o]
        if (s == ri.LengthDelimited && c != B.STRING && c != B.BYTES) {
          let v = t.uint32() + t.pos
          for (; t.pos < v; ) f.push(l(t, c))
        } else f.push(l(t, c))
      } else i[o] = l(t, c)
      break
    case "message":
      const u = e.T
      a
        ? i[o].push(J8(t, new u(), r, e))
        : Lo(i[o])
          ? J8(t, i[o], r, e)
          : ((i[o] = J8(t, new u(), r, e)),
            u.fieldWrapper &&
              !e.oneof &&
              !e.repeated &&
              (i[o] = u.fieldWrapper.unwrapField(i[o])))
      break
    case "map":
      let [d, m] = dkt(e, t, r)
      i[o][d] = m
      break
  }
}
function J8(i, t, e, s) {
  const r = t.getType().runtime.bin,
    a = s?.delimited
  return r.readMessage(t, i, a ? s.no : i.uint32(), e, a), t
}
function dkt(i, t, e) {
  const s = t.uint32(),
    r = t.pos + s
  let a, o
  for (; t.pos < r; ) {
    const [c] = t.tag()
    switch (c) {
      case 1:
        a = L8(t, i.K)
        break
      case 2:
        switch (i.V.kind) {
          case "scalar":
            o = L8(t, i.V.T)
            break
          case "enum":
            o = t.int32()
            break
          case "message":
            o = J8(t, new i.V.T(), e, void 0)
            break
        }
        break
    }
  }
  if (
    (a === void 0 && (a = $l(i.K, wa.BIGINT)),
    typeof a != "string" && typeof a != "number" && (a = a.toString()),
    o === void 0)
  )
    switch (i.V.kind) {
      case "scalar":
        o = $l(i.V.T, wa.BIGINT)
        break
      case "enum":
        o = i.V.T.values[0].no
        break
      case "message":
        o = new i.V.T()
        break
    }
  return [a, o]
}
function mkt(i, t) {
  const e = L8(i, t)
  return typeof e == "bigint" ? e.toString() : e
}
function L8(i, t) {
  switch (t) {
    case B.STRING:
      return i.string()
    case B.BOOL:
      return i.bool()
    case B.DOUBLE:
      return i.double()
    case B.FLOAT:
      return i.float()
    case B.INT32:
      return i.int32()
    case B.INT64:
      return i.int64()
    case B.UINT64:
      return i.uint64()
    case B.FIXED64:
      return i.fixed64()
    case B.BYTES:
      return i.bytes()
    case B.FIXED32:
      return i.fixed32()
    case B.SFIXED32:
      return i.sfixed32()
    case B.SFIXED64:
      return i.sfixed64()
    case B.SINT64:
      return i.sint64()
    case B.UINT32:
      return i.uint32()
    case B.SINT32:
      return i.sint32()
  }
}
function Tet(i, t, e, s) {
  ze(t !== void 0)
  const r = i.repeated
  switch (i.kind) {
    case "scalar":
    case "enum":
      let a = i.kind == "enum" ? B.INT32 : i.T
      if (r)
        if ((ze(Array.isArray(t)), i.packed)) pkt(e, a, i.no, t)
        else for (const o of t) Ed(e, a, i.no, o)
      else Ed(e, a, i.no, t)
      break
    case "message":
      if (r) {
        ze(Array.isArray(t))
        for (const o of t) ket(e, s, i, o)
      } else ket(e, s, i, t)
      break
    case "map":
      ze(typeof t == "object" && t != null)
      for (const [o, c] of Object.entries(t)) fkt(e, s, i, o, c)
      break
  }
}
function fkt(i, t, e, s, r) {
  i.tag(e.no, ri.LengthDelimited), i.fork()
  let a = s
  switch (e.K) {
    case B.INT32:
    case B.FIXED32:
    case B.UINT32:
    case B.SFIXED32:
    case B.SINT32:
      a = Number.parseInt(s)
      break
    case B.BOOL:
      ze(s == "true" || s == "false"), (a = s == "true")
      break
  }
  switch ((Ed(i, e.K, 1, a), e.V.kind)) {
    case "scalar":
      Ed(i, e.V.T, 2, r)
      break
    case "enum":
      Ed(i, B.INT32, 2, r)
      break
    case "message":
      ze(r !== void 0), i.tag(2, ri.LengthDelimited).bytes(r.toBinary(t))
      break
  }
  i.join()
}
function ket(i, t, e, s) {
  const r = met(e.T, s)
  e.delimited
    ? i.tag(e.no, ri.StartGroup).raw(r.toBinary(t)).tag(e.no, ri.EndGroup)
    : i.tag(e.no, ri.LengthDelimited).bytes(r.toBinary(t))
}
function Ed(i, t, e, s) {
  ze(s !== void 0)
  let [r, a] = Eet(t)
  i.tag(e, r)[a](s)
}
function pkt(i, t, e, s) {
  if (!s.length) return
  i.tag(e, ri.LengthDelimited).fork()
  let [, r] = Eet(t)
  for (let a = 0; a < s.length; a++) i[r](s[a])
  i.join()
}
function Eet(i) {
  let t = ri.Varint
  switch (i) {
    case B.BYTES:
    case B.STRING:
      t = ri.LengthDelimited
      break
    case B.DOUBLE:
    case B.FIXED64:
    case B.SFIXED64:
      t = ri.Bit64
      break
    case B.FIXED32:
    case B.SFIXED32:
    case B.FLOAT:
      t = ri.Bit32
      break
  }
  const e = B[i].toLowerCase()
  return [t, e]
}
function gkt() {
  return {
    setEnumType: Xtt,
    initPartial(i, t) {
      if (i === void 0) return
      const e = t.getType()
      for (const s of e.fields.byMember()) {
        const r = s.localName,
          a = t,
          o = i
        if (o[r] != null)
          switch (s.kind) {
            case "oneof":
              const c = o[r].case
              if (c === void 0) continue
              const l = s.findField(c)
              let u = o[r].value
              l && l.kind == "message" && !Lo(u, l.T)
                ? (u = new l.T(u))
                : l && l.kind === "scalar" && l.T === B.BYTES && (u = Id(u)),
                (a[r] = { case: c, value: u })
              break
            case "scalar":
            case "enum":
              let d = o[r]
              s.T === B.BYTES && (d = s.repeated ? d.map(Id) : Id(d)),
                (a[r] = d)
              break
            case "map":
              switch (s.V.kind) {
                case "scalar":
                case "enum":
                  if (s.V.T === B.BYTES)
                    for (const [p, v] of Object.entries(o[r])) a[r][p] = Id(v)
                  else Object.assign(a[r], o[r])
                  break
                case "message":
                  const f = s.V.T
                  for (const p of Object.keys(o[r])) {
                    let v = o[r][p]
                    f.fieldWrapper || (v = new f(v)), (a[r][p] = v)
                  }
                  break
              }
              break
            case "message":
              const m = s.T
              if (s.repeated) a[r] = o[r].map((f) => (Lo(f, m) ? f : new m(f)))
              else {
                const f = o[r]
                m.fieldWrapper
                  ? m.typeName === "google.protobuf.BytesValue"
                    ? (a[r] = Id(f))
                    : (a[r] = f)
                  : (a[r] = Lo(f, m) ? f : new m(f))
              }
              break
          }
      }
    },
    equals(i, t, e) {
      return t === e
        ? !0
        : !t || !e
          ? !1
          : i.fields.byMember().every((s) => {
              const r = t[s.localName],
                a = e[s.localName]
              if (s.repeated) {
                if (r.length !== a.length) return !1
                switch (s.kind) {
                  case "message":
                    return r.every((o, c) => s.T.equals(o, a[c]))
                  case "scalar":
                    return r.every((o, c) => ya(s.T, o, a[c]))
                  case "enum":
                    return r.every((o, c) => ya(B.INT32, o, a[c]))
                }
                throw new Error(`repeated cannot contain ${s.kind}`)
              }
              switch (s.kind) {
                case "message":
                  return s.T.equals(r, a)
                case "enum":
                  return ya(B.INT32, r, a)
                case "scalar":
                  return ya(s.T, r, a)
                case "oneof":
                  if (r.case !== a.case) return !1
                  const o = s.findField(r.case)
                  if (o === void 0) return !0
                  switch (o.kind) {
                    case "message":
                      return o.T.equals(r.value, a.value)
                    case "enum":
                      return ya(B.INT32, r.value, a.value)
                    case "scalar":
                      return ya(o.T, r.value, a.value)
                  }
                  throw new Error(`oneof cannot contain ${o.kind}`)
                case "map":
                  const c = Object.keys(r).concat(Object.keys(a))
                  switch (s.V.kind) {
                    case "message":
                      const l = s.V.T
                      return c.every((d) => l.equals(r[d], a[d]))
                    case "enum":
                      return c.every((d) => ya(B.INT32, r[d], a[d]))
                    case "scalar":
                      const u = s.V.T
                      return c.every((d) => ya(u, r[d], a[d]))
                  }
                  break
              }
            })
    },
    clone(i) {
      const t = i.getType(),
        e = new t(),
        s = e
      for (const r of t.fields.byMember()) {
        const a = i[r.localName]
        let o
        if (r.repeated) o = a.map(R8)
        else if (r.kind == "map") {
          o = s[r.localName]
          for (const [c, l] of Object.entries(a)) o[c] = R8(l)
        } else
          r.kind == "oneof"
            ? (o = r.findField(a.case)
                ? { case: a.case, value: R8(a.value) }
                : { case: void 0 })
            : (o = R8(a))
        s[r.localName] = o
      }
      for (const r of t.runtime.bin.listUnknownFields(i))
        t.runtime.bin.onUnknownField(s, r.no, r.wireType, r.data)
      return e
    },
  }
}
function R8(i) {
  if (i === void 0) return i
  if (Lo(i)) return i.clone()
  if (i instanceof Uint8Array) {
    const t = new Uint8Array(i.byteLength)
    return t.set(i), t
  }
  return i
}
function Id(i) {
  return i instanceof Uint8Array ? i : new Uint8Array(i)
}
function Iet(i, t, e) {
  return {
    syntax: i,
    json: rkt(),
    bin: hkt(),
    util: { ...gkt(), newFieldList: t, initFields: e },
    makeMessageType(s, r, a) {
      return jTt(this, s, r, a)
    },
    makeEnum: WTt,
    makeEnumType: Ktt,
    getEnumType: Qtt,
    makeExtension(s, r, a) {
      return XTt(this, s, r, a)
    },
  }
}
var Pet = class {
  constructor(i, t) {
    ;(this._fields = i), (this._normalizer = t)
  }
  findJsonName(i) {
    if (!this.jsonNames) {
      const t = {}
      for (const e of this.list()) t[e.jsonName] = t[e.name] = e
      this.jsonNames = t
    }
    return this.jsonNames[i]
  }
  find(i) {
    if (!this.numbers) {
      const t = {}
      for (const e of this.list()) t[e.no] = e
      this.numbers = t
    }
    return this.numbers[i]
  }
  list() {
    return this.all || (this.all = this._normalizer(this._fields)), this.all
  }
  byNumber() {
    return (
      this.numbersAsc ||
        (this.numbersAsc = this.list()
          .concat()
          .sort((i, t) => i.no - t.no)),
      this.numbersAsc
    )
  }
  byMember() {
    if (!this.members) {
      this.members = []
      const i = this.members
      let t
      for (const e of this.list())
        e.oneof ? e.oneof !== t && ((t = e.oneof), i.push(t)) : i.push(e)
    }
    return this.members
  }
}
function $et(i, t) {
  const e = xet(i)
  return t ? e : kkt(Tkt(e))
}
function vkt(i) {
  return $et(i, !1)
}
var wkt = xet
function xet(i) {
  let t = !1
  const e = []
  for (let s = 0; s < i.length; s++) {
    let r = i.charAt(s)
    switch (r) {
      case "_":
        t = !0
        break
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        e.push(r), (t = !1)
        break
      default:
        t && ((t = !1), (r = r.toUpperCase())), e.push(r)
        break
    }
  }
  return e.join("")
}
var ykt = new Set(["constructor", "toString", "toJSON", "valueOf"]),
  bkt = new Set([
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    "toObject",
  ]),
  Net = (i) => `${i}$`,
  Tkt = (i) => (bkt.has(i) ? Net(i) : i),
  kkt = (i) => (ykt.has(i) ? Net(i) : i),
  Skt = class {
    constructor(i) {
      ;(this.kind = "oneof"),
        (this.repeated = !1),
        (this.packed = !1),
        (this.opt = !1),
        (this.req = !1),
        (this.default = void 0),
        (this.fields = []),
        (this.name = i),
        (this.localName = vkt(i))
    }
    addField(i) {
      ze(i.oneof === this, `field ${i.name} not one of ${this.name}`),
        this.fields.push(i)
    }
    findField(i) {
      if (!this._lookup) {
        this._lookup = Object.create(null)
        for (let t = 0; t < this.fields.length; t++)
          this._lookup[this.fields[t].localName] = this.fields[t]
      }
      return this._lookup[i]
    }
  }
function Cet(i, t) {
  const e = []
  let s
  for (const r of typeof i == "function" ? i() : i) {
    const a = r
    if (
      ((a.localName = $et(r.name, r.oneof !== void 0)),
      (a.jsonName = r.jsonName ?? wkt(r.name)),
      (a.repeated = r.repeated ?? !1),
      r.kind == "scalar" && (a.L = r.L ?? wa.BIGINT),
      (a.delimited = r.delimited ?? !1),
      (a.req = r.req ?? !1),
      (a.opt = r.opt ?? !1),
      r.packed === void 0 &&
        (t
          ? (a.packed =
              r.kind == "enum" ||
              (r.kind == "scalar" && r.T != B.BYTES && r.T != B.STRING))
          : (a.packed = !1)),
      r.oneof !== void 0)
    ) {
      const o = typeof r.oneof == "string" ? r.oneof : r.oneof.name
      ;(!s || s.name != o) && (s = new Skt(o)), (a.oneof = s), s.addField(a)
    }
    e.push(a)
  }
  return e
}
var n = Iet(
    "proto3",
    (i) => new Pet(i, (t) => Cet(t, !0)),
    (i) => {
      for (const t of i.getType().fields.byMember()) {
        if (t.opt) continue
        const e = t.localName,
          s = i
        if (t.repeated) {
          s[e] = []
          continue
        }
        switch (t.kind) {
          case "oneof":
            s[e] = { case: void 0 }
            break
          case "enum":
            s[e] = 0
            break
          case "map":
            s[e] = {}
            break
          case "scalar":
            s[e] = $l(t.T, t.L)
            break
          case "message":
            break
        }
      }
    },
  ),
  L = Iet(
    "proto2",
    (i) => new Pet(i, (t) => Cet(t, !1)),
    (i) => {
      for (const t of i.getType().fields.byMember()) {
        const e = t.localName,
          s = i
        if (t.repeated) {
          s[e] = []
          continue
        }
        switch (t.kind) {
          case "oneof":
            s[e] = { case: void 0 }
            break
          case "map":
            s[e] = {}
            break
          case "scalar":
          case "enum":
          case "message":
            break
        }
      }
    },
  ),
  gzt = {
    NaN: Number.NaN,
    POSITIVE_INFINITY: Number.POSITIVE_INFINITY,
    NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY,
  },
  I
;(function (i) {
  ;(i[(i.Unary = 0)] = "Unary"),
    (i[(i.ServerStreaming = 1)] = "ServerStreaming"),
    (i[(i.ClientStreaming = 2)] = "ClientStreaming"),
    (i[(i.BiDiStreaming = 3)] = "BiDiStreaming")
})(I || (I = {}))
var Jet
;(function (i) {
  ;(i[(i.NoSideEffects = 1)] = "NoSideEffects"),
    (i[(i.Idempotent = 2)] = "Idempotent")
})(Jet || (Jet = {}))
var lr
;(function (i) {
  ;(i[(i.EDITION_UNKNOWN = 0)] = "EDITION_UNKNOWN"),
    (i[(i.EDITION_LEGACY = 900)] = "EDITION_LEGACY"),
    (i[(i.EDITION_PROTO2 = 998)] = "EDITION_PROTO2"),
    (i[(i.EDITION_PROTO3 = 999)] = "EDITION_PROTO3"),
    (i[(i.EDITION_2023 = 1e3)] = "EDITION_2023"),
    (i[(i.EDITION_2024 = 1001)] = "EDITION_2024"),
    (i[(i.EDITION_1_TEST_ONLY = 1)] = "EDITION_1_TEST_ONLY"),
    (i[(i.EDITION_2_TEST_ONLY = 2)] = "EDITION_2_TEST_ONLY"),
    (i[(i.EDITION_99997_TEST_ONLY = 99997)] = "EDITION_99997_TEST_ONLY"),
    (i[(i.EDITION_99998_TEST_ONLY = 99998)] = "EDITION_99998_TEST_ONLY"),
    (i[(i.EDITION_99999_TEST_ONLY = 99999)] = "EDITION_99999_TEST_ONLY"),
    (i[(i.EDITION_MAX = 2147483647)] = "EDITION_MAX")
})(lr || (lr = {})),
  L.util.setEnumType(lr, "google.protobuf.Edition", [
    { no: 0, name: "EDITION_UNKNOWN" },
    { no: 900, name: "EDITION_LEGACY" },
    { no: 998, name: "EDITION_PROTO2" },
    { no: 999, name: "EDITION_PROTO3" },
    { no: 1e3, name: "EDITION_2023" },
    { no: 1001, name: "EDITION_2024" },
    { no: 1, name: "EDITION_1_TEST_ONLY" },
    { no: 2, name: "EDITION_2_TEST_ONLY" },
    { no: 99997, name: "EDITION_99997_TEST_ONLY" },
    { no: 99998, name: "EDITION_99998_TEST_ONLY" },
    { no: 99999, name: "EDITION_99999_TEST_ONLY" },
    { no: 2147483647, name: "EDITION_MAX" },
  ])
var vzt = class ip extends h {
    constructor(t) {
      super(), (this.file = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.FileDescriptorSet"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: kM, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ip().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ip().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ip().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(ip, t, e)
    }
  },
  kM = class sp extends h {
    constructor(t) {
      super(),
        (this.dependency = []),
        (this.publicDependency = []),
        (this.weakDependency = []),
        (this.messageType = []),
        (this.enumType = []),
        (this.service = []),
        (this.extension = []),
        L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.FileDescriptorProto"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "package", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "dependency", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 10,
          name: "public_dependency",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
        { no: 11, name: "weak_dependency", kind: "scalar", T: 5, repeated: !0 },
        { no: 4, name: "message_type", kind: "message", T: Ekt, repeated: !0 },
        { no: 5, name: "enum_type", kind: "message", T: Let, repeated: !0 },
        { no: 6, name: "service", kind: "message", T: Lkt, repeated: !0 },
        { no: 7, name: "extension", kind: "message", T: SM, repeated: !0 },
        { no: 8, name: "options", kind: "message", T: Dkt, opt: !0 },
        { no: 9, name: "source_code_info", kind: "message", T: jkt, opt: !0 },
        { no: 12, name: "syntax", kind: "scalar", T: 9, opt: !0 },
        {
          no: 14,
          name: "edition",
          kind: "enum",
          T: L.getEnumType(lr),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new sp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(sp, t, e)
    }
  },
  Ekt = class nu extends h {
    constructor(t) {
      super(),
        (this.field = []),
        (this.extension = []),
        (this.nestedType = []),
        (this.enumType = []),
        (this.extensionRange = []),
        (this.oneofDecl = []),
        (this.reservedRange = []),
        (this.reservedName = []),
        L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.DescriptorProto"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "field", kind: "message", T: SM, repeated: !0 },
        { no: 6, name: "extension", kind: "message", T: SM, repeated: !0 },
        { no: 3, name: "nested_type", kind: "message", T: nu, repeated: !0 },
        { no: 4, name: "enum_type", kind: "message", T: Let, repeated: !0 },
        {
          no: 5,
          name: "extension_range",
          kind: "message",
          T: Ikt,
          repeated: !0,
        },
        { no: 8, name: "oneof_decl", kind: "message", T: Nkt, repeated: !0 },
        { no: 7, name: "options", kind: "message", T: Fkt, opt: !0 },
        {
          no: 9,
          name: "reserved_range",
          kind: "message",
          T: Pkt,
          repeated: !0,
        },
        { no: 10, name: "reserved_name", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new nu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(nu, t, e)
    }
  },
  Ikt = class rp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.DescriptorProto.ExtensionRange"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "options", kind: "message", T: $kt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new rp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(rp, t, e)
    }
  },
  Pkt = class np extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.DescriptorProto.ReservedRange"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new np().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new np().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new np().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(np, t, e)
    }
  },
  $kt = class ap extends h {
    constructor(t) {
      super(),
        (this.uninterpretedOption = []),
        (this.declaration = []),
        L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.ExtensionRangeOptions"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: En,
          repeated: !0,
        },
        { no: 2, name: "declaration", kind: "message", T: xkt, repeated: !0 },
        { no: 50, name: "features", kind: "message", T: ur, opt: !0 },
        {
          no: 3,
          name: "verification",
          kind: "enum",
          T: L.getEnumType(Pd),
          opt: !0,
          default: Pd.UNVERIFIED,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ap().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ap().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ap().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(ap, t, e)
    }
  },
  Pd
;(function (i) {
  ;(i[(i.DECLARATION = 0)] = "DECLARATION"),
    (i[(i.UNVERIFIED = 1)] = "UNVERIFIED")
})(Pd || (Pd = {})),
  L.util.setEnumType(
    Pd,
    "google.protobuf.ExtensionRangeOptions.VerificationState",
    [
      { no: 0, name: "DECLARATION" },
      { no: 1, name: "UNVERIFIED" },
    ],
  )
var xkt = class op extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.ExtensionRangeOptions.Declaration"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "number", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "full_name", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "type", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "reserved", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "repeated", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new op().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new op().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new op().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(op, t, e)
    }
  },
  SM = class cp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.FieldDescriptorProto"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "number", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "label", kind: "enum", T: L.getEnumType(D8), opt: !0 },
        { no: 5, name: "type", kind: "enum", T: L.getEnumType(Ye), opt: !0 },
        { no: 6, name: "type_name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "extendee", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "default_value", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "oneof_index", kind: "scalar", T: 5, opt: !0 },
        { no: 10, name: "json_name", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "options", kind: "message", T: Akt, opt: !0 },
        { no: 17, name: "proto3_optional", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new cp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(cp, t, e)
    }
  },
  Ye
;(function (i) {
  ;(i[(i.DOUBLE = 1)] = "DOUBLE"),
    (i[(i.FLOAT = 2)] = "FLOAT"),
    (i[(i.INT64 = 3)] = "INT64"),
    (i[(i.UINT64 = 4)] = "UINT64"),
    (i[(i.INT32 = 5)] = "INT32"),
    (i[(i.FIXED64 = 6)] = "FIXED64"),
    (i[(i.FIXED32 = 7)] = "FIXED32"),
    (i[(i.BOOL = 8)] = "BOOL"),
    (i[(i.STRING = 9)] = "STRING"),
    (i[(i.GROUP = 10)] = "GROUP"),
    (i[(i.MESSAGE = 11)] = "MESSAGE"),
    (i[(i.BYTES = 12)] = "BYTES"),
    (i[(i.UINT32 = 13)] = "UINT32"),
    (i[(i.ENUM = 14)] = "ENUM"),
    (i[(i.SFIXED32 = 15)] = "SFIXED32"),
    (i[(i.SFIXED64 = 16)] = "SFIXED64"),
    (i[(i.SINT32 = 17)] = "SINT32"),
    (i[(i.SINT64 = 18)] = "SINT64")
})(Ye || (Ye = {})),
  L.util.setEnumType(Ye, "google.protobuf.FieldDescriptorProto.Type", [
    { no: 1, name: "TYPE_DOUBLE" },
    { no: 2, name: "TYPE_FLOAT" },
    { no: 3, name: "TYPE_INT64" },
    { no: 4, name: "TYPE_UINT64" },
    { no: 5, name: "TYPE_INT32" },
    { no: 6, name: "TYPE_FIXED64" },
    { no: 7, name: "TYPE_FIXED32" },
    { no: 8, name: "TYPE_BOOL" },
    { no: 9, name: "TYPE_STRING" },
    { no: 10, name: "TYPE_GROUP" },
    { no: 11, name: "TYPE_MESSAGE" },
    { no: 12, name: "TYPE_BYTES" },
    { no: 13, name: "TYPE_UINT32" },
    { no: 14, name: "TYPE_ENUM" },
    { no: 15, name: "TYPE_SFIXED32" },
    { no: 16, name: "TYPE_SFIXED64" },
    { no: 17, name: "TYPE_SINT32" },
    { no: 18, name: "TYPE_SINT64" },
  ])
var D8
;(function (i) {
  ;(i[(i.OPTIONAL = 1)] = "OPTIONAL"),
    (i[(i.REPEATED = 3)] = "REPEATED"),
    (i[(i.REQUIRED = 2)] = "REQUIRED")
})(D8 || (D8 = {})),
  L.util.setEnumType(D8, "google.protobuf.FieldDescriptorProto.Label", [
    { no: 1, name: "LABEL_OPTIONAL" },
    { no: 3, name: "LABEL_REPEATED" },
    { no: 2, name: "LABEL_REQUIRED" },
  ])
var Nkt = class lp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.OneofDescriptorProto"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "options", kind: "message", T: Okt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(lp, t, e)
    }
  },
  Let = class up extends h {
    constructor(t) {
      super(),
        (this.value = []),
        (this.reservedRange = []),
        (this.reservedName = []),
        L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.EnumDescriptorProto"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "value", kind: "message", T: Jkt, repeated: !0 },
        { no: 3, name: "options", kind: "message", T: Bkt, opt: !0 },
        {
          no: 4,
          name: "reserved_range",
          kind: "message",
          T: Ckt,
          repeated: !0,
        },
        { no: 5, name: "reserved_name", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new up().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new up().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new up().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(up, t, e)
    }
  },
  Ckt = class hp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.EnumDescriptorProto.EnumReservedRange"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(hp, t, e)
    }
  },
  Jkt = class dp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.EnumValueDescriptorProto"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "number", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "options", kind: "message", T: qkt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new dp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(dp, t, e)
    }
  },
  Lkt = class mp extends h {
    constructor(t) {
      super(), (this.method = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.ServiceDescriptorProto"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "method", kind: "message", T: Rkt, repeated: !0 },
        { no: 3, name: "options", kind: "message", T: Ukt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(mp, t, e)
    }
  },
  Rkt = class fp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.MethodDescriptorProto"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "input_type", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "output_type", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "options", kind: "message", T: Mkt, opt: !0 },
        {
          no: 5,
          name: "client_streaming",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 6,
          name: "server_streaming",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
      ])
    }
    static fromBinary(t, e) {
      return new fp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(fp, t, e)
    }
  },
  Dkt = class pp extends h {
    constructor(t) {
      super(), (this.uninterpretedOption = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.FileOptions"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "java_package", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "java_outer_classname", kind: "scalar", T: 9, opt: !0 },
        {
          no: 10,
          name: "java_multiple_files",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 20,
          name: "java_generate_equals_and_hash",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 27,
          name: "java_string_check_utf8",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 9,
          name: "optimize_for",
          kind: "enum",
          T: L.getEnumType($d),
          opt: !0,
          default: $d.SPEED,
        },
        { no: 11, name: "go_package", kind: "scalar", T: 9, opt: !0 },
        {
          no: 16,
          name: "cc_generic_services",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 17,
          name: "java_generic_services",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 18,
          name: "py_generic_services",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 23,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 31,
          name: "cc_enable_arenas",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !0,
        },
        { no: 36, name: "objc_class_prefix", kind: "scalar", T: 9, opt: !0 },
        { no: 37, name: "csharp_namespace", kind: "scalar", T: 9, opt: !0 },
        { no: 39, name: "swift_prefix", kind: "scalar", T: 9, opt: !0 },
        { no: 40, name: "php_class_prefix", kind: "scalar", T: 9, opt: !0 },
        { no: 41, name: "php_namespace", kind: "scalar", T: 9, opt: !0 },
        {
          no: 44,
          name: "php_metadata_namespace",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 45, name: "ruby_package", kind: "scalar", T: 9, opt: !0 },
        { no: 50, name: "features", kind: "message", T: ur, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: En,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new pp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(pp, t, e)
    }
  },
  $d
;(function (i) {
  ;(i[(i.SPEED = 1)] = "SPEED"),
    (i[(i.CODE_SIZE = 2)] = "CODE_SIZE"),
    (i[(i.LITE_RUNTIME = 3)] = "LITE_RUNTIME")
})($d || ($d = {})),
  L.util.setEnumType($d, "google.protobuf.FileOptions.OptimizeMode", [
    { no: 1, name: "SPEED" },
    { no: 2, name: "CODE_SIZE" },
    { no: 3, name: "LITE_RUNTIME" },
  ])
var Fkt = class gp extends h {
    constructor(t) {
      super(), (this.uninterpretedOption = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.MessageOptions"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        {
          no: 1,
          name: "message_set_wire_format",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 2,
          name: "no_standard_descriptor_accessor",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 3,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        { no: 7, name: "map_entry", kind: "scalar", T: 8, opt: !0 },
        {
          no: 11,
          name: "deprecated_legacy_json_field_conflicts",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 12, name: "features", kind: "message", T: ur, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: En,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new gp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(gp, t, e)
    }
  },
  Akt = class vp extends h {
    constructor(t) {
      super(),
        (this.targets = []),
        (this.editionDefaults = []),
        (this.uninterpretedOption = []),
        L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.FieldOptions"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        {
          no: 1,
          name: "ctype",
          kind: "enum",
          T: L.getEnumType(xd),
          opt: !0,
          default: xd.STRING,
        },
        { no: 2, name: "packed", kind: "scalar", T: 8, opt: !0 },
        {
          no: 6,
          name: "jstype",
          kind: "enum",
          T: L.getEnumType(Nd),
          opt: !0,
          default: Nd.JS_NORMAL,
        },
        { no: 5, name: "lazy", kind: "scalar", T: 8, opt: !0, default: !1 },
        {
          no: 15,
          name: "unverified_lazy",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 3,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        { no: 10, name: "weak", kind: "scalar", T: 8, opt: !0, default: !1 },
        {
          no: 16,
          name: "debug_redact",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 17,
          name: "retention",
          kind: "enum",
          T: L.getEnumType(F8),
          opt: !0,
        },
        {
          no: 19,
          name: "targets",
          kind: "enum",
          T: L.getEnumType(A8),
          repeated: !0,
        },
        {
          no: 20,
          name: "edition_defaults",
          kind: "message",
          T: _kt,
          repeated: !0,
        },
        { no: 21, name: "features", kind: "message", T: ur, opt: !0 },
        { no: 22, name: "feature_support", kind: "message", T: Ret, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: En,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(vp, t, e)
    }
  },
  xd
;(function (i) {
  ;(i[(i.STRING = 0)] = "STRING"),
    (i[(i.CORD = 1)] = "CORD"),
    (i[(i.STRING_PIECE = 2)] = "STRING_PIECE")
})(xd || (xd = {})),
  L.util.setEnumType(xd, "google.protobuf.FieldOptions.CType", [
    { no: 0, name: "STRING" },
    { no: 1, name: "CORD" },
    { no: 2, name: "STRING_PIECE" },
  ])
var Nd
;(function (i) {
  ;(i[(i.JS_NORMAL = 0)] = "JS_NORMAL"),
    (i[(i.JS_STRING = 1)] = "JS_STRING"),
    (i[(i.JS_NUMBER = 2)] = "JS_NUMBER")
})(Nd || (Nd = {})),
  L.util.setEnumType(Nd, "google.protobuf.FieldOptions.JSType", [
    { no: 0, name: "JS_NORMAL" },
    { no: 1, name: "JS_STRING" },
    { no: 2, name: "JS_NUMBER" },
  ])
var F8
;(function (i) {
  ;(i[(i.RETENTION_UNKNOWN = 0)] = "RETENTION_UNKNOWN"),
    (i[(i.RETENTION_RUNTIME = 1)] = "RETENTION_RUNTIME"),
    (i[(i.RETENTION_SOURCE = 2)] = "RETENTION_SOURCE")
})(F8 || (F8 = {})),
  L.util.setEnumType(F8, "google.protobuf.FieldOptions.OptionRetention", [
    { no: 0, name: "RETENTION_UNKNOWN" },
    { no: 1, name: "RETENTION_RUNTIME" },
    { no: 2, name: "RETENTION_SOURCE" },
  ])
var A8
;(function (i) {
  ;(i[(i.TARGET_TYPE_UNKNOWN = 0)] = "TARGET_TYPE_UNKNOWN"),
    (i[(i.TARGET_TYPE_FILE = 1)] = "TARGET_TYPE_FILE"),
    (i[(i.TARGET_TYPE_EXTENSION_RANGE = 2)] = "TARGET_TYPE_EXTENSION_RANGE"),
    (i[(i.TARGET_TYPE_MESSAGE = 3)] = "TARGET_TYPE_MESSAGE"),
    (i[(i.TARGET_TYPE_FIELD = 4)] = "TARGET_TYPE_FIELD"),
    (i[(i.TARGET_TYPE_ONEOF = 5)] = "TARGET_TYPE_ONEOF"),
    (i[(i.TARGET_TYPE_ENUM = 6)] = "TARGET_TYPE_ENUM"),
    (i[(i.TARGET_TYPE_ENUM_ENTRY = 7)] = "TARGET_TYPE_ENUM_ENTRY"),
    (i[(i.TARGET_TYPE_SERVICE = 8)] = "TARGET_TYPE_SERVICE"),
    (i[(i.TARGET_TYPE_METHOD = 9)] = "TARGET_TYPE_METHOD")
})(A8 || (A8 = {})),
  L.util.setEnumType(A8, "google.protobuf.FieldOptions.OptionTargetType", [
    { no: 0, name: "TARGET_TYPE_UNKNOWN" },
    { no: 1, name: "TARGET_TYPE_FILE" },
    { no: 2, name: "TARGET_TYPE_EXTENSION_RANGE" },
    { no: 3, name: "TARGET_TYPE_MESSAGE" },
    { no: 4, name: "TARGET_TYPE_FIELD" },
    { no: 5, name: "TARGET_TYPE_ONEOF" },
    { no: 6, name: "TARGET_TYPE_ENUM" },
    { no: 7, name: "TARGET_TYPE_ENUM_ENTRY" },
    { no: 8, name: "TARGET_TYPE_SERVICE" },
    { no: 9, name: "TARGET_TYPE_METHOD" },
  ])
var _kt = class wp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.FieldOptions.EditionDefault"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 3, name: "edition", kind: "enum", T: L.getEnumType(lr), opt: !0 },
        { no: 2, name: "value", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(wp, t, e)
    }
  },
  Ret = class yp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.FieldOptions.FeatureSupport"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        {
          no: 1,
          name: "edition_introduced",
          kind: "enum",
          T: L.getEnumType(lr),
          opt: !0,
        },
        {
          no: 2,
          name: "edition_deprecated",
          kind: "enum",
          T: L.getEnumType(lr),
          opt: !0,
        },
        { no: 3, name: "deprecation_warning", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "edition_removed",
          kind: "enum",
          T: L.getEnumType(lr),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new yp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(yp, t, e)
    }
  },
  Okt = class bp extends h {
    constructor(t) {
      super(), (this.uninterpretedOption = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.OneofOptions"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "features", kind: "message", T: ur, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: En,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new bp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(bp, t, e)
    }
  },
  Bkt = class Tp extends h {
    constructor(t) {
      super(), (this.uninterpretedOption = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.EnumOptions"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 2, name: "allow_alias", kind: "scalar", T: 8, opt: !0 },
        {
          no: 3,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 6,
          name: "deprecated_legacy_json_field_conflicts",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 7, name: "features", kind: "message", T: ur, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: En,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Tp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Tp, t, e)
    }
  },
  qkt = class kp extends h {
    constructor(t) {
      super(), (this.uninterpretedOption = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.EnumValueOptions"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        {
          no: 1,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        { no: 2, name: "features", kind: "message", T: ur, opt: !0 },
        {
          no: 3,
          name: "debug_redact",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        { no: 4, name: "feature_support", kind: "message", T: Ret, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: En,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new kp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(kp, t, e)
    }
  },
  Ukt = class Sp extends h {
    constructor(t) {
      super(), (this.uninterpretedOption = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.ServiceOptions"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 34, name: "features", kind: "message", T: ur, opt: !0 },
        {
          no: 33,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: En,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Sp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Sp, t, e)
    }
  },
  Mkt = class Ep extends h {
    constructor(t) {
      super(), (this.uninterpretedOption = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.MethodOptions"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        {
          no: 33,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 34,
          name: "idempotency_level",
          kind: "enum",
          T: L.getEnumType(Cd),
          opt: !0,
          default: Cd.IDEMPOTENCY_UNKNOWN,
        },
        { no: 35, name: "features", kind: "message", T: ur, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: En,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Ep().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ep().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ep().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Ep, t, e)
    }
  },
  Cd
;(function (i) {
  ;(i[(i.IDEMPOTENCY_UNKNOWN = 0)] = "IDEMPOTENCY_UNKNOWN"),
    (i[(i.NO_SIDE_EFFECTS = 1)] = "NO_SIDE_EFFECTS"),
    (i[(i.IDEMPOTENT = 2)] = "IDEMPOTENT")
})(Cd || (Cd = {})),
  L.util.setEnumType(Cd, "google.protobuf.MethodOptions.IdempotencyLevel", [
    { no: 0, name: "IDEMPOTENCY_UNKNOWN" },
    { no: 1, name: "NO_SIDE_EFFECTS" },
    { no: 2, name: "IDEMPOTENT" },
  ])
var En = class Ip extends h {
    constructor(t) {
      super(), (this.name = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.UninterpretedOption"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 2, name: "name", kind: "message", T: Hkt, repeated: !0 },
        { no: 3, name: "identifier_value", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "positive_int_value", kind: "scalar", T: 4, opt: !0 },
        { no: 5, name: "negative_int_value", kind: "scalar", T: 3, opt: !0 },
        { no: 6, name: "double_value", kind: "scalar", T: 1, opt: !0 },
        { no: 7, name: "string_value", kind: "scalar", T: 12, opt: !0 },
        { no: 8, name: "aggregate_value", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ip().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ip().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ip().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Ip, t, e)
    }
  },
  Hkt = class Pp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.UninterpretedOption.NamePart"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name_part", kind: "scalar", T: 9, req: !0 },
        { no: 2, name: "is_extension", kind: "scalar", T: 8, req: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Pp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Pp, t, e)
    }
  },
  ur = class $p extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.FeatureSet"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        {
          no: 1,
          name: "field_presence",
          kind: "enum",
          T: L.getEnumType(_8),
          opt: !0,
        },
        {
          no: 2,
          name: "enum_type",
          kind: "enum",
          T: L.getEnumType(O8),
          opt: !0,
        },
        {
          no: 3,
          name: "repeated_field_encoding",
          kind: "enum",
          T: L.getEnumType(B8),
          opt: !0,
        },
        {
          no: 4,
          name: "utf8_validation",
          kind: "enum",
          T: L.getEnumType(q8),
          opt: !0,
        },
        {
          no: 5,
          name: "message_encoding",
          kind: "enum",
          T: L.getEnumType(U8),
          opt: !0,
        },
        {
          no: 6,
          name: "json_format",
          kind: "enum",
          T: L.getEnumType(M8),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new $p().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $p().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $p().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals($p, t, e)
    }
  },
  _8
;(function (i) {
  ;(i[(i.FIELD_PRESENCE_UNKNOWN = 0)] = "FIELD_PRESENCE_UNKNOWN"),
    (i[(i.EXPLICIT = 1)] = "EXPLICIT"),
    (i[(i.IMPLICIT = 2)] = "IMPLICIT"),
    (i[(i.LEGACY_REQUIRED = 3)] = "LEGACY_REQUIRED")
})(_8 || (_8 = {})),
  L.util.setEnumType(_8, "google.protobuf.FeatureSet.FieldPresence", [
    { no: 0, name: "FIELD_PRESENCE_UNKNOWN" },
    { no: 1, name: "EXPLICIT" },
    { no: 2, name: "IMPLICIT" },
    { no: 3, name: "LEGACY_REQUIRED" },
  ])
var O8
;(function (i) {
  ;(i[(i.ENUM_TYPE_UNKNOWN = 0)] = "ENUM_TYPE_UNKNOWN"),
    (i[(i.OPEN = 1)] = "OPEN"),
    (i[(i.CLOSED = 2)] = "CLOSED")
})(O8 || (O8 = {})),
  L.util.setEnumType(O8, "google.protobuf.FeatureSet.EnumType", [
    { no: 0, name: "ENUM_TYPE_UNKNOWN" },
    { no: 1, name: "OPEN" },
    { no: 2, name: "CLOSED" },
  ])
var B8
;(function (i) {
  ;(i[(i.REPEATED_FIELD_ENCODING_UNKNOWN = 0)] =
    "REPEATED_FIELD_ENCODING_UNKNOWN"),
    (i[(i.PACKED = 1)] = "PACKED"),
    (i[(i.EXPANDED = 2)] = "EXPANDED")
})(B8 || (B8 = {})),
  L.util.setEnumType(B8, "google.protobuf.FeatureSet.RepeatedFieldEncoding", [
    { no: 0, name: "REPEATED_FIELD_ENCODING_UNKNOWN" },
    { no: 1, name: "PACKED" },
    { no: 2, name: "EXPANDED" },
  ])
var q8
;(function (i) {
  ;(i[(i.UTF8_VALIDATION_UNKNOWN = 0)] = "UTF8_VALIDATION_UNKNOWN"),
    (i[(i.VERIFY = 2)] = "VERIFY"),
    (i[(i.NONE = 3)] = "NONE")
})(q8 || (q8 = {})),
  L.util.setEnumType(q8, "google.protobuf.FeatureSet.Utf8Validation", [
    { no: 0, name: "UTF8_VALIDATION_UNKNOWN" },
    { no: 2, name: "VERIFY" },
    { no: 3, name: "NONE" },
  ])
var U8
;(function (i) {
  ;(i[(i.MESSAGE_ENCODING_UNKNOWN = 0)] = "MESSAGE_ENCODING_UNKNOWN"),
    (i[(i.LENGTH_PREFIXED = 1)] = "LENGTH_PREFIXED"),
    (i[(i.DELIMITED = 2)] = "DELIMITED")
})(U8 || (U8 = {})),
  L.util.setEnumType(U8, "google.protobuf.FeatureSet.MessageEncoding", [
    { no: 0, name: "MESSAGE_ENCODING_UNKNOWN" },
    { no: 1, name: "LENGTH_PREFIXED" },
    { no: 2, name: "DELIMITED" },
  ])
var M8
;(function (i) {
  ;(i[(i.JSON_FORMAT_UNKNOWN = 0)] = "JSON_FORMAT_UNKNOWN"),
    (i[(i.ALLOW = 1)] = "ALLOW"),
    (i[(i.LEGACY_BEST_EFFORT = 2)] = "LEGACY_BEST_EFFORT")
})(M8 || (M8 = {})),
  L.util.setEnumType(M8, "google.protobuf.FeatureSet.JsonFormat", [
    { no: 0, name: "JSON_FORMAT_UNKNOWN" },
    { no: 1, name: "ALLOW" },
    { no: 2, name: "LEGACY_BEST_EFFORT" },
  ])
var wzt = class xp extends h {
    constructor(t) {
      super(), (this.defaults = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.FeatureSetDefaults"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "defaults", kind: "message", T: Wkt, repeated: !0 },
        {
          no: 4,
          name: "minimum_edition",
          kind: "enum",
          T: L.getEnumType(lr),
          opt: !0,
        },
        {
          no: 5,
          name: "maximum_edition",
          kind: "enum",
          T: L.getEnumType(lr),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new xp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(xp, t, e)
    }
  },
  Wkt = class Np extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName =
        "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 3, name: "edition", kind: "enum", T: L.getEnumType(lr), opt: !0 },
        {
          no: 4,
          name: "overridable_features",
          kind: "message",
          T: ur,
          opt: !0,
        },
        { no: 5, name: "fixed_features", kind: "message", T: ur, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Np().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Np().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Np().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Np, t, e)
    }
  },
  jkt = class Cp extends h {
    constructor(t) {
      super(), (this.location = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.SourceCodeInfo"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "location", kind: "message", T: Vkt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Cp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Cp, t, e)
    }
  },
  Vkt = class Jp extends h {
    constructor(t) {
      super(),
        (this.path = []),
        (this.span = []),
        (this.leadingDetachedComments = []),
        L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.SourceCodeInfo.Location"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "path", kind: "scalar", T: 5, repeated: !0, packed: !0 },
        { no: 2, name: "span", kind: "scalar", T: 5, repeated: !0, packed: !0 },
        { no: 3, name: "leading_comments", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "trailing_comments", kind: "scalar", T: 9, opt: !0 },
        {
          no: 6,
          name: "leading_detached_comments",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Jp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Jp, t, e)
    }
  },
  Gkt = class Lp extends h {
    constructor(t) {
      super(), (this.annotation = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.GeneratedCodeInfo"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "annotation", kind: "message", T: zkt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Lp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Lp, t, e)
    }
  },
  zkt = class Rp extends h {
    constructor(t) {
      super(), (this.path = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.GeneratedCodeInfo.Annotation"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "path", kind: "scalar", T: 5, repeated: !0, packed: !0 },
        { no: 2, name: "source_file", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "begin", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "end", kind: "scalar", T: 5, opt: !0 },
        {
          no: 5,
          name: "semantic",
          kind: "enum",
          T: L.getEnumType(H8),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Rp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Rp, t, e)
    }
  },
  H8
;(function (i) {
  ;(i[(i.NONE = 0)] = "NONE"),
    (i[(i.SET = 1)] = "SET"),
    (i[(i.ALIAS = 2)] = "ALIAS")
})(H8 || (H8 = {})),
  L.util.setEnumType(
    H8,
    "google.protobuf.GeneratedCodeInfo.Annotation.Semantic",
    [
      { no: 0, name: "NONE" },
      { no: 1, name: "SET" },
      { no: 2, name: "ALIAS" },
    ],
  )
var yzt = {
    [Ye.DOUBLE]: B.DOUBLE,
    [Ye.FLOAT]: B.FLOAT,
    [Ye.INT64]: B.INT64,
    [Ye.UINT64]: B.UINT64,
    [Ye.INT32]: B.INT32,
    [Ye.FIXED64]: B.FIXED64,
    [Ye.FIXED32]: B.FIXED32,
    [Ye.BOOL]: B.BOOL,
    [Ye.STRING]: B.STRING,
    [Ye.GROUP]: void 0,
    [Ye.MESSAGE]: void 0,
    [Ye.BYTES]: B.BYTES,
    [Ye.UINT32]: B.UINT32,
    [Ye.ENUM]: void 0,
    [Ye.SFIXED32]: B.SFIXED32,
    [Ye.SFIXED64]: B.SFIXED64,
    [Ye.SINT32]: B.SINT32,
    [Ye.SINT64]: B.SINT64,
  },
  Det
;(function (i) {
  ;(i[(i.FileDescriptorProto_Package = 2)] = "FileDescriptorProto_Package"),
    (i[(i.FileDescriptorProto_MessageType = 4)] =
      "FileDescriptorProto_MessageType"),
    (i[(i.FileDescriptorProto_EnumType = 5)] = "FileDescriptorProto_EnumType"),
    (i[(i.FileDescriptorProto_Service = 6)] = "FileDescriptorProto_Service"),
    (i[(i.FileDescriptorProto_Extension = 7)] =
      "FileDescriptorProto_Extension"),
    (i[(i.FileDescriptorProto_Syntax = 12)] = "FileDescriptorProto_Syntax"),
    (i[(i.DescriptorProto_Field = 2)] = "DescriptorProto_Field"),
    (i[(i.DescriptorProto_NestedType = 3)] = "DescriptorProto_NestedType"),
    (i[(i.DescriptorProto_EnumType = 4)] = "DescriptorProto_EnumType"),
    (i[(i.DescriptorProto_Extension = 6)] = "DescriptorProto_Extension"),
    (i[(i.DescriptorProto_OneofDecl = 8)] = "DescriptorProto_OneofDecl"),
    (i[(i.EnumDescriptorProto_Value = 2)] = "EnumDescriptorProto_Value"),
    (i[(i.ServiceDescriptorProto_Method = 2)] = "ServiceDescriptorProto_Method")
})(Det || (Det = {}))
var Fet = class Ko extends h {
    constructor(t) {
      super(),
        (this.seconds = _e.zero),
        (this.nanos = 0),
        n.util.initPartial(t, this)
    }
    fromJson(t, e) {
      if (typeof t != "string")
        throw new Error(
          `cannot decode google.protobuf.Timestamp from JSON: ${n.json.debug(t)}`,
        )
      const s = t.match(
        /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/,
      )
      if (!s)
        throw new Error(
          "cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string",
        )
      const r = Date.parse(
        s[1] +
          "-" +
          s[2] +
          "-" +
          s[3] +
          "T" +
          s[4] +
          ":" +
          s[5] +
          ":" +
          s[6] +
          (s[8] ? s[8] : "Z"),
      )
      if (Number.isNaN(r))
        throw new Error(
          "cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string",
        )
      if (
        r < Date.parse("0001-01-01T00:00:00Z") ||
        r > Date.parse("9999-12-31T23:59:59Z")
      )
        throw new Error(
          "cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive",
        )
      return (
        (this.seconds = _e.parse(r / 1e3)),
        (this.nanos = 0),
        s[7] &&
          (this.nanos =
            parseInt("1" + s[7] + "0".repeat(9 - s[7].length)) - 1e9),
        this
      )
    }
    toJson(t) {
      const e = Number(this.seconds) * 1e3
      if (
        e < Date.parse("0001-01-01T00:00:00Z") ||
        e > Date.parse("9999-12-31T23:59:59Z")
      )
        throw new Error(
          "cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive",
        )
      if (this.nanos < 0)
        throw new Error(
          "cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative",
        )
      let s = "Z"
      if (this.nanos > 0) {
        const r = (this.nanos + 1e9).toString().substring(1)
        r.substring(3) === "000000"
          ? (s = "." + r.substring(0, 3) + "Z")
          : r.substring(6) === "000"
            ? (s = "." + r.substring(0, 6) + "Z")
            : (s = "." + r + "Z")
      }
      return new Date(e).toISOString().replace(".000Z", s)
    }
    toDate() {
      return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6))
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Timestamp"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "seconds", kind: "scalar", T: 3 },
        { no: 2, name: "nanos", kind: "scalar", T: 5 },
      ])
    }
    static now() {
      return Ko.fromDate(new Date())
    }
    static fromDate(t) {
      const e = t.getTime()
      return new Ko({
        seconds: _e.parse(Math.floor(e / 1e3)),
        nanos: (e % 1e3) * 1e6,
      })
    }
    static fromBinary(t, e) {
      return new Ko().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ko().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ko().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ko, t, e)
    }
  },
  bzt = class Dp extends h {
    constructor(t) {
      super(),
        (this.seconds = _e.zero),
        (this.nanos = 0),
        n.util.initPartial(t, this)
    }
    fromJson(t, e) {
      if (typeof t != "string")
        throw new Error(
          `cannot decode google.protobuf.Duration from JSON: ${n.json.debug(t)}`,
        )
      const s = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/)
      if (s === null)
        throw new Error(
          `cannot decode google.protobuf.Duration from JSON: ${n.json.debug(t)}`,
        )
      const r = Number(s[1])
      if (r > 315576e6 || r < -315576e6)
        throw new Error(
          `cannot decode google.protobuf.Duration from JSON: ${n.json.debug(t)}`,
        )
      if (((this.seconds = _e.parse(r)), typeof s[2] == "string")) {
        const a = s[2] + "0".repeat(9 - s[2].length)
        ;(this.nanos = parseInt(a)),
          (r < 0 || Object.is(r, -0)) && (this.nanos = -this.nanos)
      }
      return this
    }
    toJson(t) {
      if (Number(this.seconds) > 315576e6 || Number(this.seconds) < -315576e6)
        throw new Error(
          "cannot encode google.protobuf.Duration to JSON: value out of range",
        )
      let e = this.seconds.toString()
      if (this.nanos !== 0) {
        let s = Math.abs(this.nanos).toString()
        ;(s = "0".repeat(9 - s.length) + s),
          s.substring(3) === "000000"
            ? (s = s.substring(0, 3))
            : s.substring(6) === "000" && (s = s.substring(0, 6)),
          (e += "." + s),
          this.nanos < 0 && Number(this.seconds) == 0 && (e = "-" + e)
      }
      return e + "s"
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Duration"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "seconds", kind: "scalar", T: 3 },
        { no: 2, name: "nanos", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Dp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dp, t, e)
    }
  },
  Ykt = class au extends h {
    constructor(t) {
      super(),
        (this.typeUrl = ""),
        (this.value = new Uint8Array(0)),
        n.util.initPartial(t, this)
    }
    toJson(t) {
      if (this.typeUrl === "") return {}
      const e = this.typeUrlToName(this.typeUrl),
        s = t?.typeRegistry?.findMessage(e)
      if (!s)
        throw new Error(
          `cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`,
        )
      let a = s.fromBinary(this.value).toJson(t)
      return (
        (e.startsWith("google.protobuf.") ||
          a === null ||
          Array.isArray(a) ||
          typeof a != "object") &&
          (a = { value: a }),
        (a["@type"] = this.typeUrl),
        a
      )
    }
    fromJson(t, e) {
      if (t === null || Array.isArray(t) || typeof t != "object")
        throw new Error(
          `cannot decode message google.protobuf.Any from JSON: expected object but got ${t === null ? "null" : Array.isArray(t) ? "array" : typeof t}`,
        )
      if (Object.keys(t).length == 0) return this
      const s = t["@type"]
      if (typeof s != "string" || s == "")
        throw new Error(
          'cannot decode message google.protobuf.Any from JSON: "@type" is empty',
        )
      const r = this.typeUrlToName(s),
        a = e?.typeRegistry?.findMessage(r)
      if (!a)
        throw new Error(
          `cannot decode message google.protobuf.Any from JSON: ${s} is not in the type registry`,
        )
      let o
      if (
        r.startsWith("google.protobuf.") &&
        Object.prototype.hasOwnProperty.call(t, "value")
      )
        o = a.fromJson(t.value, e)
      else {
        const c = Object.assign({}, t)
        delete c["@type"], (o = a.fromJson(c, e))
      }
      return this.packFrom(o), this
    }
    packFrom(t) {
      ;(this.value = t.toBinary()),
        (this.typeUrl = this.typeNameToUrl(t.getType().typeName))
    }
    unpackTo(t) {
      return this.is(t.getType()) ? (t.fromBinary(this.value), !0) : !1
    }
    unpack(t) {
      if (this.typeUrl === "") return
      const e = t.findMessage(this.typeUrlToName(this.typeUrl))
      if (e) return e.fromBinary(this.value)
    }
    is(t) {
      if (this.typeUrl === "") return !1
      const e = this.typeUrlToName(this.typeUrl)
      let s = ""
      return typeof t == "string" ? (s = t) : (s = t.typeName), e === s
    }
    typeNameToUrl(t) {
      return `type.googleapis.com/${t}`
    }
    typeUrlToName(t) {
      if (!t.length) throw new Error(`invalid type url: ${t}`)
      const e = t.lastIndexOf("/"),
        s = e >= 0 ? t.substring(e + 1) : t
      if (!s.length) throw new Error(`invalid type url: ${t}`)
      return s
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Any"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type_url", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 12 },
      ])
    }
    static pack(t) {
      const e = new au()
      return e.packFrom(t), e
    }
    static fromBinary(t, e) {
      return new au().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new au().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new au().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(au, t, e)
    }
  },
  Tzt = class Fp extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Empty"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Fp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fp, t, e)
    }
  },
  kzt = class Ap extends h {
    constructor(t) {
      super(), (this.paths = []), n.util.initPartial(t, this)
    }
    toJson(t) {
      function e(s) {
        let r = !1
        const a = []
        for (let o = 0; o < s.length; o++) {
          let c = s.charAt(o)
          switch (c) {
            case "_":
              r = !0
              break
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              a.push(c), (r = !1)
              break
            default:
              r && ((r = !1), (c = c.toUpperCase())), a.push(c)
              break
          }
        }
        return a.join("")
      }
      return this.paths
        .map((s) => {
          if (s.match(/_[0-9]?_/g) || s.match(/[A-Z]/g))
            throw new Error(
              'cannot encode google.protobuf.FieldMask to JSON: lowerCamelCase of path name "' +
                s +
                '" is irreversible',
            )
          return e(s)
        })
        .join(",")
    }
    fromJson(t, e) {
      if (typeof t != "string")
        throw new Error(
          "cannot decode google.protobuf.FieldMask from JSON: " +
            n.json.debug(t),
        )
      if (t === "") return this
      function s(r) {
        if (r.includes("_"))
          throw new Error(
            "cannot decode google.protobuf.FieldMask from JSON: path names must be lowerCamelCase",
          )
        const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase())
        return a[0] === "_" ? a.substring(1) : a
      }
      return (this.paths = t.split(",").map(s)), this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.FieldMask"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "paths", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ap().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ap().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ap().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ap, t, e)
    }
  },
  Nl
;(function (i) {
  i[(i.NULL_VALUE = 0)] = "NULL_VALUE"
})(Nl || (Nl = {})),
  n.util.setEnumType(Nl, "google.protobuf.NullValue", [
    { no: 0, name: "NULL_VALUE" },
  ])
var Aet = class _p extends h {
    constructor(t) {
      super(), (this.fields = {}), n.util.initPartial(t, this)
    }
    toJson(t) {
      const e = {}
      for (const [s, r] of Object.entries(this.fields)) e[s] = r.toJson(t)
      return e
    }
    fromJson(t, e) {
      if (typeof t != "object" || t == null || Array.isArray(t))
        throw new Error(
          "cannot decode google.protobuf.Struct from JSON " + n.json.debug(t),
        )
      for (const [s, r] of Object.entries(t)) this.fields[s] = W8.fromJson(r)
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Struct"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "fields",
          kind: "map",
          K: 9,
          V: { kind: "message", T: W8 },
        },
      ])
    }
    static fromBinary(t, e) {
      return new _p().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _p().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _p().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_p, t, e)
    }
  },
  W8 = class Op extends h {
    constructor(t) {
      super(), (this.kind = { case: void 0 }), n.util.initPartial(t, this)
    }
    toJson(t) {
      switch (this.kind.case) {
        case "nullValue":
          return null
        case "numberValue":
          if (!Number.isFinite(this.kind.value))
            throw new Error("google.protobuf.Value cannot be NaN or Infinity")
          return this.kind.value
        case "boolValue":
          return this.kind.value
        case "stringValue":
          return this.kind.value
        case "structValue":
        case "listValue":
          return this.kind.value.toJson({ ...t, emitDefaultValues: !0 })
      }
      throw new Error("google.protobuf.Value must have a value")
    }
    fromJson(t, e) {
      switch (typeof t) {
        case "number":
          this.kind = { case: "numberValue", value: t }
          break
        case "string":
          this.kind = { case: "stringValue", value: t }
          break
        case "boolean":
          this.kind = { case: "boolValue", value: t }
          break
        case "object":
          t === null
            ? (this.kind = { case: "nullValue", value: Nl.NULL_VALUE })
            : Array.isArray(t)
              ? (this.kind = { case: "listValue", value: _et.fromJson(t) })
              : (this.kind = { case: "structValue", value: Aet.fromJson(t) })
          break
        default:
          throw new Error(
            "cannot decode google.protobuf.Value from JSON " + n.json.debug(t),
          )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "null_value",
          kind: "enum",
          T: n.getEnumType(Nl),
          oneof: "kind",
        },
        { no: 2, name: "number_value", kind: "scalar", T: 1, oneof: "kind" },
        { no: 3, name: "string_value", kind: "scalar", T: 9, oneof: "kind" },
        { no: 4, name: "bool_value", kind: "scalar", T: 8, oneof: "kind" },
        { no: 5, name: "struct_value", kind: "message", T: Aet, oneof: "kind" },
        { no: 6, name: "list_value", kind: "message", T: _et, oneof: "kind" },
      ])
    }
    static fromBinary(t, e) {
      return new Op().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Op().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Op().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Op, t, e)
    }
  },
  _et = class Bp extends h {
    constructor(t) {
      super(), (this.values = []), n.util.initPartial(t, this)
    }
    toJson(t) {
      return this.values.map((e) => e.toJson())
    }
    fromJson(t, e) {
      if (!Array.isArray(t))
        throw new Error(
          "cannot decode google.protobuf.ListValue from JSON " +
            n.json.debug(t),
        )
      for (let s of t) this.values.push(W8.fromJson(s))
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.ListValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "values", kind: "message", T: W8, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Bp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bp, t, e)
    }
  },
  Szt = class ou extends h {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(B.DOUBLE, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(B.DOUBLE, t)
      } catch (s) {
        let r = 'cannot decode message google.protobuf.DoubleValue from JSON"'
        throw (
          (s instanceof Error &&
            s.message.length > 0 &&
            (r += `: ${s.message}`),
          new Error(r))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.DoubleValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 1 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new ou({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new ou().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ou().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ou().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ou, t, e)
    }
  },
  Ezt = class cu extends h {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(B.FLOAT, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(B.FLOAT, t)
      } catch (s) {
        let r = 'cannot decode message google.protobuf.FloatValue from JSON"'
        throw (
          (s instanceof Error &&
            s.message.length > 0 &&
            (r += `: ${s.message}`),
          new Error(r))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.FloatValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 2 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new cu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new cu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cu, t, e)
    }
  },
  Izt = class lu extends h {
    constructor(t) {
      super(), (this.value = _e.zero), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(B.INT64, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(B.INT64, t)
      } catch (s) {
        let r = 'cannot decode message google.protobuf.Int64Value from JSON"'
        throw (
          (s instanceof Error &&
            s.message.length > 0 &&
            (r += `: ${s.message}`),
          new Error(r))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Int64Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 3 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new lu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new lu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lu, t, e)
    }
  },
  Pzt = class uu extends h {
    constructor(t) {
      super(), (this.value = _e.zero), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(B.UINT64, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(B.UINT64, t)
      } catch (s) {
        let r = 'cannot decode message google.protobuf.UInt64Value from JSON"'
        throw (
          (s instanceof Error &&
            s.message.length > 0 &&
            (r += `: ${s.message}`),
          new Error(r))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.UInt64Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 4 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new uu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new uu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uu, t, e)
    }
  },
  $zt = class hu extends h {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(B.INT32, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(B.INT32, t)
      } catch (s) {
        let r = 'cannot decode message google.protobuf.Int32Value from JSON"'
        throw (
          (s instanceof Error &&
            s.message.length > 0 &&
            (r += `: ${s.message}`),
          new Error(r))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Int32Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 5 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new hu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new hu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hu, t, e)
    }
  },
  xzt = class du extends h {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(B.UINT32, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(B.UINT32, t)
      } catch (s) {
        let r = 'cannot decode message google.protobuf.UInt32Value from JSON"'
        throw (
          (s instanceof Error &&
            s.message.length > 0 &&
            (r += `: ${s.message}`),
          new Error(r))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.UInt32Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 13 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new du({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new du().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new du().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new du().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(du, t, e)
    }
  },
  Nzt = class mu extends h {
    constructor(t) {
      super(), (this.value = !1), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(B.BOOL, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(B.BOOL, t)
      } catch (s) {
        let r = 'cannot decode message google.protobuf.BoolValue from JSON"'
        throw (
          (s instanceof Error &&
            s.message.length > 0 &&
            (r += `: ${s.message}`),
          new Error(r))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.BoolValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 8 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new mu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new mu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mu, t, e)
    }
  },
  Czt = class fu extends h {
    constructor(t) {
      super(), (this.value = ""), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(B.STRING, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(B.STRING, t)
      } catch (s) {
        let r = 'cannot decode message google.protobuf.StringValue from JSON"'
        throw (
          (s instanceof Error &&
            s.message.length > 0 &&
            (r += `: ${s.message}`),
          new Error(r))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.StringValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 9 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new fu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new fu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fu, t, e)
    }
  },
  Jzt = class pu extends h {
    constructor(t) {
      super(), (this.value = new Uint8Array(0)), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(B.BYTES, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(B.BYTES, t)
      } catch (s) {
        let r = 'cannot decode message google.protobuf.BytesValue from JSON"'
        throw (
          (s instanceof Error &&
            s.message.length > 0 &&
            (r += `: ${s.message}`),
          new Error(r))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.BytesValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 12 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new pu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new pu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pu, t, e)
    }
  },
  Lzt = [Qtt(Nl)],
  Qkt = class qp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.compiler.Version"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "major", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "minor", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "patch", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "suffix", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new qp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(qp, t, e)
    }
  },
  Rzt = class Up extends h {
    constructor(t) {
      super(),
        (this.fileToGenerate = []),
        (this.protoFile = []),
        (this.sourceFileDescriptors = []),
        L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.compiler.CodeGeneratorRequest"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "file_to_generate", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "parameter", kind: "scalar", T: 9, opt: !0 },
        { no: 15, name: "proto_file", kind: "message", T: kM, repeated: !0 },
        {
          no: 17,
          name: "source_file_descriptors",
          kind: "message",
          T: kM,
          repeated: !0,
        },
        { no: 3, name: "compiler_version", kind: "message", T: Qkt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Up().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Up().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Up().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Up, t, e)
    }
  },
  Dzt = class Mp extends h {
    constructor(t) {
      super(), (this.file = []), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.compiler.CodeGeneratorResponse"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "error", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "supported_features", kind: "scalar", T: 4, opt: !0 },
        { no: 3, name: "minimum_edition", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "maximum_edition", kind: "scalar", T: 5, opt: !0 },
        { no: 15, name: "file", kind: "message", T: Xkt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Mp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Mp, t, e)
    }
  },
  EM
;(function (i) {
  ;(i[(i.NONE = 0)] = "NONE"),
    (i[(i.PROTO3_OPTIONAL = 1)] = "PROTO3_OPTIONAL"),
    (i[(i.SUPPORTS_EDITIONS = 2)] = "SUPPORTS_EDITIONS")
})(EM || (EM = {})),
  L.util.setEnumType(
    EM,
    "google.protobuf.compiler.CodeGeneratorResponse.Feature",
    [
      { no: 0, name: "FEATURE_NONE" },
      { no: 1, name: "FEATURE_PROTO3_OPTIONAL" },
      { no: 2, name: "FEATURE_SUPPORTS_EDITIONS" },
    ],
  )
var Xkt = class Hp extends h {
    constructor(t) {
      super(), L.util.initPartial(t, this)
    }
    static {
      this.runtime = L
    }
    static {
      this.typeName = "google.protobuf.compiler.CodeGeneratorResponse.File"
    }
    static {
      this.fields = L.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "insertion_point", kind: "scalar", T: 9, opt: !0 },
        { no: 15, name: "content", kind: "scalar", T: 9, opt: !0 },
        {
          no: 16,
          name: "generated_code_info",
          kind: "message",
          T: Gkt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Hp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return L.util.equals(Hp, t, e)
    }
  },
  IM = class Wp extends h {
    constructor(t) {
      super(), (this.fileName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.SourceContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Wp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wp, t, e)
    }
  },
  hr
;(function (i) {
  ;(i[(i.PROTO2 = 0)] = "PROTO2"),
    (i[(i.PROTO3 = 1)] = "PROTO3"),
    (i[(i.EDITIONS = 2)] = "EDITIONS")
})(hr || (hr = {})),
  n.util.setEnumType(hr, "google.protobuf.Syntax", [
    { no: 0, name: "SYNTAX_PROTO2" },
    { no: 1, name: "SYNTAX_PROTO3" },
    { no: 2, name: "SYNTAX_EDITIONS" },
  ])
var Fzt = class jp extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.fields = []),
        (this.oneofs = []),
        (this.options = []),
        (this.syntax = hr.PROTO2),
        (this.edition = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Type"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "fields", kind: "message", T: Kkt, repeated: !0 },
        { no: 3, name: "oneofs", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "options", kind: "message", T: Cl, repeated: !0 },
        { no: 5, name: "source_context", kind: "message", T: IM },
        { no: 6, name: "syntax", kind: "enum", T: n.getEnumType(hr) },
        { no: 7, name: "edition", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jp, t, e)
    }
  },
  Kkt = class Vp extends h {
    constructor(t) {
      super(),
        (this.kind = Jd.TYPE_UNKNOWN),
        (this.cardinality = Ld.UNKNOWN),
        (this.number = 0),
        (this.name = ""),
        (this.typeUrl = ""),
        (this.oneofIndex = 0),
        (this.packed = !1),
        (this.options = []),
        (this.jsonName = ""),
        (this.defaultValue = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Field"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "kind", kind: "enum", T: n.getEnumType(Jd) },
        { no: 2, name: "cardinality", kind: "enum", T: n.getEnumType(Ld) },
        { no: 3, name: "number", kind: "scalar", T: 5 },
        { no: 4, name: "name", kind: "scalar", T: 9 },
        { no: 6, name: "type_url", kind: "scalar", T: 9 },
        { no: 7, name: "oneof_index", kind: "scalar", T: 5 },
        { no: 8, name: "packed", kind: "scalar", T: 8 },
        { no: 9, name: "options", kind: "message", T: Cl, repeated: !0 },
        { no: 10, name: "json_name", kind: "scalar", T: 9 },
        { no: 11, name: "default_value", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Vp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vp, t, e)
    }
  },
  Jd
;(function (i) {
  ;(i[(i.TYPE_UNKNOWN = 0)] = "TYPE_UNKNOWN"),
    (i[(i.TYPE_DOUBLE = 1)] = "TYPE_DOUBLE"),
    (i[(i.TYPE_FLOAT = 2)] = "TYPE_FLOAT"),
    (i[(i.TYPE_INT64 = 3)] = "TYPE_INT64"),
    (i[(i.TYPE_UINT64 = 4)] = "TYPE_UINT64"),
    (i[(i.TYPE_INT32 = 5)] = "TYPE_INT32"),
    (i[(i.TYPE_FIXED64 = 6)] = "TYPE_FIXED64"),
    (i[(i.TYPE_FIXED32 = 7)] = "TYPE_FIXED32"),
    (i[(i.TYPE_BOOL = 8)] = "TYPE_BOOL"),
    (i[(i.TYPE_STRING = 9)] = "TYPE_STRING"),
    (i[(i.TYPE_GROUP = 10)] = "TYPE_GROUP"),
    (i[(i.TYPE_MESSAGE = 11)] = "TYPE_MESSAGE"),
    (i[(i.TYPE_BYTES = 12)] = "TYPE_BYTES"),
    (i[(i.TYPE_UINT32 = 13)] = "TYPE_UINT32"),
    (i[(i.TYPE_ENUM = 14)] = "TYPE_ENUM"),
    (i[(i.TYPE_SFIXED32 = 15)] = "TYPE_SFIXED32"),
    (i[(i.TYPE_SFIXED64 = 16)] = "TYPE_SFIXED64"),
    (i[(i.TYPE_SINT32 = 17)] = "TYPE_SINT32"),
    (i[(i.TYPE_SINT64 = 18)] = "TYPE_SINT64")
})(Jd || (Jd = {})),
  n.util.setEnumType(Jd, "google.protobuf.Field.Kind", [
    { no: 0, name: "TYPE_UNKNOWN" },
    { no: 1, name: "TYPE_DOUBLE" },
    { no: 2, name: "TYPE_FLOAT" },
    { no: 3, name: "TYPE_INT64" },
    { no: 4, name: "TYPE_UINT64" },
    { no: 5, name: "TYPE_INT32" },
    { no: 6, name: "TYPE_FIXED64" },
    { no: 7, name: "TYPE_FIXED32" },
    { no: 8, name: "TYPE_BOOL" },
    { no: 9, name: "TYPE_STRING" },
    { no: 10, name: "TYPE_GROUP" },
    { no: 11, name: "TYPE_MESSAGE" },
    { no: 12, name: "TYPE_BYTES" },
    { no: 13, name: "TYPE_UINT32" },
    { no: 14, name: "TYPE_ENUM" },
    { no: 15, name: "TYPE_SFIXED32" },
    { no: 16, name: "TYPE_SFIXED64" },
    { no: 17, name: "TYPE_SINT32" },
    { no: 18, name: "TYPE_SINT64" },
  ])
var Ld
;(function (i) {
  ;(i[(i.UNKNOWN = 0)] = "UNKNOWN"),
    (i[(i.OPTIONAL = 1)] = "OPTIONAL"),
    (i[(i.REQUIRED = 2)] = "REQUIRED"),
    (i[(i.REPEATED = 3)] = "REPEATED")
})(Ld || (Ld = {})),
  n.util.setEnumType(Ld, "google.protobuf.Field.Cardinality", [
    { no: 0, name: "CARDINALITY_UNKNOWN" },
    { no: 1, name: "CARDINALITY_OPTIONAL" },
    { no: 2, name: "CARDINALITY_REQUIRED" },
    { no: 3, name: "CARDINALITY_REPEATED" },
  ])
var Azt = class Gp extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.enumvalue = []),
        (this.options = []),
        (this.syntax = hr.PROTO2),
        (this.edition = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Enum"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "enumvalue", kind: "message", T: Zkt, repeated: !0 },
        { no: 3, name: "options", kind: "message", T: Cl, repeated: !0 },
        { no: 4, name: "source_context", kind: "message", T: IM },
        { no: 5, name: "syntax", kind: "enum", T: n.getEnumType(hr) },
        { no: 6, name: "edition", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Gp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gp, t, e)
    }
  },
  Zkt = class zp extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.number = 0),
        (this.options = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.EnumValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "number", kind: "scalar", T: 5 },
        { no: 3, name: "options", kind: "message", T: Cl, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zp, t, e)
    }
  },
  Cl = class Yp extends h {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Option"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "message", T: Ykt },
      ])
    }
    static fromBinary(t, e) {
      return new Yp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yp, t, e)
    }
  },
  _zt = class Qp extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.methods = []),
        (this.options = []),
        (this.version = ""),
        (this.mixins = []),
        (this.syntax = hr.PROTO2),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Api"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "methods", kind: "message", T: tSt, repeated: !0 },
        { no: 3, name: "options", kind: "message", T: Cl, repeated: !0 },
        { no: 4, name: "version", kind: "scalar", T: 9 },
        { no: 5, name: "source_context", kind: "message", T: IM },
        { no: 6, name: "mixins", kind: "message", T: eSt, repeated: !0 },
        { no: 7, name: "syntax", kind: "enum", T: n.getEnumType(hr) },
      ])
    }
    static fromBinary(t, e) {
      return new Qp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qp, t, e)
    }
  },
  tSt = class Xp extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.requestTypeUrl = ""),
        (this.requestStreaming = !1),
        (this.responseTypeUrl = ""),
        (this.responseStreaming = !1),
        (this.options = []),
        (this.syntax = hr.PROTO2),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Method"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "request_type_url", kind: "scalar", T: 9 },
        { no: 3, name: "request_streaming", kind: "scalar", T: 8 },
        { no: 4, name: "response_type_url", kind: "scalar", T: 9 },
        { no: 5, name: "response_streaming", kind: "scalar", T: 8 },
        { no: 6, name: "options", kind: "message", T: Cl, repeated: !0 },
        { no: 7, name: "syntax", kind: "enum", T: n.getEnumType(hr) },
      ])
    }
    static fromBinary(t, e) {
      return new Xp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xp, t, e)
    }
  },
  eSt = class Kp extends h {
    constructor(t) {
      super(), (this.name = ""), (this.root = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Mixin"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "root", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Kp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kp, t, e)
    }
  },
  Jl
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ERROR = 1)] = "ERROR"),
    (i[(i.WARNING = 2)] = "WARNING"),
    (i[(i.INFO = 3)] = "INFO"),
    (i[(i.HINT = 4)] = "HINT"),
    (i[(i.AI = 5)] = "AI")
})(Jl || (Jl = {})),
  n.util.setEnumType(Jl, "aiserver.v1.LintSeverity", [
    { no: 0, name: "LINT_SEVERITY_UNSPECIFIED" },
    { no: 1, name: "LINT_SEVERITY_ERROR" },
    { no: 2, name: "LINT_SEVERITY_WARNING" },
    { no: 3, name: "LINT_SEVERITY_INFO" },
    { no: 4, name: "LINT_SEVERITY_HINT" },
    { no: 5, name: "LINT_SEVERITY_AI" },
  ])
var Rd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.EDIT = 1)] = "EDIT"),
    (i[(i.GENERATE = 2)] = "GENERATE"),
    (i[(i.INLINE_LONG_COMPLETION = 3)] = "INLINE_LONG_COMPLETION")
})(Rd || (Rd = {})),
  n.util.setEnumType(Rd, "aiserver.v1.FeatureType", [
    { no: 0, name: "FEATURE_TYPE_UNSPECIFIED" },
    { no: 1, name: "FEATURE_TYPE_EDIT" },
    { no: 2, name: "FEATURE_TYPE_GENERATE" },
    { no: 3, name: "FEATURE_TYPE_INLINE_LONG_COMPLETION" },
  ])
var j8
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.VOYAGE_CODE_2 = 1)] = "VOYAGE_CODE_2"),
    (i[(i.TEXT_EMBEDDINGS_LARGE_3 = 2)] = "TEXT_EMBEDDINGS_LARGE_3"),
    (i[(i.QWEN_1_5B_CUSTOM = 3)] = "QWEN_1_5B_CUSTOM")
})(j8 || (j8 = {})),
  n.util.setEnumType(j8, "aiserver.v1.EmbeddingModel", [
    { no: 0, name: "EMBEDDING_MODEL_UNSPECIFIED" },
    { no: 1, name: "EMBEDDING_MODEL_VOYAGE_CODE_2" },
    { no: 2, name: "EMBEDDING_MODEL_TEXT_EMBEDDINGS_LARGE_3" },
    { no: 3, name: "EMBEDDING_MODEL_QWEN_1_5B_CUSTOM" },
  ])
var ba = class Zp extends h {
    constructor(t) {
      super(), (this.line = 0), (this.column = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPosition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 5 },
        { no: 2, name: "column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Zp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zp, t, e)
    }
  },
  iSt = class tg extends h {
    constructor(t) {
      super(),
        (this.selectionStartLineNumber = 0),
        (this.selectionStartColumn = 0),
        (this.positionLineNumber = 0),
        (this.positionColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SelectionWithOrientation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "selection_start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "selection_start_column", kind: "scalar", T: 5 },
        { no: 3, name: "position_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "position_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new tg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tg, t, e)
    }
  },
  Ts = class eg extends h {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimplestRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new eg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eg, t, e)
    }
  },
  Ozt = class ig extends h {
    constructor(t) {
      super(),
        (this.original = []),
        (this.modified = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComputeLinesDiffOriginalAndModified"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "modified", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ig().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ig().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ig().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ig, t, e)
    }
  },
  V8 = class sg extends h {
    constructor(t) {
      super(),
        (this.diffs = []),
        (this.diffType = Dd.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GitDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diffs", kind: "message", T: G8, repeated: !0 },
        { no: 2, name: "diff_type", kind: "enum", T: n.getEnumType(Dd) },
      ])
    }
    static fromBinary(t, e) {
      return new sg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sg, t, e)
    }
  },
  Dd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DIFF_TO_HEAD = 1)] = "DIFF_TO_HEAD"),
    (i[(i.DIFF_FROM_BRANCH_TO_MAIN = 2)] = "DIFF_FROM_BRANCH_TO_MAIN")
})(Dd || (Dd = {})),
  n.util.setEnumType(Dd, "aiserver.v1.GitDiff.DiffType", [
    { no: 0, name: "DIFF_TYPE_UNSPECIFIED" },
    { no: 1, name: "DIFF_TYPE_DIFF_TO_HEAD" },
    { no: 2, name: "DIFF_TYPE_DIFF_FROM_BRANCH_TO_MAIN" },
  ])
var G8 = class rg extends h {
    constructor(t) {
      super(),
        (this.from = ""),
        (this.to = ""),
        (this.chunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "from", kind: "scalar", T: 9 },
        { no: 2, name: "to", kind: "scalar", T: 9 },
        { no: 3, name: "chunks", kind: "message", T: sSt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new rg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rg, t, e)
    }
  },
  sSt = class ng extends h {
    constructor(t) {
      super(),
        (this.content = ""),
        (this.lines = []),
        (this.oldStart = 0),
        (this.oldLines = 0),
        (this.newStart = 0),
        (this.newLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileDiff.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "content", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "old_start", kind: "scalar", T: 5 },
        { no: 4, name: "old_lines", kind: "scalar", T: 5 },
        { no: 5, name: "new_start", kind: "scalar", T: 5 },
        { no: 6, name: "new_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ng().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ng().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ng().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ng, t, e)
    }
  },
  Pi = class ag extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumberInclusive = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number_inclusive", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ag().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ag().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ag().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ag, t, e)
    }
  },
  rSt = class og extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunkHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleFileChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ts },
        { no: 3, name: "chunk_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new og().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new og().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new og().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(og, t, e)
    }
  },
  Rs = class cg extends h {
    constructor(t) {
      super(),
        (this.remoteUrl = ""),
        (this.commitId = ""),
        (this.gitPatch = ""),
        (this.unsavedFiles = []),
        (this.unixTimestampMs = 0),
        (this.openEditors = []),
        (this.fileDiffHistories = []),
        (this.branchName = ""),
        (this.branchNotes = ""),
        (this.branchNotesRich = ""),
        (this.globalNotes = ""),
        (this.pastThoughts = []),
        (this.baseBranchName = ""),
        (this.baseBranchCommitId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "remote_url", kind: "scalar", T: 9 },
        { no: 2, name: "commit_id", kind: "scalar", T: 9 },
        { no: 3, name: "git_patch", kind: "scalar", T: 9 },
        { no: 4, name: "unsaved_files", kind: "message", T: nSt, repeated: !0 },
        { no: 5, name: "unix_timestamp_ms", kind: "scalar", T: 1 },
        { no: 6, name: "open_editors", kind: "message", T: aSt, repeated: !0 },
        {
          no: 7,
          name: "file_diff_histories",
          kind: "message",
          T: oSt,
          repeated: !0,
        },
        { no: 8, name: "branch_name", kind: "scalar", T: 9 },
        { no: 9, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 12, name: "branch_notes_rich", kind: "scalar", T: 9 },
        { no: 10, name: "global_notes", kind: "scalar", T: 9 },
        {
          no: 11,
          name: "past_thoughts",
          kind: "message",
          T: cSt,
          repeated: !0,
        },
        { no: 13, name: "base_branch_name", kind: "scalar", T: 9 },
        { no: 14, name: "base_branch_commit_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cg, t, e)
    }
  },
  nSt = class lg extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo.UnsavedFiles"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lg, t, e)
    }
  },
  aSt = class ug extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.editorGroupIndex = 0),
        (this.editorGroupId = 0),
        (this.isActive = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo.OpenEditor"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "editor_group_index", kind: "scalar", T: 5 },
        { no: 3, name: "editor_group_id", kind: "scalar", T: 5 },
        { no: 4, name: "is_active", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new ug().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ug().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ug().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ug, t, e)
    }
  },
  oSt = class hg extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diffHistory = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo.CppFileDiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hg, t, e)
    }
  },
  cSt = class dg extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.timeInUnixSeconds = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo.PastThought"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "time_in_unix_seconds", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new dg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dg, t, e)
    }
  },
  Li = class mg extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumberInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LineRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new mg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mg, t, e)
    }
  },
  Ta = class fg extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_position", kind: "message", T: ba },
        { no: 2, name: "end_position", kind: "message", T: ba },
      ])
    }
    static fromBinary(t, e) {
      return new fg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fg, t, e)
    }
  },
  PM = class pg extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.lineNumber = 0),
        (this.isSignature = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DetailedLine"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 2 },
        { no: 3, name: "is_signature", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new pg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pg, t, e)
    }
  },
  Ne = class gg extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.detailedLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeBlock"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "file_contents_length", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "range", kind: "message", T: Ta },
        { no: 4, name: "contents", kind: "scalar", T: 9 },
        { no: 5, name: "signatures", kind: "message", T: lSt },
        { no: 6, name: "override_contents", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "original_contents", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "detailed_lines", kind: "message", T: PM, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gg, t, e)
    }
  },
  lSt = class vg extends h {
    constructor(t) {
      super(), (this.ranges = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeBlock.Signatures"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranges", kind: "message", T: Ta, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new vg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vg, t, e)
    }
  },
  ks = class wg extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new wg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wg, t, e)
    }
  },
  Oet = class yg extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = Ll.UNSPECIFIED),
        (this.relatedInformation = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Diagnostic"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ta },
        { no: 3, name: "severity", kind: "enum", T: n.getEnumType(Ll) },
        {
          no: 4,
          name: "related_information",
          kind: "message",
          T: Bet,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new yg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yg, t, e)
    }
  },
  Ll
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ERROR = 1)] = "ERROR"),
    (i[(i.WARNING = 2)] = "WARNING"),
    (i[(i.INFORMATION = 3)] = "INFORMATION"),
    (i[(i.HINT = 4)] = "HINT")
})(Ll || (Ll = {})),
  n.util.setEnumType(Ll, "aiserver.v1.Diagnostic.DiagnosticSeverity", [
    { no: 0, name: "DIAGNOSTIC_SEVERITY_UNSPECIFIED" },
    { no: 1, name: "DIAGNOSTIC_SEVERITY_ERROR" },
    { no: 2, name: "DIAGNOSTIC_SEVERITY_WARNING" },
    { no: 3, name: "DIAGNOSTIC_SEVERITY_INFORMATION" },
    { no: 4, name: "DIAGNOSTIC_SEVERITY_HINT" },
  ])
var Bet = class bg extends h {
    constructor(t) {
      super(), (this.message = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Diagnostic.RelatedInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ta },
      ])
    }
    static fromBinary(t, e) {
      return new bg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bg, t, e)
    }
  },
  uSt = class Tg extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = Jl.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Lint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Pi },
        { no: 3, name: "severity", kind: "enum", T: n.getEnumType(Jl) },
      ])
    }
    static fromBinary(t, e) {
      return new Tg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tg, t, e)
    }
  },
  hSt = class kg extends h {
    constructor(t) {
      super(),
        (this.content = ""),
        (this.score = 0),
        (this.relativePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BM25Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "content", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ts },
        { no: 3, name: "score", kind: "scalar", T: 5 },
        { no: 4, name: "relative_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kg, t, e)
    }
  },
  Yt = class Sg extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.relyOnFilesync = !1),
        (this.cells = []),
        (this.topChunks = []),
        (this.contentsStartAtLine = 0),
        (this.dataframes = []),
        (this.totalNumberOfLines = 0),
        (this.languageId = ""),
        (this.diagnostics = []),
        (this.cellStartLines = []),
        (this.workspaceRootPath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CurrentFileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 18, name: "rely_on_filesync", kind: "scalar", T: 8 },
        { no: 17, name: "sha_256_hash", kind: "scalar", T: 9, opt: !0 },
        { no: 16, name: "cells", kind: "message", T: dSt, repeated: !0 },
        { no: 10, name: "top_chunks", kind: "message", T: hSt, repeated: !0 },
        { no: 9, name: "contents_start_at_line", kind: "scalar", T: 5 },
        { no: 3, name: "cursor_position", kind: "message", T: ba },
        { no: 4, name: "dataframes", kind: "message", T: qet, repeated: !0 },
        { no: 8, name: "total_number_of_lines", kind: "scalar", T: 5 },
        { no: 5, name: "language_id", kind: "scalar", T: 9 },
        { no: 6, name: "selection", kind: "message", T: Ta },
        {
          no: 11,
          name: "alternative_version_id",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 7, name: "diagnostics", kind: "message", T: Oet, repeated: !0 },
        { no: 14, name: "file_version", kind: "scalar", T: 5, opt: !0 },
        {
          no: 15,
          name: "cell_start_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
        { no: 19, name: "workspace_root_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Sg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sg, t, e)
    }
  },
  dSt = class Eg extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CurrentFileInfo.NotebookCell"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Eg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Eg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Eg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Eg, t, e)
    }
  },
  mSt = class Ig extends h {
    constructor(t) {
      super(),
        (this.apiKey = ""),
        (this.baseUrl = ""),
        (this.deployment = ""),
        (this.useAzure = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AzureState"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "api_key", kind: "scalar", T: 9 },
        { no: 2, name: "base_url", kind: "scalar", T: 9 },
        { no: 3, name: "deployment", kind: "scalar", T: 9 },
        { no: 4, name: "use_azure", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Ig().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ig().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ig().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ig, t, e)
    }
  },
  St = class Pg extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "api_key", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "enable_ghost_mode", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "azure_state", kind: "message", T: mSt, opt: !0 },
        { no: 5, name: "enable_slow_pool", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "openai_api_base_url", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Pg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pg, t, e)
    }
  },
  qet = class $g extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.shape = ""),
        (this.dataDimensionality = 0),
        (this.columns = []),
        (this.rowCount = 0),
        (this.indexColumn = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DataframeInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "shape", kind: "scalar", T: 9 },
        { no: 3, name: "data_dimensionality", kind: "scalar", T: 5 },
        { no: 6, name: "columns", kind: "message", T: fSt, repeated: !0 },
        { no: 7, name: "row_count", kind: "scalar", T: 5 },
        { no: 8, name: "index_column", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $g().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $g().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $g().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($g, t, e)
    }
  },
  fSt = class xg extends h {
    constructor(t) {
      super(), (this.key = ""), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DataframeInfo.Column"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "key", kind: "scalar", T: 9 },
        { no: 2, name: "type", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xg, t, e)
    }
  },
  ka = class Ng extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.relatedInformation = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LinterError"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ta },
        { no: 3, name: "source", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "related_information",
          kind: "message",
          T: Bet,
          repeated: !0,
        },
        {
          no: 5,
          name: "severity",
          kind: "enum",
          T: n.getEnumType(Ll),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Ng().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ng().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ng().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ng, t, e)
    }
  },
  $i = class Cg extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.errors = []),
        (this.fileContents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LinterErrors"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "errors", kind: "message", T: ka, repeated: !0 },
        { no: 3, name: "file_contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Cg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cg, t, e)
    }
  },
  pSt = class Jg extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.errors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LinterErrorsWithoutFileContents"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "errors", kind: "message", T: ka, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Jg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jg, t, e)
    }
  },
  $M = class Lg extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.description = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorRule"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "description", kind: "scalar", T: 9 },
        { no: 3, name: "body", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "is_from_glob", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Lg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lg, t, e)
    }
  },
  Oe = class Rg extends h {
    constructor(t) {
      super(),
        (this.context = ""),
        (this.rules = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ExplicitContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context", kind: "scalar", T: 9 },
        { no: 2, name: "repo_context", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "rules", kind: "message", T: $M, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Rg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rg, t, e)
    }
  },
  Fd = class Dg extends h {
    constructor(t) {
      super(),
        (this.messageType = Ad.UNSPECIFIED),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PureMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message_type", kind: "enum", T: n.getEnumType(Ad) },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Dg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dg, t, e)
    }
  },
  Ad
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SYSTEM = 1)] = "SYSTEM"),
    (i[(i.USER = 2)] = "USER"),
    (i[(i.ASSISTANT = 3)] = "ASSISTANT")
})(Ad || (Ad = {})),
  n.util.setEnumType(Ad, "aiserver.v1.PureMessage.MessageType", [
    { no: 0, name: "MESSAGE_TYPE_UNSPECIFIED" },
    { no: 1, name: "MESSAGE_TYPE_SYSTEM" },
    { no: 2, name: "MESSAGE_TYPE_USER" },
    { no: 3, name: "MESSAGE_TYPE_ASSISTANT" },
  ])
var xM = class gu extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.detail = ""),
        (this.kind = _d.UNSPECIFIED),
        (this.containerName = ""),
        (this.children = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentSymbol"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "detail", kind: "scalar", T: 9 },
        { no: 3, name: "kind", kind: "enum", T: n.getEnumType(_d) },
        { no: 5, name: "container_name", kind: "scalar", T: 9 },
        { no: 6, name: "range", kind: "message", T: Uet },
        { no: 7, name: "selection_range", kind: "message", T: Uet },
        { no: 8, name: "children", kind: "message", T: gu, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gu, t, e)
    }
  },
  _d
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FILE = 1)] = "FILE"),
    (i[(i.MODULE = 2)] = "MODULE"),
    (i[(i.NAMESPACE = 3)] = "NAMESPACE"),
    (i[(i.PACKAGE = 4)] = "PACKAGE"),
    (i[(i.CLASS = 5)] = "CLASS"),
    (i[(i.METHOD = 6)] = "METHOD"),
    (i[(i.PROPERTY = 7)] = "PROPERTY"),
    (i[(i.FIELD = 8)] = "FIELD"),
    (i[(i.CONSTRUCTOR = 9)] = "CONSTRUCTOR"),
    (i[(i.ENUM = 10)] = "ENUM"),
    (i[(i.INTERFACE = 11)] = "INTERFACE"),
    (i[(i.FUNCTION = 12)] = "FUNCTION"),
    (i[(i.VARIABLE = 13)] = "VARIABLE"),
    (i[(i.CONSTANT = 14)] = "CONSTANT"),
    (i[(i.STRING = 15)] = "STRING"),
    (i[(i.NUMBER = 16)] = "NUMBER"),
    (i[(i.BOOLEAN = 17)] = "BOOLEAN"),
    (i[(i.ARRAY = 18)] = "ARRAY"),
    (i[(i.OBJECT = 19)] = "OBJECT"),
    (i[(i.KEY = 20)] = "KEY"),
    (i[(i.NULL = 21)] = "NULL"),
    (i[(i.ENUM_MEMBER = 22)] = "ENUM_MEMBER"),
    (i[(i.STRUCT = 23)] = "STRUCT"),
    (i[(i.EVENT = 24)] = "EVENT"),
    (i[(i.OPERATOR = 25)] = "OPERATOR"),
    (i[(i.TYPE_PARAMETER = 26)] = "TYPE_PARAMETER")
})(_d || (_d = {})),
  n.util.setEnumType(_d, "aiserver.v1.DocumentSymbol.SymbolKind", [
    { no: 0, name: "SYMBOL_KIND_UNSPECIFIED" },
    { no: 1, name: "SYMBOL_KIND_FILE" },
    { no: 2, name: "SYMBOL_KIND_MODULE" },
    { no: 3, name: "SYMBOL_KIND_NAMESPACE" },
    { no: 4, name: "SYMBOL_KIND_PACKAGE" },
    { no: 5, name: "SYMBOL_KIND_CLASS" },
    { no: 6, name: "SYMBOL_KIND_METHOD" },
    { no: 7, name: "SYMBOL_KIND_PROPERTY" },
    { no: 8, name: "SYMBOL_KIND_FIELD" },
    { no: 9, name: "SYMBOL_KIND_CONSTRUCTOR" },
    { no: 10, name: "SYMBOL_KIND_ENUM" },
    { no: 11, name: "SYMBOL_KIND_INTERFACE" },
    { no: 12, name: "SYMBOL_KIND_FUNCTION" },
    { no: 13, name: "SYMBOL_KIND_VARIABLE" },
    { no: 14, name: "SYMBOL_KIND_CONSTANT" },
    { no: 15, name: "SYMBOL_KIND_STRING" },
    { no: 16, name: "SYMBOL_KIND_NUMBER" },
    { no: 17, name: "SYMBOL_KIND_BOOLEAN" },
    { no: 18, name: "SYMBOL_KIND_ARRAY" },
    { no: 19, name: "SYMBOL_KIND_OBJECT" },
    { no: 20, name: "SYMBOL_KIND_KEY" },
    { no: 21, name: "SYMBOL_KIND_NULL" },
    { no: 22, name: "SYMBOL_KIND_ENUM_MEMBER" },
    { no: 23, name: "SYMBOL_KIND_STRUCT" },
    { no: 24, name: "SYMBOL_KIND_EVENT" },
    { no: 25, name: "SYMBOL_KIND_OPERATOR" },
    { no: 26, name: "SYMBOL_KIND_TYPE_PARAMETER" },
  ])
var Uet = class Fg extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentSymbol.Range"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Fg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fg, t, e)
    }
  },
  gSt = class Ag extends h {
    constructor(t) {
      super(),
        (this.codeDetails = ""),
        (this.markdownBlocks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HoverDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_details", kind: "scalar", T: 9 },
        { no: 2, name: "markdown_blocks", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ag().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ag().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ag().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ag, t, e)
    }
  },
  vSt = class _g extends h {
    constructor(t) {
      super(), (this.scheme = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UriComponents"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "scheme", kind: "scalar", T: 9 },
        { no: 2, name: "authority", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "path", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "query", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "fragment", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _g().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _g().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _g().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_g, t, e)
    }
  },
  NM = class Og extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.textInSymbolRange = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentSymbolWithText"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol", kind: "message", T: xM },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "text_in_symbol_range", kind: "scalar", T: 9 },
        { no: 4, name: "uri_components", kind: "message", T: vSt },
      ])
    }
    static fromBinary(t, e) {
      return new Og().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Og().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Og().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Og, t, e)
    }
  },
  Bzt = class Bg extends h {
    constructor(t) {
      super(), (this.error = Sa.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ErrorDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error", kind: "enum", T: n.getEnumType(Sa) },
        { no: 2, name: "details", kind: "message", T: wSt },
        { no: 3, name: "is_expected", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Bg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bg, t, e)
    }
  },
  Sa
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.BAD_API_KEY = 1)] = "BAD_API_KEY"),
    (i[(i.BAD_USER_API_KEY = 42)] = "BAD_USER_API_KEY"),
    (i[(i.NOT_LOGGED_IN = 2)] = "NOT_LOGGED_IN"),
    (i[(i.INVALID_AUTH_ID = 3)] = "INVALID_AUTH_ID"),
    (i[(i.NOT_HIGH_ENOUGH_PERMISSIONS = 4)] = "NOT_HIGH_ENOUGH_PERMISSIONS"),
    (i[(i.AGENT_REQUIRES_LOGIN = 18)] = "AGENT_REQUIRES_LOGIN"),
    (i[(i.BAD_MODEL_NAME = 5)] = "BAD_MODEL_NAME"),
    (i[(i.NOT_FOUND = 39)] = "NOT_FOUND"),
    (i[(i.DEPRECATED = 40)] = "DEPRECATED"),
    (i[(i.USER_NOT_FOUND = 6)] = "USER_NOT_FOUND"),
    (i[(i.FREE_USER_RATE_LIMIT_EXCEEDED = 7)] =
      "FREE_USER_RATE_LIMIT_EXCEEDED"),
    (i[(i.PRO_USER_RATE_LIMIT_EXCEEDED = 8)] = "PRO_USER_RATE_LIMIT_EXCEEDED"),
    (i[(i.FREE_USER_USAGE_LIMIT = 9)] = "FREE_USER_USAGE_LIMIT"),
    (i[(i.PRO_USER_USAGE_LIMIT = 10)] = "PRO_USER_USAGE_LIMIT"),
    (i[(i.RESOURCE_EXHAUSTED = 41)] = "RESOURCE_EXHAUSTED"),
    (i[(i.AUTH_TOKEN_NOT_FOUND = 11)] = "AUTH_TOKEN_NOT_FOUND"),
    (i[(i.AUTH_TOKEN_EXPIRED = 12)] = "AUTH_TOKEN_EXPIRED"),
    (i[(i.OPENAI = 13)] = "OPENAI"),
    (i[(i.OPENAI_RATE_LIMIT_EXCEEDED = 14)] = "OPENAI_RATE_LIMIT_EXCEEDED"),
    (i[(i.OPENAI_ACCOUNT_LIMIT_EXCEEDED = 15)] =
      "OPENAI_ACCOUNT_LIMIT_EXCEEDED"),
    (i[(i.TASK_UUID_NOT_FOUND = 16)] = "TASK_UUID_NOT_FOUND"),
    (i[(i.TASK_NO_PERMISSIONS = 17)] = "TASK_NO_PERMISSIONS"),
    (i[(i.AGENT_ENGINE_NOT_FOUND = 19)] = "AGENT_ENGINE_NOT_FOUND"),
    (i[(i.MAX_TOKENS = 20)] = "MAX_TOKENS"),
    (i[(i.PRO_USER_ONLY = 23)] = "PRO_USER_ONLY"),
    (i[(i.API_KEY_NOT_SUPPORTED = 24)] = "API_KEY_NOT_SUPPORTED"),
    (i[(i.USER_ABORTED_REQUEST = 21)] = "USER_ABORTED_REQUEST"),
    (i[(i.TIMEOUT = 25)] = "TIMEOUT"),
    (i[(i.GENERIC_RATE_LIMIT_EXCEEDED = 22)] = "GENERIC_RATE_LIMIT_EXCEEDED"),
    (i[(i.SLASH_EDIT_FILE_TOO_LONG = 26)] = "SLASH_EDIT_FILE_TOO_LONG"),
    (i[(i.FILE_UNSUPPORTED = 27)] = "FILE_UNSUPPORTED"),
    (i[(i.GPT_4_VISION_PREVIEW_RATE_LIMIT = 28)] =
      "GPT_4_VISION_PREVIEW_RATE_LIMIT"),
    (i[(i.CUSTOM_MESSAGE = 29)] = "CUSTOM_MESSAGE"),
    (i[(i.OUTDATED_CLIENT = 30)] = "OUTDATED_CLIENT"),
    (i[(i.CLAUDE_IMAGE_TOO_LARGE = 31)] = "CLAUDE_IMAGE_TOO_LARGE"),
    (i[(i.GITGRAPH_NOT_FOUND = 32)] = "GITGRAPH_NOT_FOUND"),
    (i[(i.FILE_NOT_FOUND = 33)] = "FILE_NOT_FOUND"),
    (i[(i.API_KEY_RATE_LIMIT = 34)] = "API_KEY_RATE_LIMIT"),
    (i[(i.DEBOUNCED = 35)] = "DEBOUNCED"),
    (i[(i.BAD_REQUEST = 36)] = "BAD_REQUEST"),
    (i[(i.REPOSITORY_SERVICE_REPOSITORY_IS_NOT_INITIALIZED = 37)] =
      "REPOSITORY_SERVICE_REPOSITORY_IS_NOT_INITIALIZED"),
    (i[(i.UNAUTHORIZED = 38)] = "UNAUTHORIZED"),
    (i[(i.CONVERSATION_TOO_LONG = 43)] = "CONVERSATION_TOO_LONG")
})(Sa || (Sa = {})),
  n.util.setEnumType(Sa, "aiserver.v1.ErrorDetails.Error", [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_BAD_API_KEY" },
    { no: 42, name: "ERROR_BAD_USER_API_KEY" },
    { no: 2, name: "ERROR_NOT_LOGGED_IN" },
    { no: 3, name: "ERROR_INVALID_AUTH_ID" },
    { no: 4, name: "ERROR_NOT_HIGH_ENOUGH_PERMISSIONS" },
    { no: 18, name: "ERROR_AGENT_REQUIRES_LOGIN" },
    { no: 5, name: "ERROR_BAD_MODEL_NAME" },
    { no: 39, name: "ERROR_NOT_FOUND" },
    { no: 40, name: "ERROR_DEPRECATED" },
    { no: 6, name: "ERROR_USER_NOT_FOUND" },
    { no: 7, name: "ERROR_FREE_USER_RATE_LIMIT_EXCEEDED" },
    { no: 8, name: "ERROR_PRO_USER_RATE_LIMIT_EXCEEDED" },
    { no: 9, name: "ERROR_FREE_USER_USAGE_LIMIT" },
    { no: 10, name: "ERROR_PRO_USER_USAGE_LIMIT" },
    { no: 41, name: "ERROR_RESOURCE_EXHAUSTED" },
    { no: 11, name: "ERROR_AUTH_TOKEN_NOT_FOUND" },
    { no: 12, name: "ERROR_AUTH_TOKEN_EXPIRED" },
    { no: 13, name: "ERROR_OPENAI" },
    { no: 14, name: "ERROR_OPENAI_RATE_LIMIT_EXCEEDED" },
    { no: 15, name: "ERROR_OPENAI_ACCOUNT_LIMIT_EXCEEDED" },
    { no: 16, name: "ERROR_TASK_UUID_NOT_FOUND" },
    { no: 17, name: "ERROR_TASK_NO_PERMISSIONS" },
    { no: 19, name: "ERROR_AGENT_ENGINE_NOT_FOUND" },
    { no: 20, name: "ERROR_MAX_TOKENS" },
    { no: 23, name: "ERROR_PRO_USER_ONLY" },
    { no: 24, name: "ERROR_API_KEY_NOT_SUPPORTED" },
    { no: 21, name: "ERROR_USER_ABORTED_REQUEST" },
    { no: 25, name: "ERROR_TIMEOUT" },
    { no: 22, name: "ERROR_GENERIC_RATE_LIMIT_EXCEEDED" },
    { no: 26, name: "ERROR_SLASH_EDIT_FILE_TOO_LONG" },
    { no: 27, name: "ERROR_FILE_UNSUPPORTED" },
    { no: 28, name: "ERROR_GPT_4_VISION_PREVIEW_RATE_LIMIT" },
    { no: 29, name: "ERROR_CUSTOM_MESSAGE" },
    { no: 30, name: "ERROR_OUTDATED_CLIENT" },
    { no: 31, name: "ERROR_CLAUDE_IMAGE_TOO_LARGE" },
    { no: 32, name: "ERROR_GITGRAPH_NOT_FOUND" },
    { no: 33, name: "ERROR_FILE_NOT_FOUND" },
    { no: 34, name: "ERROR_API_KEY_RATE_LIMIT" },
    { no: 35, name: "ERROR_DEBOUNCED" },
    { no: 36, name: "ERROR_BAD_REQUEST" },
    { no: 37, name: "ERROR_REPOSITORY_SERVICE_REPOSITORY_IS_NOT_INITIALIZED" },
    { no: 38, name: "ERROR_UNAUTHORIZED" },
    { no: 43, name: "ERROR_CONVERSATION_TOO_LONG" },
  ])
var wSt = class qg extends h {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.detail = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomErrorDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "detail", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "allow_command_links_potentially_unsafe_please_only_use_for_handwritten_trusted_markdown",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 4, name: "is_retryable", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "show_request_id", kind: "scalar", T: 8, opt: !0 },
        {
          no: 6,
          name: "should_show_immediate_error",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new qg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qg, t, e)
    }
  },
  Ea = class Ug extends h {
    constructor(t) {
      super(), (this.data = new Uint8Array(0)), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ImageProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "data", kind: "scalar", T: 12 },
        { no: 2, name: "dimension", kind: "message", T: ySt },
      ])
    }
    static fromBinary(t, e) {
      return new Ug().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ug().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ug().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ug, t, e)
    }
  },
  ySt = class Mg extends h {
    constructor(t) {
      super(), (this.width = 0), (this.height = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ImageProto.Dimension"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "width", kind: "scalar", T: 5 },
        { no: 2, name: "height", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Mg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mg, t, e)
    }
  },
  z8 = class Hg extends h {
    constructor(t) {
      super(),
        (this.markdown = ""),
        (this.bubbleId = ""),
        (this.sectionIndex = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatQuote"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "markdown", kind: "scalar", T: 9 },
        { no: 2, name: "bubble_id", kind: "scalar", T: 9 },
        { no: 3, name: "section_index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Hg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hg, t, e)
    }
  },
  bSt = class Wg extends h {
    constructor(t) {
      super(), (this.url = ""), (this.uuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatExternalLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Wg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wg, t, e)
    }
  },
  CM = class jg extends h {
    constructor(t) {
      super(), (this.url = ""), (this.uuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerExternalLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jg, t, e)
    }
  },
  JM = class Vg extends h {
    constructor(t) {
      super(), (this.url = ""), (this.uuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKExternalLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Vg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vg, t, e)
    }
  },
  LM = class Gg extends h {
    constructor(t) {
      super(),
        (this.note = ""),
        (this.commitHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CommitNote"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "note", kind: "scalar", T: 9 },
        { no: 2, name: "commit_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Gg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gg, t, e)
    }
  },
  TSt = class zg extends h {
    constructor(t) {
      super(),
        (this.note = ""),
        (this.commitHash = ""),
        (this.embeddings = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CommitNoteWithEmbeddings"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "note", kind: "scalar", T: 9 },
        { no: 2, name: "commit_hash", kind: "scalar", T: 9 },
        { no: 3, name: "embeddings", kind: "scalar", T: 1, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zg, t, e)
    }
  },
  kSt = class Yg extends h {
    constructor(t) {
      super(), (this.diff = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CommitDiffString"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Yg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yg, t, e)
    }
  },
  qzt = class Qg extends h {
    constructor(t) {
      super(),
        (this.notes = []),
        (this.commitHash = ""),
        (this.repoUrl = ""),
        (this.filesChangedRelativePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FullCommitNotes"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "notes", kind: "message", T: LM, repeated: !0 },
        { no: 2, name: "commit_hash", kind: "scalar", T: 9 },
        { no: 3, name: "repo_url", kind: "scalar", T: 9 },
        { no: 4, name: "files_changed_relative_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Qg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qg, t, e)
    }
  },
  Met = class Xg extends h {
    constructor(t) {
      super(), (this.key = ""), (this.value = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CrossExtHostHeader"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "key", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Xg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xg, t, e)
    }
  },
  RM = class Kg extends h {
    constructor(t) {
      super(), (this.headers = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CrossExtHostHeaders"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "headers", kind: "message", T: Met, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Kg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kg, t, e)
    }
  },
  Y8 = class Zg extends h {
    constructor(t) {
      super(),
        (this.message = new Uint8Array(0)),
        (this.isError = !1),
        (this.connectError = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleUnaryCrossExtensionHostMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 12 },
        { no: 2, name: "header", kind: "message", T: RM },
        { no: 3, name: "trailer", kind: "message", T: RM },
        { no: 4, name: "is_error", kind: "scalar", T: 8 },
        { no: 5, name: "connect_error", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Zg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zg, t, e)
    }
  },
  Het = class tv extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        (this.languageIdentifier = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 4,
          name: "summarization_strategy",
          kind: "enum",
          T: n.getEnumType(X8),
          opt: !0,
        },
        { no: 5, name: "language_identifier", kind: "scalar", T: 9 },
        { no: 6, name: "intent", kind: "enum", T: n.getEnumType(Q8), opt: !0 },
        { no: 7, name: "is_final_version", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "is_first_version", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tv, t, e)
    }
  },
  Q8
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.COMPOSER_FILE = 1)] = "COMPOSER_FILE"),
    (i[(i.COMPRESSED_COMPOSER_FILE = 2)] = "COMPRESSED_COMPOSER_FILE")
})(Q8 || (Q8 = {})),
  n.util.setEnumType(Q8, "aiserver.v1.CodeChunk.Intent", [
    { no: 0, name: "INTENT_UNSPECIFIED" },
    { no: 1, name: "INTENT_COMPOSER_FILE" },
    { no: 2, name: "INTENT_COMPRESSED_COMPOSER_FILE" },
  ])
var X8
;(function (i) {
  ;(i[(i.NONE_UNSPECIFIED = 0)] = "NONE_UNSPECIFIED"),
    (i[(i.SUMMARIZED = 1)] = "SUMMARIZED"),
    (i[(i.EMBEDDED = 2)] = "EMBEDDED")
})(X8 || (X8 = {})),
  n.util.setEnumType(X8, "aiserver.v1.CodeChunk.SummarizationStrategy", [
    { no: 0, name: "SUMMARIZATION_STRATEGY_NONE_UNSPECIFIED" },
    { no: 1, name: "SUMMARIZATION_STRATEGY_SUMMARIZED" },
    { no: 2, name: "SUMMARIZATION_STRATEGY_EMBEDDED" },
  ])
var SSt = class ev extends h {
    constructor(t) {
      super(),
        (this.line = 0),
        (this.character = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSubgraphPosition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 5 },
        { no: 2, name: "character", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ev().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ev().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ev().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ev, t, e)
    }
  },
  ESt = class iv extends h {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.startCharacter = 0),
        (this.endLine = 0),
        (this.endCharacter = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSubgraphRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "start_character", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "end_character", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new iv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iv, t, e)
    }
  },
  ISt = class sv extends h {
    constructor(t) {
      super(),
        (this.type = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSubgraphContextItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "type", kind: "scalar", T: 9 },
        { no: 3, name: "content", kind: "scalar", T: 9 },
        { no: 4, name: "range", kind: "message", T: ESt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sv, t, e)
    }
  },
  DM = class rv extends h {
    constructor(t) {
      super(),
        (this.uri = ""),
        (this.symbolName = ""),
        (this.positions = []),
        (this.contextItems = []),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSubgraphFullContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
        { no: 2, name: "symbol_name", kind: "scalar", T: 9 },
        { no: 3, name: "positions", kind: "message", T: SSt, repeated: !0 },
        { no: 4, name: "context_items", kind: "message", T: ISt, repeated: !0 },
        { no: 5, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new rv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rv, t, e)
    }
  },
  Od
;(function (i) {
  ;(i[(i.FS_UPLOAD_ERROR_TYPE_UNSPECIFIED = 0)] =
    "FS_UPLOAD_ERROR_TYPE_UNSPECIFIED"),
    (i[(i.FS_UPLOAD_ERROR_TYPE_NON_EXISTANT = 1)] =
      "FS_UPLOAD_ERROR_TYPE_NON_EXISTANT"),
    (i[(i.FS_UPLOAD_ERROR_TYPE_HASH_MISMATCH = 2)] =
      "FS_UPLOAD_ERROR_TYPE_HASH_MISMATCH")
})(Od || (Od = {})),
  n.util.setEnumType(Od, "aiserver.v1.FSUploadErrorType", [
    { no: 0, name: "FS_UPLOAD_ERROR_TYPE_UNSPECIFIED" },
    { no: 1, name: "FS_UPLOAD_ERROR_TYPE_NON_EXISTANT" },
    { no: 2, name: "FS_UPLOAD_ERROR_TYPE_HASH_MISMATCH" },
  ])
var Bd
;(function (i) {
  ;(i[(i.FS_SYNC_ERROR_TYPE_UNSPECIFIED = 0)] =
    "FS_SYNC_ERROR_TYPE_UNSPECIFIED"),
    (i[(i.FS_SYNC_ERROR_TYPE_NON_EXISTANT = 1)] =
      "FS_SYNC_ERROR_TYPE_NON_EXISTANT"),
    (i[(i.FS_SYNC_ERROR_TYPE_HASH_MISMATCH = 2)] =
      "FS_SYNC_ERROR_TYPE_HASH_MISMATCH")
})(Bd || (Bd = {})),
  n.util.setEnumType(Bd, "aiserver.v1.FSSyncErrorType", [
    { no: 0, name: "FS_SYNC_ERROR_TYPE_UNSPECIFIED" },
    { no: 1, name: "FS_SYNC_ERROR_TYPE_NON_EXISTANT" },
    { no: 2, name: "FS_SYNC_ERROR_TYPE_HASH_MISMATCH" },
  ])
var Uzt = class nv extends h {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.modelVersion = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSUploadFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "contents", kind: "scalar", T: 9 },
        { no: 4, name: "model_version", kind: "scalar", T: 5 },
        { no: 5, name: "sha256_hash", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new nv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nv, t, e)
    }
  },
  Mzt = class av extends h {
    constructor(t) {
      super(),
        (this.error = Od.FS_UPLOAD_ERROR_TYPE_UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSUploadFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error", kind: "enum", T: n.getEnumType(Od) },
      ])
    }
    static fromBinary(t, e) {
      return new av().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new av().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new av().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(av, t, e)
    }
  },
  qd = class ov extends h {
    constructor(t) {
      super(),
        (this.modelVersion = 0),
        (this.relativeWorkspacePath = ""),
        (this.updates = []),
        (this.expectedFileLength = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FilesyncUpdateWithModelVersion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_version", kind: "scalar", T: 5 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "updates", kind: "message", T: PSt, repeated: !0 },
        { no: 4, name: "expected_file_length", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ov().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ov().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ov().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ov, t, e)
    }
  },
  PSt = class cv extends h {
    constructor(t) {
      super(),
        (this.startPosition = 0),
        (this.endPosition = 0),
        (this.changeLength = 0),
        (this.replacedString = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SingleUpdateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_position", kind: "scalar", T: 5 },
        { no: 2, name: "end_position", kind: "scalar", T: 5 },
        { no: 3, name: "change_length", kind: "scalar", T: 5 },
        { no: 4, name: "replaced_string", kind: "scalar", T: 9 },
        { no: 5, name: "range", kind: "message", T: Pi },
      ])
    }
    static fromBinary(t, e) {
      return new cv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cv, t, e)
    }
  },
  Hzt = class lv extends h {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.relativeWorkspacePath = ""),
        (this.modelVersion = 0),
        (this.filesyncUpdates = []),
        (this.sha256Hash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSSyncFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "model_version", kind: "scalar", T: 5 },
        {
          no: 4,
          name: "filesync_updates",
          kind: "message",
          T: qd,
          repeated: !0,
        },
        { no: 5, name: "sha256_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lv, t, e)
    }
  },
  Wzt = class uv extends h {
    constructor(t) {
      super(),
        (this.error = Bd.FS_SYNC_ERROR_TYPE_UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSSyncFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error", kind: "enum", T: n.getEnumType(Bd) },
      ])
    }
    static fromBinary(t, e) {
      return new uv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uv, t, e)
    }
  },
  jzt = class hv extends h {
    constructor(t) {
      super(), (this.uuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSIsEnabledForUserRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new hv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hv, t, e)
    }
  },
  Vzt = class dv extends h {
    constructor(t) {
      super(), (this.enabled = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSIsEnabledForUserResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new dv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dv, t, e)
    }
  },
  Gzt = class mv extends h {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.authId = ""),
        (this.relativeWorkspacePath = ""),
        (this.modelVersion = 0),
        (this.filesyncUpdates = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSGetFileContentsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "auth_id", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "model_version", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "filesync_updates",
          kind: "message",
          T: qd,
          repeated: !0,
        },
        { no: 6, name: "sha256_hash", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mv, t, e)
    }
  },
  zzt = class fv extends h {
    constructor(t) {
      super(), (this.contents = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSGetFileContentsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
        { no: 2, name: "sha256_hash", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fv, t, e)
    }
  },
  $St = class pv extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.required = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "requested_version", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "sha256_hash", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "required", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new pv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pv, t, e)
    }
  },
  Yzt = class gv extends h {
    constructor(t) {
      super(),
        (this.authId = ""),
        (this.filesyncUpdates = []),
        (this.fileRequests = []),
        (this.getAllRecentFiles = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSGetMultiFileContentsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "auth_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "filesync_updates",
          kind: "message",
          T: qd,
          repeated: !0,
        },
        { no: 3, name: "file_requests", kind: "message", T: $St, repeated: !0 },
        { no: 4, name: "get_all_recent_files", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new gv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gv, t, e)
    }
  },
  xSt = class vv extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.modelVersion = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileRetrieved"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "model_version", kind: "scalar", T: 5 },
        { no: 4, name: "last_modified", kind: "message", T: Fet },
      ])
    }
    static fromBinary(t, e) {
      return new vv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vv, t, e)
    }
  },
  Qzt = class wv extends h {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSGetMultiFileContentsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: xSt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wv, t, e)
    }
  },
  Xzt = class yv extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSInternalHealthCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "from_server", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yv, t, e)
    }
  },
  Kzt = class bv extends h {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSInternalHealthCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new bv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bv, t, e)
    }
  },
  Zzt = class Tv extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Tv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tv, t, e)
    }
  },
  tYt = class kv extends h {
    constructor(t) {
      super(), (this.checkFilesyncHashPercent = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "check_filesync_hash_percent", kind: "scalar", T: 2 },
        {
          no: 2,
          name: "rate_limiter_breaker_reset_time_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 3, name: "rate_limiter_rps", kind: "scalar", T: 5, opt: !0 },
        {
          no: 4,
          name: "rate_limiter_burst_capacity",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "max_recent_updates_stored",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 6,
          name: "max_model_version_cache_size",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 7,
          name: "max_file_size_to_sync_bytes",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 8,
          name: "sync_retry_max_attempts",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 9,
          name: "sync_retry_initial_delay_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 10,
          name: "sync_retry_time_multiplier",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 11,
          name: "file_sync_status_max_cache_size",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 12,
          name: "successive_syncs_required_for_reliance",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 13,
          name: "extra_successful_syncs_needed_after_errors",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 14,
          name: "big_change_stripping_threshold_bytes",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 15,
          name: "last_n_updates_to_send",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 16,
          name: "file_sync_status_ttl_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 17, name: "sync_debounce_ms", kind: "scalar", T: 5, opt: !0 },
        {
          no: 18,
          name: "sync_update_threshold",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new kv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kv, t, e)
    }
  },
  Wet = class Sv extends h {
    constructor(t) {
      super(),
        (this.file = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.codeLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugLocation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "code_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Sv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sv, t, e)
    }
  },
  K8 = class Ev extends h {
    constructor(t) {
      super(),
        (this.locations = []),
        (this.id = ""),
        (this.description = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugReport"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "locations", kind: "message", T: Wet, repeated: !0 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "description", kind: "scalar", T: 9 },
        { no: 4, name: "confidence", kind: "scalar", T: 2, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ev().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ev().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ev().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ev, t, e)
    }
  },
  jet = class Iv extends h {
    constructor(t) {
      super(), (this.bugReports = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugReports"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_reports", kind: "message", T: K8, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Iv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Iv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Iv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Iv, t, e)
    }
  },
  FM = class Pv extends h {
    constructor(t) {
      super(),
        (this.inBackgroundSubsidized = !1),
        (this.hasTelemetry = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "git_diff", kind: "message", T: V8 },
        { no: 2, name: "model_details", kind: "message", T: St },
        { no: 3, name: "user_instructions", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "bug_detection_guidelines",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 5, name: "iterations", kind: "scalar", T: 5, opt: !0 },
        {
          no: 12,
          name: "unified_context_lines",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 6, name: "in_background_subsidized", kind: "scalar", T: 8 },
        { no: 7, name: "session_id", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "price_id", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "has_telemetry", kind: "scalar", T: 8 },
        { no: 10, name: "constrain_to_file", kind: "scalar", T: 9, opt: !0 },
        {
          no: 11,
          name: "constrain_to_range",
          kind: "message",
          T: NSt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Pv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pv, t, e)
    }
  },
  NSt = class $v extends h {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotRequest.Range"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new $v().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $v().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $v().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($v, t, e)
    }
  },
  eYt = class xv extends h {
    constructor(t) {
      super(), (this.seed = ""), (this.date = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunBugBotPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "req", kind: "message", T: FM },
        { no: 2, name: "seed", kind: "scalar", T: 9 },
        { no: 3, name: "date", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xv, t, e)
    }
  },
  CSt = class Nv extends h {
    constructor(t) {
      super(), (this.date = ""), (this.seed = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotDiscriminatorPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "req", kind: "message", T: FM },
        { no: 2, name: "bug", kind: "message", T: K8 },
        { no: 3, name: "date", kind: "scalar", T: 9 },
        { no: 4, name: "seed", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Nv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nv, t, e)
    }
  },
  iYt = class Cv extends h {
    constructor(t) {
      super(), (this.isRealBug = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotDiscriminatorTrainingPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "props", kind: "message", T: CSt },
        { no: 2, name: "is_real_bug", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Cv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cv, t, e)
    }
  },
  Ud
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ACCEPT = 1)] = "ACCEPT"),
    (i[(i.REJECT = 2)] = "REJECT"),
    (i[(i.PARTIAL_ACCEPT = 3)] = "PARTIAL_ACCEPT")
})(Ud || (Ud = {})),
  n.util.setEnumType(Ud, "aiserver.v1.CppFate", [
    { no: 0, name: "CPP_FATE_UNSPECIFIED" },
    { no: 1, name: "CPP_FATE_ACCEPT" },
    { no: 2, name: "CPP_FATE_REJECT" },
    { no: 3, name: "CPP_FATE_PARTIAL_ACCEPT" },
  ])
var Md
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LINE_CHANGE = 1)] = "LINE_CHANGE"),
    (i[(i.TYPING = 2)] = "TYPING"),
    (i[(i.OPTION_HOLD = 3)] = "OPTION_HOLD"),
    (i[(i.LINTER_ERRORS = 4)] = "LINTER_ERRORS"),
    (i[(i.PARAMETER_HINTS = 5)] = "PARAMETER_HINTS"),
    (i[(i.CURSOR_PREDICTION = 6)] = "CURSOR_PREDICTION"),
    (i[(i.MANUAL_TRIGGER = 7)] = "MANUAL_TRIGGER"),
    (i[(i.EDITOR_CHANGE = 8)] = "EDITOR_CHANGE"),
    (i[(i.LSP_SUGGESTIONS = 9)] = "LSP_SUGGESTIONS")
})(Md || (Md = {})),
  n.util.setEnumType(Md, "aiserver.v1.CppSource", [
    { no: 0, name: "CPP_SOURCE_UNSPECIFIED" },
    { no: 1, name: "CPP_SOURCE_LINE_CHANGE" },
    { no: 2, name: "CPP_SOURCE_TYPING" },
    { no: 3, name: "CPP_SOURCE_OPTION_HOLD" },
    { no: 4, name: "CPP_SOURCE_LINTER_ERRORS" },
    { no: 5, name: "CPP_SOURCE_PARAMETER_HINTS" },
    { no: 6, name: "CPP_SOURCE_CURSOR_PREDICTION" },
    { no: 7, name: "CPP_SOURCE_MANUAL_TRIGGER" },
    { no: 8, name: "CPP_SOURCE_EDITOR_CHANGE" },
    { no: 9, name: "CPP_SOURCE_LSP_SUGGESTIONS" },
  ])
var Vet = class Jv extends h {
    constructor(t) {
      super(), (this.source = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppIntentInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "source", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Jv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jv, t, e)
    }
  },
  JSt = class Lv extends h {
    constructor(t) {
      super(), (this.label = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Lv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lv, t, e)
    }
  },
  LSt = class Rv extends h {
    constructor(t) {
      super(), (this.suggestions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSuggestedItems"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "suggestions", kind: "message", T: JSt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Rv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rv, t, e)
    }
  },
  RSt = class Dv extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShouldTurnOnCppOnboardingRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Dv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dv, t, e)
    }
  },
  DSt = class Fv extends h {
    constructor(t) {
      super(),
        (this.shouldTurnOnCppOnboarding = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShouldTurnOnCppOnboardingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "should_turn_on_cpp_onboarding", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Fv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fv, t, e)
    }
  },
  AM = class Av extends h {
    constructor(t) {
      super(),
        (this.diffHistory = []),
        (this.contextItems = []),
        (this.diffHistoryKeys = []),
        (this.fileDiffHistories = []),
        (this.mergedDiffHistories = []),
        (this.blockDiffPatches = []),
        (this.parameterHints = []),
        (this.lspContexts = []),
        (this.additionalFiles = []),
        (this.filesyncUpdates = []),
        (this.timeSinceRequestStart = 0),
        (this.timeAtRequestSend = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCppRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "linter_errors", kind: "message", T: $i, opt: !0 },
        { no: 13, name: "context_items", kind: "message", T: OM, repeated: !0 },
        {
          no: 5,
          name: "diff_history_keys",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "give_debug_output", kind: "scalar", T: 8, opt: !0 },
        {
          no: 7,
          name: "file_diff_histories",
          kind: "message",
          T: Xi,
          repeated: !0,
        },
        {
          no: 8,
          name: "merged_diff_histories",
          kind: "message",
          T: Xi,
          repeated: !0,
        },
        {
          no: 9,
          name: "block_diff_patches",
          kind: "message",
          T: UM,
          repeated: !0,
        },
        { no: 10, name: "is_nightly", kind: "scalar", T: 8, opt: !0 },
        { no: 11, name: "is_debug", kind: "scalar", T: 8, opt: !0 },
        { no: 12, name: "immediately_ack", kind: "scalar", T: 8, opt: !0 },
        { no: 17, name: "enable_more_context", kind: "scalar", T: 8, opt: !0 },
        {
          no: 14,
          name: "parameter_hints",
          kind: "message",
          T: zet,
          repeated: !0,
        },
        { no: 15, name: "lsp_contexts", kind: "message", T: DM, repeated: !0 },
        { no: 16, name: "cpp_intent_info", kind: "message", T: Vet, opt: !0 },
        { no: 18, name: "workspace_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 19,
          name: "additional_files",
          kind: "message",
          T: GSt,
          repeated: !0,
        },
        {
          no: 20,
          name: "control_token",
          kind: "enum",
          T: n.getEnumType(Z8),
          opt: !0,
        },
        { no: 21, name: "client_time", kind: "scalar", T: 1, opt: !0 },
        {
          no: 22,
          name: "filesync_updates",
          kind: "message",
          T: qd,
          repeated: !0,
        },
        { no: 23, name: "time_since_request_start", kind: "scalar", T: 1 },
        { no: 24, name: "time_at_request_send", kind: "scalar", T: 1 },
        {
          no: 25,
          name: "client_timezone_offset",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        {
          no: 26,
          name: "lsp_suggested_items",
          kind: "message",
          T: LSt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Av().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Av().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Av().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Av, t, e)
    }
  },
  Z8
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.QUIET = 1)] = "QUIET"),
    (i[(i.LOUD = 2)] = "LOUD"),
    (i[(i.OP = 3)] = "OP")
})(Z8 || (Z8 = {})),
  n.util.setEnumType(Z8, "aiserver.v1.StreamCppRequest.ControlToken", [
    { no: 0, name: "CONTROL_TOKEN_UNSPECIFIED" },
    { no: 1, name: "CONTROL_TOKEN_QUIET" },
    { no: 2, name: "CONTROL_TOKEN_LOUD" },
    { no: 3, name: "CONTROL_TOKEN_OP" },
  ])
var FSt = class _v extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCppResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "suggestion_start_line", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "suggestion_confidence", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "done_stream", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "debug_model_output", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "debug_model_input", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "debug_stream_time", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "debug_total_time", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "debug_ttft_time", kind: "scalar", T: 9, opt: !0 },
        { no: 10, name: "debug_server_timing", kind: "scalar", T: 9, opt: !0 },
        { no: 11, name: "range_to_replace", kind: "message", T: Li, opt: !0 },
        {
          no: 12,
          name: "cursor_prediction_target",
          kind: "message",
          T: ASt,
          opt: !0,
        },
        { no: 13, name: "done_edit", kind: "scalar", T: 8, opt: !0 },
        { no: 14, name: "model_info", kind: "message", T: _St, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _v().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _v().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _v().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_v, t, e)
    }
  },
  ASt = class Ov extends h {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.lineNumberOneIndexed = 0),
        (this.expectedContent = ""),
        (this.shouldRetriggerCpp = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCppResponse.CursorPredictionTarget"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 3, name: "expected_content", kind: "scalar", T: 9 },
        { no: 4, name: "should_retrigger_cpp", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Ov().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ov().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ov().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ov, t, e)
    }
  },
  _St = class Bv extends h {
    constructor(t) {
      super(),
        (this.isFusedCursorPredictionModel = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCppResponse.ModelInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "is_fused_cursor_prediction_model",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Bv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bv, t, e)
    }
  },
  OSt = class qv extends h {
    constructor(t) {
      super(), (this.model = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_nightly", kind: "scalar", T: 8, opt: !0 },
        { no: 2, name: "model", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qv, t, e)
    }
  },
  BSt = class Uv extends h {
    constructor(t) {
      super(),
        (this.heuristics = []),
        (this.excludeRecentlyViewedFilesPatterns = []),
        (this.enableRvfTracking = !1),
        (this.globalDebounceDurationMillis = 0),
        (this.clientDebounceDurationMillis = 0),
        (this.cppUrl = ""),
        (this.useWhitespaceDiffHistory = !1),
        (this.enableFilesyncDebounceSkipping = !1),
        (this.checkFilesyncHashPercent = 0),
        (this.geoCppBackendUrl = ""),
        (this.isFusedCursorPredictionModel = !1),
        (this.includeUnchangedLines = !1),
        (this.shouldFetchRvfText = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "above_radius", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "below_radius", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "merge_behavior", kind: "message", T: USt, opt: !0 },
        { no: 5, name: "is_on", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "is_ghost_text", kind: "scalar", T: 8, opt: !0 },
        {
          no: 7,
          name: "should_let_user_enable_cpp_even_if_not_pro",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 8,
          name: "heuristics",
          kind: "enum",
          T: n.getEnumType(tB),
          repeated: !0,
        },
        {
          no: 9,
          name: "exclude_recently_viewed_files_patterns",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 10, name: "enable_rvf_tracking", kind: "scalar", T: 8 },
        {
          no: 11,
          name: "global_debounce_duration_millis",
          kind: "scalar",
          T: 5,
        },
        {
          no: 12,
          name: "client_debounce_duration_millis",
          kind: "scalar",
          T: 5,
        },
        { no: 13, name: "cpp_url", kind: "scalar", T: 9 },
        { no: 14, name: "use_whitespace_diff_history", kind: "scalar", T: 8 },
        { no: 15, name: "import_prediction_config", kind: "message", T: qSt },
        {
          no: 16,
          name: "enable_filesync_debounce_skipping",
          kind: "scalar",
          T: 8,
        },
        { no: 17, name: "check_filesync_hash_percent", kind: "scalar", T: 2 },
        { no: 18, name: "geo_cpp_backend_url", kind: "scalar", T: 9 },
        {
          no: 19,
          name: "recently_rejected_edit_thresholds",
          kind: "message",
          T: MSt,
          opt: !0,
        },
        {
          no: 20,
          name: "is_fused_cursor_prediction_model",
          kind: "scalar",
          T: 8,
        },
        { no: 21, name: "include_unchanged_lines", kind: "scalar", T: 8 },
        { no: 22, name: "should_fetch_rvf_text", kind: "scalar", T: 8 },
        {
          no: 23,
          name: "max_number_of_cleared_suggestions_since_last_accept",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 24,
          name: "suggestion_hint_config",
          kind: "message",
          T: HSt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Uv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Uv, t, e)
    }
  },
  tB
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOTS_OF_ADDED_TEXT = 1)] = "LOTS_OF_ADDED_TEXT"),
    (i[(i.DUPLICATING_LINE_AFTER_SUGGESTION = 2)] =
      "DUPLICATING_LINE_AFTER_SUGGESTION"),
    (i[(i.DUPLICATING_MULTIPLE_LINES_AFTER_SUGGESTION = 3)] =
      "DUPLICATING_MULTIPLE_LINES_AFTER_SUGGESTION"),
    (i[(i.REVERTING_USER_CHANGE = 4)] = "REVERTING_USER_CHANGE"),
    (i[(i.OUTPUT_EXTENDS_BEYOND_RANGE_AND_IS_REPEATED = 5)] =
      "OUTPUT_EXTENDS_BEYOND_RANGE_AND_IS_REPEATED"),
    (i[(i.SUGGESTING_RECENTLY_REJECTED_EDIT = 6)] =
      "SUGGESTING_RECENTLY_REJECTED_EDIT")
})(tB || (tB = {})),
  n.util.setEnumType(tB, "aiserver.v1.CppConfigResponse.Heuristic", [
    { no: 0, name: "HEURISTIC_UNSPECIFIED" },
    { no: 1, name: "HEURISTIC_LOTS_OF_ADDED_TEXT" },
    { no: 2, name: "HEURISTIC_DUPLICATING_LINE_AFTER_SUGGESTION" },
    { no: 3, name: "HEURISTIC_DUPLICATING_MULTIPLE_LINES_AFTER_SUGGESTION" },
    { no: 4, name: "HEURISTIC_REVERTING_USER_CHANGE" },
    { no: 5, name: "HEURISTIC_OUTPUT_EXTENDS_BEYOND_RANGE_AND_IS_REPEATED" },
    { no: 6, name: "HEURISTIC_SUGGESTING_RECENTLY_REJECTED_EDIT" },
  ])
var qSt = class Mv extends h {
    constructor(t) {
      super(),
        (this.isDisabledByBackend = !1),
        (this.shouldTurnOnAutomatically = !1),
        (this.pythonEnabled = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigResponse.ImportPredictionConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_disabled_by_backend", kind: "scalar", T: 8 },
        { no: 2, name: "should_turn_on_automatically", kind: "scalar", T: 8 },
        { no: 3, name: "python_enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Mv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mv, t, e)
    }
  },
  USt = class Hv extends h {
    constructor(t) {
      super(), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigResponse.MergeBehavior"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "limit", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "radius", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Hv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hv, t, e)
    }
  },
  MSt = class Wv extends h {
    constructor(t) {
      super(),
        (this.hardRejectThreshold = 0),
        (this.softRejectThreshold = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.CppConfigResponse.RecentlyRejectedEditThresholds"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "hard_reject_threshold", kind: "scalar", T: 5 },
        { no: 2, name: "soft_reject_threshold", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Wv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wv, t, e)
    }
  },
  HSt = class jv extends h {
    constructor(t) {
      super(),
        (this.importantLspExtensions = []),
        (this.enabledForPathExtensions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigResponse.SuggestionHintConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "important_lsp_extensions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 2,
          name: "enabled_for_path_extensions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new jv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jv, t, e)
    }
  },
  Get = class Vv extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SuggestedEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "edit_range", kind: "message", T: Pi },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Vv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vv, t, e)
    }
  },
  WSt = class Gv extends h {
    constructor(t) {
      super(),
        (this.suggestedEdits = []),
        (this.markerTouchesGreen = !1),
        (this.currentFileContentsForLinterErrors = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCppEditClassificationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_request", kind: "message", T: AM },
        {
          no: 25,
          name: "suggested_edits",
          kind: "message",
          T: Get,
          repeated: !0,
        },
        { no: 26, name: "marker_touches_green", kind: "scalar", T: 8 },
        {
          no: 27,
          name: "current_file_contents_for_linter_errors",
          kind: "scalar",
          T: 9,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Gv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gv, t, e)
    }
  },
  jSt = class zv extends h {
    constructor(t) {
      super(), (this.scoredEdits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCppEditClassificationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "scored_edits", kind: "message", T: _M, repeated: !0 },
        { no: 2, name: "noop_edit", kind: "message", T: _M },
        { no: 3, name: "should_noop", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "generation_edit", kind: "message", T: _M },
      ])
    }
    static fromBinary(t, e) {
      return new zv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zv, t, e)
    }
  },
  VSt = class Yv extends h {
    constructor(t) {
      super(),
        (this.tokens = []),
        (this.tokenLogprobs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCppEditClassificationResponse.LogProbs"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tokens", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "token_logprobs", kind: "scalar", T: 1, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Yv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yv, t, e)
    }
  },
  _M = class Qv extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCppEditClassificationResponse.ScoredEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "edit", kind: "message", T: Get },
        { no: 2, name: "log_probs", kind: "message", T: VSt },
      ])
    }
    static fromBinary(t, e) {
      return new Qv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qv, t, e)
    }
  },
  GSt = class Xv extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.isOpen = !1),
        (this.visibleRangeContent = []),
        (this.startLineNumberOneIndexed = []),
        (this.visibleRanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AdditionalFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "is_open", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "visible_range_content",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 4, name: "last_viewed_at", kind: "scalar", T: 1, opt: !0 },
        {
          no: 5,
          name: "start_line_number_one_indexed",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
        { no: 6, name: "visible_ranges", kind: "message", T: Li, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Xv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xv, t, e)
    }
  },
  zSt = class Kv extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.performanceNowTime = 0),
        (this.fate = Ud.UNSPECIFIED),
        (this.extension = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecordCppFateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "performance_now_time", kind: "scalar", T: 2 },
        { no: 3, name: "fate", kind: "enum", T: n.getEnumType(Ud) },
        { no: 4, name: "extension", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Kv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kv, t, e)
    }
  },
  YSt = class Zv extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecordCppFateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Zv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zv, t, e)
    }
  },
  QSt = class t1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableCppModelsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new t1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t1, t, e)
    }
  },
  XSt = class e1 extends h {
    constructor(t) {
      super(), (this.models = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableCppModelsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "models", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "default_model", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new e1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e1, t, e)
    }
  },
  KSt = class i1 extends h {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.fileDiffHistories = []),
        (this.mergedDiffHistories = []),
        (this.blockDiffPatches = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHoldCppRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 4, name: "linter_errors", kind: "message", T: $i, opt: !0 },
        { no: 13, name: "context_items", kind: "message", T: OM, repeated: !0 },
        {
          no: 7,
          name: "file_diff_histories",
          kind: "message",
          T: Xi,
          repeated: !0,
        },
        {
          no: 8,
          name: "merged_diff_histories",
          kind: "message",
          T: Xi,
          repeated: !0,
        },
        {
          no: 9,
          name: "block_diff_patches",
          kind: "message",
          T: UM,
          repeated: !0,
        },
        { no: 10, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new i1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i1, t, e)
    }
  },
  ZSt = class s1 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHoldCppResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new s1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s1, t, e)
    }
  },
  Xi = class r1 extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diffHistory = []),
        (this.diffHistoryTimestamps = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppFileDiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 3,
          name: "diff_history_timestamps",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new r1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r1, t, e)
    }
  },
  OM = class n1 extends h {
    constructor(t) {
      super(),
        (this.contents = ""),
        (this.relativeWorkspacePath = ""),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppContextItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
        { no: 2, name: "symbol", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new n1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n1, t, e)
    }
  },
  tEt = class a1 extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.sessionId = ""),
        (this.responseType = Hd.UNSPECIFIED),
        (this.modelCodeName = ""),
        (this.modelOpenaiName = ""),
        (this.currentPerformanceNowTime = 0),
        (this.sessionPerformanceOriginTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkCppRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "session_id", kind: "scalar", T: 9 },
        { no: 3, name: "response_type", kind: "enum", T: n.getEnumType(Hd) },
        { no: 4, name: "desired_completion", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "range_transformation", kind: "message", T: eEt },
        { no: 10, name: "model_code_name", kind: "scalar", T: 9 },
        { no: 11, name: "model_openai_name", kind: "scalar", T: 9 },
        { no: 12, name: "current_performance_now_time", kind: "scalar", T: 1 },
        {
          no: 13,
          name: "session_performance_origin_time",
          kind: "scalar",
          T: 1,
        },
      ])
    }
    static fromBinary(t, e) {
      return new a1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a1, t, e)
    }
  },
  Hd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GOOD = 1)] = "GOOD"),
    (i[(i.BAD = 2)] = "BAD"),
    (i[(i.BAD_CONTEXT = 3)] = "BAD_CONTEXT"),
    (i[(i.BAD_REASONING = 4)] = "BAD_REASONING"),
    (i[(i.BAD_STUPID_MISTAKE = 5)] = "BAD_STUPID_MISTAKE"),
    (i[(i.BAD_FORMATTING = 6)] = "BAD_FORMATTING"),
    (i[(i.BAD_RANGE = 7)] = "BAD_RANGE"),
    (i[(i.GOOD_PREDICTION = 8)] = "GOOD_PREDICTION"),
    (i[(i.BAD_FALSE_POSITIVE_TRIGGER = 9)] = "BAD_FALSE_POSITIVE_TRIGGER"),
    (i[(i.BAD_FALSE_NEGATIVE_TRIGGER = 10)] = "BAD_FALSE_NEGATIVE_TRIGGER")
})(Hd || (Hd = {})),
  n.util.setEnumType(Hd, "aiserver.v1.MarkCppRequest.CppResponseTypes", [
    { no: 0, name: "CPP_RESPONSE_TYPES_UNSPECIFIED" },
    { no: 1, name: "CPP_RESPONSE_TYPES_GOOD" },
    { no: 2, name: "CPP_RESPONSE_TYPES_BAD" },
    { no: 3, name: "CPP_RESPONSE_TYPES_BAD_CONTEXT" },
    { no: 4, name: "CPP_RESPONSE_TYPES_BAD_REASONING" },
    { no: 5, name: "CPP_RESPONSE_TYPES_BAD_STUPID_MISTAKE" },
    { no: 6, name: "CPP_RESPONSE_TYPES_BAD_FORMATTING" },
    { no: 7, name: "CPP_RESPONSE_TYPES_BAD_RANGE" },
    { no: 8, name: "CPP_RESPONSE_TYPES_GOOD_PREDICTION" },
    { no: 9, name: "CPP_RESPONSE_TYPES_BAD_FALSE_POSITIVE_TRIGGER" },
    { no: 10, name: "CPP_RESPONSE_TYPES_BAD_FALSE_NEGATIVE_TRIGGER" },
  ])
var eEt = class o1 extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkCppRequest.RangeTransformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new o1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o1, t, e)
    }
  },
  zet = class c1 extends h {
    constructor(t) {
      super(), (this.label = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppParameterHint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "documentation", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new c1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c1, t, e)
    }
  },
  iEt = class l1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkCppResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new l1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l1, t, e)
    }
  },
  Ss = class u1 extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new u1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u1, t, e)
    }
  },
  eB = class h1 extends h {
    constructor(t) {
      super(),
        (this.lineNumberOneIndexed = 0),
        (this.columnOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OneIndexedPosition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 2, name: "column_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new h1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h1, t, e)
    }
  },
  sEt = class d1 extends h {
    constructor(t) {
      super(),
        (this.selectionStartLineNumber = 0),
        (this.selectionStartColumn = 0),
        (this.positionLineNumber = 0),
        (this.positionColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "selection_start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "selection_start_column", kind: "scalar", T: 5 },
        { no: 3, name: "position_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "position_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new d1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d1, t, e)
    }
  },
  Wd = class m1 extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.modelIsAttachedToEditor = !1),
        (this.modelIsAttachedToTheActiveEditor = !1),
        (this.cursorSelections = []),
        (this.modelVersionAtMetadataRetrievalTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ss },
        { no: 3, name: "final_model_hash", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "model_version_immediately_after_this_change",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "performance_now_timestamp",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        { no: 7, name: "is_undoing", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "is_redoing", kind: "scalar", T: 8, opt: !0 },
        { no: 9, name: "model_is_attached_to_editor", kind: "scalar", T: 8 },
        {
          no: 10,
          name: "model_is_attached_to_the_active_editor",
          kind: "scalar",
          T: 8,
        },
        {
          no: 11,
          name: "cursor_selections",
          kind: "message",
          T: sEt,
          repeated: !0,
        },
        {
          no: 12,
          name: "model_version_at_metadata_retrieval_time",
          kind: "scalar",
          T: 5,
        },
      ])
    }
    static fromBinary(t, e) {
      return new m1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m1, t, e)
    }
  },
  iB = class f1 extends h {
    constructor(t) {
      super(),
        (this.suggestionId = 0),
        (this.suggestionText = ""),
        (this.modelVersionWhenTheChangeIsFirstIndicatedToTheUserButNotShownInTheModel = 0),
        (this.originalText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CurrentlyShownCppSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "suggestion_id", kind: "scalar", T: 5 },
        { no: 2, name: "suggestion_text", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "model_version_when_the_change_is_first_indicated_to_the_user_but_not_shown_in_the_model",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "range_of_suggestion_in_current_model",
          kind: "message",
          T: Ss,
          opt: !0,
        },
        { no: 5, name: "original_text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new f1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f1, t, e)
    }
  },
  rEt = class p1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppAcceptEventNew"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: iB },
        { no: 7, name: "point_in_time_model", kind: "message", T: ni },
      ])
    }
    static fromBinary(t, e) {
      return new p1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p1, t, e)
    }
  },
  Yet = class g1 extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.suggestionText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecoverableCppData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "suggestion_text", kind: "scalar", T: 9 },
        { no: 3, name: "suggestion_range", kind: "message", T: Ss },
        { no: 4, name: "position", kind: "message", T: eB },
      ])
    }
    static fromBinary(t, e) {
      return new g1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g1, t, e)
    }
  },
  nEt = class v1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppSuggestEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: iB },
        { no: 2, name: "point_in_time_model", kind: "message", T: ni },
        { no: 3, name: "recoverable_cpp_data", kind: "message", T: Yet },
      ])
    }
    static fromBinary(t, e) {
      return new v1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v1, t, e)
    }
  },
  aEt = class w1 extends h {
    constructor(t) {
      super(),
        (this.generationUuid = ""),
        (this.modelVersion = 0),
        (this.source = Md.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTriggerEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "generation_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "model_version", kind: "scalar", T: 5 },
        { no: 3, name: "cursor_position", kind: "message", T: eB },
        { no: 4, name: "point_in_time_model", kind: "message", T: ni },
        { no: 5, name: "source", kind: "enum", T: n.getEnumType(Md) },
      ])
    }
    static fromBinary(t, e) {
      return new w1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w1, t, e)
    }
  },
  oEt = class y1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishedCppGenerationEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: ni },
        { no: 2, name: "recoverable_cpp_data", kind: "message", T: Yet },
      ])
    }
    static fromBinary(t, e) {
      return new y1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y1, t, e)
    }
  },
  cEt = class b1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppRejectEventNew"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: iB },
        { no: 7, name: "point_in_time_model", kind: "message", T: ni },
      ])
    }
    static fromBinary(t, e) {
      return new b1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b1, t, e)
    }
  },
  lEt = class T1 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ss },
      ])
    }
    static fromBinary(t, e) {
      return new T1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T1, t, e)
    }
  },
  uEt = class k1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppPartialAcceptEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: iB },
        { no: 2, name: "edit", kind: "message", T: lEt },
        { no: 3, name: "point_in_time_model", kind: "message", T: ni },
      ])
    }
    static fromBinary(t, e) {
      return new k1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k1, t, e)
    }
  },
  BM = class S1 extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.predictionId = 0),
        (this.lineNumber = 0),
        (this.source = jd.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPrediction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "prediction_id", kind: "scalar", T: 5 },
        { no: 3, name: "line_number", kind: "scalar", T: 5 },
        { no: 4, name: "source", kind: "enum", T: n.getEnumType(jd) },
      ])
    }
    static fromBinary(t, e) {
      return new S1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S1, t, e)
    }
  },
  jd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ALWAYS_ON = 1)] = "ALWAYS_ON"),
    (i[(i.ACCEPT = 2)] = "ACCEPT"),
    (i[(i.UNDO = 3)] = "UNDO"),
    (i[(i.EDITOR_CHANGE = 4)] = "EDITOR_CHANGE")
})(jd || (jd = {})),
  n.util.setEnumType(
    jd,
    "aiserver.v1.CursorPrediction.CursorPredictionSource",
    [
      { no: 0, name: "CURSOR_PREDICTION_SOURCE_UNSPECIFIED" },
      { no: 1, name: "CURSOR_PREDICTION_SOURCE_ALWAYS_ON" },
      { no: 2, name: "CURSOR_PREDICTION_SOURCE_ACCEPT" },
      { no: 3, name: "CURSOR_PREDICTION_SOURCE_UNDO" },
      { no: 4, name: "CURSOR_PREDICTION_SOURCE_EDITOR_CHANGE" },
    ],
  )
var hEt = class E1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SuggestCursorPredictionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cursor_prediction", kind: "message", T: BM },
        { no: 2, name: "point_in_time_model", kind: "message", T: ni },
      ])
    }
    static fromBinary(t, e) {
      return new E1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E1, t, e)
    }
  },
  dEt = class I1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AcceptCursorPredictionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cursor_prediction", kind: "message", T: BM },
        { no: 2, name: "point_in_time_model", kind: "message", T: ni },
      ])
    }
    static fromBinary(t, e) {
      return new I1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I1, t, e)
    }
  },
  mEt = class P1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RejectCursorPredictionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cursor_prediction", kind: "message", T: BM },
        { no: 2, name: "point_in_time_model", kind: "message", T: ni },
      ])
    }
    static fromBinary(t, e) {
      return new P1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P1, t, e)
    }
  },
  Qet = class $1 extends h {
    constructor(t) {
      super(),
        (this.modelVersion = 0),
        (this.relativePath = ""),
        (this.modelId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MaybeDefinedPointInTimeModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_uuid", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "model_version", kind: "scalar", T: 5 },
        { no: 3, name: "relative_path", kind: "scalar", T: 9 },
        { no: 4, name: "model_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($1, t, e)
    }
  },
  ni = class x1 extends h {
    constructor(t) {
      super(),
        (this.modelUuid = ""),
        (this.modelVersion = 0),
        (this.relativePath = ""),
        (this.modelId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PointInTimeModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "model_version", kind: "scalar", T: 5 },
        { no: 3, name: "relative_path", kind: "scalar", T: 9 },
        { no: 4, name: "model_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new x1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x1, t, e)
    }
  },
  fEt = class N1 extends h {
    constructor(t) {
      super(),
        (this.lineNumberOneIndexed = 0),
        (this.columnNumberOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppManualTriggerEventNew"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 2, name: "column_number_one_indexed", kind: "scalar", T: 5 },
        { no: 7, name: "point_in_time_model", kind: "message", T: ni },
      ])
    }
    static fromBinary(t, e) {
      return new N1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N1, t, e)
    }
  },
  pEt = class C1 extends h {
    constructor(t) {
      super(),
        (this.modelUuid = ""),
        (this.relativePath = ""),
        (this.reason = Vd.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppStoppedTrackingModelEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "relative_path", kind: "scalar", T: 9 },
        { no: 3, name: "reason", kind: "enum", T: n.getEnumType(Vd) },
      ])
    }
    static fromBinary(t, e) {
      return new C1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C1, t, e)
    }
  },
  Vd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FILE_TOO_BIG = 1)] = "FILE_TOO_BIG"),
    (i[(i.FILE_DISPOSED = 2)] = "FILE_DISPOSED"),
    (i[(i.CHANGE_TOO_BIG = 3)] = "CHANGE_TOO_BIG")
})(Vd || (Vd = {})),
  n.util.setEnumType(
    Vd,
    "aiserver.v1.CppStoppedTrackingModelEvent.StoppedTrackingModelReason",
    [
      { no: 0, name: "STOPPED_TRACKING_MODEL_REASON_UNSPECIFIED" },
      { no: 1, name: "STOPPED_TRACKING_MODEL_REASON_FILE_TOO_BIG" },
      { no: 2, name: "STOPPED_TRACKING_MODEL_REASON_FILE_DISPOSED" },
      { no: 3, name: "STOPPED_TRACKING_MODEL_REASON_CHANGE_TOO_BIG" },
    ],
  )
var gEt = class J1 extends h {
    constructor(t) {
      super(),
        (this.addedErrors = []),
        (this.removedErrors = []),
        (this.errors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppLinterErrorEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: ni },
        { no: 2, name: "added_errors", kind: "message", T: ka, repeated: !0 },
        { no: 3, name: "removed_errors", kind: "message", T: ka, repeated: !0 },
        { no: 4, name: "errors", kind: "message", T: ka, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new J1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J1, t, e)
    }
  },
  vEt = class L1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppDebouncedCursorMovementEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: ni },
        { no: 2, name: "cursor_position", kind: "message", T: eB },
      ])
    }
    static fromBinary(t, e) {
      return new L1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L1, t, e)
    }
  },
  wEt = class R1 extends h {
    constructor(t) {
      super(),
        (this.visibleRanges = []),
        (this.editorId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppEditorChangedEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: ni },
        { no: 2, name: "cursor_position", kind: "message", T: eB },
        { no: 3, name: "visible_ranges", kind: "message", T: Ss, repeated: !0 },
        { no: 4, name: "editor_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new R1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R1, t, e)
    }
  },
  yEt = class D1 extends h {
    constructor(t) {
      super(), (this.clipboardContents = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppCopyEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "clipboard_contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new D1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D1, t, e)
    }
  },
  Xet = class F1 extends h {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.id = ""),
        (this.arguments = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppQuickActionCommand"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "arguments", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new F1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F1, t, e)
    }
  },
  sB = class A1 extends h {
    constructor(t) {
      super(), (this.title = ""), (this.edits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppQuickAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "edits", kind: "message", T: bEt, repeated: !0 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "command", kind: "message", T: Xet },
      ])
    }
    static fromBinary(t, e) {
      return new A1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A1, t, e)
    }
  },
  bEt = class _1 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppQuickAction.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ss },
      ])
    }
    static fromBinary(t, e) {
      return new _1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_1, t, e)
    }
  },
  TEt = class O1 extends h {
    constructor(t) {
      super(),
        (this.added = []),
        (this.removed = []),
        (this.actions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppChangeQuickActionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: ni },
        { no: 2, name: "added", kind: "message", T: sB, repeated: !0 },
        { no: 3, name: "removed", kind: "message", T: sB, repeated: !0 },
        { no: 4, name: "actions", kind: "message", T: sB, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new O1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O1, t, e)
    }
  },
  kEt = class B1 extends h {
    constructor(t) {
      super(),
        (this.actionIdentifier = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppQuickActionFireEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: ni },
        {
          no: 2,
          name: "quick_action_command",
          kind: "message",
          T: Xet,
          oneof: "action_identifier",
        },
        {
          no: 3,
          name: "quick_action_event",
          kind: "message",
          T: sB,
          oneof: "action_identifier",
        },
      ])
    }
    static fromBinary(t, e) {
      return new B1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B1, t, e)
    }
  },
  SEt = class q1 extends h {
    constructor(t) {
      super(),
        (this.terminalId = 0),
        (this.terminalPath = ""),
        (this.event = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTerminalEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "terminal_id", kind: "scalar", T: 5 },
        { no: 2, name: "terminal_path", kind: "scalar", T: 9 },
        { no: 6, name: "terminal_cwd", kind: "scalar", T: 9, opt: !0 },
        {
          no: 3,
          name: "terminal_input",
          kind: "message",
          T: EEt,
          oneof: "event",
        },
        {
          no: 4,
          name: "command_started",
          kind: "message",
          T: IEt,
          oneof: "event",
        },
        {
          no: 5,
          name: "command_finished",
          kind: "message",
          T: PEt,
          oneof: "event",
        },
      ])
    }
    static fromBinary(t, e) {
      return new q1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q1, t, e)
    }
  },
  EEt = class U1 extends h {
    constructor(t) {
      super(), (this.bufferedKeypresses = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTerminalEvent.TerminalInput"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "buffered_keypresses",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new U1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U1, t, e)
    }
  },
  IEt = class M1 extends h {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.startedTimestampUnixMs = 0),
        (this.commandWasTrimmed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTerminalEvent.CommandStarted"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "started_timestamp_unix_ms", kind: "scalar", T: 1 },
        { no: 3, name: "command_was_trimmed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new M1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M1, t, e)
    }
  },
  PEt = class H1 extends h {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.output = ""),
        (this.finishedTimestampUnixMs = 0),
        (this.commandWasTrimmed = !1),
        (this.outputWasTrimmed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTerminalEvent.CommandFinished"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "exit_code", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "output", kind: "scalar", T: 9 },
        { no: 4, name: "finished_timestamp_unix_ms", kind: "scalar", T: 1 },
        { no: 5, name: "command_was_trimmed", kind: "scalar", T: 8 },
        { no: 6, name: "output_was_trimmed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new H1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H1, t, e)
    }
  },
  $Et = class W1 extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.eventType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: ni },
        { no: 2, name: "request_id", kind: "scalar", T: 9 },
        { no: 20, name: "prompt_bar_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 3,
          name: "submit_prompt",
          kind: "message",
          T: xEt,
          oneof: "event_type",
        },
        {
          no: 4,
          name: "end_of_generation",
          kind: "message",
          T: NEt,
          oneof: "event_type",
        },
        {
          no: 5,
          name: "interrupt_generation",
          kind: "message",
          T: CEt,
          oneof: "event_type",
        },
        {
          no: 6,
          name: "accept_all",
          kind: "message",
          T: JEt,
          oneof: "event_type",
        },
        {
          no: 7,
          name: "reject_all",
          kind: "message",
          T: LEt,
          oneof: "event_type",
        },
        {
          no: 8,
          name: "reject_partial_diff",
          kind: "message",
          T: DEt,
          oneof: "event_type",
        },
        {
          no: 9,
          name: "accept_partial_diff",
          kind: "message",
          T: REt,
          oneof: "event_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new W1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W1, t, e)
    }
  },
  xEt = class j1 extends h {
    constructor(t) {
      super(),
        (this.originalText = ""),
        (this.prompt = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.SubmitPrompt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original_range", kind: "message", T: Ss },
        { no: 2, name: "original_text", kind: "scalar", T: 9 },
        { no: 3, name: "prompt", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new j1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j1, t, e)
    }
  },
  NEt = class V1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.EndOfGeneration"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new V1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V1, t, e)
    }
  },
  CEt = class G1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.InterruptGeneration"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new G1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G1, t, e)
    }
  },
  JEt = class z1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.AcceptDiffs"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new z1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z1, t, e)
    }
  },
  LEt = class Y1 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.RejectDiffs"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Y1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y1, t, e)
    }
  },
  REt = class Q1 extends h {
    constructor(t) {
      super(),
        (this.greenLines = []),
        (this.redLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.AcceptPartialDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "green_range", kind: "message", T: Ss },
        { no: 2, name: "green_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "red_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Q1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q1, t, e)
    }
  },
  DEt = class X1 extends h {
    constructor(t) {
      super(),
        (this.greenLines = []),
        (this.redLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.RejectPartialDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "green_range", kind: "message", T: Ss },
        { no: 2, name: "green_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "red_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new X1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X1, t, e)
    }
  },
  FEt = class K1 extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.eventType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "submit_prompt",
          kind: "message",
          T: AEt,
          oneof: "event_type",
        },
        {
          no: 3,
          name: "end_of_any_generation",
          kind: "message",
          T: _Et,
          oneof: "event_type",
        },
        {
          no: 4,
          name: "end_of_uninterrupted_generation",
          kind: "message",
          T: OEt,
          oneof: "event_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new K1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K1, t, e)
    }
  },
  AEt = class Z1 extends h {
    constructor(t) {
      super(), (this.prompt = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatEvent.SubmitPrompt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Z1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z1, t, e)
    }
  },
  _Et = class tw extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatEvent.EndOfAnyGeneration"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new tw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tw, t, e)
    }
  },
  OEt = class ew extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatEvent.EndOfUninterruptedGeneration"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new ew().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ew().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ew().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ew, t, e)
    }
  },
  BEt = class iw extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.eventType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "point_in_time_model", kind: "message", T: ni },
        {
          no: 3,
          name: "lint_generated",
          kind: "message",
          T: UEt,
          oneof: "event_type",
        },
        {
          no: 4,
          name: "lint_dismissed",
          kind: "message",
          T: MEt,
          oneof: "event_type",
        },
        {
          no: 5,
          name: "user_feedback",
          kind: "message",
          T: HEt,
          oneof: "event_type",
        },
        {
          no: 6,
          name: "viewed_report",
          kind: "message",
          T: WEt,
          oneof: "event_type",
        },
        {
          no: 7,
          name: "unviewed_report",
          kind: "message",
          T: jEt,
          oneof: "event_type",
        },
        {
          no: 8,
          name: "started",
          kind: "message",
          T: qEt,
          oneof: "event_type",
        },
        {
          no: 9,
          name: "not_shown_because_heuristic",
          kind: "message",
          T: VEt,
          oneof: "event_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new iw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iw, t, e)
    }
  },
  qEt = class sw extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.Started"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new sw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sw, t, e)
    }
  },
  UEt = class rw extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.LintGenerated"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report", kind: "message", T: K8 },
      ])
    }
    static fromBinary(t, e) {
      return new rw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rw, t, e)
    }
  },
  MEt = class nw extends h {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.LintDismissed"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nw, t, e)
    }
  },
  HEt = class aw extends h {
    constructor(t) {
      super(),
        (this.bugReportId = ""),
        (this.feedback = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.UserFeedback"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
        { no: 2, name: "feedback", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new aw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aw, t, e)
    }
  },
  WEt = class ow extends h {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.ViewedReport"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ow().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ow().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ow().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ow, t, e)
    }
  },
  jEt = class cw extends h {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.UnviewedReport"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cw, t, e)
    }
  },
  VEt = class lw extends h {
    constructor(t) {
      super(), (this.heuristic = Gd.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.NotShownBecauseHeuristic"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "heuristic", kind: "enum", T: n.getEnumType(Gd) },
      ])
    }
    static fromBinary(t, e) {
      return new lw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lw, t, e)
    }
  },
  Gd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LINT_OVERLAP = 1)] = "LINT_OVERLAP"),
    (i[(i.LINES_MISMATCH = 2)] = "LINES_MISMATCH")
})(Gd || (Gd = {})),
  n.util.setEnumType(
    Gd,
    "aiserver.v1.BugBotLinterEvent.NotShownBecauseHeuristic.Heuristic",
    [
      { no: 0, name: "HEURISTIC_UNSPECIFIED" },
      { no: 1, name: "HEURISTIC_LINT_OVERLAP" },
      { no: 2, name: "HEURISTIC_LINES_MISMATCH" },
    ],
  )
var GEt = class uw extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.eventType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "started",
          kind: "message",
          T: zEt,
          oneof: "event_type",
        },
        {
          no: 3,
          name: "reports_generated",
          kind: "message",
          T: YEt,
          oneof: "event_type",
        },
        {
          no: 4,
          name: "pressed_fix_in_composer",
          kind: "message",
          T: QEt,
          oneof: "event_type",
        },
        {
          no: 5,
          name: "pressed_open_in_editor",
          kind: "message",
          T: KEt,
          oneof: "event_type",
        },
        {
          no: 6,
          name: "viewed_report",
          kind: "message",
          T: ZEt,
          oneof: "event_type",
        },
        {
          no: 7,
          name: "user_feedback",
          kind: "message",
          T: eIt,
          oneof: "event_type",
        },
        {
          no: 8,
          name: "pressed_add_to_chat",
          kind: "message",
          T: XEt,
          oneof: "event_type",
        },
        {
          no: 9,
          name: "background_interval_started",
          kind: "message",
          T: iIt,
          oneof: "event_type",
        },
        {
          no: 10,
          name: "background_interval_ended",
          kind: "message",
          T: sIt,
          oneof: "event_type",
        },
        {
          no: 11,
          name: "background_interval_interrupted",
          kind: "message",
          T: rIt,
          oneof: "event_type",
        },
        {
          no: 12,
          name: "background_interval_errored",
          kind: "message",
          T: nIt,
          oneof: "event_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new uw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uw, t, e)
    }
  },
  zd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DISABLED = 1)] = "DISABLED"),
    (i[(i.TOO_RECENT = 2)] = "TOO_RECENT"),
    (i[(i.UNVIEWED_BUG_REPORTS = 3)] = "UNVIEWED_BUG_REPORTS"),
    (i[(i.NOT_IN_GIT_REPO = 4)] = "NOT_IN_GIT_REPO"),
    (i[(i.DEFAULT_BRANCH_IS_NOT_CURRENT_BRANCH = 5)] =
      "DEFAULT_BRANCH_IS_NOT_CURRENT_BRANCH"),
    (i[(i.NO_GIT_USER = 6)] = "NO_GIT_USER"),
    (i[(i.NO_LAST_COMMIT = 7)] = "NO_LAST_COMMIT"),
    (i[(i.LAST_COMMIT_NOT_MADE_BY_USER = 8)] = "LAST_COMMIT_NOT_MADE_BY_USER"),
    (i[(i.LAST_COMMIT_TOO_OLD = 9)] = "LAST_COMMIT_TOO_OLD"),
    (i[(i.DIFF_TOO_LONG = 10)] = "DIFF_TOO_LONG"),
    (i[(i.DIFF_TOO_SHORT = 11)] = "DIFF_TOO_SHORT"),
    (i[(i.TELEMETRY_UNHEALTHY = 12)] = "TELEMETRY_UNHEALTHY")
})(zd || (zd = {})),
  n.util.setEnumType(
    zd,
    "aiserver.v1.BugBotEvent.BackgroundIntervalInterruptedReason",
    [
      { no: 0, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_UNSPECIFIED" },
      { no: 1, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_DISABLED" },
      { no: 2, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_TOO_RECENT" },
      {
        no: 3,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_UNVIEWED_BUG_REPORTS",
      },
      { no: 4, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_NOT_IN_GIT_REPO" },
      {
        no: 5,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_DEFAULT_BRANCH_IS_NOT_CURRENT_BRANCH",
      },
      { no: 6, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_NO_GIT_USER" },
      { no: 7, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_NO_LAST_COMMIT" },
      {
        no: 8,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_LAST_COMMIT_NOT_MADE_BY_USER",
      },
      {
        no: 9,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_LAST_COMMIT_TOO_OLD",
      },
      { no: 10, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_DIFF_TOO_LONG" },
      { no: 11, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_DIFF_TOO_SHORT" },
      {
        no: 12,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_TELEMETRY_UNHEALTHY",
      },
    ],
  )
var zEt = class hw extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.Started"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new hw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hw, t, e)
    }
  },
  YEt = class dw extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.ReportsGenerated"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_reports", kind: "message", T: jet },
      ])
    }
    static fromBinary(t, e) {
      return new dw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dw, t, e)
    }
  },
  QEt = class mw extends h {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.PressedFixInComposer"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new mw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mw, t, e)
    }
  },
  XEt = class fw extends h {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.PressedAddToChat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new fw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fw, t, e)
    }
  },
  KEt = class pw extends h {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.PressedOpenInEditor"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_location", kind: "message", T: Wet },
        { no: 2, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new pw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pw, t, e)
    }
  },
  ZEt = class gw extends h {
    constructor(t) {
      super(),
        (this.secondsViewed = 0),
        (this.reportViews = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.ViewedReport"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "seconds_viewed", kind: "scalar", T: 5 },
        { no: 2, name: "report_views", kind: "message", T: tIt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gw, t, e)
    }
  },
  tIt = class vw extends h {
    constructor(t) {
      super(),
        (this.bugReportId = ""),
        (this.viewPercentage = 0),
        (this.textPercentage = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.ViewedReport.ReportView"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
        { no: 2, name: "view_percentage", kind: "scalar", T: 1 },
        { no: 3, name: "text_percentage", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new vw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vw, t, e)
    }
  },
  eIt = class ww extends h {
    constructor(t) {
      super(),
        (this.bugReportId = ""),
        (this.feedback = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.UserFeedback"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
        { no: 2, name: "feedback", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ww().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ww().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ww().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ww, t, e)
    }
  },
  iIt = class yw extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.BackgroundIntervalStarted"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new yw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yw, t, e)
    }
  },
  sIt = class bw extends h {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.BackgroundIntervalEnded"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new bw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bw, t, e)
    }
  },
  rIt = class Tw extends h {
    constructor(t) {
      super(), (this.reason = zd.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.BackgroundIntervalInterrupted"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "reason", kind: "enum", T: n.getEnumType(zd) },
      ])
    }
    static fromBinary(t, e) {
      return new Tw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tw, t, e)
    }
  },
  nIt = class kw extends h {
    constructor(t) {
      super(), (this.errorMessage = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.BackgroundIntervalErrored"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kw, t, e)
    }
  },
  aIt = class Sw extends h {
    constructor(t) {
      super(),
        (this.requestType = Yd.UNSPECIFIED),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiRequestEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_type", kind: "enum", T: n.getEnumType(Yd) },
        { no: 2, name: "request_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Sw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sw, t, e)
    }
  },
  Yd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.START = 1)] = "START"),
    (i[(i.END = 2)] = "END")
})(Yd || (Yd = {})),
  n.util.setEnumType(Yd, "aiserver.v1.AiRequestEvent.RequestType", [
    { no: 0, name: "REQUEST_TYPE_UNSPECIFIED" },
    { no: 1, name: "REQUEST_TYPE_START" },
    { no: 2, name: "REQUEST_TYPE_END" },
  ])
var oIt = class Ew extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelOpenedEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: ni },
      ])
    }
    static fromBinary(t, e) {
      return new Ew().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ew().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ew().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ew, t, e)
    }
  },
  cIt = class Iw extends h {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundFilesEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "files", kind: "message", T: lIt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Iw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Iw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Iw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Iw, t, e)
    }
  },
  lIt = class Pw extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.hash = ""),
        (this.fullPath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundFilesEvent.BackgroundFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "hash", kind: "scalar", T: 9 },
        { no: 4, name: "full_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Pw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pw, t, e)
    }
  },
  uIt = class $w extends h {
    constructor(t) {
      super(),
        (this.visibleRanges = []),
        (this.editorId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ScrollEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: ni },
        { no: 2, name: "visible_ranges", kind: "message", T: Ss, repeated: !0 },
        { no: 3, name: "editor_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $w().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $w().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $w().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($w, t, e)
    }
  },
  hIt = class xw extends h {
    constructor(t) {
      super(), (this.editorId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditorCloseEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "editor_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xw, t, e)
    }
  },
  dIt = class Nw extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TabCloseEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: Qet },
      ])
    }
    static fromBinary(t, e) {
      return new Nw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nw, t, e)
    }
  },
  mIt = class Cw extends h {
    constructor(t) {
      super(),
        (this.fullUri = ""),
        (this.modelId = ""),
        (this.uriScheme = ""),
        (this.isTooLargeForSyncing = !1),
        (this.isTooLargeForTokenization = !1),
        (this.isTooLargeForHeapOperation = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelAddedEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: Qet },
        { no: 2, name: "full_uri", kind: "scalar", T: 9 },
        { no: 3, name: "model_id", kind: "scalar", T: 9 },
        { no: 4, name: "uri_scheme", kind: "scalar", T: 9 },
        { no: 5, name: "is_too_large_for_syncing", kind: "scalar", T: 8 },
        { no: 6, name: "is_too_large_for_tokenization", kind: "scalar", T: 8 },
        {
          no: 7,
          name: "is_too_large_for_heap_operation",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Cw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cw, t, e)
    }
  },
  fIt = class Jw extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.rootFsPath = ""),
        (this.refs = []),
        (this.remotes = []),
        (this.submodules = []),
        (this.mergeChanges = []),
        (this.indexChanges = []),
        (this.workingTreeChanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "root_fs_path", kind: "scalar", T: 9 },
        { no: 3, name: "head", kind: "message", T: pIt, opt: !0 },
        { no: 4, name: "refs", kind: "message", T: vIt, repeated: !0 },
        { no: 5, name: "remotes", kind: "message", T: wIt, repeated: !0 },
        { no: 6, name: "submodules", kind: "message", T: yIt, repeated: !0 },
        { no: 7, name: "rebase_commit", kind: "message", T: bIt, opt: !0 },
        { no: 8, name: "merge_changes", kind: "message", T: qM, repeated: !0 },
        { no: 9, name: "index_changes", kind: "message", T: qM, repeated: !0 },
        {
          no: 10,
          name: "working_tree_changes",
          kind: "message",
          T: qM,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Jw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jw, t, e)
    }
  },
  pIt = class Lw extends h {
    constructor(t) {
      super(), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Head"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "commit", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "remote", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "upstream_ref", kind: "message", T: gIt, opt: !0 },
        { no: 6, name: "ahead", kind: "scalar", T: 5, opt: !0 },
        { no: 7, name: "behind", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Lw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lw, t, e)
    }
  },
  gIt = class Rw extends h {
    constructor(t) {
      super(), (this.remote = ""), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Head.UpstreamRef"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "remote", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9 },
        { no: 3, name: "commit", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Rw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rw, t, e)
    }
  },
  vIt = class Dw extends h {
    constructor(t) {
      super(), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Ref"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "commit", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "remote", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Dw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dw, t, e)
    }
  },
  wIt = class Fw extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.isReadOnly = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Remote"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "fetch_url", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "push_url", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "is_read_only", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Fw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fw, t, e)
    }
  },
  yIt = class Aw extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.path = ""),
        (this.url = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Submodule"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "path", kind: "scalar", T: 9 },
        { no: 3, name: "url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Aw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Aw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Aw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Aw, t, e)
    }
  },
  bIt = class _w extends h {
    constructor(t) {
      super(),
        (this.hash = ""),
        (this.message = ""),
        (this.parents = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Commit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "hash", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "parents", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "author_date", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "author_name", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "author_email", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "commit_date", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "short_stat", kind: "message", T: TIt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _w().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _w().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _w().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_w, t, e)
    }
  },
  TIt = class Ow extends h {
    constructor(t) {
      super(),
        (this.files = 0),
        (this.insertions = 0),
        (this.deletions = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Commit.CommitShortStat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "scalar", T: 5 },
        { no: 2, name: "insertions", kind: "scalar", T: 5 },
        { no: 3, name: "deletions", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Ow().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ow().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ow().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ow, t, e)
    }
  },
  qM = class Bw extends h {
    constructor(t) {
      super(),
        (this.uri = ""),
        (this.originalUri = ""),
        (this.status = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Change"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
        { no: 2, name: "original_uri", kind: "scalar", T: 9 },
        { no: 3, name: "rename_uri", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "status", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Bw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bw, t, e)
    }
  },
  kIt = class qw extends h {
    constructor(t) {
      super(), (this.item = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AnythingQuickAccessItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "resource", kind: "message", T: SIt, oneof: "item" },
        { no: 2, name: "separator", kind: "scalar", T: 9, oneof: "item" },
      ])
    }
    static fromBinary(t, e) {
      return new qw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qw, t, e)
    }
  },
  SIt = class Uw extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AnythingQuickAccessItem.Resource"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model", kind: "message", T: ni, opt: !0 },
        { no: 2, name: "range", kind: "message", T: Ss, opt: !0 },
        { no: 3, name: "uri", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Uw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Uw, t, e)
    }
  },
  EIt = class Mw extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.items = []),
        (this.selectedIndices = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AnythingQuickAccessSelectionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "items", kind: "message", T: kIt, repeated: !0 },
        { no: 3, name: "selected_indices", kind: "scalar", T: 5, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Mw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mw, t, e)
    }
  },
  IIt = class Hw extends h {
    constructor(t) {
      super(), (this.suggestions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSuggestionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "suggestions", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "request_id", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "editor_id", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "point_in_time_model", kind: "message", T: ni },
      ])
    }
    static fromBinary(t, e) {
      return new Hw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hw, t, e)
    }
  },
  Ket = class Ww extends h {
    constructor(t) {
      super(),
        (this.event = { case: void 0 }),
        (this.performanceNowTimestamp = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppSessionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 2,
          name: "accept_event",
          kind: "message",
          T: rEt,
          oneof: "event",
        },
        {
          no: 3,
          name: "reject_event",
          kind: "message",
          T: cEt,
          oneof: "event",
        },
        {
          no: 4,
          name: "manual_trigger_event",
          kind: "message",
          T: fEt,
          oneof: "event",
        },
        {
          no: 6,
          name: "stopped_tracking_model_event",
          kind: "message",
          T: pEt,
          oneof: "event",
        },
        {
          no: 7,
          name: "suggest_event",
          kind: "message",
          T: nEt,
          oneof: "event",
        },
        {
          no: 8,
          name: "linter_error_event",
          kind: "message",
          T: gEt,
          oneof: "event",
        },
        {
          no: 9,
          name: "debounced_cursor_movement_event",
          kind: "message",
          T: vEt,
          oneof: "event",
        },
        {
          no: 10,
          name: "editor_changed_event",
          kind: "message",
          T: wEt,
          oneof: "event",
        },
        { no: 11, name: "copy_event", kind: "message", T: yEt, oneof: "event" },
        {
          no: 13,
          name: "quick_action_event",
          kind: "message",
          T: TEt,
          oneof: "event",
        },
        {
          no: 14,
          name: "quick_action_fire_event",
          kind: "message",
          T: kEt,
          oneof: "event",
        },
        {
          no: 15,
          name: "model_opened_event",
          kind: "message",
          T: oIt,
          oneof: "event",
        },
        {
          no: 17,
          name: "cmd_k_event",
          kind: "message",
          T: $Et,
          oneof: "event",
        },
        { no: 18, name: "chat_event", kind: "message", T: FEt, oneof: "event" },
        { no: 19, name: "ai_event", kind: "message", T: aIt, oneof: "event" },
        {
          no: 21,
          name: "scroll_event",
          kind: "message",
          T: uIt,
          oneof: "event",
        },
        {
          no: 22,
          name: "editor_close_event",
          kind: "message",
          T: hIt,
          oneof: "event",
        },
        {
          no: 23,
          name: "tab_close_event",
          kind: "message",
          T: dIt,
          oneof: "event",
        },
        {
          no: 33,
          name: "model_added_event",
          kind: "message",
          T: mIt,
          oneof: "event",
        },
        {
          no: 26,
          name: "partial_accept_event",
          kind: "message",
          T: uEt,
          oneof: "event",
        },
        {
          no: 27,
          name: "accept_cursor_prediction_event",
          kind: "message",
          T: dEt,
          oneof: "event",
        },
        {
          no: 28,
          name: "reject_cursor_prediction_event",
          kind: "message",
          T: mEt,
          oneof: "event",
        },
        {
          no: 29,
          name: "suggest_cursor_prediction_event",
          kind: "message",
          T: hEt,
          oneof: "event",
        },
        {
          no: 30,
          name: "cpp_trigger_event",
          kind: "message",
          T: aEt,
          oneof: "event",
        },
        {
          no: 31,
          name: "finished_cpp_generation_event",
          kind: "message",
          T: oEt,
          oneof: "event",
        },
        {
          no: 32,
          name: "bug_bot_event",
          kind: "message",
          T: GEt,
          oneof: "event",
        },
        {
          no: 34,
          name: "bug_bot_linter_event",
          kind: "message",
          T: BEt,
          oneof: "event",
        },
        {
          no: 35,
          name: "anything_quick_access_selection_event",
          kind: "message",
          T: EIt,
          oneof: "event",
        },
        {
          no: 36,
          name: "lsp_suggestion_event",
          kind: "message",
          T: IIt,
          oneof: "event",
        },
        {
          no: 16,
          name: "background_files_event",
          kind: "message",
          T: cIt,
          oneof: "event",
        },
        {
          no: 20,
          name: "terminal_event",
          kind: "message",
          T: SEt,
          oneof: "event",
        },
        {
          no: 24,
          name: "git_context_event",
          kind: "message",
          T: fIt,
          oneof: "event",
        },
        { no: 5, name: "performance_now_timestamp", kind: "scalar", T: 1 },
        {
          no: 25,
          name: "performance_time_origin",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Ww().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ww().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ww().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ww, t, e)
    }
  },
  PIt = class jw extends h {
    constructor(t) {
      super(), (this.changes = new Uint8Array(0)), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppAppendRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "changes", kind: "scalar", T: 12 },
      ])
    }
    static fromBinary(t, e) {
      return new jw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jw, t, e)
    }
  },
  $It = class Vw extends h {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppAppendResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Vw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vw, t, e)
    }
  },
  xIt = class Gw extends h {
    constructor(t) {
      super(),
        (this.sessionId = ""),
        (this.modelUuid = ""),
        (this.relativePath = ""),
        (this.uri = ""),
        (this.clientVersion = ""),
        (this.changes = []),
        (this.sessionEvents = []),
        (this.modelChangesMayBeOutOfOrder = !1),
        (this.privacyModeStatus = Qd.UNSPECIFIED),
        (this.events = []),
        (this.timeOrigin = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditHistoryAppendChangesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_id", kind: "scalar", T: 9 },
        { no: 2, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 3, name: "starting_model_value", kind: "scalar", T: 9, opt: !0 },
        {
          no: 10,
          name: "starting_model_version",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 5, name: "relative_path", kind: "scalar", T: 9 },
        { no: 14, name: "uri", kind: "scalar", T: 9 },
        { no: 6, name: "client_version", kind: "scalar", T: 9 },
        { no: 8, name: "client_commit", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "changes", kind: "message", T: Wd, repeated: !0 },
        {
          no: 9,
          name: "session_events",
          kind: "message",
          T: Ket,
          repeated: !0,
        },
        {
          no: 11,
          name: "model_changes_may_be_out_of_order",
          kind: "scalar",
          T: 8,
        },
        {
          no: 12,
          name: "privacy_mode_status",
          kind: "enum",
          T: n.getEnumType(Qd),
        },
        { no: 7, name: "events", kind: "message", T: FIt, repeated: !0 },
        { no: 13, name: "time_origin", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new Gw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gw, t, e)
    }
  },
  Qd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.PRIVACY_ENABLED = 1)] = "PRIVACY_ENABLED"),
    (i[(i.IMPLICIT_NO_PRIVACY = 2)] = "IMPLICIT_NO_PRIVACY"),
    (i[(i.EXPLICIT_NO_PRIVACY = 3)] = "EXPLICIT_NO_PRIVACY")
})(Qd || (Qd = {})),
  n.util.setEnumType(
    Qd,
    "aiserver.v1.EditHistoryAppendChangesRequest.PrivacyModeStatus",
    [
      { no: 0, name: "PRIVACY_MODE_STATUS_UNSPECIFIED" },
      { no: 1, name: "PRIVACY_MODE_STATUS_PRIVACY_ENABLED" },
      { no: 2, name: "PRIVACY_MODE_STATUS_IMPLICIT_NO_PRIVACY" },
      { no: 3, name: "PRIVACY_MODE_STATUS_EXPLICIT_NO_PRIVACY" },
    ],
  )
var NIt = class zw extends h {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditHistoryAppendChangesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new zw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zw, t, e)
    }
  },
  CIt = class Yw extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppEditHistoryStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Yw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yw, t, e)
    }
  },
  JIt = class Qw extends h {
    constructor(t) {
      super(),
        (this.on = !1),
        (this.onlyIfExplicit = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppEditHistoryStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "on", kind: "scalar", T: 8 },
        { no: 2, name: "only_if_explicit", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Qw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qw, t, e)
    }
  },
  LIt = class Xw extends h {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.startingContents = ""),
        (this.beforeStartModelChanges = []),
        (this.clientVersion = ""),
        (this.modelUuid = ""),
        (this.sessionId = ""),
        (this.uri = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartingModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "starting_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "starting_model_version",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "before_start_model_changes",
          kind: "message",
          T: Wd,
          repeated: !0,
        },
        { no: 5, name: "client_version", kind: "scalar", T: 9 },
        { no: 6, name: "client_commit", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 8, name: "session_id", kind: "scalar", T: 9 },
        { no: 9, name: "uri", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Xw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xw, t, e)
    }
  },
  UM = class Kw extends h {
    constructor(t) {
      super(),
        (this.changes = []),
        (this.relativePath = ""),
        (this.modelUuid = ""),
        (this.startFromChangeIndex = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BlockDiffPatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_model_window", kind: "message", T: DIt },
        { no: 3, name: "changes", kind: "message", T: RIt, repeated: !0 },
        { no: 4, name: "relative_path", kind: "scalar", T: 9 },
        { no: 7, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 5, name: "start_from_change_index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Kw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kw, t, e)
    }
  },
  RIt = class Zw extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BlockDiffPatch.Change"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ss },
      ])
    }
    static fromBinary(t, e) {
      return new Zw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zw, t, e)
    }
  },
  DIt = class ty extends h {
    constructor(t) {
      super(),
        (this.lines = []),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BlockDiffPatch.ModelWindow"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ty().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ty().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ty().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ty, t, e)
    }
  },
  FIt = class ey extends h {
    constructor(t) {
      super(), (this.event = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppHistoryAppendEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_change", kind: "message", T: Wd, oneof: "event" },
        {
          no: 2,
          name: "accept_event",
          kind: "message",
          T: _It,
          oneof: "event",
        },
        {
          no: 3,
          name: "reject_event",
          kind: "message",
          T: OIt,
          oneof: "event",
        },
        {
          no: 4,
          name: "manual_trigger_event",
          kind: "message",
          T: AIt,
          oneof: "event",
        },
        { no: 10, name: "final_model_hash", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ey().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ey().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ey().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ey, t, e)
    }
  },
  AIt = class iy extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppManualTriggerEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "position", kind: "message", T: ba },
      ])
    }
    static fromBinary(t, e) {
      return new iy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iy, t, e)
    }
  },
  _It = class sy extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppAcceptEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: Zet },
      ])
    }
    static fromBinary(t, e) {
      return new sy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sy, t, e)
    }
  },
  OIt = class ry extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppRejectEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: Zet },
      ])
    }
    static fromBinary(t, e) {
      return new ry().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ry().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ry().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ry, t, e)
    }
  },
  Zet = class ny extends h {
    constructor(t) {
      super(),
        (this.suggestionText = ""),
        (this.seen = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "suggestion_text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Ss },
        { no: 5, name: "seen", kind: "scalar", T: 8 },
        {
          no: 6,
          name: "editor_selection_before_peek",
          kind: "message",
          T: iSt,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ny().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ny().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ny().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ny, t, e)
    }
  },
  sYt = class ay extends h {
    constructor(t) {
      super(),
        (this.changes = []),
        (this.modelUuid = ""),
        (this.numCorrectChanges = 0),
        (this.numUnvalidatedChanges = 0),
        (this.numIncorrectChanges = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelWithHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "changes", kind: "message", T: Wd, repeated: !0 },
        { no: 2, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 3, name: "starting_model", kind: "message", T: LIt },
        { no: 4, name: "num_correct_changes", kind: "scalar", T: 5 },
        { no: 5, name: "num_unvalidated_changes", kind: "scalar", T: 5 },
        { no: 6, name: "num_incorrect_changes", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ay().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ay().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ay().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ay, t, e)
    }
  },
  rYt = class oy extends h {
    constructor(t) {
      super(),
        (this.timestamp = 0),
        (this.v = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTimelineEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "timestamp", kind: "scalar", T: 1 },
        { no: 2, name: "event", kind: "message", T: Ket, oneof: "v" },
        { no: 3, name: "change", kind: "message", T: BIt, oneof: "v" },
      ])
    }
    static fromBinary(t, e) {
      return new oy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oy, t, e)
    }
  },
  BIt = class cy extends h {
    constructor(t) {
      super(),
        (this.modelUuid = ""),
        (this.changeIndex = 0),
        (this.status = Xd.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTimelineEvent.Change"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "change_index", kind: "scalar", T: 5 },
        { no: 3, name: "change", kind: "message", T: Wd },
        { no: 4, name: "status", kind: "enum", T: n.getEnumType(Xd) },
      ])
    }
    static fromBinary(t, e) {
      return new cy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cy, t, e)
    }
  },
  Xd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.CORRECT = 1)] = "CORRECT"),
    (i[(i.UNVALIDATED = 2)] = "UNVALIDATED"),
    (i[(i.INCORRECT = 3)] = "INCORRECT")
})(Xd || (Xd = {})),
  n.util.setEnumType(Xd, "aiserver.v1.CppTimelineEvent.Change.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_CORRECT" },
    { no: 2, name: "STATUS_UNVALIDATED" },
    { no: 3, name: "STATUS_INCORRECT" },
  ])
function Kd(i, t, e) {
  return new Uu((s) => MM(s, e)).isEqual(i, t)
}
function qIt(i, t, e) {
  return Kd(i.uri, t.uri, e) ? 0 : Ha(i.uri.toString(), t.uri.toString())
}
function UIt(i, t, e) {
  return i.index !== t.index
    ? i.index < t.index
      ? -1
      : 1
    : Kd(i.uri, t.uri, e)
      ? Ha(i.name, t.name)
      : Ha(i.uri.toString(), t.uri.toString())
}
function tit(i, t, e, s) {
  const r = i.slice(0).sort((o, c) => e(o, c, s)),
    a = t.slice(0).sort((o, c) => e(o, c, s))
  return Lht(r, a, (o, c) => e(o, c, s))
}
function MM(i, t) {
  const e = t.getCapabilities(i.scheme)
  return !(e && e & 1024)
}
var HM = class vV extends Kwt {
    static toExtHostWorkspace(t, e, s, r) {
      if (!t) return { workspace: null, added: [], removed: [] }
      const {
          id: a,
          name: o,
          folders: c,
          configuration: l,
          transient: u,
          isUntitled: d,
        } = t,
        m = [],
        f = e
      e
        ? c.forEach((k, E) => {
            const P = S.revive(k.uri),
              C = vV.o(s || e, P, r)
            C
              ? ((C.name = k.name), (C.index = k.index), m.push(C))
              : m.push({ uri: P, name: k.name, index: E })
          })
        : m.push(
            ...c.map(({ uri: k, name: E, index: P }) => ({
              uri: S.revive(k),
              name: E,
              index: P,
            })),
          ),
        m.sort((k, E) => (k.index < E.index ? -1 : 1))
      const p = new vV(a, o, m, !!u, l ? S.revive(l) : null, !!d, (k) =>
          MM(k, r),
        ),
        { added: v, removed: b } = tit(
          f ? f.workspaceFolders : [],
          p.workspaceFolders,
          qIt,
          r,
        )
      return { workspace: p, added: v, removed: b }
    }
    static o(t, e, s) {
      for (let r = 0; r < t.folders.length; r++) {
        const a = t.workspaceFolders[r]
        if (Kd(a.uri, e, s)) return a
      }
    }
    constructor(t, e, s, r, a, o, c) {
      super(
        t,
        s.map((l) => new Oq(l)),
        r,
        a,
        c,
      ),
        (this.t = e),
        (this.u = o),
        (this.q = []),
        (this.s = ea.forUris(c, () => !0)),
        s.forEach((l) => {
          this.q.push(l), this.s.set(l.uri, l)
        })
    }
    get name() {
      return this.t
    }
    get isUntitled() {
      return this.u
    }
    get workspaceFolders() {
      return this.q.slice(0)
    }
    getWorkspaceFolder(t, e) {
      return e && this.s.get(t) && (t = C_(t)), this.s.findSubstr(t)
    }
    resolveWorkspaceFolder(t) {
      return this.s.get(t)
    }
  },
  WM = class {
    constructor(t, e, s, r, a) {
      ;(this.c = new J()),
        (this.onDidChangeWorkspace = this.c.event),
        (this.g = new J()),
        (this.onDidGrantWorkspaceTrust = this.g.event),
        (this.u = []),
        (this.v = !1),
        (this.w = new Map()),
        (this.x = new Map()),
        (this.A = 0),
        (this.D = 0),
        (this.F = new Du()),
        (this.G = new Map()),
        (this.h = r),
        (this.s = s),
        (this.t = a),
        (this.j = new Gwt()),
        (this.k = new Ns()),
        (this.o = t.getProxy(K.MainThreadWorkspace)),
        (this.q = t.getProxy(K.MainThreadMessageService))
      const o = e.workspace
      this.l = o
        ? new HM(
            o.id,
            o.name,
            [],
            !!o.transient,
            o.configuration ? S.revive(o.configuration) : null,
            !!o.isUntitled,
            (c) => MM(c, s),
          )
        : void 0
    }
    $initializeWorkspace(t, e) {
      ;(this.v = e), this.$acceptWorkspaceData(t), this.k.open()
    }
    waitForInitializeCall() {
      return this.k.wait()
    }
    get workspace() {
      return this.y
    }
    get name() {
      return this.y ? this.y.name : void 0
    }
    get workspaceFile() {
      if (this.y && this.y.configuration)
        return this.y.isUntitled
          ? S.from({ scheme: G.untitled, path: xr(C_(this.y.configuration)) })
          : this.y.configuration
    }
    get y() {
      return this.n || this.l
    }
    getWorkspaceFolders() {
      if (this.y) return this.y.workspaceFolders.slice(0)
    }
    async getWorkspaceFolders2() {
      if ((await this.k.wait(), !!this.y))
        return this.y.workspaceFolders.slice(0)
    }
    updateWorkspaceFolders(t, e, s, ...r) {
      const a = []
      if (
        (Array.isArray(r) &&
          r.forEach((d) => {
            S.isUri(d.uri) &&
              !a.some((m) => Kd(m.uri, d.uri, this.s)) &&
              a.push({ uri: d.uri, name: d.name || L7(d.uri) })
          }),
        this.n ||
          [e, s].some((d) => typeof d != "number" || d < 0) ||
          (s === 0 && a.length === 0))
      )
        return !1
      const o = this.y ? this.y.workspaceFolders : []
      if (e + s > o.length) return !1
      const c = o.slice(0)
      c.splice(
        e,
        s,
        ...a.map((d) => ({
          uri: d.uri,
          name: d.name || L7(d.uri),
          index: void 0,
        })),
      )
      for (let d = 0; d < c.length; d++) {
        const m = c[d]
        if (c.some((f, p) => p !== d && Kd(m.uri, f.uri, this.s))) return !1
      }
      c.forEach((d, m) => (d.index = m))
      const { added: l, removed: u } = tit(o, c, UIt, this.s)
      if (l.length === 0 && u.length === 0) return !1
      if (this.o) {
        const d = t.displayName || t.name
        this.o.$updateWorkspaceFolders(d, e, s, a).then(void 0, (m) => {
          this.n = void 0
          const f = {
            source: {
              identifier: t.identifier,
              label: t.displayName || t.name,
            },
          }
          this.q.$showMessage(Ywt.Error, g(2775, null, d, m.toString()), f, [])
        })
      }
      return this.z(c), !0
    }
    getWorkspaceFolder(t, e) {
      if (this.y) return this.y.getWorkspaceFolder(t, e)
    }
    async getWorkspaceFolder2(t, e) {
      if ((await this.k.wait(), !!this.y))
        return this.y.getWorkspaceFolder(t, e)
    }
    async resolveWorkspaceFolder(t) {
      if ((await this.k.wait(), !!this.y))
        return this.y.resolveWorkspaceFolder(t)
    }
    getPath() {
      if (!this.y) return
      const { folders: t } = this.y
      if (t.length !== 0) return t[0].uri.fsPath
    }
    getRelativePath(t, e) {
      let s,
        r = ""
      if (
        (typeof t == "string"
          ? ((s = S.file(t)), (r = t))
          : typeof t < "u" && ((s = t), (r = t.fsPath)),
        !s)
      )
        return r
      const a = this.getWorkspaceFolder(s, !0)
      if (!a) return r
      typeof e > "u" && this.y && (e = this.y.folders.length > 1)
      let o = WG(a.uri, s)
      return e && a.name && (o = `${a.name}/${o}`), o
    }
    z(t) {
      this.y &&
        (this.n =
          HM.toExtHostWorkspace(
            {
              id: this.y.id,
              name: this.y.name,
              configuration: this.y.configuration,
              folders: t,
              isUntitled: this.y.isUntitled,
            },
            this.y,
            void 0,
            this.s,
          ).workspace || void 0)
    }
    $acceptWorkspaceData(t) {
      const {
        workspace: e,
        added: s,
        removed: r,
      } = HM.toExtHostWorkspace(t, this.l, this.n, this.s)
      ;(this.l = e || void 0),
        (this.n = void 0),
        this.c.fire(Object.freeze({ added: s, removed: r }))
    }
    registerControlProvider(t, e) {
      if (this.x.has(t))
        throw new Error(
          `A control provider for the scheme '${t}' is already registered.`,
        )
      this.x.set(t, e)
      const s = this.t.transformOutgoingScheme(t),
        r = this.A++
      return (
        this.o.$registerControlProvider(r, s),
        et(() => {
          this.o.$unregisterControlProvider(r), this.x.delete(t)
        })
      )
    }
    async $controlGetDataframeSummary(t) {
      const e = "vscode-jupyter",
        s = this.x.get(e)
      if (!s) throw new Error(`No control provider for scheme '${e}' found.`)
      const r = S.revive(t)
      if (!r) {
        this.h.warn("Unable to resolve workspace folder")
        return
      }
      return await s.getDataframeSummary(r)
    }
    async $controlGetFullDiff(t, e) {
      const s = "git",
        r = this.x.get(s)
      if (!r) throw new Error(`No control provider for scheme '${s}' found.`)
      return await r.getFullDiff(t, e)
    }
    async $controlAppendCppTelem(t, e) {
      const s = "cursor-retrieval",
        r = this.x.get(s)
      if (!r) throw new Error(`No control provider for scheme '${s}' found.`)
      await r.appendCppTelem(t.buffer, e)
    }
    async $controlStreamCpp(t, e) {
      const s = "cursor-retrieval",
        r = this.x.get(s)
      if (!r) throw new Error(`No control provider for scheme '${s}' found.`)
      await r.streamCpp(AM.fromBinary(t.buffer), e)
    }
    async $controlFlushCpp(t) {
      const e = "cursor-retrieval",
        s = this.x.get(e)
      if (!s) throw new Error(`No control provider for scheme '${e}' found.`)
      const r = await s.flushCpp(t)
      return r === null
        ? { type: "failure", reason: "flushCppResponse is null" }
        : r === void 0
          ? { type: "failure", reason: "flushCppResponse is undefined" }
          : r
    }
    async $controlGetCppReport() {
      const t = "cursor-retrieval",
        e = this.x.get(t)
      if (!e) throw new Error(`No control provider for scheme '${t}' found.`)
      const s = await e.getCppReport()
      if (s !== null) return s
    }
    async $controlCancelCpp(t) {
      const e = "cursor-retrieval",
        s = this.x.get(e)
      if (!s) throw new Error(`No control provider for scheme '${e}' found.`)
      await s.cancelCpp(t)
    }
    async $controlTokenizeBPE(t, e) {
      const s = "cursor-tokenize",
        r = this.x.get(s)
      if (!r) throw new Error(`No control provider for scheme '${s}' found.`)
      return await r.tokenizeBPE(t, e)
    }
    findFiles(t, e, s, r, a = ce.None) {
      this.h.trace(
        `extHostWorkspace#findFiles: fileSearch, extension: ${r.value}, entryPoint: findFiles`,
      )
      let o = "",
        c = !0
      return (
        e === null
          ? (c = !1)
          : e !== void 0 && (typeof e == "string" ? (o = e) : (o = e.pattern)),
        this.B(
          { type: "include", value: t },
          {
            exclude: [o],
            maxResults: s,
            useExcludeSettings: c ? kn.FilesExclude : kn.None,
            useIgnoreFiles: { local: !1 },
          },
          a,
        )
      )
    }
    findFiles2(t, e = {}, s, r = ce.None) {
      return (
        this.h.trace(
          `extHostWorkspace#findFiles2New: fileSearch, extension: ${s.value}, entryPoint: findFiles2New`,
        ),
        this.B({ type: "filePatterns", value: t }, e, r)
      )
    }
    async B(t, e, s) {
      if (s.isCancellationRequested) return Promise.resolve([])
      const r = t.type === "include" ? [t.value] : (t.value ?? [])
      if (!Array.isArray(r))
        throw new Error(`Invalid file pattern provided ${r}`)
      const a = r.map((o) => {
        const c = eit(e.exclude),
          l = {
            ignoreSymlinks:
              typeof e.followSymlinks == "boolean" ? !e.followSymlinks : void 0,
            disregardIgnoreFiles:
              typeof e.useIgnoreFiles?.local == "boolean"
                ? !e.useIgnoreFiles.local
                : void 0,
            disregardGlobalIgnoreFiles:
              typeof e.useIgnoreFiles?.global == "boolean"
                ? !e.useIgnoreFiles.global
                : void 0,
            disregardParentIgnoreFiles:
              typeof e.useIgnoreFiles?.parent == "boolean"
                ? !e.useIgnoreFiles.parent
                : void 0,
            disregardExcludeSettings:
              e.useExcludeSettings !== void 0 &&
              e.useExcludeSettings === kn.None,
            disregardSearchExcludeSettings:
              e.useExcludeSettings !== void 0 &&
              e.useExcludeSettings !== kn.SearchAndFilesExclude,
            maxResults: e.maxResults,
            excludePattern: c.length > 0 ? c : void 0,
            _reason: "startFileSearch",
            shouldGlobSearch: t.type === "include" ? void 0 : !0,
          },
          u = rB(us.from(o)),
          d = u?.folder
        return (
          t.type === "include"
            ? (l.includePattern = u?.pattern)
            : (l.filePattern = u?.pattern),
          { folder: d, options: l }
        )
      })
      return this.C(a, s)
    }
    async C(t, e) {
      return (
        await Promise.all(
          t?.map((r) =>
            this.o
              .$startFileSearch(r.folder ?? null, r.options, e)
              .then((a) => (Array.isArray(a) ? a.map((o) => S.revive(o)) : [])),
          ) ?? [],
        )
      ).flat()
    }
    findTextInFiles2(t, e, s, r = ce.None) {
      this.h.trace(
        `extHostWorkspace#findTextInFiles2: textSearch, extension: ${s.value}, entryPoint: findTextInFiles2`,
      )
      const a = (f) => {
          if (!e) return { folder: void 0, options: {} }
          const p = f ? rB(us.from(f)) : void 0,
            v = e.exclude ? eit(e.exclude) : void 0
          return {
            options: {
              ignoreSymlinks:
                typeof e.followSymlinks == "boolean"
                  ? !e.followSymlinks
                  : void 0,
              disregardIgnoreFiles:
                typeof e.useIgnoreFiles == "boolean"
                  ? !e.useIgnoreFiles
                  : void 0,
              disregardGlobalIgnoreFiles:
                typeof e.useIgnoreFiles?.global == "boolean"
                  ? !e.useIgnoreFiles?.global
                  : void 0,
              disregardParentIgnoreFiles:
                typeof e.useIgnoreFiles?.parent == "boolean"
                  ? !e.useIgnoreFiles?.parent
                  : void 0,
              disregardExcludeSettings:
                e.useExcludeSettings !== void 0 &&
                e.useExcludeSettings === kn.None,
              disregardSearchExcludeSettings:
                e.useExcludeSettings !== void 0 &&
                e.useExcludeSettings !== kn.SearchAndFilesExclude,
              fileEncoding: e.encoding,
              maxResults: e.maxResults,
              previewOptions: e.previewOptions
                ? {
                    matchLines: e.previewOptions?.numMatchLines ?? 100,
                    charsPerLine: e.previewOptions?.charsPerLine ?? 1e4,
                  }
                : void 0,
              surroundingContext: e.surroundingContext,
              includePattern: p?.pattern,
              excludePattern: v,
            },
            folder: p?.folder,
          }
        },
        c = (e?.include?.map((f) => a(f)) ?? [a(void 0)]).filter((f) => !!f),
        l = new gt(),
        u = l.add(new J()),
        d = this.findTextInFilesBase(
          t,
          c,
          (f, p) => u.fire({ result: f, uri: p }),
          r,
        )
      return {
        results: new Mu(async (f) => {
          l.add(
            u.event((p) => {
              const v = p.result,
                b = p.uri
              dM(v)
                ? f.emitOne(
                    new Tn(
                      b,
                      v.rangeLocations.map((k) => ({
                        previewRange: new Nt(
                          k.preview.startLineNumber,
                          k.preview.startColumn,
                          k.preview.endLineNumber,
                          k.preview.endColumn,
                        ),
                        sourceRange: new Nt(
                          k.source.startLineNumber,
                          k.source.startColumn,
                          k.source.endLineNumber,
                          k.source.endColumn,
                        ),
                      })),
                      v.previewText,
                    ),
                  )
                : f.emitOne(new k8(b, v.text, v.lineNumber))
            }),
          ),
            await d
        }),
        complete: d.then((f) => (l.dispose(), { limitHit: f?.limitHit ?? !1 })),
      }
    }
    async findTextInFilesBase(t, e, s, r = ce.None) {
      const a = this.j.getNext()
      let o = !1
      if (
        (r.onCancellationRequested((c) => {
          o = !0
        }),
        (this.u[a] = (c) => {
          if (o) return
          const l = S.revive(c.resource)
          c.results.forEach((u) => {
            const d = ki(u)
            s(d, l)
          })
        }),
        r.isCancellationRequested)
      )
        return {}
      try {
        const c = await Promise.all(
          e?.map(
            (l) =>
              this.o.$startTextSearch(t, l.folder ?? null, l.options, a, r) ||
              {},
          ) ?? [],
        )
        return (
          delete this.u[a],
          c.reduce(
            (l, u) => ({
              limitHit: l?.limitHit || (u?.limitHit ?? !1),
              message: [l?.message ?? [], u?.message ?? []].flat(),
            }),
            {},
          ) ?? { limitHit: !1 }
        )
      } catch (c) {
        throw (delete this.u[a], c)
      }
    }
    async findTextInFiles(t, e, s, r, a = ce.None) {
      this.h.trace(
        `extHostWorkspace#findTextInFiles: textSearch, extension: ${r.value}, entryPoint: findTextInFiles`,
      )
      const o =
          typeof e.previewOptions > "u"
            ? { matchLines: 100, charsPerLine: 1e4 }
            : e.previewOptions,
        c = rB(us.from(e.include)),
        l =
          typeof e.exclude == "string"
            ? e.exclude
            : e.exclude
              ? e.exclude.pattern
              : void 0,
        u = {
          ignoreSymlinks:
            typeof e.followSymlinks == "boolean" ? !e.followSymlinks : void 0,
          disregardIgnoreFiles:
            typeof e.useIgnoreFiles == "boolean" ? !e.useIgnoreFiles : void 0,
          disregardGlobalIgnoreFiles:
            typeof e.useGlobalIgnoreFiles == "boolean"
              ? !e.useGlobalIgnoreFiles
              : void 0,
          disregardParentIgnoreFiles:
            typeof e.useParentIgnoreFiles == "boolean"
              ? !e.useParentIgnoreFiles
              : void 0,
          disregardExcludeSettings:
            typeof e.useDefaultExcludes == "boolean"
              ? !e.useDefaultExcludes
              : !0,
          disregardSearchExcludeSettings:
            typeof e.useSearchExclude == "boolean" ? !e.useSearchExclude : !0,
          fileEncoding: e.encoding,
          maxResults: e.maxResults,
          previewOptions: o,
          surroundingContext: e.afterContext,
          includePattern: c?.pattern,
          excludePattern: l ? [{ pattern: l }] : void 0,
        },
        d = (m, f) => {
          dM(m)
            ? s({
                uri: f,
                preview: {
                  text: m.previewText,
                  matches: m_(
                    m.rangeLocations,
                    (p) =>
                      new Nt(
                        p.preview.startLineNumber,
                        p.preview.startColumn,
                        p.preview.endLineNumber,
                        p.preview.endColumn,
                      ),
                  ),
                },
                ranges: m_(
                  m.rangeLocations,
                  (p) =>
                    new Nt(
                      p.source.startLineNumber,
                      p.source.startColumn,
                      p.source.endLineNumber,
                      p.source.endColumn,
                    ),
                ),
              })
            : s({ uri: f, text: m.text, lineNumber: m.lineNumber })
        }
      return this.findTextInFilesBase(
        t,
        [{ options: u, folder: c?.folder }],
        d,
        a,
      )
    }
    $handleTextSearchResult(t, e) {
      this.u[e]?.(t)
    }
    async save(t) {
      const e = await this.o.$save(t, { saveAs: !1 })
      return S.revive(e)
    }
    async saveAs(t) {
      const e = await this.o.$save(t, { saveAs: !0 })
      return S.revive(e)
    }
    saveAll(t) {
      return this.o.$saveAll(t)
    }
    resolveProxy(t) {
      return this.o.$resolveProxy(t)
    }
    lookupAuthorization(t) {
      return this.o.$lookupAuthorization(t)
    }
    lookupKerberosAuthorization(t) {
      return this.o.$lookupKerberosAuthorization(t)
    }
    loadCertificates() {
      return this.o.$loadCertificates()
    }
    get trusted() {
      return this.v
    }
    requestWorkspaceTrust(t) {
      return this.o.$requestWorkspaceTrust(t)
    }
    $onDidGrantWorkspaceTrust() {
      this.v || ((this.v = !0), this.g.fire())
    }
    registerEditSessionIdentityProvider(t, e) {
      if (this.w.has(t))
        throw new Error(
          `A provider has already been registered for scheme ${t}`,
        )
      this.w.set(t, e)
      const s = this.t.transformOutgoingScheme(t),
        r = this.D++
      return (
        this.o.$registerEditSessionIdentityProvider(r, s),
        et(() => {
          this.w.delete(t), this.o.$unregisterEditSessionIdentityProvider(r)
        })
      )
    }
    async $getEditSessionIdentifier(t, e) {
      this.h.info("Getting edit session identifier for workspaceFolder", t)
      const s = await this.resolveWorkspaceFolder(S.revive(t))
      if (!s) {
        this.h.warn("Unable to resolve workspace folder")
        return
      }
      this.h.info("Invoking #provideEditSessionIdentity for workspaceFolder", s)
      const r = this.w.get(s.uri.scheme)
      if (
        (this.h.info(`Provider for scheme ${s.uri.scheme} is defined: `, !!r),
        !r)
      )
        return
      const a = await r.provideEditSessionIdentity(s, e)
      if ((this.h.info("Provider returned edit session identifier: ", a), !!a))
        return a
    }
    async $provideEditSessionIdentityMatch(t, e, s, r) {
      this.h.info("Getting edit session identifier for workspaceFolder", t)
      const a = await this.resolveWorkspaceFolder(S.revive(t))
      if (!a) {
        this.h.warn("Unable to resolve workspace folder")
        return
      }
      this.h.info("Invoking #provideEditSessionIdentity for workspaceFolder", a)
      const o = this.w.get(a.uri.scheme)
      if (
        (this.h.info(`Provider for scheme ${a.uri.scheme} is defined: `, !!o),
        !o)
      )
        return
      const c = await o.provideEditSessionIdentityMatch?.(e, s, r)
      if (
        (this.h.info(
          "Provider returned edit session identifier match result: ",
          c,
        ),
        !!c)
      )
        return c
    }
    getOnWillCreateEditSessionIdentityEvent(t) {
      return (e, s, r) => {
        const a = function (c) {
          e.call(s, c)
        }
        return (a.extension = t), this.F.event(a, void 0, r)
      }
    }
    async $onWillCreateEditSessionIdentity(t, e, s) {
      const r = await this.resolveWorkspaceFolder(S.revive(t))
      if (r === void 0) throw new Error("Unable to resolve workspace folder")
      await this.F.fireAsync({ workspaceFolder: r }, e, async (a, o) => {
        const c = Date.now()
        await Promise.resolve(a),
          Date.now() - c > s &&
            this.h.warn(
              "SLOW edit session create-participant",
              o.extension.identifier,
            )
      }),
        e.isCancellationRequested
    }
    registerCanonicalUriProvider(t, e) {
      if (this.G.has(t))
        throw new Error(
          `A provider has already been registered for scheme ${t}`,
        )
      this.G.set(t, e)
      const s = this.t.transformOutgoingScheme(t),
        r = this.D++
      return (
        this.o.$registerCanonicalUriProvider(r, s),
        et(() => {
          this.G.delete(t), this.o.$unregisterCanonicalUriProvider(r)
        })
      )
    }
    async provideCanonicalUri(t, e, s) {
      const r = this.G.get(t.scheme)
      if (!r) return
      const a = await r.provideCanonicalUri?.(S.revive(t), e, s)
      if (a) return a
    }
    async $provideCanonicalUri(t, e, s) {
      return this.provideCanonicalUri(S.revive(t), { targetScheme: e }, s)
    }
  }
WM = __decorate(
  [
    __param(0, Ot),
    __param(1, ti),
    __param(2, Nc),
    __param(3, Rt),
    __param(4, ah),
  ],
  WM,
)
var dr = X("IExtHostWorkspace")
function rB(i) {
  let t, e
  if (i)
    return (
      typeof i == "string"
        ? (t = i)
        : ((t = i.pattern), (e = S.revive(i.baseUri))),
      { pattern: t, folder: e }
    )
}
function eit(i) {
  return (
    i?.map((t) => {
      if (typeof t == "string")
        return t === "" ? void 0 : { pattern: t, uri: void 0 }
      {
        const e = rB(t)
        return e ? { pattern: e.pattern, uri: e.folder } : void 0
      }
    }) ?? []
  ).filter((t) => !!t)
}
var iit
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.UnexpectedEndOfComment = 1)] = "UnexpectedEndOfComment"),
    (i[(i.UnexpectedEndOfString = 2)] = "UnexpectedEndOfString"),
    (i[(i.UnexpectedEndOfNumber = 3)] = "UnexpectedEndOfNumber"),
    (i[(i.InvalidUnicode = 4)] = "InvalidUnicode"),
    (i[(i.InvalidEscapeCharacter = 5)] = "InvalidEscapeCharacter"),
    (i[(i.InvalidCharacter = 6)] = "InvalidCharacter")
})(iit || (iit = {}))
var sit
;(function (i) {
  ;(i[(i.OpenBraceToken = 1)] = "OpenBraceToken"),
    (i[(i.CloseBraceToken = 2)] = "CloseBraceToken"),
    (i[(i.OpenBracketToken = 3)] = "OpenBracketToken"),
    (i[(i.CloseBracketToken = 4)] = "CloseBracketToken"),
    (i[(i.CommaToken = 5)] = "CommaToken"),
    (i[(i.ColonToken = 6)] = "ColonToken"),
    (i[(i.NullKeyword = 7)] = "NullKeyword"),
    (i[(i.TrueKeyword = 8)] = "TrueKeyword"),
    (i[(i.FalseKeyword = 9)] = "FalseKeyword"),
    (i[(i.StringLiteral = 10)] = "StringLiteral"),
    (i[(i.NumericLiteral = 11)] = "NumericLiteral"),
    (i[(i.LineCommentTrivia = 12)] = "LineCommentTrivia"),
    (i[(i.BlockCommentTrivia = 13)] = "BlockCommentTrivia"),
    (i[(i.LineBreakTrivia = 14)] = "LineBreakTrivia"),
    (i[(i.Trivia = 15)] = "Trivia"),
    (i[(i.Unknown = 16)] = "Unknown"),
    (i[(i.EOF = 17)] = "EOF")
})(sit || (sit = {}))
var rit
;(function (i) {
  ;(i[(i.InvalidSymbol = 1)] = "InvalidSymbol"),
    (i[(i.InvalidNumberFormat = 2)] = "InvalidNumberFormat"),
    (i[(i.PropertyNameExpected = 3)] = "PropertyNameExpected"),
    (i[(i.ValueExpected = 4)] = "ValueExpected"),
    (i[(i.ColonExpected = 5)] = "ColonExpected"),
    (i[(i.CommaExpected = 6)] = "CommaExpected"),
    (i[(i.CloseBraceExpected = 7)] = "CloseBraceExpected"),
    (i[(i.CloseBracketExpected = 8)] = "CloseBracketExpected"),
    (i[(i.EndOfFileExpected = 9)] = "EndOfFileExpected"),
    (i[(i.InvalidCommentToken = 10)] = "InvalidCommentToken"),
    (i[(i.UnexpectedEndOfComment = 11)] = "UnexpectedEndOfComment"),
    (i[(i.UnexpectedEndOfString = 12)] = "UnexpectedEndOfString"),
    (i[(i.UnexpectedEndOfNumber = 13)] = "UnexpectedEndOfNumber"),
    (i[(i.InvalidUnicode = 14)] = "InvalidUnicode"),
    (i[(i.InvalidEscapeCharacter = 15)] = "InvalidEscapeCharacter"),
    (i[(i.InvalidCharacter = 16)] = "InvalidCharacter")
})(rit || (rit = {}))
var jM
;(function (i) {
  i.DEFAULT = { allowTrailingComma: !0 }
})(jM || (jM = {}))
function MIt(i, t = !1) {
  let e = 0
  const s = i.length
  let r = "",
    a = 0,
    o = 16,
    c = 0
  function l(b) {
    let k = 0,
      E = 0
    for (; k < b; ) {
      const P = i.charCodeAt(e)
      if (P >= 48 && P <= 57) E = E * 16 + P - 48
      else if (P >= 65 && P <= 70) E = E * 16 + P - 65 + 10
      else if (P >= 97 && P <= 102) E = E * 16 + P - 97 + 10
      else break
      e++, k++
    }
    return k < b && (E = -1), E
  }
  function u(b) {
    ;(e = b), (r = ""), (a = 0), (o = 16), (c = 0)
  }
  function d() {
    const b = e
    if (i.charCodeAt(e) === 48) e++
    else for (e++; e < i.length && Rl(i.charCodeAt(e)); ) e++
    if (e < i.length && i.charCodeAt(e) === 46)
      if ((e++, e < i.length && Rl(i.charCodeAt(e))))
        for (e++; e < i.length && Rl(i.charCodeAt(e)); ) e++
      else return (c = 3), i.substring(b, e)
    let k = e
    if (e < i.length && (i.charCodeAt(e) === 69 || i.charCodeAt(e) === 101))
      if (
        (e++,
        ((e < i.length && i.charCodeAt(e) === 43) || i.charCodeAt(e) === 45) &&
          e++,
        e < i.length && Rl(i.charCodeAt(e)))
      ) {
        for (e++; e < i.length && Rl(i.charCodeAt(e)); ) e++
        k = e
      } else c = 3
    return i.substring(b, k)
  }
  function m() {
    let b = "",
      k = e
    for (;;) {
      if (e >= s) {
        ;(b += i.substring(k, e)), (c = 2)
        break
      }
      const E = i.charCodeAt(e)
      if (E === 34) {
        ;(b += i.substring(k, e)), e++
        break
      }
      if (E === 92) {
        if (((b += i.substring(k, e)), e++, e >= s)) {
          c = 2
          break
        }
        switch (i.charCodeAt(e++)) {
          case 34:
            b += '"'
            break
          case 92:
            b += "\\"
            break
          case 47:
            b += "/"
            break
          case 98:
            b += "\b"
            break
          case 102:
            b += "\f"
            break
          case 110:
            b += `
`
            break
          case 114:
            b += "\r"
            break
          case 116:
            b += "	"
            break
          case 117: {
            const C = l(4)
            C >= 0 ? (b += String.fromCharCode(C)) : (c = 4)
            break
          }
          default:
            c = 5
        }
        k = e
        continue
      }
      if (E >= 0 && E <= 31)
        if (nB(E)) {
          ;(b += i.substring(k, e)), (c = 2)
          break
        } else c = 6
      e++
    }
    return b
  }
  function f() {
    if (((r = ""), (c = 0), (a = e), e >= s)) return (a = s), (o = 17)
    let b = i.charCodeAt(e)
    if (VM(b)) {
      do e++, (r += String.fromCharCode(b)), (b = i.charCodeAt(e))
      while (VM(b))
      return (o = 15)
    }
    if (nB(b))
      return (
        e++,
        (r += String.fromCharCode(b)),
        b === 13 &&
          i.charCodeAt(e) === 10 &&
          (e++,
          (r += `
`)),
        (o = 14)
      )
    switch (b) {
      case 123:
        return e++, (o = 1)
      case 125:
        return e++, (o = 2)
      case 91:
        return e++, (o = 3)
      case 93:
        return e++, (o = 4)
      case 58:
        return e++, (o = 6)
      case 44:
        return e++, (o = 5)
      case 34:
        return e++, (r = m()), (o = 10)
      case 47: {
        const k = e - 1
        if (i.charCodeAt(e + 1) === 47) {
          for (e += 2; e < s && !nB(i.charCodeAt(e)); ) e++
          return (r = i.substring(k, e)), (o = 12)
        }
        if (i.charCodeAt(e + 1) === 42) {
          e += 2
          const E = s - 1
          let P = !1
          for (; e < E; ) {
            if (i.charCodeAt(e) === 42 && i.charCodeAt(e + 1) === 47) {
              ;(e += 2), (P = !0)
              break
            }
            e++
          }
          return P || (e++, (c = 1)), (r = i.substring(k, e)), (o = 13)
        }
        return (r += String.fromCharCode(b)), e++, (o = 16)
      }
      case 45:
        if (
          ((r += String.fromCharCode(b)), e++, e === s || !Rl(i.charCodeAt(e)))
        )
          return (o = 16)
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return (r += d()), (o = 11)
      default:
        for (; e < s && p(b); ) e++, (b = i.charCodeAt(e))
        if (a !== e) {
          switch (((r = i.substring(a, e)), r)) {
            case "true":
              return (o = 8)
            case "false":
              return (o = 9)
            case "null":
              return (o = 7)
          }
          return (o = 16)
        }
        return (r += String.fromCharCode(b)), e++, (o = 16)
    }
  }
  function p(b) {
    if (VM(b) || nB(b)) return !1
    switch (b) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return !1
    }
    return !0
  }
  function v() {
    let b
    do b = f()
    while (b >= 12 && b <= 15)
    return b
  }
  return {
    setPosition: u,
    getPosition: () => e,
    scan: t ? v : f,
    getToken: () => o,
    getTokenValue: () => r,
    getTokenOffset: () => a,
    getTokenLength: () => e - a,
    getTokenError: () => c,
  }
}
function VM(i) {
  return (
    i === 32 ||
    i === 9 ||
    i === 11 ||
    i === 12 ||
    i === 160 ||
    i === 5760 ||
    (i >= 8192 && i <= 8203) ||
    i === 8239 ||
    i === 8287 ||
    i === 12288 ||
    i === 65279
  )
}
function nB(i) {
  return i === 10 || i === 13 || i === 8232 || i === 8233
}
function Rl(i) {
  return i >= 48 && i <= 57
}
var nit
;(function (i) {
  ;(i[(i.nullCharacter = 0)] = "nullCharacter"),
    (i[(i.maxAsciiCharacter = 127)] = "maxAsciiCharacter"),
    (i[(i.lineFeed = 10)] = "lineFeed"),
    (i[(i.carriageReturn = 13)] = "carriageReturn"),
    (i[(i.lineSeparator = 8232)] = "lineSeparator"),
    (i[(i.paragraphSeparator = 8233)] = "paragraphSeparator"),
    (i[(i.nextLine = 133)] = "nextLine"),
    (i[(i.space = 32)] = "space"),
    (i[(i.nonBreakingSpace = 160)] = "nonBreakingSpace"),
    (i[(i.enQuad = 8192)] = "enQuad"),
    (i[(i.emQuad = 8193)] = "emQuad"),
    (i[(i.enSpace = 8194)] = "enSpace"),
    (i[(i.emSpace = 8195)] = "emSpace"),
    (i[(i.threePerEmSpace = 8196)] = "threePerEmSpace"),
    (i[(i.fourPerEmSpace = 8197)] = "fourPerEmSpace"),
    (i[(i.sixPerEmSpace = 8198)] = "sixPerEmSpace"),
    (i[(i.figureSpace = 8199)] = "figureSpace"),
    (i[(i.punctuationSpace = 8200)] = "punctuationSpace"),
    (i[(i.thinSpace = 8201)] = "thinSpace"),
    (i[(i.hairSpace = 8202)] = "hairSpace"),
    (i[(i.zeroWidthSpace = 8203)] = "zeroWidthSpace"),
    (i[(i.narrowNoBreakSpace = 8239)] = "narrowNoBreakSpace"),
    (i[(i.ideographicSpace = 12288)] = "ideographicSpace"),
    (i[(i.mathematicalSpace = 8287)] = "mathematicalSpace"),
    (i[(i.ogham = 5760)] = "ogham"),
    (i[(i._ = 95)] = "_"),
    (i[(i.$ = 36)] = "$"),
    (i[(i._0 = 48)] = "_0"),
    (i[(i._1 = 49)] = "_1"),
    (i[(i._2 = 50)] = "_2"),
    (i[(i._3 = 51)] = "_3"),
    (i[(i._4 = 52)] = "_4"),
    (i[(i._5 = 53)] = "_5"),
    (i[(i._6 = 54)] = "_6"),
    (i[(i._7 = 55)] = "_7"),
    (i[(i._8 = 56)] = "_8"),
    (i[(i._9 = 57)] = "_9"),
    (i[(i.a = 97)] = "a"),
    (i[(i.b = 98)] = "b"),
    (i[(i.c = 99)] = "c"),
    (i[(i.d = 100)] = "d"),
    (i[(i.e = 101)] = "e"),
    (i[(i.f = 102)] = "f"),
    (i[(i.g = 103)] = "g"),
    (i[(i.h = 104)] = "h"),
    (i[(i.i = 105)] = "i"),
    (i[(i.j = 106)] = "j"),
    (i[(i.k = 107)] = "k"),
    (i[(i.l = 108)] = "l"),
    (i[(i.m = 109)] = "m"),
    (i[(i.n = 110)] = "n"),
    (i[(i.o = 111)] = "o"),
    (i[(i.p = 112)] = "p"),
    (i[(i.q = 113)] = "q"),
    (i[(i.r = 114)] = "r"),
    (i[(i.s = 115)] = "s"),
    (i[(i.t = 116)] = "t"),
    (i[(i.u = 117)] = "u"),
    (i[(i.v = 118)] = "v"),
    (i[(i.w = 119)] = "w"),
    (i[(i.x = 120)] = "x"),
    (i[(i.y = 121)] = "y"),
    (i[(i.z = 122)] = "z"),
    (i[(i.A = 65)] = "A"),
    (i[(i.B = 66)] = "B"),
    (i[(i.C = 67)] = "C"),
    (i[(i.D = 68)] = "D"),
    (i[(i.E = 69)] = "E"),
    (i[(i.F = 70)] = "F"),
    (i[(i.G = 71)] = "G"),
    (i[(i.H = 72)] = "H"),
    (i[(i.I = 73)] = "I"),
    (i[(i.J = 74)] = "J"),
    (i[(i.K = 75)] = "K"),
    (i[(i.L = 76)] = "L"),
    (i[(i.M = 77)] = "M"),
    (i[(i.N = 78)] = "N"),
    (i[(i.O = 79)] = "O"),
    (i[(i.P = 80)] = "P"),
    (i[(i.Q = 81)] = "Q"),
    (i[(i.R = 82)] = "R"),
    (i[(i.S = 83)] = "S"),
    (i[(i.T = 84)] = "T"),
    (i[(i.U = 85)] = "U"),
    (i[(i.V = 86)] = "V"),
    (i[(i.W = 87)] = "W"),
    (i[(i.X = 88)] = "X"),
    (i[(i.Y = 89)] = "Y"),
    (i[(i.Z = 90)] = "Z"),
    (i[(i.ampersand = 38)] = "ampersand"),
    (i[(i.asterisk = 42)] = "asterisk"),
    (i[(i.at = 64)] = "at"),
    (i[(i.backslash = 92)] = "backslash"),
    (i[(i.bar = 124)] = "bar"),
    (i[(i.caret = 94)] = "caret"),
    (i[(i.closeBrace = 125)] = "closeBrace"),
    (i[(i.closeBracket = 93)] = "closeBracket"),
    (i[(i.closeParen = 41)] = "closeParen"),
    (i[(i.colon = 58)] = "colon"),
    (i[(i.comma = 44)] = "comma"),
    (i[(i.dot = 46)] = "dot"),
    (i[(i.doubleQuote = 34)] = "doubleQuote"),
    (i[(i.equals = 61)] = "equals"),
    (i[(i.exclamation = 33)] = "exclamation"),
    (i[(i.greaterThan = 62)] = "greaterThan"),
    (i[(i.lessThan = 60)] = "lessThan"),
    (i[(i.minus = 45)] = "minus"),
    (i[(i.openBrace = 123)] = "openBrace"),
    (i[(i.openBracket = 91)] = "openBracket"),
    (i[(i.openParen = 40)] = "openParen"),
    (i[(i.percent = 37)] = "percent"),
    (i[(i.plus = 43)] = "plus"),
    (i[(i.question = 63)] = "question"),
    (i[(i.semicolon = 59)] = "semicolon"),
    (i[(i.singleQuote = 39)] = "singleQuote"),
    (i[(i.slash = 47)] = "slash"),
    (i[(i.tilde = 126)] = "tilde"),
    (i[(i.backspace = 8)] = "backspace"),
    (i[(i.formFeed = 12)] = "formFeed"),
    (i[(i.byteOrderMark = 65279)] = "byteOrderMark"),
    (i[(i.tab = 9)] = "tab"),
    (i[(i.verticalTab = 11)] = "verticalTab")
})(nit || (nit = {}))
function HIt(i, t, e = jM.DEFAULT) {
  const s = MIt(i, !1)
  function r(M) {
    return M ? () => M(s.getTokenOffset(), s.getTokenLength()) : () => !0
  }
  function a(M) {
    return M ? (rt) => M(rt, s.getTokenOffset(), s.getTokenLength()) : () => !0
  }
  const o = r(t.onObjectBegin),
    c = a(t.onObjectProperty),
    l = r(t.onObjectEnd),
    u = r(t.onArrayBegin),
    d = r(t.onArrayEnd),
    m = a(t.onLiteralValue),
    f = a(t.onSeparator),
    p = r(t.onComment),
    v = a(t.onError),
    b = e && e.disallowComments,
    k = e && e.allowTrailingComma
  function E() {
    for (;;) {
      const M = s.scan()
      switch (s.getTokenError()) {
        case 4:
          P(14)
          break
        case 5:
          P(15)
          break
        case 3:
          P(13)
          break
        case 1:
          b || P(11)
          break
        case 2:
          P(12)
          break
        case 6:
          P(16)
          break
      }
      switch (M) {
        case 12:
        case 13:
          b ? P(10) : p()
          break
        case 16:
          P(1)
          break
        case 15:
        case 14:
          break
        default:
          return M
      }
    }
  }
  function P(M, rt = [], Jt = []) {
    if ((v(M), rt.length + Jt.length > 0)) {
      let ct = s.getToken()
      for (; ct !== 17; ) {
        if (rt.indexOf(ct) !== -1) {
          E()
          break
        } else if (Jt.indexOf(ct) !== -1) break
        ct = E()
      }
    }
  }
  function C(M) {
    const rt = s.getTokenValue()
    return M ? m(rt) : c(rt), E(), !0
  }
  function R() {
    switch (s.getToken()) {
      case 11: {
        let M = 0
        try {
          ;(M = JSON.parse(s.getTokenValue())),
            typeof M != "number" && (P(2), (M = 0))
        } catch {
          P(2)
        }
        m(M)
        break
      }
      case 7:
        m(null)
        break
      case 8:
        m(!0)
        break
      case 9:
        m(!1)
        break
      default:
        return !1
    }
    return E(), !0
  }
  function D() {
    return s.getToken() !== 10
      ? (P(3, [], [2, 5]), !1)
      : (C(!1),
        s.getToken() === 6
          ? (f(":"), E(), Z() || P(4, [], [2, 5]))
          : P(5, [], [2, 5]),
        !0)
  }
  function V() {
    o(), E()
    let M = !1
    for (; s.getToken() !== 2 && s.getToken() !== 17; ) {
      if (s.getToken() === 5) {
        if ((M || P(4, [], []), f(","), E(), s.getToken() === 2 && k)) break
      } else M && P(6, [], [])
      D() || P(4, [], [2, 5]), (M = !0)
    }
    return l(), s.getToken() !== 2 ? P(7, [2], []) : E(), !0
  }
  function tt() {
    u(), E()
    let M = !1
    for (; s.getToken() !== 4 && s.getToken() !== 17; ) {
      if (s.getToken() === 5) {
        if ((M || P(4, [], []), f(","), E(), s.getToken() === 4 && k)) break
      } else M && P(6, [], [])
      Z() || P(4, [], [4, 5]), (M = !0)
    }
    return d(), s.getToken() !== 4 ? P(8, [4], []) : E(), !0
  }
  function Z() {
    switch (s.getToken()) {
      case 3:
        return tt()
      case 1:
        return V()
      case 10:
        return C(!0)
      default:
        return R()
    }
  }
  return (
    E(),
    s.getToken() === 17
      ? e.allowEmptyContent
        ? !0
        : (P(4, [], []), !1)
      : Z()
        ? (s.getToken() !== 17 && P(9, [], []), !0)
        : (P(4, [], []), !1)
  )
}
function Zd(i) {
  return Object.isFrozen(i) ? i : MY(i)
}
var Dl = class Zo {
    static createEmptyModel(t) {
      return new Zo({}, [], [], void 0, t)
    }
    constructor(t, e, s, r, a) {
      ;(this.b = t),
        (this.c = e),
        (this.d = s),
        (this.raw = r),
        (this.f = a),
        (this.a = new Map())
    }
    get rawConfiguration() {
      if (!this.g)
        if (this.raw?.length) {
          const t = this.raw.map((e) => {
            if (e instanceof Zo) return e
            const s = new WIt("", this.f)
            return s.parseRaw(e), s.configurationModel
          })
          this.g = t.reduce((e, s) => (s === e ? s : e.merge(s)), t[0])
        } else this.g = this
      return this.g
    }
    get contents() {
      return this.b
    }
    get overrides() {
      return this.d
    }
    get keys() {
      return this.c
    }
    isEmpty() {
      return (
        this.c.length === 0 &&
        Object.keys(this.b).length === 0 &&
        this.d.length === 0
      )
    }
    getValue(t) {
      return t ? y6(this.contents, t) : this.contents
    }
    inspect(t, e) {
      const s = this
      return {
        get value() {
          return Zd(s.rawConfiguration.getValue(t))
        },
        get override() {
          return e ? Zd(s.rawConfiguration.getOverrideValue(t, e)) : void 0
        },
        get merged() {
          return Zd(
            e
              ? s.rawConfiguration.override(e).getValue(t)
              : s.rawConfiguration.getValue(t),
          )
        },
        get overrides() {
          const r = []
          for (const { contents: a, identifiers: o, keys: c } of s
            .rawConfiguration.overrides) {
            const l = new Zo(a, c, [], void 0, s.f).getValue(t)
            l !== void 0 && r.push({ identifiers: o, value: l })
          }
          return r.length ? Zd(r) : void 0
        },
      }
    }
    getOverrideValue(t, e) {
      const s = this.j(e)
      return s ? (t ? y6(s, t) : s) : void 0
    }
    getKeysForOverrideIdentifier(t) {
      const e = []
      for (const s of this.overrides)
        s.identifiers.includes(t) && e.push(...s.keys)
      return ac(e)
    }
    getAllOverrideIdentifiers() {
      const t = []
      for (const e of this.overrides) t.push(...e.identifiers)
      return ac(t)
    }
    override(t) {
      let e = this.a.get(t)
      return e || ((e = this.h(t)), this.a.set(t, e)), e
    }
    merge(...t) {
      const e = pe(this.contents),
        s = pe(this.overrides),
        r = [...this.keys],
        a = this.raw?.length ? [...this.raw] : [this]
      for (const o of t)
        if ((a.push(...(o.raw?.length ? o.raw : [o])), !o.isEmpty())) {
          this.i(e, o.contents)
          for (const c of o.overrides) {
            const [l] = s.filter((u) => Er(u.identifiers, c.identifiers))
            l
              ? (this.i(l.contents, c.contents),
                l.keys.push(...c.keys),
                (l.keys = ac(l.keys)))
              : s.push(pe(c))
          }
          for (const c of o.keys) r.indexOf(c) === -1 && r.push(c)
        }
      return new Zo(
        e,
        r,
        s,
        a.every((o) => o instanceof Zo) ? void 0 : a,
        this.f,
      )
    }
    h(t) {
      const e = this.j(t)
      if (!e || typeof e != "object" || !Object.keys(e).length) return this
      const s = {}
      for (const r of ac([...Object.keys(this.contents), ...Object.keys(e)])) {
        let a = this.contents[r]
        const o = e[r]
        o &&
          (typeof a == "object" && typeof o == "object"
            ? ((a = pe(a)), this.i(a, o))
            : (a = o)),
          (s[r] = a)
      }
      return new Zo(s, this.keys, this.overrides, void 0, this.f)
    }
    i(t, e) {
      for (const s of Object.keys(e)) {
        if (s in t && Je(t[s]) && Je(e[s])) {
          this.i(t[s], e[s])
          continue
        }
        t[s] = pe(e[s])
      }
    }
    j(t) {
      let e = null,
        s = null
      const r = (a) => {
        a && (s ? this.i(s, a) : (s = pe(a)))
      }
      for (const a of this.overrides)
        a.identifiers.length === 1 && a.identifiers[0] === t
          ? (e = a.contents)
          : a.identifiers.includes(t) && r(a.contents)
      return r(e), s
    }
    toJSON() {
      return {
        contents: this.contents,
        overrides: this.overrides,
        keys: this.keys,
      }
    }
    addValue(t, e) {
      this.k(t, e, !0)
    }
    setValue(t, e) {
      this.k(t, e, !1)
    }
    removeValue(t) {
      const e = this.keys.indexOf(t)
      e !== -1 &&
        (this.keys.splice(e, 1),
        j0t(this.contents, t),
        Rr.test(t) &&
          this.overrides.splice(
            this.overrides.findIndex((s) => Er(s.identifiers, bh(t))),
            1,
          ))
    }
    k(t, e, s) {
      if (
        (MK(this.contents, t, e, (r) => this.f.error(r)),
        (s = s || this.keys.indexOf(t) === -1),
        s && this.keys.push(t),
        Rr.test(t))
      ) {
        const r = bh(t),
          a = {
            identifiers: r,
            keys: Object.keys(this.contents[t]),
            contents: f2(this.contents[t], (c) => this.f.error(c)),
          },
          o = this.overrides.findIndex((c) => Er(c.identifiers, r))
        o !== -1 ? (this.overrides[o] = a) : this.overrides.push(a)
      }
    }
  },
  WIt = class {
    constructor(i, t) {
      ;(this.f = i),
        (this.g = t),
        (this.a = null),
        (this.b = null),
        (this.c = []),
        (this.d = [])
    }
    get configurationModel() {
      return this.b || Dl.createEmptyModel(this.g)
    }
    get restrictedConfigurations() {
      return this.c
    }
    get errors() {
      return this.d
    }
    parse(i, t) {
      if (!Fe(i)) {
        const e = this.h(i)
        this.parseRaw(e, t)
      }
    }
    reparse(i) {
      this.a && this.parseRaw(this.a, i)
    }
    parseRaw(i, t) {
      this.a = i
      const {
        contents: e,
        keys: s,
        overrides: r,
        restricted: a,
        hasExcludedProperties: o,
      } = this.i(i, t)
      ;(this.b = new Dl(e, s, r, o ? [i] : void 0, this.g)), (this.c = a || [])
    }
    h(i) {
      let t = {},
        e = null,
        s = []
      const r = [],
        a = []
      function o(l) {
        Array.isArray(s) ? s.push(l) : e !== null && (s[e] = l)
      }
      const c = {
        onObjectBegin: () => {
          const l = {}
          o(l), r.push(s), (s = l), (e = null)
        },
        onObjectProperty: (l) => {
          e = l
        },
        onObjectEnd: () => {
          s = r.pop()
        },
        onArrayBegin: () => {
          const l = []
          o(l), r.push(s), (s = l), (e = null)
        },
        onArrayEnd: () => {
          s = r.pop()
        },
        onLiteralValue: o,
        onError: (l, u, d) => {
          a.push({ error: l, offset: u, length: d })
        },
      }
      if (i)
        try {
          HIt(i, c), (t = s[0] || {})
        } catch (l) {
          this.g.error(`Error while parsing settings file ${this.f}: ${l}`),
            (this.d = [l])
        }
      return t
    }
    i(i, t) {
      const e = Si.as(_c.Configuration).getConfigurationProperties(),
        s = this.j(i, e, !0, t)
      i = s.raw
      const r = f2(i, (c) =>
          this.g.error(`Conflict in settings file ${this.f}: ${c}`),
        ),
        a = Object.keys(i),
        o = this.m(i, (c) =>
          this.g.error(`Conflict in settings file ${this.f}: ${c}`),
        )
      return {
        contents: r,
        keys: a,
        overrides: o,
        restricted: s.restricted,
        hasExcludedProperties: s.hasExcludedProperties,
      }
    }
    j(i, t, e, s) {
      let r = !1
      if (!s?.scopes && !s?.skipRestricted && !s?.exclude?.length)
        return { raw: i, restricted: [], hasExcludedProperties: r }
      const a = {},
        o = []
      for (const c in i)
        if (Rr.test(c) && e) {
          const l = this.j(i[c], t, !1, s)
          ;(a[c] = l.raw),
            (r = r || l.hasExcludedProperties),
            o.push(...l.restricted)
        } else {
          const l = t[c]
          l?.restricted && o.push(c), this.l(c, l, s) ? (a[c] = i[c]) : (r = !0)
        }
      return { raw: a, restricted: o, hasExcludedProperties: r }
    }
    l(i, t, e) {
      if (e.exclude?.includes(i)) return !1
      if (e.include?.includes(i)) return !0
      if ((e.skipRestricted && t?.restricted) || (e.skipUnregistered && !t))
        return !1
      const s = t ? (typeof t.scope < "u" ? t.scope : 3) : void 0
      return s === void 0 || e.scopes === void 0 ? !0 : e.scopes.includes(s)
    }
    m(i, t) {
      const e = []
      for (const s of Object.keys(i))
        if (Rr.test(s)) {
          const r = {}
          for (const a in i[s]) r[a] = i[s][a]
          e.push({
            identifiers: bh(s),
            keys: Object.keys(r),
            contents: f2(r, t),
          })
        }
      return e
    }
  },
  jIt = class {
    constructor(i, t, e, s, r, a, o, c, l, u, d, m, f) {
      ;(this.a = i),
        (this.b = t),
        (this.c = e),
        (this.overrideIdentifiers = s),
        (this.d = r),
        (this.f = a),
        (this.g = o),
        (this.h = c),
        (this.i = l),
        (this.j = u),
        (this.k = d),
        (this.l = m),
        (this.m = f)
    }
    get value() {
      return Zd(this.c)
    }
    n(i) {
      return i?.value !== void 0 ||
        i?.override !== void 0 ||
        i?.overrides !== void 0
        ? i
        : void 0
    }
    get q() {
      return (
        this.p || (this.p = this.d.inspect(this.a, this.b.overrideIdentifier)),
        this.p
      )
    }
    get defaultValue() {
      return this.q.merged
    }
    get default() {
      return this.n(this.q)
    }
    get s() {
      return (
        this.r === void 0 && (this.r = this.f ? this.f.inspect(this.a) : null),
        this.r
      )
    }
    get policyValue() {
      return this.s?.merged
    }
    get policy() {
      return this.s?.value !== void 0 ? { value: this.s.value } : void 0
    }
    get u() {
      return (
        this.t === void 0 && (this.t = this.g ? this.g.inspect(this.a) : null),
        this.t
      )
    }
    get applicationValue() {
      return this.u?.merged
    }
    get application() {
      return this.n(this.u)
    }
    get w() {
      return (
        this.v || (this.v = this.h.inspect(this.a, this.b.overrideIdentifier)),
        this.v
      )
    }
    get userValue() {
      return this.w.merged
    }
    get user() {
      return this.n(this.w)
    }
    get y() {
      return (
        this.x || (this.x = this.i.inspect(this.a, this.b.overrideIdentifier)),
        this.x
      )
    }
    get userLocalValue() {
      return this.y.merged
    }
    get userLocal() {
      return this.n(this.y)
    }
    get A() {
      return (
        this.z || (this.z = this.j.inspect(this.a, this.b.overrideIdentifier)),
        this.z
      )
    }
    get userRemoteValue() {
      return this.A.merged
    }
    get userRemote() {
      return this.n(this.A)
    }
    get D() {
      return (
        this.B === void 0 &&
          (this.B = this.k
            ? this.k.inspect(this.a, this.b.overrideIdentifier)
            : null),
        this.B
      )
    }
    get workspaceValue() {
      return this.D?.merged
    }
    get workspace() {
      return this.n(this.D)
    }
    get F() {
      return (
        this.E === void 0 &&
          (this.E = this.l
            ? this.l.inspect(this.a, this.b.overrideIdentifier)
            : null),
        this.E
      )
    }
    get workspaceFolderValue() {
      return this.F?.merged
    }
    get workspaceFolder() {
      return this.n(this.F)
    }
    get H() {
      return (
        this.G === void 0 &&
          (this.G = this.m.inspect(this.a, this.b.overrideIdentifier)),
        this.G
      )
    }
    get memoryValue() {
      return this.H.merged
    }
    get memory() {
      return this.n(this.H)
    }
  },
  GM = class nut {
    constructor(t, e, s, r, a, o, c, l, u, d) {
      ;(this.j = t),
        (this.l = e),
        (this.m = s),
        (this.n = r),
        (this.p = a),
        (this.q = o),
        (this.r = c),
        (this.s = l),
        (this.t = u),
        (this.u = d),
        (this.h = null),
        (this.i = new oi()),
        (this.v = null)
    }
    getValue(t, e, s) {
      return this.w(t, e, s).getValue(t)
    }
    updateValue(t, e, s = {}) {
      let r
      s.resource
        ? ((r = this.t.get(s.resource)),
          r || ((r = Dl.createEmptyModel(this.u)), this.t.set(s.resource, r)))
        : (r = this.s),
        e === void 0 ? r.removeValue(t) : r.setValue(t, e),
        s.resource || (this.h = null)
    }
    inspect(t, e, s) {
      const r = this.w(t, e, s),
        a = this.A(e.resource, s),
        o = e.resource ? this.t.get(e.resource) || this.s : this.s,
        c = new Set()
      for (const l of r.overrides)
        for (const u of l.identifiers)
          r.getOverrideValue(t, u) !== void 0 && c.add(u)
      return new jIt(
        t,
        e,
        r.getValue(t),
        c.size ? [...c] : void 0,
        this.j,
        this.l.isEmpty() ? void 0 : this.l,
        this.applicationConfiguration.isEmpty()
          ? void 0
          : this.applicationConfiguration,
        this.userConfiguration,
        this.localUserConfiguration,
        this.remoteUserConfiguration,
        s ? this.q : void 0,
        a || void 0,
        o,
      )
    }
    keys(t) {
      const e = this.A(void 0, t)
      return {
        default: this.j.keys.slice(0),
        user: this.userConfiguration.keys.slice(0),
        workspace: this.q.keys.slice(0),
        workspaceFolder: e ? e.keys.slice(0) : [],
      }
    }
    updateDefaultConfiguration(t) {
      ;(this.j = t), (this.h = null), this.i.clear()
    }
    updatePolicyConfiguration(t) {
      this.l = t
    }
    updateApplicationConfiguration(t) {
      ;(this.m = t), (this.h = null), this.i.clear()
    }
    updateLocalUserConfiguration(t) {
      ;(this.n = t), (this.v = null), (this.h = null), this.i.clear()
    }
    updateRemoteUserConfiguration(t) {
      ;(this.p = t), (this.v = null), (this.h = null), this.i.clear()
    }
    updateWorkspaceConfiguration(t) {
      ;(this.q = t), (this.h = null), this.i.clear()
    }
    updateFolderConfiguration(t, e) {
      this.r.set(t, e), this.i.delete(t)
    }
    deleteFolderConfiguration(t) {
      this.folderConfigurations.delete(t), this.i.delete(t)
    }
    compareAndUpdateDefaultConfiguration(t, e) {
      const s = []
      if (!e) {
        const { added: r, updated: a, removed: o } = Ia(this.j, t)
        e = [...r, ...a, ...o]
      }
      for (const r of e)
        for (const a of bh(r)) {
          const o = this.j.getKeysForOverrideIdentifier(a),
            c = t.getKeysForOverrideIdentifier(a),
            l = [
              ...c.filter((u) => o.indexOf(u) === -1),
              ...o.filter((u) => c.indexOf(u) === -1),
              ...o.filter(
                (u) =>
                  !Qs(
                    this.j.override(a).getValue(u),
                    t.override(a).getValue(u),
                  ),
              ),
            ]
          s.push([a, l])
        }
      return this.updateDefaultConfiguration(t), { keys: e, overrides: s }
    }
    compareAndUpdatePolicyConfiguration(t) {
      const { added: e, updated: s, removed: r } = Ia(this.l, t),
        a = [...e, ...s, ...r]
      return (
        a.length && this.updatePolicyConfiguration(t),
        { keys: a, overrides: [] }
      )
    }
    compareAndUpdateApplicationConfiguration(t) {
      const {
          added: e,
          updated: s,
          removed: r,
          overrides: a,
        } = Ia(this.applicationConfiguration, t),
        o = [...e, ...s, ...r]
      return (
        o.length && this.updateApplicationConfiguration(t),
        { keys: o, overrides: a }
      )
    }
    compareAndUpdateLocalUserConfiguration(t) {
      const {
          added: e,
          updated: s,
          removed: r,
          overrides: a,
        } = Ia(this.localUserConfiguration, t),
        o = [...e, ...s, ...r]
      return (
        o.length && this.updateLocalUserConfiguration(t),
        { keys: o, overrides: a }
      )
    }
    compareAndUpdateRemoteUserConfiguration(t) {
      const {
          added: e,
          updated: s,
          removed: r,
          overrides: a,
        } = Ia(this.remoteUserConfiguration, t),
        o = [...e, ...s, ...r]
      return (
        o.length && this.updateRemoteUserConfiguration(t),
        { keys: o, overrides: a }
      )
    }
    compareAndUpdateWorkspaceConfiguration(t) {
      const {
          added: e,
          updated: s,
          removed: r,
          overrides: a,
        } = Ia(this.workspaceConfiguration, t),
        o = [...e, ...s, ...r]
      return (
        o.length && this.updateWorkspaceConfiguration(t),
        { keys: o, overrides: a }
      )
    }
    compareAndUpdateFolderConfiguration(t, e) {
      const s = this.folderConfigurations.get(t),
        { added: r, updated: a, removed: o, overrides: c } = Ia(s, e),
        l = [...r, ...a, ...o]
      return (
        (l.length || !s) && this.updateFolderConfiguration(t, e),
        { keys: l, overrides: c }
      )
    }
    compareAndDeleteFolderConfiguration(t) {
      const e = this.folderConfigurations.get(t)
      if (!e) throw new Error("Unknown folder")
      this.deleteFolderConfiguration(t)
      const { added: s, updated: r, removed: a, overrides: o } = Ia(e, void 0)
      return { keys: [...s, ...r, ...a], overrides: o }
    }
    get defaults() {
      return this.j
    }
    get applicationConfiguration() {
      return this.m
    }
    get userConfiguration() {
      return (
        this.v || (this.v = this.p.isEmpty() ? this.n : this.n.merge(this.p)),
        this.v
      )
    }
    get localUserConfiguration() {
      return this.n
    }
    get remoteUserConfiguration() {
      return this.p
    }
    get workspaceConfiguration() {
      return this.q
    }
    get folderConfigurations() {
      return this.r
    }
    w(t, e, s) {
      let r = this.x(e, s)
      return (
        e.overrideIdentifier && (r = r.override(e.overrideIdentifier)),
        !this.l.isEmpty() &&
          this.l.getValue(t) !== void 0 &&
          (r = r.merge(this.l)),
        r
      )
    }
    x({ resource: t }, e) {
      let s = this.y()
      if (e && t) {
        const r = e.getFolder(t)
        r && (s = this.z(r.uri) || s)
        const a = this.t.get(t)
        a && (s = s.merge(a))
      }
      return s
    }
    y() {
      return (
        this.h ||
          (this.h = this.j.merge(
            this.applicationConfiguration,
            this.userConfiguration,
            this.q,
            this.s,
          )),
        this.h
      )
    }
    z(t) {
      let e = this.i.get(t)
      if (!e) {
        const s = this.y(),
          r = this.r.get(t)
        r ? ((e = s.merge(r)), this.i.set(t, e)) : (e = s)
      }
      return e
    }
    A(t, e) {
      if (e && t) {
        const s = e.getFolder(t)
        if (s) return this.r.get(s.uri)
      }
    }
    toData() {
      return {
        defaults: {
          contents: this.j.contents,
          overrides: this.j.overrides,
          keys: this.j.keys,
        },
        policy: {
          contents: this.l.contents,
          overrides: this.l.overrides,
          keys: this.l.keys,
        },
        application: {
          contents: this.applicationConfiguration.contents,
          overrides: this.applicationConfiguration.overrides,
          keys: this.applicationConfiguration.keys,
        },
        user: {
          contents: this.userConfiguration.contents,
          overrides: this.userConfiguration.overrides,
          keys: this.userConfiguration.keys,
        },
        workspace: {
          contents: this.q.contents,
          overrides: this.q.overrides,
          keys: this.q.keys,
        },
        folders: [...this.r.keys()].reduce((t, e) => {
          const { contents: s, overrides: r, keys: a } = this.r.get(e)
          return t.push([e, { contents: s, overrides: r, keys: a }]), t
        }, []),
      }
    }
    allKeys() {
      const t = new Set()
      return (
        this.j.keys.forEach((e) => t.add(e)),
        this.userConfiguration.keys.forEach((e) => t.add(e)),
        this.q.keys.forEach((e) => t.add(e)),
        this.r.forEach((e) => e.keys.forEach((s) => t.add(s))),
        [...t.values()]
      )
    }
    B() {
      const t = new Set()
      return (
        this.j.getAllOverrideIdentifiers().forEach((e) => t.add(e)),
        this.userConfiguration
          .getAllOverrideIdentifiers()
          .forEach((e) => t.add(e)),
        this.q.getAllOverrideIdentifiers().forEach((e) => t.add(e)),
        this.r.forEach((e) =>
          e.getAllOverrideIdentifiers().forEach((s) => t.add(s)),
        ),
        [...t.values()]
      )
    }
    D(t) {
      const e = new Set()
      return (
        this.j.getKeysForOverrideIdentifier(t).forEach((s) => e.add(s)),
        this.userConfiguration
          .getKeysForOverrideIdentifier(t)
          .forEach((s) => e.add(s)),
        this.q.getKeysForOverrideIdentifier(t).forEach((s) => e.add(s)),
        this.r.forEach((s) =>
          s.getKeysForOverrideIdentifier(t).forEach((r) => e.add(r)),
        ),
        [...e.values()]
      )
    }
    static parse(t, e) {
      const s = this.E(t.defaults, e),
        r = this.E(t.policy, e),
        a = this.E(t.application, e),
        o = this.E(t.user, e),
        c = this.E(t.workspace, e),
        l = t.folders.reduce(
          (u, d) => (u.set(S.revive(d[0]), this.E(d[1], e)), u),
          new oi(),
        )
      return new nut(
        s,
        r,
        a,
        o,
        Dl.createEmptyModel(e),
        c,
        l,
        Dl.createEmptyModel(e),
        new oi(),
        e,
      )
    }
    static E(t, e) {
      return new Dl(t.contents, t.keys, t.overrides, void 0, e)
    }
  },
  VIt = class {
    constructor(i, t, e, s, r) {
      ;(this.change = i),
        (this.f = t),
        (this.g = e),
        (this.h = s),
        (this.i = r),
        (this.a = `
`),
        (this.b = this.a.charCodeAt(0)),
        (this.c = 46),
        (this.affectedKeys = new Set()),
        (this.j = void 0)
      for (const a of i.keys) this.affectedKeys.add(a)
      for (const [, a] of i.overrides)
        for (const o of a) this.affectedKeys.add(o)
      this.d = this.a
      for (const a of this.affectedKeys) this.d += a + this.a
    }
    get previousConfiguration() {
      return (
        !this.j && this.f && (this.j = GM.parse(this.f.data, this.i)), this.j
      )
    }
    affectsConfiguration(i, t) {
      const e = this.a + i,
        s = this.d.indexOf(e)
      if (s < 0) return !1
      const r = s + e.length
      if (r >= this.d.length) return !1
      const a = this.d.charCodeAt(r)
      if (a !== this.b && a !== this.c) return !1
      if (t) {
        const o = this.previousConfiguration
            ? this.previousConfiguration.getValue(i, t, this.f?.workspace)
            : void 0,
          c = this.g.getValue(i, t, this.h)
        return !Qs(o, c)
      }
      return !0
    }
  }
function Ia(i, t) {
  const {
      added: e,
      removed: s,
      updated: r,
    } = ait(t?.rawConfiguration, i?.rawConfiguration),
    a = [],
    o = i?.getAllOverrideIdentifiers() || [],
    c = t?.getAllOverrideIdentifiers() || []
  if (t) {
    const l = c.filter((u) => !o.includes(u))
    for (const u of l) a.push([u, t.getKeysForOverrideIdentifier(u)])
  }
  if (i) {
    const l = o.filter((u) => !c.includes(u))
    for (const u of l) a.push([u, i.getKeysForOverrideIdentifier(u)])
  }
  if (t && i) {
    for (const l of o)
      if (c.includes(l)) {
        const u = ait(
          {
            contents: i.getOverrideValue(void 0, l) || {},
            keys: i.getKeysForOverrideIdentifier(l),
          },
          {
            contents: t.getOverrideValue(void 0, l) || {},
            keys: t.getKeysForOverrideIdentifier(l),
          },
        )
        a.push([l, [...u.added, ...u.removed, ...u.updated]])
      }
  }
  return { added: e, removed: s, updated: r, overrides: a }
}
function ait(i, t) {
  const e = i
      ? t
        ? i.keys.filter((a) => t.keys.indexOf(a) === -1)
        : [...i.keys]
      : [],
    s = t
      ? i
        ? t.keys.filter((a) => i.keys.indexOf(a) === -1)
        : [...t.keys]
      : [],
    r = []
  if (i && t) {
    for (const a of t.keys)
      if (i.keys.indexOf(a) !== -1) {
        const o = y6(t.contents, a),
          c = y6(i.contents, a)
        Qs(o, c) || r.push(a)
      }
  }
  return { added: e, removed: s, updated: r }
}
function tm(i, t) {
  if (t) {
    const e = t.split(".")
    let s = i
    for (let r = 0; s && r < e.length; r++) s = s[e[r]]
    return s
  }
}
function GIt(i) {
  return i instanceof S
}
function zIt(i) {
  return (
    i && i.uri instanceof S && i.languageId && typeof i.languageId == "string"
  )
}
function YIt(i) {
  return i && !i.uri && i.languageId && typeof i.languageId == "string"
}
function QIt(i) {
  return (
    i &&
    i.uri instanceof S &&
    (!i.name || typeof i.name == "string") &&
    (!i.index || typeof i.index == "number")
  )
}
function oit(i) {
  if (GIt(i)) return { resource: i }
  if (zIt(i)) return { resource: i.uri, overrideIdentifier: i.languageId }
  if (YIt(i)) return { overrideIdentifier: i.languageId }
  if (QIt(i)) return { resource: i.uri }
  if (i === null) return { resource: null }
}
var zM = class {
  constructor(t, e, s) {
    ;(this.a = t.getProxy(K.MainThreadConfiguration)),
      (this.c = e),
      (this.b = s),
      (this.d = new Ns()),
      (this.e = null)
  }
  getConfigProvider() {
    return this.d.wait().then((t) => this.e)
  }
  $initializeConfiguration(t) {
    ;(this.e = new XIt(this.a, this.c, t, this.b)), this.d.open()
  }
  $acceptConfigurationChanged(t, e) {
    this.getConfigProvider().then((s) => s.$acceptConfigurationChanged(t, e))
  }
}
zM = __decorate([__param(0, Ot), __param(1, dr), __param(2, Rt)], zM)
var XIt = class {
    constructor(i, t, e, s) {
      ;(this.a = new J()),
        (this.b = i),
        (this.f = s),
        (this.c = t),
        (this.e = GM.parse(e, s)),
        (this.d = this.k(e.configurationScopes))
    }
    get onDidChangeConfiguration() {
      return this.a && this.a.event
    }
    $acceptConfigurationChanged(i, t) {
      const e = { data: this.e.toData(), workspace: this.c.workspace }
      ;(this.e = GM.parse(i, this.f)),
        (this.d = this.k(i.configurationScopes)),
        this.a.fire(this.j(t, e))
    }
    getConfiguration(i, t, e) {
      const s = oit(t) || {},
        r = this.g(
          i
            ? tm(this.e.getValue(void 0, s, this.c.workspace), i)
            : this.e.getValue(void 0, s, this.c.workspace),
        )
      i && this.h(i, s, e?.identifier)
      function a(c) {
        if (c == null) return null
        if (typeof c == "boolean") return c ? 2 : 5
        switch (c) {
          case tl.Global:
            return 2
          case tl.Workspace:
            return 5
          case tl.WorkspaceFolder:
            return 6
        }
      }
      const o = {
        has(c) {
          return typeof tm(r, c) < "u"
        },
        get: (c, l) => {
          this.h(i ? `${i}.${c}` : c, s, e?.identifier)
          let u = tm(r, c)
          if (typeof u > "u") u = l
          else {
            let d
            const m = (f, p) => {
              if (Je(f)) {
                let v
                const b = () => {
                  ;(d = d || pe(r)), (v = v || tm(d, p))
                }
                return new Proxy(f, {
                  get: (k, E) => {
                    if (typeof E == "string" && E.toLowerCase() === "tojson")
                      return b(), () => v
                    if (d) return (v = v || tm(d, p)), v[E]
                    const P = k[E]
                    return typeof E == "string" ? m(P, `${p}.${E}`) : P
                  },
                  set: (k, E, P) => (b(), v && (v[E] = P), !0),
                  deleteProperty: (k, E) => (b(), v && delete v[E], !0),
                  defineProperty: (k, E, P) => (
                    b(), v && Object.defineProperty(v, E, P), !0
                  ),
                })
              }
              return Array.isArray(f) ? pe(f) : f
            }
            u = m(u, c)
          }
          return u
        },
        update: (c, l, u, d) => {
          c = i ? `${i}.${c}` : c
          const m = a(u)
          return l !== void 0
            ? this.b.$updateConfigurationOption(m, c, l, s, d)
            : this.b.$removeConfigurationOption(m, c, s, d)
        },
        inspect: (c) => {
          c = i ? `${i}.${c}` : c
          const l = this.e.inspect(c, s, this.c.workspace)
          if (l)
            return {
              key: c,
              defaultValue: pe(l.policy?.value ?? l.default?.value),
              globalValue: pe(l.user?.value ?? l.application?.value),
              workspaceValue: pe(l.workspace?.value),
              workspaceFolderValue: pe(l.workspaceFolder?.value),
              defaultLanguageValue: pe(l.default?.override),
              globalLanguageValue: pe(
                l.user?.override ?? l.application?.override,
              ),
              workspaceLanguageValue: pe(l.workspace?.override),
              workspaceFolderLanguageValue: pe(l.workspaceFolder?.override),
              languageIds: pe(l.overrideIdentifiers),
            }
        },
      }
      return typeof r == "object" && en(o, r, !1), Object.freeze(o)
    }
    g(i) {
      const t = (e) =>
        Je(e)
          ? new Proxy(e, {
              get: (s, r) => t(s[r]),
              set: (s, r, a) => {
                throw new Error(
                  `TypeError: Cannot assign to read only property '${String(r)}' of object`,
                )
              },
              deleteProperty: (s, r) => {
                throw new Error(
                  `TypeError: Cannot delete read only property '${String(r)}' of object`,
                )
              },
              defineProperty: (s, r) => {
                throw new Error(
                  `TypeError: Cannot define property '${String(r)}' for a readonly object`,
                )
              },
              setPrototypeOf: (s) => {
                throw new Error(
                  "TypeError: Cannot set prototype for a readonly object",
                )
              },
              isExtensible: () => !1,
              preventExtensions: () => !0,
            })
          : e
      return t(i)
    }
    h(i, t, e) {
      const s = Rr.test(i) ? 4 : this.d.get(i),
        r = e ? `[${e.value}] ` : ""
      if (s === 4) {
        typeof t?.resource > "u" &&
          this.f.warn(
            `${r}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${i}', provide the URI of a resource or 'null' for any resource.`,
          )
        return
      }
      if (s === 3) {
        t?.resource &&
          this.f.warn(
            `${r}Accessing a window scoped configuration for a resource is not expected. To associate '${i}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`,
          )
        return
      }
    }
    j(i, t) {
      const e = new VIt(i, t, this.e, this.c.workspace, this.f)
      return Object.freeze({
        affectsConfiguration: (s, r) => e.affectsConfiguration(s, oit(r)),
      })
    }
    k(i) {
      return i.reduce((t, e) => (t.set(e[0], e[1]), t), new Map())
    }
  },
  Ds = X("IExtHostConfiguration"),
  KIt = class {
    constructor(i, t) {
      ;(this.versionId = i), (this.removedDueToLooping = t)
    }
  },
  em = class aut {
    static isHostExtension(t, e, s) {
      if (e.getExtensionDescription(t)) return !1
      const r = s.getExtensionDescription(t)
      return r ? !!((r.main || r.browser) && r.api === "none") : !1
    }
    constructor(t, e) {
      ;(this.j = t),
        (this.c = new J()),
        (this.onDidChange = this.c.event),
        (this.d = 0),
        (this.e = e.map(YM)),
        this.k()
    }
    k() {
      this.e.sort(tPt), (this.f = new hn()), (this.g = []), (this.h = new Map())
      for (const t of this.e) {
        if (this.f.has(t.identifier)) {
          console.error(
            "Extension `" + t.identifier.value + "` is already registered",
          )
          continue
        }
        this.f.set(t.identifier, t), this.g.push(t)
        const e = this.j.readActivationEvents(t)
        for (const s of e)
          this.h.has(s) || this.h.set(s, []), this.h.get(s).push(t)
      }
    }
    set(t) {
      return (
        (this.e = t.map(YM)),
        this.k(),
        this.d++,
        this.c.fire(void 0),
        { versionId: this.d }
      )
    }
    deltaExtensions(t, e) {
      ;(t = t.map(YM)), (this.e = lit(this.e, e)), (this.e = this.e.concat(t))
      const s = aut.l(this.e)
      return (
        (this.e = lit(
          this.e,
          s.map((r) => r.identifier),
        )),
        this.k(),
        this.d++,
        this.c.fire(void 0),
        new KIt(this.d, s)
      )
    }
    static l(t) {
      const e = new (class {
          constructor() {
            ;(this.c = new Map()), (this.d = new Set()), (this.e = [])
          }
          addNode(c) {
            this.d.has(c) || (this.d.add(c), this.e.push(c))
          }
          addArc(c, l) {
            this.addNode(c),
              this.addNode(l),
              this.c.has(c) ? this.c.get(c).push(l) : this.c.set(c, [l])
          }
          getArcs(c) {
            return this.c.has(c) ? this.c.get(c) : []
          }
          hasOnlyGoodArcs(c, l) {
            const u = e.getArcs(c)
            for (let d = 0; d < u.length; d++) if (!l.has(u[d])) return !1
            return !0
          }
          getNodes() {
            return this.e
          }
        })(),
        s = new hn()
      for (const c of t)
        if ((s.set(c.identifier, c), c.extensionDependencies))
          for (const l of c.extensionDependencies)
            e.addArc(ae.toKey(c.identifier), ae.toKey(l))
      const r = new Set()
      e.getNodes()
        .filter((c) => e.getArcs(c).length === 0)
        .forEach((c) => r.add(c))
      const a = e.getNodes().filter((c) => !r.has(c))
      let o
      do {
        o = !1
        for (let c = 0; c < a.length; c++) {
          const l = a[c]
          e.hasOnlyGoodArcs(l, r) && (a.splice(c, 1), c--, r.add(l), (o = !0))
        }
      } while (o)
      return a.map((c) => s.get(c))
    }
    containsActivationEvent(t) {
      return this.h.has(t)
    }
    containsExtension(t) {
      return this.f.has(t)
    }
    getExtensionDescriptionsForActivationEvent(t) {
      const e = this.h.get(t)
      return e ? e.slice(0) : []
    }
    getAllExtensionDescriptions() {
      return this.g.slice(0)
    }
    getSnapshot() {
      return new ZIt(this.d, this.getAllExtensionDescriptions())
    }
    getExtensionDescription(t) {
      const e = this.f.get(t)
      return e || void 0
    }
    getExtensionDescriptionByUUID(t) {
      for (const e of this.g) if (e.uuid === t) return e
    }
    getExtensionDescriptionByIdOrUUID(t, e) {
      return (
        this.getExtensionDescription(t) ??
        (e ? this.getExtensionDescriptionByUUID(e) : void 0)
      )
    }
  },
  ZIt = class {
    constructor(i, t) {
      ;(this.versionId = i), (this.extensions = t)
    }
  },
  cit
;(function (i) {
  ;(i[(i.Builtin = 0)] = "Builtin"),
    (i[(i.User = 1)] = "User"),
    (i[(i.Dev = 2)] = "Dev")
})(cit || (cit = {}))
function tPt(i, t) {
  const e = i.isBuiltin ? 0 : i.isUnderDevelopment ? 2 : 1,
    s = t.isBuiltin ? 0 : t.isUnderDevelopment ? 2 : 1
  if (e !== s) return e - s
  const r = Wt.basename(i.extensionLocation.path),
    a = Wt.basename(t.extensionLocation.path)
  return r < a ? -1 : r > a ? 1 : 0
}
function lit(i, t) {
  const e = new no(t)
  return i.filter((s) => !e.has(s.identifier))
}
function YM(i) {
  return {
    ...i,
    extensionDependencies: i.extensionDependencies?.map(
      (t) => K_.modifiedExtensionDependencies?.[t] ?? t,
    ),
  }
}
var QM = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$",
  oYt = new RegExp(QM),
  uit
;(function (i) {
  ;(i.COMMAND = "command"), (i.SETTINGS_SYNC = "settingsSync")
})(uit || (uit = {}))
var hit
;(function (i) {
  ;(i[(i.NoneOrRelevance = 0)] = "NoneOrRelevance"),
    (i[(i.LastUpdatedDate = 1)] = "LastUpdatedDate"),
    (i[(i.Title = 2)] = "Title"),
    (i[(i.PublisherName = 3)] = "PublisherName"),
    (i[(i.InstallCount = 4)] = "InstallCount"),
    (i[(i.PublishedDate = 10)] = "PublishedDate"),
    (i[(i.AverageRating = 6)] = "AverageRating"),
    (i[(i.WeightedRating = 12)] = "WeightedRating")
})(hit || (hit = {}))
var dit
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.Ascending = 1)] = "Ascending"),
    (i[(i.Descending = 2)] = "Descending")
})(dit || (dit = {}))
var mit
;(function (i) {
  ;(i.Install = "install"), (i.Uninstall = "uninstall")
})(mit || (mit = {}))
var fit
;(function (i) {
  ;(i[(i.None = 1)] = "None"),
    (i[(i.Install = 2)] = "Install"),
    (i[(i.Update = 3)] = "Update"),
    (i[(i.Migrate = 4)] = "Migrate")
})(fit || (fit = {}))
var cYt = X("extensionGalleryService"),
  pit
;(function (i) {
  ;(i.Timeout = "Timeout"),
    (i.Cancelled = "Cancelled"),
    (i.Failed = "Failed"),
    (i.DownloadFailedWriting = "DownloadFailedWriting"),
    (i.Offline = "Offline")
})(pit || (pit = {}))
var git
;(function (i) {
  ;(i.Unsupported = "Unsupported"),
    (i.Deprecated = "Deprecated"),
    (i.Malicious = "Malicious"),
    (i.Incompatible = "Incompatible"),
    (i.IncompatibleApi = "IncompatibleApi"),
    (i.IncompatibleTargetPlatform = "IncompatibleTargetPlatform"),
    (i.ReleaseVersionNotFound = "ReleaseVersionNotFound"),
    (i.Invalid = "Invalid"),
    (i.Download = "Download"),
    (i.DownloadSignature = "DownloadSignature"),
    (i.DownloadFailedWriting = "DownloadFailedWriting"),
    (i.UpdateMetadata = "UpdateMetadata"),
    (i.Extract = "Extract"),
    (i.Scanning = "Scanning"),
    (i.ScanningExtension = "ScanningExtension"),
    (i.ReadUninstalled = "ReadUninstalled"),
    (i.UnsetUninstalled = "UnsetUninstalled"),
    (i.Delete = "Delete"),
    (i.Rename = "Rename"),
    (i.IntializeDefaultProfile = "IntializeDefaultProfile"),
    (i.AddToProfile = "AddToProfile"),
    (i.InstalledExtensionNotFound = "InstalledExtensionNotFound"),
    (i.PostInstall = "PostInstall"),
    (i.CorruptZip = "CorruptZip"),
    (i.IncompleteZip = "IncompleteZip"),
    (i.PackageNotSigned = "PackageNotSigned"),
    (i.SignatureVerificationInternal = "SignatureVerificationInternal"),
    (i.SignatureVerificationFailed = "SignatureVerificationFailed"),
    (i.NotAllowed = "NotAllowed"),
    (i.Gallery = "Gallery"),
    (i.Cancelled = "Cancelled"),
    (i.Unknown = "Unknown"),
    (i.Internal = "Internal")
})(git || (git = {}))
var vit
;(function (i) {
  ;(i.NotSigned = "NotSigned"),
    (i.Success = "Success"),
    (i.RequiredArgumentMissing = "RequiredArgumentMissing"),
    (i.InvalidArgument = "InvalidArgument"),
    (i.PackageIsUnreadable = "PackageIsUnreadable"),
    (i.UnhandledException = "UnhandledException"),
    (i.SignatureManifestIsMissing = "SignatureManifestIsMissing"),
    (i.SignatureManifestIsUnreadable = "SignatureManifestIsUnreadable"),
    (i.SignatureIsMissing = "SignatureIsMissing"),
    (i.SignatureIsUnreadable = "SignatureIsUnreadable"),
    (i.CertificateIsUnreadable = "CertificateIsUnreadable"),
    (i.SignatureArchiveIsUnreadable = "SignatureArchiveIsUnreadable"),
    (i.FileAlreadyExists = "FileAlreadyExists"),
    (i.SignatureArchiveIsInvalidZip = "SignatureArchiveIsInvalidZip"),
    (i.SignatureArchiveHasSameSignatureFile =
      "SignatureArchiveHasSameSignatureFile"),
    (i.PackageIntegrityCheckFailed = "PackageIntegrityCheckFailed"),
    (i.SignatureIsInvalid = "SignatureIsInvalid"),
    (i.SignatureManifestIsInvalid = "SignatureManifestIsInvalid"),
    (i.SignatureIntegrityCheckFailed = "SignatureIntegrityCheckFailed"),
    (i.EntryIsMissing = "EntryIsMissing"),
    (i.EntryIsTampered = "EntryIsTampered"),
    (i.Untrusted = "Untrusted"),
    (i.CertificateRevoked = "CertificateRevoked"),
    (i.SignatureIsNotValid = "SignatureIsNotValid"),
    (i.UnknownError = "UnknownError"),
    (i.PackageIsInvalidZip = "PackageIsInvalidZip"),
    (i.SignatureArchiveHasTooManyEntries = "SignatureArchiveHasTooManyEntries")
})(vit || (vit = {}))
var lYt = X("extensionManagementService"),
  uYt = X("IGlobalExtensionEnablementService"),
  hYt = X("IExtensionTipsService"),
  dYt = X("IAllowedExtensionsService"),
  mYt = p7(1832, "Extensions"),
  fYt = p7(1833, "Preferences"),
  pYt = X("telemetryService"),
  gYt = X("customEndpointTelemetryService"),
  wit
;(function (i) {
  ;(i[(i.NONE = 0)] = "NONE"),
    (i[(i.CRASH = 1)] = "CRASH"),
    (i[(i.ERROR = 2)] = "ERROR"),
    (i[(i.USAGE = 3)] = "USAGE")
})(wit || (wit = {}))
var yit
;(function (i) {
  ;(i.OFF = "off"), (i.ON = "all")
})(yit || (yit = {}))
var XM = class {
    constructor(i) {
      ;(this.value = i), (this.isTrustedTelemetryValue = !0)
    }
  },
  ePt = class {
    constructor() {
      ;(this.telemetryLevel = 0),
        (this.sessionId = "someValue.sessionId"),
        (this.machineId = "someValue.machineId"),
        (this.macMachineId = "someValue.macMachineId"),
        (this.sqmId = "someValue.sqmId"),
        (this.devDeviceId = "someValue.devDeviceId"),
        (this.firstSessionDate = "someValue.firstSessionDate"),
        (this.sendErrorTelemetry = !1)
    }
    registerAuthId() {}
    publicLog() {}
    publicLog2() {}
    publicLogError() {}
    publicLogError2() {}
    publicLogCapture() {}
    setExperimentProperty() {}
  },
  vYt = new ePt(),
  iPt = "extensionTelemetryLog",
  sPt = new Set([
    "ssh-remote",
    "dev-container",
    "attached-container",
    "wsl",
    "tunnel",
    "codespaces",
    "amlext",
  ])
function rPt(i) {
  if (!i) return "none"
  const t = m2(i)
  return sPt.has(t) ? t : "other"
}
function nPt(i, t) {
  if (!i || (!i.includes("/") && !i.includes("\\"))) return i
  let e = i
  const s = []
  for (const c of t)
    for (;;) {
      const l = c.exec(i)
      if (!l) break
      s.push([l.index, c.lastIndex])
    }
  const r = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/,
    a =
      /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g
  let o = 0
  for (e = ""; ; ) {
    const c = a.exec(i)
    if (!c) break
    const l = s.some(([u, d]) => c.index < d && u < a.lastIndex)
    !r.test(c[0]) &&
      !l &&
      ((e += i.substring(o, c.index) + "<REDACTED: user-file-path>"),
      (o = a.lastIndex))
  }
  return o < i.length && (e += i.substr(o)), e
}
function aPt(i) {
  if (!i) return i
  const t = [
    { label: "Google API Key", regex: /AIza[A-Za-z0-9_\\\-]{35}/ },
    { label: "Slack Token", regex: /xox[pbar]\-[A-Za-z0-9]/ },
    {
      label: "GitHub Token",
      regex:
        /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/,
    },
    {
      label: "Generic Secret",
      regex:
        /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i,
    },
    {
      label: "CLI Credentials",
      regex:
        /((login|psexec|(certutil|psexec)\.exe).{1,50}(\s-u(ser(name)?)?\s+.{3,100})?\s-(admin|user|vm|root)?p(ass(word)?)?\s+["']?[^$\-\/\s]|(^|[\s\r\n\\])net(\.exe)?.{1,5}(user\s+|share\s+\/user:| user -? secrets ? set) \s + [^ $\s \/])/,
    },
    {
      label: "Microsoft Entra ID",
      regex: /eyJ(?:0eXAiOiJKV1Qi|hbGci|[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.)/,
    },
    { label: "Email", regex: /@[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+/ },
  ]
  for (const e of t) if (e.regex.test(i)) return `<REDACTED: ${e.label}>`
  return i
}
function bit(i, t) {
  return Sc(i, (e) => {
    if (
      e instanceof XM ||
      Object.hasOwnProperty.call(e, "isTrustedTelemetryValue")
    )
      return e.value
    if (typeof e == "string") {
      let s = e.replaceAll("%20", " ")
      s = nPt(s, t)
      for (const r of t) s = s.replace(r, "")
      return (s = aPt(s)), s
    }
  })
}
var wYt = new ae("pprice.better-merge"),
  oPt = class {
    constructor() {
      ;(this.a = new Map()), (this.b = new WeakMap())
    }
    register(i, t) {
      this.a.set(i, t)
    }
    readActivationEvents(i) {
      return this.b.has(i) || this.b.set(i, this.c(i)), this.b.get(i)
    }
    createActivationEventsMap(i) {
      const t = Object.create(null)
      for (const e of i) {
        const s = this.readActivationEvents(e)
        s.length > 0 && (t[ae.toKey(e.identifier)] = s)
      }
      return t
    }
    c(i) {
      if (typeof i.main > "u" && typeof i.browser > "u") return []
      const t = Array.isArray(i.activationEvents)
        ? i.activationEvents.slice(0)
        : []
      for (let e = 0; e < t.length; e++)
        t[e] === "onUri" && (t[e] = `onUri:${ae.toKey(i.identifier)}`)
      if (!i.contributes) return t
      for (const e in i.contributes) {
        const s = this.a.get(e)
        if (!s) continue
        const r = i.contributes[e],
          a = Array.isArray(r) ? r : [r]
        try {
          s(a, t)
        } catch (o) {
          $e(o)
        }
      }
      return t
    }
  },
  cPt = new oPt(),
  lPt = Object.freeze({
    identifier: new ae("nullExtensionDescription"),
    name: "Null Extension Description",
    version: "0.0.0",
    publisher: "vscode",
    engines: { vscode: "" },
    extensionLocation: S.parse("void:location"),
    isBuiltin: !1,
    targetPlatform: "undefined",
    isUserBuiltin: !1,
    isUnderDevelopment: !1,
    preRelease: !1,
  }),
  uPt = X("extensionService"),
  Tit = class {
    constructor(i) {
      this.dependency = i
    }
  },
  kit
;(function (i) {
  ;(i[(i.EagerAutoStart = 1)] = "EagerAutoStart"),
    (i[(i.EagerManualStart = 2)] = "EagerManualStart"),
    (i[(i.Lazy = 3)] = "Lazy")
})(kit || (kit = {}))
function hi(i, t) {
  return ((t === "control" || t === "cursor" || t === "cursorNoDeps") &&
    !i.isBuiltin) ||
    !i.enabledApiProposals
    ? !1
    : i.enabledApiProposals.includes(t)
}
function _(i, t) {
  if (!hi(i, t))
    throw new Error(`Extension '${i.identifier.value}' CANNOT use API proposal: ${t}.
Its package.json#enabledApiProposals-property declares: ${i.enabledApiProposals?.join(", ") ?? "[]"} but NOT ${t}.
 The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${i.identifier.value}. Note that the cursor and control proposals are only available for built-in extensions`)
}
var Sit
;(function (i) {
  ;(i[(i.Normal = 0)] = "Normal"), (i[(i.Immediate = 1)] = "Immediate")
})(Sit || (Sit = {}))
var aB = class out {
    static {
      this.NONE = new out(!1, -1, -1, -1)
    }
    constructor(t, e, s, r) {
      ;(this.startup = t),
        (this.codeLoadingTime = e),
        (this.activateCallTime = s),
        (this.activateResolvedTime = r)
    }
  },
  Eit = class {
    constructor(i) {
      ;(this.a = i),
        (this.b = -1),
        (this.c = -1),
        (this.d = -1),
        (this.f = -1),
        (this.g = -1),
        (this.h = -1)
    }
    j(i, t) {
      return i === -1 || t === -1 ? -1 : t - i
    }
    build() {
      return new aB(
        this.a,
        this.j(this.b, this.c),
        this.j(this.d, this.f),
        this.j(this.g, this.h),
      )
    }
    codeLoadingStart() {
      this.b = Date.now()
    }
    codeLoadingStop() {
      this.c = Date.now()
    }
    activateCallStart() {
      this.d = Date.now()
    }
    activateCallStop() {
      this.f = Date.now()
    }
    activateResolveStart() {
      this.g = Date.now()
    }
    activateResolveStop() {
      this.h = Date.now()
    }
  },
  oB = class {
    constructor(i, t, e, s, r, a) {
      ;(this.activationFailed = i),
        (this.activationFailedError = t),
        (this.activationTimes = e),
        (this.module = s),
        (this.exports = r),
        (this.disposable = a)
    }
  },
  hPt = class extends oB {
    constructor(i) {
      super(
        !1,
        null,
        i,
        { activate: void 0, deactivate: void 0 },
        void 0,
        at.None,
      )
    }
  },
  dPt = class extends oB {
    constructor() {
      super(
        !1,
        null,
        aB.NONE,
        { activate: void 0, deactivate: void 0 },
        void 0,
        at.None,
      )
    }
  },
  cB = class extends oB {
    constructor(i) {
      super(
        !0,
        i,
        aB.NONE,
        { activate: void 0, deactivate: void 0 },
        void 0,
        at.None,
      )
    }
  },
  KM = class {
    constructor(t, e, s, r) {
      ;(this.g = r),
        (this.a = t),
        (this.b = e),
        (this.c = s),
        (this.d = new hn()),
        (this.f = Object.create(null))
    }
    dispose() {
      for (const [t, e] of this.d) e.dispose()
    }
    async waitForActivatingExtensions() {
      const t = []
      for (const [e, s] of this.d) t.push(s.wait())
      await Promise.all(t)
    }
    isActivated(t) {
      const e = this.d.get(t)
      return !!(e && e.value)
    }
    getActivatedExtension(t) {
      const e = this.d.get(t)
      if (!e || !e.value)
        throw new Error(`Extension '${t.value}' is not known or not activated`)
      return e.value
    }
    async activateByEvent(t, e) {
      if (this.f[t]) return
      const s = this.a.getExtensionDescriptionsForActivationEvent(t)
      await this.h(
        s.map((r) => ({
          id: r.identifier,
          reason: { startup: e, extensionId: r.identifier, activationEvent: t },
        })),
      ),
        (this.f[t] = !0)
    }
    activateById(t, e) {
      const s = this.a.getExtensionDescription(t)
      if (!s) throw new Error(`Extension '${t.value}' is not known`)
      return this.h([{ id: s.identifier, reason: e }])
    }
    async h(t) {
      const e = t.filter((s) => !this.isActivated(s.id)).map((s) => this.j(s))
      await Promise.all(e.map((s) => s.wait()))
    }
    j(t) {
      if (this.d.has(t.id)) return this.d.get(t.id)
      if (this.l(t.id)) return this.k(t, null, [], null)
      const e = this.a.getExtensionDescription(t.id)
      if (!e) {
        const a = new Error(
            `Cannot activate unknown extension '${t.id.value}'`,
          ),
          o = this.k(t, null, [], new cB(a))
        return (
          this.c.onExtensionActivationError(t.id, a, new Tit(t.id.value)), o
        )
      }
      const s = [],
        r = typeof e.extensionDependencies > "u" ? [] : e.extensionDependencies
      for (const a of r) {
        if (this.m(a)) continue
        const o = this.d.get(a)
        if (o) {
          s.push(o)
          continue
        }
        if (this.l(a)) {
          s.push(
            this.j({
              id: this.b.getExtensionDescription(a).identifier,
              reason: t.reason,
            }),
          )
          continue
        }
        const c = this.a.getExtensionDescription(a)
        if (c) {
          if (!c.main && !c.browser) continue
          s.push(this.j({ id: c.identifier, reason: t.reason }))
          continue
        }
        const l = e.displayName || e.identifier.value,
          u = new Error(
            `Cannot activate the '${l}' extension because it depends on unknown extension '${a}'`,
          ),
          d = this.k(t, e.displayName, [], new cB(u))
        return this.c.onExtensionActivationError(e.identifier, u, new Tit(a)), d
      }
      return this.k(t, e.displayName, s, null)
    }
    k(t, e, s, r) {
      const a = new ZM(t.id, e, t.reason, s, r, this.c, this.g)
      return this.d.set(t.id, a), a
    }
    l(t) {
      return em.isHostExtension(t, this.a, this.b)
    }
    m(t) {
      const e = this.b.getExtensionDescription(t)
      return e ? !e.main && !e.browser : !1
    }
  }
KM = __decorate([__param(3, Rt)], KM)
var ZM = class {
  get value() {
    return this.h
  }
  get friendlyName() {
    return this.d || this.c.value
  }
  constructor(t, e, s, r, a, o, c) {
    ;(this.c = t),
      (this.d = e),
      (this.f = s),
      (this.g = r),
      (this.h = a),
      (this.j = o),
      (this.k = c),
      (this.a = new Ns()),
      (this.b = !1),
      this.l()
  }
  dispose() {
    this.b = !0
  }
  wait() {
    return this.a.wait()
  }
  async l() {
    await this.m(), this.a.open()
  }
  async m() {
    if (!this.h) {
      for (; this.g.length > 0; ) {
        for (let t = 0; t < this.g.length; t++) {
          const e = this.g[t]
          if (e.value && !e.value.activationFailed) {
            this.g.splice(t, 1), t--
            continue
          }
          if (e.value && e.value.activationFailed) {
            const s = new Error(
              `Cannot activate the '${this.friendlyName}' extension because its dependency '${e.friendlyName}' failed to activate`,
            )
            ;(s.detail = e.value.activationFailedError),
              (this.h = new cB(s)),
              this.j.onExtensionActivationError(this.c, s, null)
            return
          }
        }
        this.g.length > 0 && (await Promise.race(this.g.map((t) => t.wait())))
      }
      await this.n()
    }
  }
  async n() {
    try {
      this.h = await this.j.actualActivateExtension(this.c, this.f)
    } catch (t) {
      const e = new Error()
      if (
        (t && t.name && (e.name = t.name),
        t && t.message
          ? (e.message = `Activating extension '${this.c.value}' failed: ${t.message}.`)
          : (e.message = `Activating extension '${this.c.value}' failed: ${t}.`),
        t && t.stack && (e.stack = t.stack),
        (this.h = new cB(e)),
        this.b && Ms(t))
      )
        return
      this.j.onExtensionActivationError(this.c, e, null),
        this.k.error(
          `Activating extension ${this.c.value} failed due to an error:`,
        ),
        this.k.error(t)
    }
  }
}
ZM = __decorate([__param(6, Rt)], ZM)
var Iit = class {
    constructor(i, t) {
      ;(this.c = t),
        (this.b = new J()),
        (this.onDidChangeStorage = this.b.event),
        (this.a = i.getProxy(K.MainThreadStorage))
    }
    registerExtensionStorageKeysToSync(i, t) {
      this.a.$registerExtensionStorageKeysToSync(i, t)
    }
    async initializeExtensionStorage(i, t, e) {
      const s = await this.a.$initializeExtensionStorage(i, t)
      let r
      return s && (r = this.d(i, t, s)), r || e
    }
    setValue(i, t, e) {
      return this.a.$setValue(i, t, e)
    }
    $acceptValue(i, t, e) {
      const s = this.d(i, t, e)
      s && this.b.fire({ shared: i, key: t, value: s })
    }
    d(i, t, e) {
      try {
        return JSON.parse(e)
      } catch (s) {
        this.c.error(
          `[extHostStorage] unexpected error parsing storage contents (extensionId: ${t}, global: ${i}): ${s}`,
        )
      }
    }
  },
  tH = X("IExtHostStorage"),
  Pit = class {
    constructor(i, t, e) {
      ;(this.h = new Map()),
        (this.a = i),
        (this.b = t),
        (this.c = e),
        (this.d = this.c
          .initializeExtensionStorage(this.b, this.a, Object.create(null))
          .then((s) => ((this.f = s), this))),
        (this.g = this.c.onDidChangeStorage((s) => {
          s.shared === this.b && s.key === this.a && (this.f = s.value)
        })),
        (this.i = new tn(() => {
          const s = this.h
          ;(this.h = new Map()),
            (async () => {
              try {
                await this.c.setValue(this.b, this.a, this.f)
                for (const r of s.values()) r.complete()
              } catch (r) {
                for (const a of s.values()) a.error(r)
              }
            })()
        }, 0))
    }
    keys() {
      return Object.entries(this.f ?? {})
        .filter(([, i]) => i !== void 0)
        .map(([i]) => i)
    }
    get whenReady() {
      return this.d
    }
    get(i, t) {
      let e = this.f[i]
      return typeof e > "u" && (e = t), e
    }
    update(i, t) {
      this.f[i] = t
      const e = this.h.get(i)
      if (e !== void 0) return e.p
      const s = new Yn()
      return this.h.set(i, s), this.i.isScheduled() || this.i.schedule(), s.p
    }
    dispose() {
      this.g.dispose()
    }
  },
  mPt = class extends Pit {
    setKeysForSync(i) {
      this.c.registerExtensionStorageKeysToSync(
        { id: this.a, version: this.j.version },
        i,
      )
    }
    constructor(i, t) {
      super(i.identifier.value, !0, t), (this.j = i)
    }
  },
  qr,
  eH = (qr = class {
    constructor(t, e) {
      ;(this.b = new Map()),
        (this.c = new KG()),
        (this.a = t.getProxy(K.MainThreadFileSystem))
      const s = this
      this.value = Object.freeze({
        async stat(r) {
          try {
            let a
            const o = s.b.get(r.scheme)
            return (
              o
                ? (await s.a.$ensureActivation(r.scheme),
                  (a = await o.impl.stat(r)))
                : (a = await s.a.$stat(r)),
              {
                type: a.type,
                ctime: a.ctime,
                mtime: a.mtime,
                size: a.size,
                permissions: a.permissions === ia.Readonly ? 1 : void 0,
              }
            )
          } catch (a) {
            qr.e(a)
          }
        },
        async readDirectory(r) {
          try {
            const a = s.b.get(r.scheme)
            return a
              ? (await s.a.$ensureActivation(r.scheme),
                (await a.impl.readDirectory(r)).slice())
              : await s.a.$readdir(r)
          } catch (a) {
            return qr.e(a)
          }
        },
        async createDirectory(r) {
          try {
            const a = s.b.get(r.scheme)
            return a && !a.isReadonly
              ? (await s.a.$ensureActivation(r.scheme),
                await s.d(a.impl, a.extUri, r))
              : await s.a.$mkdir(r)
          } catch (a) {
            return qr.e(a)
          }
        },
        async readFile(r) {
          try {
            const a = s.b.get(r.scheme)
            return a
              ? (await s.a.$ensureActivation(r.scheme),
                (await a.impl.readFile(r)).slice())
              : (await s.a.$readFile(r)).buffer
          } catch (a) {
            return qr.e(a)
          }
        },
        async writeFile(r, a) {
          try {
            const o = s.b.get(r.scheme)
            return o && !o.isReadonly
              ? (await s.a.$ensureActivation(r.scheme),
                await s.d(o.impl, o.extUri, o.extUri.dirname(r)),
                await s.c.queueFor(r, () =>
                  Promise.resolve(
                    o.impl.writeFile(r, a, { create: !0, overwrite: !0 }),
                  ),
                ))
              : await s.a.$writeFile(r, Q.wrap(a))
          } catch (o) {
            return qr.e(o)
          }
        },
        async delete(r, a) {
          try {
            const o = s.b.get(r.scheme)
            return o && !o.isReadonly && !a?.useTrash
              ? (await s.a.$ensureActivation(r.scheme),
                await o.impl.delete(r, { recursive: !1, ...a }))
              : await s.a.$delete(r, {
                  recursive: !1,
                  useTrash: !1,
                  atomic: !1,
                  ...a,
                })
          } catch (o) {
            return qr.e(o)
          }
        },
        async rename(r, a, o) {
          try {
            return await s.a.$rename(r, a, { overwrite: !1, ...o })
          } catch (c) {
            return qr.e(c)
          }
        },
        async copy(r, a, o) {
          try {
            return await s.a.$copy(r, a, { overwrite: !1, ...o })
          } catch (c) {
            return qr.e(c)
          }
        },
        isWritableFileSystem(r) {
          const a = e.getCapabilities(r)
          if (typeof a == "number") return !(a & 2048)
        },
      })
    }
    async d(t, e, s) {
      const r = []
      for (; !e.isEqual(s, e.dirname(s)); )
        try {
          if (!((await t.stat(s)).type & cs.Directory))
            throw ei.FileExists(
              `Unable to create folder '${s.scheme === G.file ? s.fsPath : s.toString(!0)}' that already exists but is not a directory`,
            )
          break
        } catch (a) {
          if (p6(a) !== dt.FileNotFound) throw a
          r.push(e.basename(s)), (s = e.dirname(s))
        }
      for (let a = r.length - 1; a >= 0; a--) {
        s = e.joinPath(s, r[a])
        try {
          await t.createDirectory(s)
        } catch (o) {
          if (p6(o) !== dt.FileExists) throw o
        }
      }
    }
    static e(t) {
      if (t instanceof ei) throw t
      if (t instanceof f6)
        switch (t.code) {
          case dt.FileExists:
            throw ei.FileExists(t.message)
          case dt.FileNotFound:
            throw ei.FileNotFound(t.message)
          case dt.FileNotADirectory:
            throw ei.FileNotADirectory(t.message)
          case dt.FileIsADirectory:
            throw ei.FileIsADirectory(t.message)
          case dt.NoPermissions:
            throw ei.NoPermissions(t.message)
          case dt.Unavailable:
            throw ei.Unavailable(t.message)
          default:
            throw new ei(t.message, t.name)
        }
      if (!(t instanceof Error)) throw new ei(String(t))
      if (t.name === "ENOPRO" || t.message.includes("ENOPRO"))
        throw ei.Unavailable(t.message)
      switch (t.name) {
        case dt.FileExists:
          throw ei.FileExists(t.message)
        case dt.FileNotFound:
          throw ei.FileNotFound(t.message)
        case dt.FileNotADirectory:
          throw ei.FileNotADirectory(t.message)
        case dt.FileIsADirectory:
          throw ei.FileIsADirectory(t.message)
        case dt.NoPermissions:
          throw ei.NoPermissions(t.message)
        case dt.Unavailable:
          throw ei.Unavailable(t.message)
        default:
          throw new ei(t.message, t.name)
      }
    }
    addFileSystemProvider(t, e, s) {
      return (
        this.b.set(t, {
          impl: e,
          extUri: s?.isCaseSensitive ? Xt : Imt,
          isReadonly: !!s?.isReadonly,
        }),
        et(() => this.b.delete(t))
      )
    }
    getFileSystemProviderExtUri(t) {
      return this.b.get(t)?.extUri ?? Xt
    }
  })
eH = qr = __decorate([__param(0, Ot), __param(1, Nc)], eH)
var im = X("IExtHostConsumerFileSystem"),
  iH = X("IExtensionStoragePaths"),
  sH = class {
    constructor(t, e, s) {
      ;(this.d = e),
        (this.f = s),
        (this.a = t.workspace ?? void 0),
        (this.b = t.environment),
        (this.whenReady = this.h().then((r) => (this.c = r)))
    }
    async g(t) {
      return S.joinPath(this.b.workspaceStorageHome, t)
    }
    async h() {
      if (!this.a) return Promise.resolve(void 0)
      const t = this.a.id,
        e = await this.g(t)
      try {
        return (
          await this.f.value.stat(e),
          this.d.trace("[ExtHostStorage] storage dir already exists", e),
          e
        )
      } catch {}
      try {
        return (
          this.d.trace("[ExtHostStorage] creating dir and metadata-file", e),
          await this.f.value.createDirectory(e),
          await this.f.value.writeFile(
            S.joinPath(e, "meta.json"),
            new TextEncoder().encode(
              JSON.stringify(
                {
                  id: this.a.id,
                  configuration: S.revive(this.a.configuration)?.toString(),
                  name: this.a.name,
                },
                void 0,
                2,
              ),
            ),
          ),
          e
        )
      } catch (s) {
        this.d.error("[ExtHostStorage]", s)
        return
      }
    }
    workspaceValue(t) {
      if (this.c) return S.joinPath(this.c, t.identifier.value)
    }
    globalValue(t) {
      return S.joinPath(
        this.b.globalStorageHome,
        t.identifier.value.toLowerCase(),
      )
    }
    onWillDeactivateAll() {}
  }
sH = __decorate([__param(0, ti), __param(1, Rt), __param(2, im)], sH)
var fPt = X("tunnelService"),
  SYt = X("sharedTunnelsService"),
  Fs
;(function (i) {
  ;(i.Http = "http"), (i.Https = "https")
})(Fs || (Fs = {}))
var Ur
;(function (i) {
  ;(i.ConstantPrivate = "constantPrivate"),
    (i.Private = "private"),
    (i.Public = "public")
})(Ur || (Ur = {}))
function pPt(i) {
  return !!i.forwardPort
}
var Pa
;(function (i) {
  ;(i[(i.Notify = 1)] = "Notify"),
    (i[(i.OpenBrowser = 2)] = "OpenBrowser"),
    (i[(i.OpenPreview = 3)] = "OpenPreview"),
    (i[(i.Silent = 4)] = "Silent"),
    (i[(i.Ignore = 5)] = "Ignore"),
    (i[(i.OpenBrowserOnce = 6)] = "OpenBrowserOnce")
})(Pa || (Pa = {}))
function gPt(i) {
  if (i.scheme !== "http" && i.scheme !== "https") return
  const t = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(i.authority)
  if (t) return { address: t[1], port: +t[2] }
}
var sm = ["localhost", "127.0.0.1", "0:0:0:0:0:0:0:1", "::1"]
function Ro(i) {
  return sm.indexOf(i) >= 0
}
var lB = ["0.0.0.0", "0:0:0:0:0:0:0:0", "::"]
function In(i) {
  return lB.indexOf(i) >= 0
}
function vPt(i, t, e, s) {
  if (e === 1) return !1
  if (e === 2 && In(t)) {
    const r = /(\d+)\.(\d+)\.(\d+)/g.exec(s)
    if (r?.length === 4 && parseInt(r[1]) >= 18) return !1
  }
  return i < 1024
}
var wPt = class {
    constructor(i, t, e) {
      ;(this.remoteAddress = i),
        (this.localAddress = t),
        (this.b = e),
        (this.a = new J()),
        (this.onDidDispose = this.a.event)
    }
    dispose() {
      return this.a.fire(), this.b()
    }
  },
  rH = class extends at {
    constructor(t, e) {
      super(),
        (this.q = t),
        (this.r = e),
        (this.a = new J()),
        (this.onTunnelOpened = this.a.event),
        (this.b = new J()),
        (this.onTunnelClosed = this.b.event),
        (this.c = new J()),
        (this.onAddedTunnelProvider = this.c.event),
        (this.f = new Map()),
        (this.h = !1),
        (this.j = !0),
        (this.m = []),
        (this.n = new Set())
    }
    get hasTunnelProvider() {
      return !!this.g
    }
    get s() {
      const t = this.r.getValue("remote.localPortHost")
      return !t || t === "localhost" ? "127.0.0.1" : "0.0.0.0"
    }
    setTunnelProvider(t) {
      return (
        (this.g = t),
        t
          ? (this.c.fire(),
            {
              dispose: () => {
                ;(this.g = void 0), (this.h = !1), (this.m = [])
              },
            })
          : ((this.h = !1), (this.m = []), this.c.fire(), { dispose: () => {} })
      )
    }
    setTunnelFeatures(t) {
      ;(this.h = t.elevation),
        (this.m = t.privacyOptions),
        (this.j = t.protocol)
    }
    get canChangeProtocol() {
      return this.j
    }
    get canElevate() {
      return this.h
    }
    get canChangePrivacy() {
      return this.m.length > 0
    }
    get privacyOptions() {
      return this.m
    }
    get tunnels() {
      return this.t()
    }
    async t() {
      const t = [],
        e = Array.from(this.f.values())
      for (const s of e) {
        const r = Array.from(s.values())
        for (const a of r) {
          const o = await a.value
          o && typeof o != "string" && t.push(o)
        }
      }
      return t
    }
    async dispose() {
      super.dispose()
      for (const t of this.f.values()) {
        for (const { value: e } of t.values())
          await e.then((s) => (typeof s != "string" ? s?.dispose() : void 0))
        t.clear()
      }
      this.f.clear()
    }
    setEnvironmentTunnel(t, e, s, r, a) {
      this.y(
        t,
        e,
        Promise.resolve({
          tunnelRemoteHost: t,
          tunnelRemotePort: e,
          localAddress: s,
          privacy: r,
          protocol: a,
          dispose: () => Promise.resolve(),
        }),
      )
    }
    async getExistingTunnel(t, e) {
      ;(In(t) || Ro(t)) && (t = sm[0])
      const s = this.C(t, e)
      if (s) return ++s.refcount, s.value
    }
    openTunnel(t, e, s, r, a, o = !1, c, l) {
      this.q.trace(
        `ForwardedPorts: (TunnelService) openTunnel request for ${e}:${s} on local port ${a}.`,
      )
      const u = this.g ?? t
      if (!u) return
      if (
        (e || (e = "localhost"), r || (r = this.s), this.g && this.n.has(s))
      ) {
        this.q.debug(
          "ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.",
        )
        return
      }
      const d = this.F(u, e, s, r, a, o, c, l)
      return d
        ? d.then((m) => {
            if (m) {
              if (typeof m == "string")
                return (
                  this.q.trace(
                    "ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.",
                  ),
                  this.z(e, s),
                  m
                )
            } else {
              this.q.trace(
                "ForwardedPorts: (TunnelService) New tunnel is undefined.",
              ),
                this.z(e, s)
              return
            }
            this.q.trace(
              "ForwardedPorts: (TunnelService) New tunnel established.",
            )
            const f = this.u(m)
            return (
              (m.tunnelRemoteHost !== e || m.tunnelRemotePort !== s) &&
                this.q.warn(
                  "ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.",
                ),
              c &&
                m.privacy !== c &&
                this.q.warn(
                  "ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.",
                ),
              this.a.fire(f),
              f
            )
          })
        : (this.q.trace(
            "ForwardedPorts: (TunnelService) Tunnel was not created.",
          ),
          d)
    }
    u(t) {
      return {
        tunnelRemotePort: t.tunnelRemotePort,
        tunnelRemoteHost: t.tunnelRemoteHost,
        tunnelLocalPort: t.tunnelLocalPort,
        localAddress: t.localAddress,
        privacy: t.privacy,
        protocol: t.protocol,
        dispose: async () => {
          this.q.trace(
            `ForwardedPorts: (TunnelService) dispose request for ${t.tunnelRemoteHost}:${t.tunnelRemotePort} `,
          )
          const e = this.f.get(t.tunnelRemoteHost)
          if (e) {
            const s = e.get(t.tunnelRemotePort)
            s &&
              (s.refcount--,
              await this.w(t.tunnelRemoteHost, t.tunnelRemotePort, s))
          }
        },
      }
    }
    async w(t, e, s) {
      if (s.refcount <= 0) {
        this.q.trace(
          `ForwardedPorts: (TunnelService) Tunnel is being disposed ${t}:${e}.`,
        )
        const r = s.value.then(async (a) => {
          a &&
            typeof a != "string" &&
            (await a.dispose(!0),
            this.b.fire({ host: a.tunnelRemoteHost, port: a.tunnelRemotePort }))
        })
        return this.f.has(t) && this.f.get(t).delete(e), r
      }
    }
    async closeTunnel(t, e) {
      this.q.trace(
        `ForwardedPorts: (TunnelService) close request for ${t}:${e} `,
      )
      const s = this.f.get(t)
      if (s && s.has(e)) {
        const r = s.get(e)
        ;(r.refcount = 0), await this.w(t, e, r)
      }
    }
    y(t, e, s) {
      this.f.has(t) || this.f.set(t, new Map()),
        this.f.get(t).set(e, { refcount: 1, value: s })
    }
    async z(t, e) {
      const s = this.f.get(t)
      if (s) {
        const r = s.get(e),
          a = r ? await r.value : void 0
        ;(!a || typeof a == "string") && s.delete(e),
          s.size === 0 && this.f.delete(t)
      }
    }
    C(t, e) {
      const s = [t]
      Ro(t) ? (s.push(...sm), s.push(...lB)) : In(t) && s.push(...lB)
      const r = s.map((a) => this.f.get(a))
      for (const a of r) {
        const o = a?.get(e)
        if (o) return o
      }
    }
    canTunnel(t) {
      return !!gPt(t)
    }
    G(t, e, s, r, a, o, c) {
      this.q.trace(
        `ForwardedPorts: (TunnelService) Creating tunnel with provider ${e}:${s} on local port ${r}.`,
      )
      const l = s
      this.n.add(l)
      const u = r === void 0 ? s : r,
        d = { elevationRequired: a ? this.isPortPrivileged(u) : !1 },
        m = {
          remoteAddress: { host: e, port: s },
          localAddressPort: r,
          privacy: o,
          public: o ? o !== Ur.Private : void 0,
          protocol: c,
        },
        f = t.forwardPort(m, d)
      return (
        f
          ? (this.y(e, s, f),
            f.finally(() => {
              this.q.trace(
                "ForwardedPorts: (TunnelService) Tunnel created by provider.",
              ),
                this.n.delete(l)
            }))
          : this.n.delete(l),
        f
      )
    }
  }
rH = __decorate([__param(0, Rt), __param(1, dn)], rH)
var yPt = class extends wPt {},
  nH
;(function (i) {
  function t(s) {
    return {
      remoteAddress: s.remoteAddress,
      localAddress: s.localAddress,
      public: !!s.public,
      privacy: s.privacy ?? (s.public ? Ur.Public : Ur.Private),
      protocol: s.protocol,
    }
  }
  i.fromApiTunnel = t
  function e(s) {
    return {
      remoteAddress: { host: s.tunnelRemoteHost, port: s.tunnelRemotePort },
      localAddress: s.localAddress,
      public:
        s.privacy !== Ur.ConstantPrivate && s.privacy !== Ur.ConstantPrivate,
      privacy: s.privacy,
      protocol: s.protocol,
    }
  }
  i.fromServiceTunnel = e
})(nH || (nH = {}))
var uB = X("IExtHostTunnelService"),
  hB = class extends at {
    constructor(t, e, s) {
      super(),
        (this.r = s),
        (this.f = () => Promise.resolve(!0)),
        (this.g = new Map()),
        (this.h = new J()),
        (this.onDidChangeTunnels = this.h.event),
        (this.n = 0),
        (this.q = new Map()),
        (this.a = t.getProxy(K.MainThreadTunnelService))
    }
    async openTunnel(t, e) {
      this.r.trace(
        `ForwardedPorts: (ExtHostTunnelService) ${t.identifier.value} called openTunnel API for ${e.remoteAddress.host}:${e.remoteAddress.port}.`,
      )
      const s = await this.a.$openTunnel(e, t.displayName)
      if (s) {
        const r = new yPt(s.remoteAddress, s.localAddress, () =>
          this.a.$closeTunnel(s.remoteAddress),
        )
        return this.D(r), r
      }
    }
    async getTunnels() {
      return this.a.$getTunnels()
    }
    s() {
      return this.n++
    }
    registerPortsAttributesProvider(t, e) {
      t.portRange === void 0 &&
        t.commandPattern === void 0 &&
        this.r.error(
          "PortAttributesProvider must specify either a portRange or a commandPattern",
        )
      const s = this.s()
      return (
        this.q.set(s, { selector: t, provider: e }),
        this.a.$registerPortsAttributesProvider(t, s),
        new Ht(() => {
          this.q.delete(s), this.a.$unregisterPortsAttributesProvider(s)
        })
      )
    }
    async $providePortAttributes(t, e, s, r, a) {
      const o = []
      for (const l of t) {
        const u = this.q.get(l)
        if (!u) return []
        o.push(
          ...(await Promise.all(
            e.map(async (d) => {
              let m
              try {
                m = await u.provider.providePortAttributes(
                  { port: d, pid: s, commandLine: r },
                  a,
                )
              } catch {
                m = await u.provider.providePortAttributes(d, s, r, a)
              }
              return { providedAttributes: m, port: d }
            }),
          )),
        )
      }
      const c = o.filter((l) => !!l.providedAttributes)
      return c.length > 0
        ? c.map((l) => ({
            autoForwardAction: l.providedAttributes.autoForwardAction,
            port: l.port,
          }))
        : []
    }
    async $registerCandidateFinder(t) {}
    registerTunnelProvider(t, e) {
      if (this.b)
        throw new Error(
          "A tunnel provider has already been registered. Only the first tunnel provider to be registered will be used.",
        )
      this.b = async (r, a) => (await t.provideTunnel(r, a, ce.None)) ?? void 0
      const s = e.tunnelFeatures
        ? {
            elevation: !!e.tunnelFeatures?.elevation,
            privacyOptions: e.tunnelFeatures?.privacyOptions,
            protocol:
              e.tunnelFeatures.protocol === void 0
                ? !0
                : e.tunnelFeatures.protocol,
          }
        : void 0
      return (
        this.a.$setTunnelProvider(s, !0),
        Promise.resolve(
          et(() => {
            ;(this.b = void 0), this.a.$setTunnelProvider(void 0, !1)
          }),
        )
      )
    }
    async setTunnelFactory(t, e) {
      if (t) {
        t.candidatePortSource !== void 0 &&
          this.a.$setCandidatePortSource(t.candidatePortSource),
          t.showCandidatePort &&
            ((this.f = t.showCandidatePort), this.a.$setCandidateFilter())
        const s = t.tunnelFactory ?? (e ? this.u(e) : void 0)
        if (s) {
          this.b = s
          let r = t.tunnelFeatures?.privacyOptions ?? []
          t.tunnelFeatures?.public &&
            r.length === 0 &&
            (r = [
              { id: "private", label: g(2773, null), themeIcon: "lock" },
              { id: "public", label: g(2774, null), themeIcon: "eye" },
            ])
          const a = t.tunnelFeatures
            ? {
                elevation: !!t.tunnelFeatures?.elevation,
                public: !!t.tunnelFeatures?.public,
                privacyOptions: r,
                protocol: !0,
              }
            : void 0
          this.a.$setTunnelProvider(a, !!t.tunnelFactory)
        }
      } else this.b = void 0
      return et(() => {
        this.b = void 0
      })
    }
    u(t) {}
    async $closeTunnel(t, e) {
      if (this.g.has(t.host)) {
        const s = this.g.get(t.host)
        s.has(t.port) &&
          (e && s.get(t.port).disposeListener.dispose(),
          await s.get(t.port).tunnel.dispose(),
          s.delete(t.port))
      }
    }
    async $onDidTunnelsChange() {
      this.h.fire()
    }
    async $forwardPort(t, e) {
      if (this.b)
        try {
          this.r.trace(
            "ForwardedPorts: (ExtHostTunnelService) Getting tunnel from provider.",
          )
          const s = this.b(t, e)
          if (
            (this.r.trace(
              "ForwardedPorts: (ExtHostTunnelService) Got tunnel promise from provider.",
            ),
            s !== void 0)
          ) {
            const r = await s
            if (
              (this.r.trace(
                "ForwardedPorts: (ExtHostTunnelService) Successfully awaited tunnel from provider.",
              ),
              r === void 0)
            ) {
              this.r.error(
                "ForwardedPorts: (ExtHostTunnelService) Resolved tunnel is undefined",
              )
              return
            }
            this.g.has(t.remoteAddress.host) ||
              this.g.set(t.remoteAddress.host, new Map())
            const a = this.D(
              r.onDidDispose(
                () => (
                  this.r.trace(
                    "ForwardedPorts: (ExtHostTunnelService) Extension fired tunnel's onDidDispose.",
                  ),
                  this.a.$closeTunnel(r.remoteAddress)
                ),
              ),
            )
            return (
              this.g
                .get(t.remoteAddress.host)
                .set(t.remoteAddress.port, { tunnel: r, disposeListener: a }),
              nH.fromApiTunnel(r)
            )
          } else
            this.r.trace(
              "ForwardedPorts: (ExtHostTunnelService) Tunnel is undefined",
            )
        } catch (s) {
          if (
            (this.r.trace(
              "ForwardedPorts: (ExtHostTunnelService) tunnel provider error",
            ),
            s instanceof Error)
          )
            return s.message
        }
    }
    async $applyCandidateFilter(t) {
      const e = await Promise.all(
          t.map((r) => this.f(r.host, r.port, r.detail ?? "")),
        ),
        s = t.filter((r, a) => e[a])
      return (
        this.r.trace(
          `ForwardedPorts: (ExtHostTunnelService) filtered from ${t.map((r) => r.port).join(", ")} to ${s.map((r) => r.port).join(", ")}`,
        ),
        s
      )
    }
  }
hB = __decorate([__param(0, Ot), __param(1, ti), __param(2, Rt)], hB)
function bPt(i) {
  return [...i.entries()]
}
function TPt(i) {
  return i ? [...i.entries()] : []
}
var kPt = class {
    constructor(i) {
      ;(this.b = i), (this.a = new Map())
    }
    dispose() {
      for (const i of this.a.values()) i.dispose()
    }
    startBuffering(i, t, e = 5) {
      const s = t((r) => {
        const a = typeof r == "string" ? r : r.data
        let o = this.a.get(i)
        if (o) {
          o.data.push(a)
          return
        }
        const c = setTimeout(() => this.flushBuffer(i), e)
        ;(o = {
          data: [a],
          timeoutId: c,
          dispose: () => {
            clearTimeout(c), this.flushBuffer(i), s.dispose()
          },
        }),
          this.a.set(i, o)
      })
      return s
    }
    stopBuffering(i) {
      this.a.get(i)?.dispose()
    }
    flushBuffer(i) {
      const t = this.a.get(i)
      t && (this.a.delete(i), this.b(i, t.data.join("")))
    }
  },
  Do = (i, t, e, s) => {
    let r = t
    return {
      enumerable: !0,
      configurable: !1,
      get() {
        return r
      },
      set(a) {
        if (!e(r, a)) {
          const o = r
          ;(r = a), i.listener?.(s(a, o))
        }
      },
    }
  },
  Fl = (i, t) => i === t,
  $a = {
    range: (i, t) => (i === t ? !0 : !i || !t ? !1 : i.isEqual(t)),
    label: Fl,
    description: Fl,
    sortText: Fl,
    busy: Fl,
    error: Fl,
    canResolveChildren: Fl,
    tags: (i, t) =>
      !(i.length !== t.length || i.some((e) => !t.find((s) => e.id === s.id))),
  },
  Al = (i) => (t) => ({ op: 4, update: i(t) }),
  SPt = (i, t) => ({
    range: (() => {
      let e
      const s = Al((r) => ({ range: ue.lift(U.from(r)) }))
      return {
        enumerable: !0,
        configurable: !1,
        get() {
          return e
        },
        set(r) {
          i.listener?.({ op: 6 }),
            $a.range(e, r) || ((e = r), i.listener?.(s(r)))
        },
      }
    })(),
    label: Do(
      i,
      t,
      $a.label,
      Al((e) => ({ label: e })),
    ),
    description: Do(
      i,
      void 0,
      $a.description,
      Al((e) => ({ description: e })),
    ),
    sortText: Do(
      i,
      void 0,
      $a.sortText,
      Al((e) => ({ sortText: e })),
    ),
    canResolveChildren: Do(i, !1, $a.canResolveChildren, (e) => ({
      op: 2,
      state: e,
    })),
    busy: Do(
      i,
      !1,
      $a.busy,
      Al((e) => ({ busy: e })),
    ),
    error: Do(
      i,
      void 0,
      $a.error,
      Al((e) => ({ error: Dt.fromStrict(e) || null })),
    ),
    tags: Do(i, [], $a.tags, (e, s) => ({
      op: 1,
      new: e.map(cr.from),
      old: s.map(cr.from),
    })),
  }),
  EPt = (i) => {
    const t = jt.fromString(i.extId),
      e = new rm(t.controllerId, t.localId, i.label, S.revive(i.uri) || void 0)
    return (
      (e.range = U.to(i.range || void 0)),
      (e.description = i.description || void 0),
      (e.sortText = i.sortText || void 0),
      (e.tags = i.tags.map((s) => cr.to({ id: AZ(s).tagId }))),
      e
    )
  },
  $it = (i) => {
    let t
    for (const e of i.tests) {
      const s = EPt(e.item)
      ;(j6(s).parent = t), (t = s)
    }
    return t
  },
  rm = class cut {
    constructor(t, e, s, r) {
      if (e.includes("\0"))
        throw new Error(
          `Test IDs may not include the ${JSON.stringify(e)} symbol`,
        )
      const a = iTt(this, t)
      Object.defineProperties(this, {
        id: { value: e, enumerable: !0, writable: !1 },
        uri: { value: r, enumerable: !0, writable: !1 },
        parent: {
          enumerable: !1,
          get() {
            return a.parent instanceof aH ? void 0 : a.parent
          },
        },
        children: { value: eTt(a, j6, cut), enumerable: !0, writable: !1 },
        ...SPt(a, s),
      })
    }
  },
  aH = class extends rm {
    constructor(i, t) {
      super(i, i, t, void 0), (this._isRoot = !0)
    }
  },
  IPt = class extends Kbt {
    constructor(i, t, e) {
      super({
        controllerId: i,
        getDocumentVersion: (s) => s && e.getDocument(s)?.version,
        getApiFor: j6,
        getChildren: (s) => s.children,
        root: new aH(i, t),
        toITestItem: fa.from,
      })
    }
  },
  nm
;(function (i) {
  ;(i[(i.Desktop = 1)] = "Desktop"), (i[(i.Web = 2)] = "Web")
})(nm || (nm = {}))
var xit
;(function (i) {
  ;(i[(i.VersionMismatch = 55)] = "VersionMismatch"),
    (i[(i.UnexpectedError = 81)] = "UnexpectedError")
})(xit || (xit = {}))
var Nit
;(function (i) {
  ;(i[(i.Initialized = 0)] = "Initialized"),
    (i[(i.Ready = 1)] = "Ready"),
    (i[(i.Terminate = 2)] = "Terminate")
})(Nit || (Nit = {}))
function Cit(i) {
  const t = Q.alloc(1)
  switch (i) {
    case 0:
      t.writeUInt8(1, 0)
      break
    case 1:
      t.writeUInt8(2, 0)
      break
    case 2:
      t.writeUInt8(3, 0)
      break
  }
  return t
}
function PPt(i, t) {
  if (i.byteLength !== 1) return !1
  switch (i.readUInt8(0)) {
    case 1:
      return t === 0
    case 2:
      return t === 1
    case 3:
      return t === 2
    default:
      return !1
  }
}
var Jit
;(function (i) {
  ;(i.Start = "START_NATIVE_LOG"), (i.End = "END_NATIVE_LOG")
})(Jit || (Jit = {}))
var oH = class extends at {
  constructor(t, e) {
    super(),
      (this.r = t),
      (this.s = e),
      (this.a = this.D(new J())),
      (this.onDidChangeTelemetryEnabled = this.a.event),
      (this.b = this.D(new J())),
      (this.onDidChangeTelemetryConfiguration = this.b.event),
      (this.c = { usage: !0, error: !0 }),
      (this.f = 0),
      (this.g = !1),
      (this.j = !1),
      (this.q = new Map()),
      (this.m = S.revive(this.r.environment.extensionTelemetryLogResource)),
      (this.j = this.r.environment.isExtensionTelemetryLoggingOnly),
      (this.n = e.createLogger(this.m, {
        id: iPt,
        name: g(2770, null, this.j ? " (Not Sent)" : ""),
        hidden: !0,
      })),
      this.D(this.n),
      this.D(
        e.onDidChangeLogLevel((s) => {
          Jwt(s) && this.t()
        }),
      ),
      this.n.info(
        "Below are logs for extension telemetry events sent to the telemetry output channel API once the log level is set to trace.",
      ),
      this.n.info("===========================================================")
  }
  t() {
    this.s.setVisibility(this.m, this.g && this.s.getLogLevel() === vt.Trace)
  }
  getTelemetryConfiguration() {
    return this.f === 3
  }
  getTelemetryDetails() {
    return {
      isCrashEnabled: this.f >= 1,
      isErrorsEnabled: this.c.error ? this.f >= 2 : !1,
      isUsageEnabled: this.c.usage ? this.f >= 3 : !1,
    }
  }
  instantiateLogger(t, e, s) {
    const r = this.getTelemetryDetails(),
      a = new Lit(e, s, t, this.n, this.j, this.getBuiltInCommonProperties(t), {
        isUsageEnabled: r.isUsageEnabled,
        isErrorsEnabled: r.isErrorsEnabled,
      }),
      o = this.q.get(t.identifier.value) ?? []
    return this.q.set(t.identifier.value, [...o, a]), a.apiTelemetryLogger
  }
  $initializeTelemetryLevel(t, e, s) {
    ;(this.f = t),
      (this.g = e),
      (this.c = s ?? { usage: !0, error: !0 }),
      this.t()
  }
  getBuiltInCommonProperties(t) {
    const e = Object.create(null)
    switch (
      ((e["common.extname"] = `${t.publisher}.${t.name}`),
      (e["common.extversion"] = t.version),
      (e["common.vscodemachineid"] = this.r.telemetryInfo.machineId),
      (e["common.vscodesessionid"] = this.r.telemetryInfo.sessionId),
      (e["common.macMachineId"] = this.r.telemetryInfo.macMachineId),
      (e["common.sqmid"] = this.r.telemetryInfo.sqmId),
      (e["common.devDeviceId"] = this.r.telemetryInfo.devDeviceId),
      (e["common.vscodeversion"] = this.r.version),
      (e["common.isnewappinstall"] = Rit(
        this.r.telemetryInfo.firstSessionDate,
      )),
      (e["common.product"] = this.r.environment.appHost),
      this.r.uiKind)
    ) {
      case nm.Web:
        e["common.uikind"] = "web"
        break
      case nm.Desktop:
        e["common.uikind"] = "desktop"
        break
      default:
        e["common.uikind"] = "unknown"
    }
    return (e["common.remotename"] = m2(rPt(this.r.remote.authority))), e
  }
  $onDidChangeTelemetryLevel(t) {
    ;(this.h = this.getTelemetryConfiguration()), (this.f = t)
    const e = this.getTelemetryDetails()
    this.q.forEach((s, r) => {
      const a = s.filter((o) => !o.isDisposed)
      a.length === 0 ? this.q.delete(r) : this.q.set(r, a)
    }),
      this.q.forEach((s) => {
        for (const r of s)
          r.updateTelemetryEnablements(e.isUsageEnabled, e.isErrorsEnabled)
      }),
      this.h !== this.getTelemetryConfiguration() &&
        this.a.fire(this.getTelemetryConfiguration()),
      this.b.fire(this.getTelemetryDetails()),
      this.t()
  }
  onExtensionError(t, e) {
    const r = this.q.get(t.value)?.filter((o) => !o.isDisposed)
    if (!r) return this.q.delete(t.value), !1
    let a = !1
    for (const o of r)
      o.ignoreUnhandledExtHostErrors || (o.logError(e), (a = !0))
    return a
  }
}
oH = __decorate([__param(0, ti), __param(1, $c)], oH)
var Lit = class {
  static validateSender(i) {
    if (typeof i != "object")
      throw new TypeError("TelemetrySender argument is invalid")
    if (typeof i.sendEventData != "function")
      throw new TypeError("TelemetrySender.sendEventData must be a function")
    if (typeof i.sendErrorData != "function")
      throw new TypeError("TelemetrySender.sendErrorData must be a function")
    if (typeof i.flush < "u" && typeof i.flush != "function")
      throw new TypeError(
        "TelemetrySender.flush must be a function or undefined",
      )
  }
  constructor(i, t, e, s, r, a, o) {
    ;(this.g = e),
      (this.h = s),
      (this.i = r),
      (this.j = a),
      (this.a = new J()),
      (this.ignoreUnhandledExtHostErrors = t?.ignoreUnhandledErrors ?? !1),
      (this.b = t?.ignoreBuiltInCommonProperties ?? !1),
      (this.c = t?.additionalCommonProperties),
      (this.f = i),
      (this.d = {
        isUsageEnabled: o.isUsageEnabled,
        isErrorsEnabled: o.isErrorsEnabled,
      })
  }
  updateTelemetryEnablements(i, t) {
    this.e &&
      ((this.d = { isUsageEnabled: i, isErrorsEnabled: t }),
      this.a.fire(this.e))
  }
  mixInCommonPropsAndCleanData(i) {
    let t = "properties" in i ? (i.properties ?? {}) : i
    return (
      (t = bit(t, [])),
      this.c && (t = en(t, this.c)),
      this.b || (t = en(t, this.j)),
      "properties" in i ? (i.properties = t) : (i = t),
      i
    )
  }
  k(i, t) {
    this.f &&
      (this.g.publisher === "vscode"
        ? (i = this.g.name + "/" + i)
        : (i = this.g.identifier.value + "/" + i),
      (t = this.mixInCommonPropsAndCleanData(t || {})),
      this.i || this.f?.sendEventData(i, t),
      this.h.trace(i, t))
  }
  logUsage(i, t) {
    this.d.isUsageEnabled && this.k(i, t)
  }
  logError(i, t) {
    if (!(!this.d.isErrorsEnabled || !this.f))
      if (typeof i == "string") this.k(i, t)
      else {
        const e = {
            name: i.name,
            message: i.message,
            stack: i.stack,
            cause: i.cause,
          },
          s = bit(e, []),
          r = new Error(s.message, { cause: s.cause })
        ;(r.stack = s.stack),
          (r.name = s.name),
          (t = this.mixInCommonPropsAndCleanData(t || {})),
          this.i || this.f.sendErrorData(r, t),
          this.h.trace("exception", t)
      }
  }
  get apiTelemetryLogger() {
    if (!this.e) {
      const i = this,
        t = {
          logUsage: i.logUsage.bind(i),
          get isUsageEnabled() {
            return i.d.isUsageEnabled
          },
          get isErrorsEnabled() {
            return i.d.isErrorsEnabled
          },
          logError: i.logError.bind(i),
          dispose: i.dispose.bind(i),
          onDidChangeEnableStates: i.a.event.bind(i),
        }
      this.e = Object.freeze(t)
    }
    return this.e
  }
  get isDisposed() {
    return !this.f
  }
  dispose() {
    if (this.f?.flush) {
      let i = this.f
      ;(this.f = void 0),
        Promise.resolve(i.flush()).then((i = void 0)),
        (this.e = void 0)
    } else this.f = void 0
  }
}
function Rit(i) {
  const t = Date.now() - new Date(i).getTime()
  return isNaN(t) ? !1 : t < 1e3 * 60 * 60 * 24
}
var dB = X("IExtHostTelemetry"),
  cH = class {
    #t
    #e
    #i
    constructor(t, e, s) {
      ;(this.b = new Map()),
        (this.c = new Map()),
        (this.#t = t.getProxy(K.MainThreadCommands)),
        (this.d = e),
        (this.#i = s),
        (this.#e = t.getProxy(K.MainThreadTelemetry)),
        (this.converter = new $Pt(
          this,
          (r) => {
            const a = this.c.get(r)
            return a?.result === yt.Void ? a : void 0
          },
          e,
        )),
        (this.f = [
          {
            processArgument(r) {
              return ki(r)
            },
          },
          {
            processArgument(r) {
              return Sc(r, function (a) {
                if (ue.isIRange(a)) return U.to(a)
                if (ws.isIPosition(a)) return Kt.to(a)
                if (ue.isIRange(a.range) && S.isUri(a.uri)) return Qi.to(a)
                if (a instanceof Q) return a.buffer.buffer
                if (!Array.isArray(a)) return a
              })
            },
          },
        ])
    }
    registerArgumentProcessor(t) {
      this.f.push(t)
    }
    registerApiCommand(t) {
      const e = this.registerCommand(
        !1,
        t.id,
        async (...s) => {
          const r = t.args.map((o, c) => {
              if (!o.validate(s[c]))
                throw new Error(
                  `Invalid argument '${o.name}' when running '${t.id}', received: ${typeof s[c] == "object" ? JSON.stringify(s[c], null, "	") : s[c]} `,
                )
              return o.convert(s[c])
            }),
            a = await this.executeCommand(t.internalId, ...r)
          return t.result.convert(a, s, this.converter)
        },
        void 0,
        {
          description: t.description,
          args: t.args,
          returns: t.result.description,
        },
      )
      return (
        this.c.set(t.id, t),
        new Ht(() => {
          e.dispose(), this.c.delete(t.id)
        })
      )
    }
    registerCommand(t, e, s, r, a, o) {
      if (
        (this.d.trace("ExtHostCommands#registerCommand", e), !e.trim().length)
      )
        throw new Error("invalid id")
      if (this.b.has(e)) throw new Error(`command '${e}' already exists`)
      return (
        this.b.set(e, { callback: s, thisArg: r, metadata: a, extension: o }),
        t && this.#t.$registerCommand(e),
        new Ht(() => {
          this.b.delete(e) && t && this.#t.$unregisterCommand(e)
        })
      )
    }
    executeCommand(t, ...e) {
      return this.d.trace("ExtHostCommands#executeCommand", t), this.g(t, e, !0)
    }
    async g(t, e, s) {
      if (this.b.has(t))
        return this.#t.$fireCommandActivationEvent(t), this.h(t, e, !1)
      {
        let r = !1
        const a = Sc(e, function (o) {
          if (o instanceof Ft) return Kt.from(o)
          if (o instanceof Nt) return U.from(o)
          if (o instanceof ys) return Qi.from(o)
          if (gn.isNotebookRange(o)) return Or.from(o)
          if (o instanceof ArrayBuffer)
            return (r = !0), Q.wrap(new Uint8Array(o))
          if (o instanceof Uint8Array) return (r = !0), Q.wrap(o)
          if (o instanceof Q) return (r = !0), o
          if (!Array.isArray(o)) return o
        })
        try {
          const o = await this.#t.$executeCommand(t, r ? new gs(a) : a, s)
          return ki(o)
        } catch (o) {
          if (o instanceof Error && o.message === "$executeCommand:retry")
            return this.g(t, e, !1)
          throw o
        }
      }
    }
    async h(t, e, s) {
      const r = this.b.get(t)
      if (!r) throw new Error("Unknown command")
      const { callback: a, thisArg: o, metadata: c } = r
      if (c?.args)
        for (let u = 0; u < c.args.length; u++)
          try {
            imt(e[u], c.args[u].constraint)
          } catch {
            throw new Error(
              `Running the contributed command: '${t}' failed. Illegal argument '${c.args[u].name}' - ${c.args[u].description}`,
            )
          }
      const l = ss.create()
      try {
        return await a.apply(o, e)
      } catch (u) {
        if (t === this.converter.delegatingCommandId) {
          const d = this.converter.getActualCommand(...e)
          d && (t = d.command)
        }
        if ((this.d.error(u, t, r.extension?.identifier), !s)) throw u
        if (r.extension?.identifier) {
          const d = this.#i.onExtensionError(r.extension.identifier, u)
          this.d.trace(
            "forwarded error to extension?",
            d,
            r.extension?.identifier,
          )
        }
        throw new (class extends Error {
          constructor() {
            super(Zs(u)),
              (this.id = t),
              (this.source = r.extension?.displayName ?? r.extension?.name)
          }
        })()
      } finally {
        this.j(r, t, l.elapsed())
      }
    }
    j(t, e, s) {
      t.extension &&
        this.#e.$publicLog2("Extension:ActionExecuted", {
          extensionId: t.extension.identifier.value,
          id: new XM(e),
          duration: s,
        })
    }
    $executeContributedCommand(t, ...e) {
      this.d.trace("ExtHostCommands#$executeContributedCommand", t)
      const s = this.b.get(t)
      return s
        ? ((e = e.map((r) =>
            this.f.reduce(
              (a, o) => o.processArgument(a, s.extension?.identifier),
              r,
            ),
          )),
          this.h(t, e, !0))
        : Promise.reject(
            new Error(`Contributed command '${t}' does not exist.`),
          )
    }
    getCommands(t = !1) {
      return (
        this.d.trace("ExtHostCommands#getCommands", t),
        this.#t
          .$getCommands()
          .then((e) => (t && (e = e.filter((s) => s[0] !== "_")), e))
      )
    }
    $getContributedCommandMetadata() {
      const t = Object.create(null)
      for (const [e, s] of this.b) {
        const { metadata: r } = s
        r && (t[e] = r)
      }
      return Promise.resolve(t)
    }
  }
cH = __decorate([__param(0, Ot), __param(1, Rt), __param(2, dB)], cH)
var mr = X("IExtHostCommands"),
  $Pt = class {
    constructor(i, t, e) {
      ;(this.d = i),
        (this.f = t),
        (this.g = e),
        (this.delegatingCommandId = `__vsc${Ze()}`),
        (this.b = new Map()),
        (this.c = 0),
        this.d.registerCommand(!0, this.delegatingCommandId, this.h, this)
    }
    toInternal(i, t) {
      if (!i) return
      const e = {
        $ident: void 0,
        id: i.command,
        title: i.title,
        tooltip: i.tooltip,
      }
      if (!i.command) return e
      const s = this.f(i.command)
      if (s)
        (e.id = s.internalId),
          (e.arguments = s.args.map((r, a) =>
            r.convert(i.arguments && i.arguments[a]),
          ))
      else if (Cu(i.arguments)) {
        const r = `${i.command} /${++this.c}`
        this.b.set(r, i),
          t.add(
            et(() => {
              this.b.delete(r), this.g.trace("CommandsConverter#DISPOSE", r)
            }),
          ),
          (e.$ident = r),
          (e.id = this.delegatingCommandId),
          (e.arguments = [r]),
          this.g.trace("CommandsConverter#CREATE", i.command, r)
      }
      return e
    }
    fromInternal(i) {
      return typeof i.$ident == "string"
        ? this.b.get(i.$ident)
        : { command: i.id, title: i.title, arguments: i.arguments }
    }
    getActualCommand(...i) {
      return this.b.get(i[0])
    }
    h(...i) {
      const t = this.getActualCommand(...i)
      return (
        this.g.trace(
          "CommandsConverter#EXECUTE",
          i[0],
          t ? t.command : "MISSING",
        ),
        t
          ? this.d.executeCommand(t.command, ...(t.arguments || []))
          : Promise.reject(
              `Actual command not found, wanted to execute ${i[0]}`,
            )
      )
    }
  },
  H = class Bi {
    static {
      this.Uri = new Bi(
        "uri",
        "Uri of a text document",
        (t) => S.isUri(t),
        (t) => t,
      )
    }
    static {
      this.Position = new Bi(
        "position",
        "A position in a text document",
        (t) => Ft.isPosition(t),
        Kt.from,
      )
    }
    static {
      this.Range = new Bi(
        "range",
        "A range in a text document",
        (t) => Nt.isRange(t),
        U.from,
      )
    }
    static {
      this.Selection = new Bi(
        "selection",
        "A selection in a text document",
        (t) => fn.isSelection(t),
        or.from,
      )
    }
    static {
      this.Number = new Bi(
        "number",
        "",
        (t) => typeof t == "number",
        (t) => t,
      )
    }
    static {
      this.String = new Bi(
        "string",
        "",
        (t) => typeof t == "string",
        (t) => t,
      )
    }
    static {
      this.StringArray = Bi.Arr(Bi.String)
    }
    static Arr(t) {
      return new Bi(
        `${t.name}_array`,
        `Array of ${t.name}, ${t.description}`,
        (e) => Array.isArray(e) && e.every((s) => t.validate(s)),
        (e) => e.map((s) => t.convert(s)),
      )
    }
    static {
      this.CallHierarchyItem = new Bi(
        "item",
        "A call hierarchy item",
        (t) => t instanceof _2,
        $o.from,
      )
    }
    static {
      this.TypeHierarchyItem = new Bi(
        "item",
        "A type hierarchy item",
        (t) => t instanceof gU,
        No.from,
      )
    }
    static {
      this.TestItem = new Bi(
        "testItem",
        "A VS Code TestItem",
        (t) => t instanceof rm,
        fa.from,
      )
    }
    static {
      this.TestProfile = new Bi(
        "testProfile",
        "A VS Code test profile",
        (t) => t instanceof gtt,
        ZU.from,
      )
    }
    constructor(t, e, s, r) {
      ;(this.name = t),
        (this.description = e),
        (this.validate = s),
        (this.convert = r)
    }
    optional() {
      return new Bi(
        this.name,
        `(optional) ${this.description}`,
        (t) => t == null || this.validate(t),
        (t) => (t === void 0 ? void 0 : t === null ? null : this.convert(t)),
      )
    }
    with(t, e) {
      return new Bi(
        t ?? this.name,
        e ?? this.description,
        this.validate,
        this.convert,
      )
    }
  },
  yt = class lut {
    static {
      this.Void = new lut("no result", (t) => t)
    }
    constructor(t, e) {
      ;(this.description = t), (this.convert = e)
    }
  },
  Tt = class {
    constructor(i, t, e, s, r) {
      ;(this.id = i),
        (this.internalId = t),
        (this.description = e),
        (this.args = s),
        (this.result = r)
    }
  },
  Pn = X("IExtHostTerminalService"),
  lH = class extends at {
    constructor(i, t, e, s) {
      super(),
        (this.s = i),
        (this._id = t),
        (this.u = e),
        (this.w = s),
        (this.a = !1),
        (this.m = { isInteractedWith: !1 }),
        (this.isOpen = !1),
        (this.q = this.D(new J())),
        (this.onWillDispose = this.q.event),
        (this.u = Object.freeze(this.u)),
        (this.b = new Promise((a) => (this.g = a)))
      const r = this
      this.value = {
        get name() {
          return r.w || ""
        },
        get processId() {
          return r.b
        },
        get creationOptions() {
          return r.u
        },
        get exitStatus() {
          return r.j
        },
        get state() {
          return r.m
        },
        get selection() {
          return r.n
        },
        get shellIntegration() {
          return r.shellIntegration
        },
        sendText(a, o = !0) {
          r.z(), r.s.$sendText(r._id, a, o)
        },
        show(a) {
          r.z(), r.s.$show(r._id, a)
        },
        hide() {
          r.z(), r.s.$hide(r._id)
        },
        dispose() {
          r.a || ((r.a = !0), r.s.$dispose(r._id))
        },
        get dimensions() {
          if (!(r.f === void 0 || r.h === void 0))
            return { columns: r.f, rows: r.h }
        },
      }
    }
    dispose() {
      this.q.fire(), super.dispose()
    }
    async create(i, t) {
      if (typeof this._id != "string")
        throw new Error("Terminal has already been created")
      await this.s.$createTerminal(this._id, {
        name: i.name,
        shellPath: i.shellPath ?? void 0,
        shellArgs: i.shellArgs ?? void 0,
        cwd: i.cwd ?? t?.cwd ?? void 0,
        env: i.env ?? void 0,
        icon: Fit(i.iconPath) ?? void 0,
        color: Cc.isThemeColor(i.color) ? i.color.id : void 0,
        initialText: i.message ?? void 0,
        strictEnv: i.strictEnv ?? void 0,
        hideFromUser: i.hideFromUser ?? void 0,
        forceShellIntegration: t?.forceShellIntegration ?? void 0,
        isFeatureTerminal: t?.isFeatureTerminal ?? void 0,
        isExtensionOwnedTerminal: !0,
        useShellEnvironment: t?.useShellEnvironment ?? void 0,
        location:
          t?.location || this.y(i.location, t?.resolvedExtHostIdentifier),
        isTransient: i.isTransient ?? void 0,
      })
    }
    async createExtensionTerminal(i, t, e, s, r) {
      if (typeof this._id != "string")
        throw new Error("Terminal has already been created")
      if (
        (await this.s.$createTerminal(this._id, {
          name: this.w,
          isExtensionCustomPtyTerminal: !0,
          icon: s,
          color: Cc.isThemeColor(r) ? r.id : void 0,
          location: t?.location || this.y(i, e),
          isTransient: !0,
        }),
        typeof this._id == "string")
      )
        throw new Error("Terminal creation failed")
      return this._id
    }
    y(i, t) {
      return typeof i == "object"
        ? "parentTerminal" in i && i.parentTerminal && t
          ? { parentTerminal: t }
          : "viewColumn" in i
            ? {
                viewColumn: ii.from(i.viewColumn),
                preserveFocus: i.preserveFocus,
              }
            : void 0
        : i
    }
    z() {
      if (this.a) throw new Error("Terminal has already been disposed")
    }
    set name(i) {
      this.w = i
    }
    setExitStatus(i, t) {
      this.j = Object.freeze({ code: i, reason: t })
    }
    setDimensions(i, t) {
      return (i === this.f && t === this.h) || i === 0 || t === 0
        ? !1
        : ((this.f = i), (this.h = t), !0)
    }
    setInteractedWith() {
      return this.m.isInteractedWith
        ? !1
        : ((this.m = { isInteractedWith: !0 }), !0)
    }
    setSelection(i) {
      this.n = i
    }
    _setProcessId(i) {
      this.g
        ? (this.g(i), (this.g = void 0))
        : this.b.then((t) => {
            t !== i && (this.b = Promise.resolve(i))
          })
    }
  },
  uH = class {
    get onProcessReady() {
      return this.b.event
    }
    constructor(i) {
      ;(this.g = i),
        (this.id = 0),
        (this.shouldPersist = !1),
        (this.a = new J()),
        (this.onProcessData = this.a.event),
        (this.b = new J()),
        (this.d = new J()),
        (this.onDidChangeProperty = this.d.event),
        (this.f = new J()),
        (this.onProcessExit = this.f.event)
    }
    refreshProperty(i) {
      throw new Error(
        `refreshProperty is not suppported in extension owned terminals. property: ${i}`,
      )
    }
    updateProperty(i, t) {
      throw new Error(
        `updateProperty is not suppported in extension owned terminals. property: ${i}, value: ${t}`,
      )
    }
    async start() {}
    shutdown() {
      this.g.close()
    }
    input(i) {
      this.g.handleInput?.(i)
    }
    resize(i, t) {
      this.g.setDimensions?.({ columns: i, rows: t })
    }
    clearBuffer() {}
    async processBinary(i) {}
    acknowledgeDataEvent(i) {}
    async setUnicodeVersion(i) {}
    getInitialCwd() {
      return Promise.resolve("")
    }
    getCwd() {
      return Promise.resolve("")
    }
    startSendingEvents(i) {
      this.g.onDidWrite((t) => this.a.fire(t)),
        this.g.onDidClose?.((t = void 0) => {
          this.f.fire(t === void 0 ? void 0 : t)
        }),
        this.g.onDidOverrideDimensions?.((t) => {
          t &&
            this.d.fire({
              type: "overrideDimensions",
              value: { cols: t.columns, rows: t.rows },
            })
        }),
        this.g.onDidChangeName?.((t) => {
          this.d.fire({ type: "title", value: t })
        }),
        this.g.open(i || void 0),
        i && this.g.setDimensions?.(i),
        this.b.fire({ pid: -1, cwd: "", windowsPty: void 0 })
    }
  },
  xPt = 1,
  mB = class extends at {
    get activeTerminal() {
      return this.b?.value
    }
    get terminals() {
      return this.f.map((t) => t.value)
    }
    constructor(t, e, s) {
      super(),
        (this.R = e),
        (this.f = []),
        (this.g = new Map()),
        (this.h = {}),
        (this.j = {}),
        (this.m = {}),
        (this.n = new Map()),
        (this.u = this.D(new zr())),
        (this.y = new Set()),
        (this.z = new Map()),
        (this.C = new Map()),
        (this.F = new Map()),
        (this.G = new Map()),
        (this.H = new Map()),
        (this.I = new J()),
        (this.onDidCloseTerminal = this.I.event),
        (this.J = new J()),
        (this.onDidOpenTerminal = this.J.event),
        (this.L = new J()),
        (this.onDidChangeActiveTerminal = this.L.event),
        (this.M = new J()),
        (this.onDidChangeTerminalDimensions = this.M.event),
        (this.N = new J()),
        (this.onDidChangeTerminalState = this.N.event),
        (this.O = new J()),
        (this.onDidChangeShell = this.O.event),
        (this.P = new J({
          onWillAddFirstListener: () => this.a.$startSendingDataEvents(),
          onDidRemoveLastListener: () => this.a.$stopSendingDataEvents(),
        })),
        (this.onDidWriteTerminalData = this.P.event),
        (this.Q = new J({
          onWillAddFirstListener: () => this.a.$startSendingCommandEvents(),
          onDidRemoveLastListener: () => this.a.$stopSendingCommandEvents(),
        })),
        (this.onDidExecuteTerminalCommand = this.Q.event),
        (this.a = s.getProxy(K.MainThreadTerminalService)),
        (this.w = new kPt(this.a.$sendProcessData)),
        this.a.$registerProcessSupport(t),
        this.R.registerArgumentProcessor({
          processArgument: (r) => {
            const a = (o) => {
              const c = o
              return this.getTerminalById(c.instanceId)?.value
            }
            switch (r?.$mid) {
              case 15:
                return a(r)
              default: {
                if (Array.isArray(r))
                  for (let o = 0; o < r.length && r[o].$mid === 15; o++)
                    r[o] = a(r[o])
                return r
              }
            }
          },
        }),
        this.D({
          dispose: () => {
            for (const [r, a] of this.g) a.shutdown(!0)
          },
        })
    }
    getDefaultShell(t) {
      return (t ? this.s : this.q)?.path || ""
    }
    getDefaultShellArgs(t) {
      return (t ? this.s : this.q)?.args || []
    }
    createExtensionTerminal(t, e) {
      const s = new lH(this.a, Ze(), t, t.name),
        r = new uH(t.pty)
      return (
        s
          .createExtensionTerminal(
            t.location,
            e,
            this.S(t, e).resolvedExtHostIdentifier,
            Fit(t.iconPath),
            CPt(t.color),
          )
          .then((a) => {
            const o = this.U(a, r)
            this.h[a] = o
          }),
        this.f.push(s),
        s.value
      )
    }
    S(t, e) {
      if (
        ((e = e || {}),
        t.location &&
          typeof t.location == "object" &&
          "parentTerminal" in t.location)
      ) {
        const s = t.location.parentTerminal
        if (s) {
          const r = this.f.find((a) => a.value === s)
          r && (e.resolvedExtHostIdentifier = r._id)
        }
      } else
        t.location && typeof t.location != "object"
          ? (e.location = t.location)
          : e.location &&
            typeof e.location == "object" &&
            "splitActiveTerminal" in e.location &&
            (e.location = { splitActiveTerminal: !0 })
      return e
    }
    attachPtyToTerminal(t, e) {
      if (!this.getTerminalById(t))
        throw new Error(
          `Cannot resolve terminal with id ${t} for virtual process`,
        )
      const r = new uH(e),
        a = this.U(t, r)
      this.h[t] = a
    }
    async $acceptActiveTerminalChanged(t) {
      const e = this.b
      if (t === null) {
        ;(this.b = void 0), e !== this.b && this.L.fire(this.b)
        return
      }
      const s = this.getTerminalById(t)
      s && ((this.b = s), e !== this.b && this.L.fire(this.b.value))
    }
    async $acceptTerminalProcessData(t, e) {
      const s = this.getTerminalById(t)
      s && this.P.fire({ terminal: s.value, data: e })
    }
    async $acceptTerminalDimensions(t, e, s) {
      const r = this.getTerminalById(t)
      r &&
        r.setDimensions(e, s) &&
        this.M.fire({ terminal: r.value, dimensions: r.value.dimensions })
    }
    async $acceptDidExecuteCommand(t, e) {
      const s = this.getTerminalById(t)
      s && this.Q.fire({ terminal: s.value, ...e })
    }
    async $acceptTerminalMaximumDimensions(t, e, s) {
      this.g.get(t)?.resize(e, s)
    }
    async $acceptTerminalTitleChange(t, e) {
      const s = this.getTerminalById(t)
      s && (s.name = e)
    }
    async $acceptTerminalClosed(t, e, s) {
      const r = this.Y(this.f, t)
      if (r !== null) {
        const a = this.f.splice(r, 1)[0]
        a.setExitStatus(e, s), this.I.fire(a.value)
      }
    }
    $acceptTerminalOpened(t, e, s, r) {
      if (e) {
        const c = this.Y(this.f, e)
        if (c !== null) {
          ;(this.f[c]._id = t),
            this.J.fire(this.terminals[c]),
            (this.f[c].isOpen = !0)
          return
        }
      }
      const a = {
          name: r.name,
          shellPath: r.executable,
          shellArgs: r.args,
          cwd: typeof r.cwd == "string" ? r.cwd : S.revive(r.cwd),
          env: r.env,
          hideFromUser: r.hideFromUser,
        },
        o = new lH(this.a, t, a, s)
      this.f.push(o), this.J.fire(o.value), (o.isOpen = !0)
    }
    async $acceptTerminalProcessId(t, e) {
      this.getTerminalById(t)?._setProcessId(e)
    }
    async $startExtensionTerminal(t, e) {
      const s = this.getTerminalById(t)
      if (!s) return { message: g(2771, null, t) }
      s.isOpen ||
        (await new Promise((a) => {
          const o = this.onDidOpenTerminal(async (c) => {
            c === s.value && (o.dispose(), a())
          })
        }))
      const r = this.g.get(t)
      r ? r.startSendingEvents(e) : (this.j[t] = { initialDimensions: e })
    }
    U(t, e) {
      const s = new gt()
      s.add(
        e.onProcessReady((a) =>
          this.a.$sendProcessReady(t, a.pid, a.cwd, a.windowsPty),
        ),
      ),
        s.add(e.onDidChangeProperty((a) => this.a.$sendProcessProperty(t, a))),
        this.w.startBuffering(t, e.onProcessData),
        s.add(e.onProcessExit((a) => this.W(t, a))),
        this.g.set(t, e)
      const r = this.j[t]
      return (
        r &&
          e instanceof uH &&
          (e.startSendingEvents(r.initialDimensions), delete this.j[t]),
        s
      )
    }
    $acceptProcessAckDataEvent(t, e) {
      this.g.get(t)?.acknowledgeDataEvent(e)
    }
    $acceptProcessInput(t, e) {
      this.g.get(t)?.input(e)
    }
    $acceptTerminalInteraction(t) {
      const e = this.getTerminalById(t)
      e?.setInteractedWith() && this.N.fire(e.value)
    }
    $acceptTerminalSelection(t, e) {
      this.getTerminalById(t)?.setSelection(e)
    }
    $acceptProcessResize(t, e, s) {
      try {
        this.g.get(t)?.resize(e, s)
      } catch (r) {
        if (r.code !== "EPIPE" && r.code !== "ERR_IPC_CHANNEL_CLOSED") throw r
      }
    }
    $acceptProcessShutdown(t, e) {
      this.g.get(t)?.shutdown(e)
    }
    $acceptProcessRequestInitialCwd(t) {
      this.g
        .get(t)
        ?.getInitialCwd()
        .then((e) =>
          this.a.$sendProcessProperty(t, { type: "initialCwd", value: e }),
        )
    }
    $acceptProcessRequestCwd(t) {
      this.g
        .get(t)
        ?.getCwd()
        .then((e) => this.a.$sendProcessProperty(t, { type: "cwd", value: e }))
    }
    $acceptProcessRequestLatency(t) {
      return Promise.resolve(t)
    }
    registerProfileProvider(t, e, s) {
      if (this.C.has(e))
        throw new Error(`Terminal profile provider "${e}" already registered`)
      return (
        this.C.set(e, s),
        this.a.$registerProfileProvider(e, t.identifier.value),
        new Ht(() => {
          this.C.delete(e), this.a.$unregisterProfileProvider(e)
        })
      )
    }
    registerTerminalCompletionProvider(t, e, ...s) {
      if (this.z.has(e.id))
        throw new Error(
          `Terminal completion provider "${e.id}" already registered`,
        )
      return (
        this.z.set(e.id, e),
        this.a.$registerCompletionProvider(e.id, t.identifier.value, ...s),
        new Ht(() => {
          this.z.delete(e.id), this.a.$unregisterCompletionProvider(e.id)
        })
      )
    }
    async $provideTerminalCompletions(t, e) {
      const s = new fe().token
      if (s.isCancellationRequested || !this.activeTerminal) return
      const r = this.z.get(t)
      if (!r) return
      const a = await r.provideTerminalCompletions(this.activeTerminal, e, s)
      if (a != null) return a
    }
    registerTerminalQuickFixProvider(t, e, s) {
      if (this.F.has(t))
        throw new Error(
          `Terminal quick fix provider "${t}" is already registered`,
        )
      return (
        this.F.set(t, s),
        this.a.$registerQuickFixProvider(t, e),
        new Ht(() => {
          this.F.delete(t), this.a.$unregisterQuickFixProvider(t)
        })
      )
    }
    async $provideTerminalQuickFixes(t, e) {
      const s = new fe().token
      if (s.isCancellationRequested) return
      const r = this.F.get(t)
      if (!r) return
      const a = await r.provideTerminalQuickFixes(e, s)
      if (a === null || (Array.isArray(a) && a.length === 0)) return
      const o = new gt()
      if (((this.u.value = o), !Array.isArray(a)))
        return a ? T8.from(a, this.R.converter, o) : void 0
      const c = []
      for (const l of a) {
        const u = T8.from(l, this.R.converter, o)
        u && c.push(u)
      }
      return c
    }
    async $createContributedProfileTerminal(t, e) {
      const s = new fe().token
      let r = await this.C.get(t)?.provideTerminalProfile(s)
      if (!s.isCancellationRequested) {
        if (
          (r && !("options" in r) && (r = { options: r }),
          !r || !("options" in r))
        )
          throw new Error(`No terminal profile options provided for id "${t}"`)
        if ("pty" in r.options) {
          this.createExtensionTerminal(r.options, e)
          return
        }
        this.createTerminalFromOptions(r.options, e)
      }
    }
    registerLinkProvider(t) {
      return (
        this.y.add(t),
        this.y.size === 1 && this.a.$startLinkProvider(),
        new Ht(() => {
          this.y.delete(t), this.y.size === 0 && this.a.$stopLinkProvider()
        })
      )
    }
    async $provideLinks(t, e) {
      const s = this.getTerminalById(t)
      if (!s) return []
      this.G.delete(t), this.H.get(t)?.dispose(!0)
      const a = new fe()
      this.H.set(t, a)
      const o = [],
        c = { terminal: s.value, line: e },
        l = []
      for (const m of this.y)
        l.push(
          Qn.withAsyncBody(async (f) => {
            a.token.onCancellationRequested(() => f({ provider: m, links: [] }))
            const p = (await m.provideTerminalLinks(c, a.token)) || []
            a.token.isCancellationRequested || f({ provider: m, links: p })
          }),
        )
      const u = await Promise.all(l)
      if (a.token.isCancellationRequested) return []
      const d = new Map()
      for (const m of u)
        m &&
          m.links.length > 0 &&
          o.push(
            ...m.links.map((f) => {
              const p = {
                id: xPt++,
                startIndex: f.startIndex,
                length: f.length,
                label: f.tooltip,
              }
              return d.set(p.id, { provider: m.provider, link: f }), p
            }),
          )
      return this.G.set(t, d), o
    }
    $activateLink(t, e) {
      const s = this.G.get(t)?.get(e)
      s && s.provider.handleTerminalLink(s.link)
    }
    W(t, e) {
      this.w.stopBuffering(t), this.g.delete(t), delete this.j[t]
      const s = this.h[t]
      s && (s.dispose(), delete this.h[t]), this.a.$sendProcessExit(t, e)
    }
    getTerminalById(t) {
      return this.X(this.f, t)
    }
    getTerminalIdByApiObject(t) {
      const e = this.f.findIndex((s) => s.value === t)
      return e >= 0 ? e : null
    }
    X(t, e) {
      const s = this.Y(t, e)
      return s !== null ? t[s] : null
    }
    Y(t, e) {
      const s = t.findIndex((r) => r._id === e)
      return s >= 0 ? s : null
    }
    getEnvironmentVariableCollection(t) {
      let e = this.n.get(t.identifier.value)
      return (
        e || ((e = this.D(new Dit())), this.$(t.identifier.value, e)),
        e.getScopedEnvironmentVariableCollection(void 0)
      )
    }
    Z(t, e) {
      const s = bPt(e.map),
        r = TPt(e.descriptionMap)
      this.a.$setEnvironmentVariableCollection(
        t,
        e.persistent,
        s.length === 0 ? void 0 : s,
        r,
      )
    }
    $initEnvironmentVariableCollections(t) {
      t.forEach((e) => {
        const s = e[0],
          r = this.D(new Dit(e[1]))
        this.$(s, r)
      })
    }
    $acceptDefaultProfile(t, e) {
      const s = this.q
      ;(this.q = t), (this.s = e), s?.path !== t.path && this.O.fire(t.path)
    }
    $(t, e) {
      this.n.set(t, e),
        this.D(
          e.onDidChangeCollection(() => {
            this.Z(t, e)
          }),
        )
    }
  }
mB = __decorate([__param(1, mr), __param(2, Ot)], mB)
var Dit = class extends at {
    get persistent() {
      return this.b
    }
    set persistent(i) {
      ;(this.b = i), this.f.fire()
    }
    get onDidChangeCollection() {
      return this.f && this.f.event
    }
    constructor(i) {
      super(),
        (this.map = new Map()),
        (this.a = new Map()),
        (this.descriptionMap = new Map()),
        (this.b = !0),
        (this.f = new J()),
        (this.map = new Map(i))
    }
    getScopedEnvironmentVariableCollection(i) {
      const t = this.j(i)
      let e = this.a.get(t)
      return (
        e ||
          ((e = new NPt(this, i)),
          this.a.set(t, e),
          this.D(e.onDidChangeCollection(() => this.f.fire()))),
        e
      )
    }
    replace(i, t, e, s) {
      this.g(i, {
        value: t,
        type: Hc.Replace,
        options: e ?? { applyAtProcessCreation: !0 },
        scope: s,
      })
    }
    append(i, t, e, s) {
      this.g(i, {
        value: t,
        type: Hc.Append,
        options: e ?? { applyAtProcessCreation: !0 },
        scope: s,
      })
    }
    prepend(i, t, e, s) {
      this.g(i, {
        value: t,
        type: Hc.Prepend,
        options: e ?? { applyAtProcessCreation: !0 },
        scope: s,
      })
    }
    g(i, t) {
      if (
        t.options &&
        t.options.applyAtProcessCreation === !1 &&
        !t.options.applyAtShellIntegration
      )
        throw new Error(
          "EnvironmentVariableMutatorOptions must apply at either process creation or shell integration",
        )
      const e = this.h(i, t.scope),
        s = this.map.get(e),
        r = t.options
          ? {
              applyAtProcessCreation: t.options.applyAtProcessCreation ?? !1,
              applyAtShellIntegration: t.options.applyAtShellIntegration ?? !1,
            }
          : { applyAtProcessCreation: !0 }
      if (
        !s ||
        s.value !== t.value ||
        s.type !== t.type ||
        s.options?.applyAtProcessCreation !== r.applyAtProcessCreation ||
        s.options?.applyAtShellIntegration !== r.applyAtShellIntegration ||
        s.scope?.workspaceFolder?.index !== t.scope?.workspaceFolder?.index
      ) {
        const a = this.h(i, t.scope),
          o = { variable: i, ...t, options: r }
        this.map.set(a, o), this.f.fire()
      }
    }
    get(i, t) {
      const e = this.h(i, t),
        s = this.map.get(e)
      return s ? Ait(s) : void 0
    }
    h(i, t) {
      const e = this.j(t)
      return e.length ? `${i}:::${e}` : i
    }
    j(i) {
      return this.m(i?.workspaceFolder) ?? ""
    }
    m(i) {
      return i ? i.uri.toString() : void 0
    }
    getVariableMap(i) {
      const t = new Map()
      for (const [e, s] of this.map)
        this.j(s.scope) === this.j(i) && t.set(s.variable, Ait(s))
      return t
    }
    delete(i, t) {
      const e = this.h(i, t)
      this.map.delete(e), this.f.fire()
    }
    clear(i) {
      if (i?.workspaceFolder) {
        for (const [t, e] of this.map)
          e.scope?.workspaceFolder?.index === i.workspaceFolder.index &&
            this.map.delete(t)
        this.n(i)
      } else this.map.clear(), this.descriptionMap.clear()
      this.f.fire()
    }
    setDescription(i, t) {
      const e = this.j(t),
        s = this.descriptionMap.get(e)
      if (!s || s.description !== i) {
        let r
        typeof i == "string"
          ? (r = i)
          : (r = i?.value.split(`

`)[0])
        const a = { description: r, scope: t }
        this.descriptionMap.set(e, a), this.f.fire()
      }
    }
    getDescription(i) {
      const t = this.j(i)
      return this.descriptionMap.get(t)?.description
    }
    n(i) {
      const t = this.j(i)
      this.descriptionMap.delete(t)
    }
  },
  NPt = class {
    get persistent() {
      return this.b.persistent
    }
    set persistent(i) {
      this.b.persistent = i
    }
    get onDidChangeCollection() {
      return this.a && this.a.event
    }
    constructor(i, t) {
      ;(this.b = i), (this.d = t), (this.a = new J())
    }
    getScoped(i) {
      return this.b.getScopedEnvironmentVariableCollection(i)
    }
    replace(i, t, e) {
      this.b.replace(i, t, e, this.d)
    }
    append(i, t, e) {
      this.b.append(i, t, e, this.d)
    }
    prepend(i, t, e) {
      this.b.prepend(i, t, e, this.d)
    }
    get(i) {
      return this.b.get(i, this.d)
    }
    forEach(i, t) {
      this.b
        .getVariableMap(this.d)
        .forEach((e, s) => i.call(t, s, e, this), this.d)
    }
    [Symbol.iterator]() {
      return this.b.getVariableMap(this.d).entries()
    }
    delete(i) {
      this.b.delete(i, this.d), this.a.fire(void 0)
    }
    clear() {
      this.b.clear(this.d)
    }
    set description(i) {
      this.b.setDescription(i, this.d)
    }
    get description() {
      return this.b.getDescription(this.d)
    }
  },
  hH = class extends mB {
    constructor(t, e) {
      super(!1, t, e)
    }
    createTerminal(t, e, s) {
      throw new h7()
    }
    createTerminalFromOptions(t, e) {
      throw new h7()
    }
  }
hH = __decorate([__param(0, mr), __param(1, Ot)], hH)
function Fit(i) {
  if (!(!i || typeof i == "string"))
    return "id" in i ? { id: i.id, color: i.color } : i
}
function CPt(i) {
  return Cc.isThemeColor(i) ? i : void 0
}
function Ait(i) {
  const t = { ...i }
  return delete t.scope, (t.options = t.options ?? void 0), delete t.variable, t
}
var JPt = X("progressService"),
  _it
;(function (i) {
  ;(i[(i.Explorer = 1)] = "Explorer"),
    (i[(i.Scm = 3)] = "Scm"),
    (i[(i.Extensions = 5)] = "Extensions"),
    (i[(i.Window = 10)] = "Window"),
    (i[(i.Notification = 15)] = "Notification"),
    (i[(i.Dialog = 20)] = "Dialog")
})(_it || (_it = {}))
var JYt = Object.freeze({ total() {}, worked() {}, done() {} }),
  dH = class {
    static {
      this.None = Object.freeze({ report() {} })
    }
    get value() {
      return this.a
    }
    constructor(i) {
      this.b = i
    }
    report(i) {
      ;(this.a = i), this.b(this.a)
    }
  },
  Oit = class extends at {
    constructor(t, e) {
      super(),
        (this.a = new Yn()),
        e.withProgress(
          t,
          (s) => ((this.b = s), this.c && s.report(this.c), this.a.p),
        ),
        this.D(et(() => this.a.complete()))
    }
    report(t) {
      this.b ? this.b.report(t) : (this.c = t)
    }
  }
Oit = __decorate([__param(1, JPt)], Oit)
var LPt = X("editorProgressService"),
  RPt = Object.freeze({ total() {}, worked() {}, done() {} }),
  DPt = class extends at {
    show(i, t) {
      return RPt
    }
    showWhile(i, t) {
      return Promise.resolve()
    }
  }
Ut(LPt, DPt, 1)
var Bit = "__",
  RYt = X("IAuthenticationService"),
  DYt = X("IAuthenticationExtensionsService"),
  mH = X("IExtHostAuthentication"),
  fH = class {
    constructor(t) {
      ;(this.b = new Map()),
        (this.c = new J()),
        (this.d = new FPt()),
        (this.a = t.getProxy(K.MainThreadAuthentication))
    }
    getExtensionScopedSessionsEvent(t) {
      const e = t.toLowerCase()
      return Qt.chain(this.c.event, (s) =>
        s
          .filter(
            (r) => !r.extensionIdFilter || r.extensionIdFilter.includes(e),
          )
          .map((r) => ({ provider: r.provider })),
      )
    }
    async getSession(t, e, s, r = {}) {
      const a = ae.toKey(t.identifier),
        o = [...s].sort().join(" ")
      return await this.d.getOrCreate(`${a} ${e} ${o}`, async () => {
        await this.a.$ensureProvider(e)
        const c = t.displayName || t.name
        return this.a.$getSession(e, s, a, c, r)
      })
    }
    async getAccounts(t) {
      return await this.a.$ensureProvider(t), await this.a.$getAccounts(t)
    }
    async removeSession(t, e) {
      const s = this.b.get(t)
      return s ? s.provider.removeSession(e) : this.a.$removeSession(t, e)
    }
    registerAuthenticationProvider(t, e, s, r) {
      if (this.b.get(t))
        throw new Error(
          `An authentication provider with id '${t}' is already registered.`,
        )
      this.b.set(t, {
        label: e,
        provider: s,
        options: r ?? { supportsMultipleAccounts: !1 },
      })
      const a = s.onDidChangeSessions((o) =>
        this.a.$sendDidChangeSessions(t, o),
      )
      return (
        this.a.$registerAuthenticationProvider(
          t,
          e,
          r?.supportsMultipleAccounts ?? !1,
        ),
        new Ht(() => {
          a.dispose(),
            this.b.delete(t),
            this.a.$unregisterAuthenticationProvider(t)
        })
      )
    }
    async $createSession(t, e, s) {
      const r = this.b.get(t)
      if (r) return await r.provider.createSession(e, s)
      throw new Error(
        `Unable to find authentication provider with handle: ${t}`,
      )
    }
    async $removeSession(t, e) {
      const s = this.b.get(t)
      if (s) return await s.provider.removeSession(e)
      throw new Error(
        `Unable to find authentication provider with handle: ${t}`,
      )
    }
    async $getSessions(t, e, s) {
      const r = this.b.get(t)
      if (r) return await r.provider.getSessions(e, s)
      throw new Error(
        `Unable to find authentication provider with handle: ${t}`,
      )
    }
    $onDidChangeAuthenticationSessions(t, e, s) {
      return (
        t.startsWith(Bit) ||
          this.c.fire({ provider: { id: t, label: e }, extensionIdFilter: s }),
        Promise.resolve()
      )
    }
  }
fH = __decorate([__param(0, Ot)], fH)
var FPt = class {
    constructor() {
      this.a = new Map()
    }
    getOrCreate(i, t) {
      const e = this.a.get(i)
      if (e) return e
      const s = t().finally(() => this.a.delete(i))
      return this.a.set(i, s), s
    }
  },
  fB,
  pH = X("IExtHostLanguageModels"),
  qit = class {
    constructor(i, t) {
      ;(this.option = i),
        (this.stream = new R7()),
        (this.stream = t ?? new R7())
    }
  },
  APt = class {
    constructor() {
      ;(this.a = new Map()), (this.b = new R7()), (this.c = !1)
      const i = this
      this.apiObject = {
        get stream() {
          return i.b.asyncIterable
        },
        get text() {
          return Mu.map(i.b.asyncIterable, (t) => {
            if (t instanceof Yi) return t.value
          }).coalesce()
        },
      }
    }
    *d() {
      if (this.a.size > 0) for (const [, i] of this.a) yield i.stream
      else yield this.b
    }
    handleFragment(i) {
      if (this.c) return
      let t = this.a.get(i.index)
      t ||
        (this.a.size === 0
          ? (t = new qit(i.index, this.b))
          : (t = new qit(i.index)),
        this.a.set(i.index, t))
      let e
      i.part.type === "text"
        ? (e = new Yi(i.part.value))
        : (e = new cd(i.part.toolCallId, i.part.name, i.part.parameters)),
        t.stream.emitOne(e)
    }
    reject(i) {
      this.c = !0
      for (const t of this.d()) t.reject(i)
    }
    resolve() {
      this.c = !0
      for (const i of this.d()) i.resolve()
    }
  },
  gH = class {
    static {
      fB = this
    }
    static {
      this.a = 1
    }
    constructor(t, e, s) {
      ;(this.k = e),
        (this.l = s),
        (this.c = new J()),
        (this.d = new J()),
        (this.onDidChangeProviders = this.d.event),
        (this.f = new Map()),
        (this.g = new Map()),
        (this.h = new hn()),
        (this.i = new Map()),
        (this.j = new Map()),
        (this.t = new Set()),
        (this.b = t.getProxy(K.MainThreadLanguageModels))
    }
    dispose() {
      this.c.dispose(), this.d.dispose()
    }
    registerLanguageModel(t, e, s, r) {
      const a = fB.a++
      this.f.set(a, {
        extension: t.identifier,
        provider: s,
        languageModelId: e,
      })
      let o
      r.auth &&
        (o = {
          providerLabel: t.displayName || t.name,
          accountLabel: typeof r.auth == "object" ? r.auth.label : void 0,
        }),
        this.b.$registerLanguageModelProvider(
          a,
          `${ae.toKey(t.identifier)}/${e}`,
          {
            extension: t.identifier,
            id: e,
            vendor: r.vendor ?? ae.toKey(t.identifier),
            name: r.name ?? "",
            family: r.family ?? "",
            version: r.version,
            maxInputTokens: r.maxInputTokens,
            maxOutputTokens: r.maxOutputTokens,
            auth: o,
            targetExtensions: r.extensions,
            isDefault: r.isDefault,
            isUserSelectable: r.isUserSelectable,
          },
        )
      const c = s.onDidReceiveLanguageModelResponse2?.(
        ({ extensionId: l, participant: u, tokenCount: d }) => {
          this.b.$whenLanguageModelChatRequestMade(e, new ae(l), u, d)
        },
      )
      return et(() => {
        this.f.delete(a), this.b.$unregisterProvider(a), c?.dispose()
      })
    }
    async $startChatRequest(t, e, s, r, a, o) {
      const c = this.f.get(t)
      if (!c) throw new Error("Provider not found")
      const l = new dH(async (d) => {
        if (o.isCancellationRequested) {
          this.k.warn(
            `[CHAT](${c.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`,
          )
          return
        }
        let m
        if (
          (d.part instanceof cd
            ? (m = {
                type: "tool_use",
                name: d.part.name,
                parameters: d.part.input,
                toolCallId: d.part.callId,
              })
            : d.part instanceof Yi &&
              (m = { type: "text", value: d.part.value }),
          !m)
        ) {
          this.k.warn(
            `[CHAT](${c.extension.value}) UNKNOWN part ${JSON.stringify(d)}`,
          )
          return
        }
        this.b.$reportResponsePart(e, { index: d.index, part: m })
      })
      let u
      c.provider.provideLanguageModelResponse2
        ? (u = Promise.resolve(
            c.provider.provideLanguageModelResponse2(
              r.map(El.to),
              a,
              ae.toKey(s),
              l,
              o,
            ),
          ))
        : (u = Promise.resolve(
            c.provider.provideLanguageModelResponse(
              r.map(El.to),
              a,
              ae.toKey(s),
              l,
              o,
            ),
          )),
        u.then(
          () => {
            this.b.$reportResponseDone(e, void 0)
          },
          (d) => {
            this.b.$reportResponseDone(e, xu(d))
          },
        )
    }
    $provideTokenLength(t, e, s) {
      const r = this.f.get(t)
      return r
        ? Promise.resolve(r.provider.provideTokenCount(e, s))
        : Promise.resolve(0)
    }
    $acceptChatModelMetadata(t) {
      if (t.added)
        for (const { identifier: e, metadata: s } of t.added)
          this.g.set(e, { metadata: s, apiObjects: new hn() })
      if (t.removed)
        for (const e of t.removed) {
          this.g.delete(e)
          for (const [s, r] of this.i)
            r.languageModelId === e &&
              (r.res.reject(new bi()), this.i.delete(s))
        }
      t.added?.forEach((e) => this.r(e.metadata)), this.d.fire(void 0)
    }
    async getDefaultLanguageModel(t) {
      const e = ms.find(
        this.g.entries(),
        ([, s]) => !!s.metadata.isDefault,
      )?.[0]
      if (e) return this.getLanguageModelByIdentifier(t, e)
    }
    async getLanguageModelByIdentifier(t, e) {
      const s = this.g.get(e)
      if (!s) return
      this.q(t.identifier, s.metadata) && (await this.r(s.metadata))
      let r = s.apiObjects.get(t.identifier)
      if (!r) {
        const a = this
        ;(r = {
          id: s.metadata.id,
          vendor: s.metadata.vendor,
          family: s.metadata.family,
          version: s.metadata.version,
          name: s.metadata.name,
          maxInputTokens: s.metadata.maxInputTokens,
          countTokens(o, c) {
            if (!a.g.has(e)) throw wn.NotFound(e)
            return a.s(e, o, c ?? ce.None)
          },
          sendRequest(o, c, l) {
            if (!a.g.has(e)) throw wn.NotFound(e)
            return a.m(t, e, o, c ?? {}, l ?? ce.None)
          },
        }),
          Object.freeze(r),
          s.apiObjects.set(t.identifier, r)
      }
      return r
    }
    async selectLanguageModels(t, e) {
      const s = await this.b.$selectChatModels({
          ...e,
          extension: t.identifier,
        }),
        r = []
      for (const a of s) {
        const o = await this.getLanguageModelByIdentifier(t, a)
        o && r.push(o)
      }
      return r
    }
    async m(t, e, s, r, a) {
      const o = this.n(t, s),
        c = t.identifier,
        l = this.g.get(e)?.metadata
      if (!l || !this.g.has(e))
        throw wn.NotFound(`Language model '${e}' is unknown.`)
      if (
        this.q(c, l) &&
        (!(await this.o(
          t,
          { identifier: l.extension, displayName: l.auth.providerLabel },
          r.justification,
          !1,
        )) ||
          !this.h.get(c)?.has(l.extension))
      )
        throw wn.NoPermissions(
          `Language model '${e}' cannot be used by '${c.value}'.`,
        )
      try {
        const u = (Math.random() * 1e6) | 0,
          d = new APt()
        this.i.set(u, { languageModelId: e, res: d })
        try {
          await this.b.$tryStartChatRequest(c, e, u, o, r, a)
        } catch (m) {
          throw (this.i.delete(u), m)
        }
        return d.apiObject
      } catch (u) {
        throw u.name === wn.name
          ? u
          : new wn(`Language model '${e}' errored: ${Zs(u)}`, "Unknown", u)
      }
    }
    n(t, e) {
      const s = []
      for (const r of e)
        r.role === Js.System && _(t, "languageModelSystem"), s.push(El.from(r))
      return s
    }
    async $acceptResponsePart(t, e) {
      const s = this.i.get(t)
      s && s.res.handleFragment(e)
    }
    async $acceptResponseDone(t, e) {
      const s = this.i.get(t)
      s && (this.i.delete(t), e ? s.res.reject(Iht(e)) : s.res.resolve())
    }
    async o(t, e, s, r) {
      const a = Bit + e.identifier.value
      if (await this.l.getSession(t, a, [], { silent: !0 }))
        return (
          this.$updateModelAccesslist([
            { from: t.identifier, to: e.identifier, enabled: !0 },
          ]),
          !0
        )
      if (r) return !1
      try {
        const c = s ? g(2762, null, e.displayName, s) : void 0
        return (
          await this.l.getSession(t, a, [], { forceNewSession: { detail: c } }),
          this.$updateModelAccesslist([
            { from: t.identifier, to: e.identifier, enabled: !0 },
          ]),
          !0
        )
      } catch {
        return !1
      }
    }
    q(t, e) {
      return !!e.auth && !ae.equals(e.extension, t)
    }
    async r(t) {
      if (t.auth)
        for (const e of this.t)
          try {
            await this.o(
              e,
              { identifier: t.extension, displayName: "" },
              void 0,
              !0,
            )
          } catch (s) {
            this.k.error("Fake Auth request failed"), this.k.error(s)
          }
    }
    async s(t, e, s) {
      if (!this.g.get(t)) throw wn.NotFound(`Language model '${t}' is unknown.`)
      const a = ms.find(this.f.values(), (o) => o.languageModelId === t)
      return a
        ? a.provider.provideTokenCount(e, s)
        : this.b.$countTokens(t, typeof e == "string" ? e : El.from(e), s)
    }
    $updateModelAccesslist(t) {
      const e = new Array()
      for (const { from: s, to: r, enabled: a } of t) {
        const o = this.h.get(s) ?? new no()
        if (o.has(r) !== a) {
          a ? o.add(r) : o.delete(r), this.h.set(s, o)
          const l = { from: s, to: r }
          e.push(l), this.c.fire(l)
        }
      }
    }
    createLanguageModelAccessInformation(t) {
      this.t.add(t)
      const e = this,
        s = Qt.signal(
          Qt.filter(this.c.event, (a) => ae.equals(a.from, t.identifier)),
        ),
        r = Qt.signal(this.d.event)
      return {
        get onDidChange() {
          return Qt.any(s, r)
        },
        canSendRequest(a) {
          let o
          t: for (const [l, u] of e.g)
            for (const d of u.apiObjects.values())
              if (d === a) {
                o = u.metadata
                break t
              }
          if (!o) return
          if (!e.q(t.identifier, o)) return !0
          const c = e.h.get(t.identifier)
          if (c) return c.has(o.extension)
        },
      }
    }
    fileIsIgnored(t, e, s) {
      return _(t, "chatParticipantAdditions"), this.b.$fileIsIgnored(e, s)
    }
    async $isFileIgnored(t, e, s) {
      const r = this.j.get(t)
      if (!r) throw new Error("Unknown LanguageModelIgnoredFileProvider")
      return (await r.provideFileIgnored(S.revive(e), s)) ?? !1
    }
    registerIgnoredFileProvider(t, e) {
      _(t, "chatParticipantPrivate")
      const s = fB.a++
      return (
        this.b.$registerFileIgnoreProvider(s),
        this.j.set(s, e),
        et(() => {
          this.b.$unregisterFileIgnoreProvider(s), this.j.delete(s)
        })
      )
    }
  }
gH = fB = __decorate([__param(0, Ot), __param(1, Rt), __param(2, mH)], gH)
function am(i, t = ie) {
  return x7(i, t) ? i.charAt(0).toUpperCase() + i.slice(1) : i
}
function _Pt(i, t) {
  return i.replace(/^~($|\/|\\)/, `${t}$1`)
}
var Uit
;(function (i) {
  ;(i[(i.TEXT = 0)] = "TEXT"),
    (i[(i.VARIABLE = 1)] = "VARIABLE"),
    (i[(i.SEPARATOR = 2)] = "SEPARATOR")
})(Uit || (Uit = {}))
var OPt = 60,
  BPt = OPt * 60,
  vH = BPt * 24,
  _Yt = vH * 7,
  OYt = vH * 30,
  BYt = vH * 365
function qPt(i) {
  return (
    i.getFullYear() +
    "-" +
    String(i.getMonth() + 1).padStart(2, "0") +
    "-" +
    String(i.getDate()).padStart(2, "0") +
    "T" +
    String(i.getHours()).padStart(2, "0") +
    ":" +
    String(i.getMinutes()).padStart(2, "0") +
    ":" +
    String(i.getSeconds()).padStart(2, "0") +
    "." +
    (i.getMilliseconds() / 1e3).toFixed(3).slice(2, 5) +
    "Z"
  )
}
var UPt = {
    DateTimeFormat(i, t) {
      try {
        return new Intl.DateTimeFormat(i, t)
      } catch {
        return new Intl.DateTimeFormat(void 0, t)
      }
    },
    Collator(i, t) {
      try {
        return new Intl.Collator(i, t)
      } catch {
        return new Intl.Collator(void 0, t)
      }
    },
    Segmenter(i, t) {
      try {
        return new Intl.Segmenter(i, t)
      } catch {
        return new Intl.Segmenter(void 0, t)
      }
    },
    Locale(i, t) {
      try {
        return new Intl.Locale(i, t)
      } catch {
        return new Intl.Locale(qn, t)
      }
    },
  },
  Mit
;(function (i) {
  ;(i[(i.MAX_SAFE_SMALL_INTEGER = 1073741824)] = "MAX_SAFE_SMALL_INTEGER"),
    (i[(i.MIN_SAFE_SMALL_INTEGER = -1073741824)] = "MIN_SAFE_SMALL_INTEGER"),
    (i[(i.MAX_UINT_8 = 255)] = "MAX_UINT_8"),
    (i[(i.MAX_UINT_16 = 65535)] = "MAX_UINT_16"),
    (i[(i.MAX_UINT_32 = 4294967295)] = "MAX_UINT_32"),
    (i[(i.UNICODE_SUPPLEMENTARY_PLANE_BEGIN = 65536)] =
      "UNICODE_SUPPLEMENTARY_PLANE_BEGIN")
})(Mit || (Mit = {}))
function Hit(i) {
  return i < 0 ? 0 : i > 255 ? 255 : i | 0
}
function _l(i) {
  return i < 0 ? 0 : i > 4294967295 ? 4294967295 : i | 0
}
var Wit = class uut {
    constructor(t) {
      const e = Hit(t)
      ;(this.c = e), (this.a = uut.d(e)), (this.b = new Map())
    }
    static d(t) {
      const e = new Uint8Array(256)
      return e.fill(t), e
    }
    set(t, e) {
      const s = Hit(e)
      t >= 0 && t < 256 ? (this.a[t] = s) : this.b.set(t, s)
    }
    get(t) {
      return t >= 0 && t < 256 ? this.a[t] : this.b.get(t) || this.c
    }
    clear() {
      this.a.fill(this.c), this.b.clear()
    }
  },
  jit
;(function (i) {
  ;(i[(i.False = 0)] = "False"), (i[(i.True = 1)] = "True")
})(jit || (jit = {}))
var Vit
;(function (i) {
  ;(i[(i.Regular = 0)] = "Regular"),
    (i[(i.Whitespace = 1)] = "Whitespace"),
    (i[(i.WordSeparator = 2)] = "WordSeparator")
})(Vit || (Vit = {}))
var MPt = class extends Wit {
    constructor(i, t) {
      super(0),
        (this.e = null),
        (this.f = null),
        (this.g = []),
        (this.intlSegmenterLocales = t),
        this.intlSegmenterLocales.length > 0
          ? (this.e = UPt.Segmenter(this.intlSegmenterLocales, {
              granularity: "word",
            }))
          : (this.e = null)
      for (let e = 0, s = i.length; e < s; e++) this.set(i.charCodeAt(e), 2)
      this.set(32, 1), this.set(9, 1)
    }
    findPrevIntlWordBeforeOrAtOffset(i, t) {
      let e = null
      for (const s of this.h(i)) {
        if (s.index > t) break
        e = s
      }
      return e
    }
    findNextIntlWordAtOrAfterOffset(i, t) {
      for (const e of this.h(i)) if (!(e.index < t)) return e
      return null
    }
    h(i) {
      return this.e
        ? this.f === i
          ? this.g
          : ((this.f = i), (this.g = this.j(this.e.segment(i))), this.g)
        : []
    }
    j(i) {
      const t = []
      for (const e of i) this.k(e) && t.push(e)
      return t
    }
    k(i) {
      return !!i.isWordLike
    }
  },
  Git = new Ju(10)
function HPt(i, t) {
  const e = `${i}/${t.join(",")}`
  let s = Git.get(e)
  return s || ((s = new MPt(i, t)), Git.set(e, s)), s
}
var wH
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"),
    (i[(i.Center = 2)] = "Center"),
    (i[(i.Right = 4)] = "Right"),
    (i[(i.Full = 7)] = "Full")
})(wH || (wH = {}))
var zit
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"),
    (i[(i.Center = 2)] = "Center"),
    (i[(i.Right = 3)] = "Right")
})(zit || (zit = {}))
var Yit
;(function (i) {
  ;(i[(i.Inline = 1)] = "Inline"), (i[(i.Gutter = 2)] = "Gutter")
})(Yit || (Yit = {}))
var Qit
;(function (i) {
  ;(i[(i.Normal = 1)] = "Normal"), (i[(i.Underlined = 2)] = "Underlined")
})(Qit || (Qit = {}))
var Xit
;(function (i) {
  ;(i[(i.Both = 0)] = "Both"),
    (i[(i.Right = 1)] = "Right"),
    (i[(i.Left = 2)] = "Left"),
    (i[(i.None = 3)] = "None")
})(Xit || (Xit = {}))
var Kit
;(function (i) {
  ;(i[(i.TextDefined = 0)] = "TextDefined"),
    (i[(i.LF = 1)] = "LF"),
    (i[(i.CRLF = 2)] = "CRLF")
})(Kit || (Kit = {}))
var Zit
;(function (i) {
  ;(i[(i.LF = 1)] = "LF"), (i[(i.CRLF = 2)] = "CRLF")
})(Zit || (Zit = {}))
var tst
;(function (i) {
  ;(i[(i.LF = 0)] = "LF"), (i[(i.CRLF = 1)] = "CRLF")
})(tst || (tst = {}))
var yH = class {
    constructor(i, t) {
      ;(this._findMatchBrand = void 0), (this.range = i), (this.matches = t)
    }
  },
  est
;(function (i) {
  ;(i[(i.AlwaysGrowsWhenTypingAtEdges = 0)] = "AlwaysGrowsWhenTypingAtEdges"),
    (i[(i.NeverGrowsWhenTypingAtEdges = 1)] = "NeverGrowsWhenTypingAtEdges"),
    (i[(i.GrowsOnlyWhenTypingBefore = 2)] = "GrowsOnlyWhenTypingBefore"),
    (i[(i.GrowsOnlyWhenTypingAfter = 3)] = "GrowsOnlyWhenTypingAfter")
})(est || (est = {}))
var ist
;(function (i) {
  ;(i[(i.Left = 0)] = "Left"),
    (i[(i.Right = 1)] = "Right"),
    (i[(i.None = 2)] = "None"),
    (i[(i.LeftOfInjectedText = 3)] = "LeftOfInjectedText"),
    (i[(i.RightOfInjectedText = 4)] = "RightOfInjectedText")
})(ist || (ist = {}))
var sst
;(function (i) {
  i[(i.FIRST_LINE_DETECTION_LENGTH_LIMIT = 1e3)] =
    "FIRST_LINE_DETECTION_LENGTH_LIMIT"
})(sst || (sst = {}))
var WPt = class {
    constructor(i, t, e) {
      ;(this.regex = i), (this.wordSeparators = t), (this.simpleSearch = e)
    }
  },
  jPt = class {
    constructor(i, t, e) {
      ;(this.reverseEdits = i),
        (this.changes = t),
        (this.trimAutoWhitespaceLineNumbers = e)
    }
  },
  rst = class {
    constructor(i, t, e, s) {
      ;(this.searchString = i),
        (this.isRegex = t),
        (this.matchCase = e),
        (this.wordSeparators = s)
    }
    parseSearchRequest() {
      if (this.searchString === "") return null
      let i
      this.isRegex
        ? (i = nst(this.searchString))
        : (i =
            this.searchString.indexOf(`
`) >= 0)
      let t = null
      try {
        t = hG(this.searchString, this.isRegex, {
          matchCase: this.matchCase,
          wholeWord: !1,
          multiline: i,
          global: !0,
          unicode: !0,
        })
      } catch {
        return null
      }
      if (!t) return null
      let e = !this.isRegex && !i
      return (
        e &&
          this.searchString.toLowerCase() !== this.searchString.toUpperCase() &&
          (e = this.matchCase),
        new WPt(
          t,
          this.wordSeparators ? HPt(this.wordSeparators, []) : null,
          e ? this.searchString : null,
        )
      )
    }
  }
function nst(i) {
  if (!i || i.length === 0) return !1
  for (let t = 0, e = i.length; t < e; t++) {
    const s = i.charCodeAt(t)
    if (s === 10) return !0
    if (s === 92) {
      if ((t++, t >= e)) break
      const r = i.charCodeAt(t)
      if (r === 110 || r === 114 || r === 87) return !0
    }
  }
  return !1
}
function ast(i, t, e) {
  if (!e) return new yH(i, null)
  const s = []
  for (let r = 0, a = t.length; r < a; r++) s[r] = t[r]
  return new yH(i, s)
}
function VPt(i, t, e, s, r) {
  if (s === 0) return !0
  const a = t.charCodeAt(s - 1)
  if (i.get(a) !== 0 || a === 13 || a === 10) return !0
  if (r > 0) {
    const o = t.charCodeAt(s)
    if (i.get(o) !== 0) return !0
  }
  return !1
}
function GPt(i, t, e, s, r) {
  if (s + r === e) return !0
  const a = t.charCodeAt(s + r)
  if (i.get(a) !== 0 || a === 13 || a === 10) return !0
  if (r > 0) {
    const o = t.charCodeAt(s + r - 1)
    if (i.get(o) !== 0) return !0
  }
  return !1
}
function ost(i, t, e, s, r) {
  return VPt(i, t, e, s, r) && GPt(i, t, e, s, r)
}
var zPt = class {
  constructor(i, t) {
    ;(this._wordSeparators = i), (this.a = t), (this.b = -1), (this.c = 0)
  }
  reset(i) {
    ;(this.a.lastIndex = i), (this.b = -1), (this.c = 0)
  }
  next(i) {
    const t = i.length
    let e
    do {
      if (this.b + this.c === t || ((e = this.a.exec(i)), !e)) return null
      const s = e.index,
        r = e[0].length
      if (s === this.b && r === this.c) {
        if (r === 0) {
          vG(i, t, this.a.lastIndex) > 65535
            ? (this.a.lastIndex += 2)
            : (this.a.lastIndex += 1)
          continue
        }
        return null
      }
      if (
        ((this.b = s),
        (this.c = r),
        !this._wordSeparators || ost(this._wordSeparators, i, t, s, r))
      )
        return e
    } while (e)
    return null
  }
}
function cst(i) {
  return i.scheme !== G.file && i.scheme !== G.vscodeRemote
}
function YPt(i) {
  if (i.folders.length)
    return i.folders.every((t) => cst(t.uri)) ? i.folders[0].uri : void 0
  if (i.configuration && cst(i.configuration)) return i.configuration
}
function QPt(i) {
  return YPt(i)?.scheme
}
var lst = g2,
  ust = X("remoteAgentService"),
  qYt = new (class {
    constructor() {
      ;(this.maxSampleCount = 5),
        (this.sampleDelay = 2e3),
        (this.initial = []),
        (this.maxInitialCount = 3),
        (this.average = []),
        (this.maxAverageCount = 100),
        (this.highLatencyMultiple = 2),
        (this.highLatencyMinThreshold = 500),
        (this.highLatencyMaxThreshold = 1500),
        (this.lastMeasurement = void 0)
    }
    get latency() {
      return this.lastMeasurement
    }
    async measure(i) {
      let t = 1 / 0
      for (let s = 0; s < this.maxSampleCount; s++) {
        const r = await i.getRoundTripTime()
        if (r === void 0) return
        ;(t = Math.min(t, r / 2)), await Fi(this.sampleDelay)
      }
      this.average.push(t),
        this.average.length > this.maxAverageCount && this.average.shift()
      let e
      return (
        this.initial.length < this.maxInitialCount
          ? this.initial.push(t)
          : (e = this.initial.reduce((s, r) => s + r, 0) / this.initial.length),
        (this.lastMeasurement = {
          initial: e,
          current: t,
          average:
            this.average.reduce((s, r) => s + r, 0) / this.average.length,
          high:
            typeof e > "u"
              ? !1
              : t > this.highLatencyMaxThreshold ||
                (t > this.highLatencyMinThreshold &&
                  t > e * this.highLatencyMultiple),
        }),
        this.lastMeasurement
      )
    }
  })(),
  bH,
  XPt = X("pathService"),
  hst = (bH = class {
    constructor(t, e, s, r) {
      ;(this.d = t),
        (this.e = e),
        (this.f = s),
        (this.g = r),
        (this.a = (async () => (await this.e.getEnvironment())?.os || w7)()),
        (this.b = (async () => {
          const a = await this.e.getEnvironment()
          return (this.c = a?.userHome ?? t)
        })())
    }
    hasValidBasename(t, e, s) {
      return typeof e == "string" || typeof e > "u"
        ? this.a.then((r) => this.h(t, r, e))
        : this.h(t, e, s)
    }
    h(t, e, s) {
      return t.scheme === G.file || t.scheme === G.vscodeRemote
        ? omt(s ?? xr(t), e === 1)
        : !0
    }
    get defaultUriScheme() {
      return bH.findDefaultUriScheme(this.f, this.g)
    }
    static findDefaultUriScheme(t, e) {
      if (t.remoteAuthority) return G.vscodeRemote
      const s = QPt(e.getWorkspace())
      if (s) return s
      const r = e.getWorkspace().folders[0]
      if (r) return r.uri.scheme
      const a = e.getWorkspace().configuration
      return a ? a.scheme : G.file
    }
    userHome(t) {
      return t?.preferLocal ? this.d : this.b
    }
    get resolvedUserHome() {
      return this.c
    }
    get path() {
      return this.a.then((t) => (t === 1 ? Ve : Wt))
    }
    async fileURI(t) {
      let e = ""
      if (
        ((await this.a) === 1 && (t = t.replace(/\\/g, "/")),
        t[0] === "/" && t[1] === "/")
      ) {
        const r = t.indexOf("/", 2)
        r === -1
          ? ((e = t.substring(2)), (t = "/"))
          : ((e = t.substring(2, r)), (t = t.substring(r) || "/"))
      }
      return S.from({
        scheme: G.file,
        authority: e,
        path: t,
        query: "",
        fragment: "",
      })
    }
  })
hst = bH = __decorate([__param(1, ust), __param(2, lst), __param(3, s6)], hst)
function KPt(i) {
  return typeof i == "object" && "uri" in i && "pattern" in i
}
var dst = class {
  constructor(t, e, s, r, a, o) {
    ;(this.a = t),
      (this.b = e),
      (this.c = s),
      (this.d = r),
      (this.f = a),
      (this.g = o)
  }
  aiText(t, e, s = {}) {
    return { ...this.j(e?.map(Bq), s), type: 3, contentPattern: t }
  }
  text(t, e, s = {}) {
    t = this.h(t, s)
    const r = this.a.getValue(),
      a =
        e && e.some((c) => !this.a.getValue({ resource: c }).search.useRipgrep)
    return {
      ...this.j(e?.map(Bq), s),
      type: 2,
      contentPattern: t,
      previewOptions: s.previewOptions,
      maxFileSize: s.maxFileSize,
      usePCRE2: r.search.usePCRE2 || a || !1,
      surroundingContext: s.surroundingContext,
      userDisabledExcludesAndIgnoreFiles:
        s.disregardExcludeSettings && s.disregardIgnoreFiles,
    }
  }
  h(t, e) {
    const s = this.a.getValue()
    t.isRegExp && (t.pattern = t.pattern.replace(/\r?\n/g, "\\n"))
    const r = { ...t, wordSeparators: s.editor.wordSeparators }
    return (
      this.l(t, e) && (r.isCaseSensitive = !0),
      this.m(t) && (r.isMultiline = !0),
      e.notebookSearchConfig?.includeMarkupInput &&
        (r.notebookInfo || (r.notebookInfo = {}),
        (r.notebookInfo.isInNotebookMarkdownInput =
          e.notebookSearchConfig.includeMarkupInput)),
      e.notebookSearchConfig?.includeMarkupPreview &&
        (r.notebookInfo || (r.notebookInfo = {}),
        (r.notebookInfo.isInNotebookMarkdownPreview =
          e.notebookSearchConfig.includeMarkupPreview)),
      e.notebookSearchConfig?.includeCodeInput &&
        (r.notebookInfo || (r.notebookInfo = {}),
        (r.notebookInfo.isInNotebookCellInput =
          e.notebookSearchConfig.includeCodeInput)),
      e.notebookSearchConfig?.includeOutput &&
        (r.notebookInfo || (r.notebookInfo = {}),
        (r.notebookInfo.isInNotebookCellOutput =
          e.notebookSearchConfig.includeOutput)),
      r
    )
  }
  file(t, e = {}) {
    return {
      ...this.j(t, e),
      type: 1,
      filePattern: e.filePattern ? e.filePattern.trim() : e.filePattern,
      exists: e.exists,
      sortByScore: e.sortByScore,
      cacheKey: e.cacheKey,
      shouldGlobMatchFilePattern: e.shouldGlobSearch,
    }
  }
  i(t, e) {
    if (!t) return {}
    if (Array.isArray(t)) {
      if (((t = t.filter((s) => s.length > 0).map(pB)), !t.length)) return {}
    } else t = pB(t)
    return e
      ? this.parseSearchPaths(t)
      : { pattern: TH(...(Array.isArray(t) ? t : [t])) }
  }
  j(t = [], e = {}) {
    let s = Array.isArray(e.excludePattern)
      ? e.excludePattern.map((d) => d.pattern).flat()
      : e.excludePattern
    s = s?.length === 1 ? s[0] : s
    const r = this.i(e.includePattern, e.expandPatterns),
      a = this.i(s, e.expandPatterns),
      o = t.length > 1,
      c = (
        r.searchPaths && r.searchPaths.length
          ? r.searchPaths.map((d) => this.t(d, e, a))
          : t.map((d) => this.u(d, e, a, o))
      ).filter((d) => !!d),
      l = {
        _reason: e._reason,
        folderQueries: c,
        usingSearchPaths: !!(r.searchPaths && r.searchPaths.length),
        extraFileResources: e.extraFileResources,
        excludePattern: a.pattern,
        includePattern: r.pattern,
        onlyOpenEditors: e.onlyOpenEditors,
        maxResults: e.maxResults,
        onlyFileScheme: e.onlyFileScheme,
      }
    if (e.onlyOpenEditors) {
      const d = Ue(
        this.c.groups.flatMap((p) => p.editors.map((v) => v.resource)),
      )
      this.d.trace(
        "QueryBuilder#commonQuery - openEditor URIs",
        JSON.stringify(d),
      )
      const m = d.filter((p) => Htt(l, p.fsPath)),
        f = this.k(m)
      return (
        this.d.trace(
          "QueryBuilder#commonQuery - openEditor Query",
          JSON.stringify(f),
        ),
        { ...l, ...f }
      )
    }
    const u =
      e.extraFileResources &&
      e.extraFileResources.filter((d) => Htt(l, d.fsPath))
    return (l.extraFileResources = u && u.length ? u : void 0), l
  }
  k(t) {
    const e = [],
      s = new oi(),
      r = {}
    let a = !1
    return (
      t.forEach((o) => {
        if (o.scheme === G.walkThrough) return
        if ($mt(o)) {
          const l =
            this.b.getWorkspaceFolder(o)?.uri ?? this.g.extUri.dirname(o)
          let u = s.get(l)
          u ||
            ((a = !0),
            (u = { folder: l, includePattern: {} }),
            e.push(u),
            s.set(l, u))
          const d = uc(l.fsPath, o.fsPath)
          hc(u.includePattern)[d.replace(/\\/g, "/")] = !0
        } else o.fsPath && ((a = !0), (r[o.fsPath] = !0))
      }),
      {
        folderQueries: e,
        includePattern: r,
        usingSearchPaths: !0,
        excludePattern: a ? void 0 : { "**/*": !0 },
      }
    )
  }
  l(t, e) {
    if (e.isSmartCase) {
      if (t.isRegExp) {
        if (TG(t.pattern, !0)) return !0
      } else if (TG(t.pattern)) return !0
    }
    return !!t.isCaseSensitive
  }
  m(t) {
    return t.isMultiline ||
      (t.isRegExp && nst(t.pattern)) ||
      t.pattern.indexOf(`
`) >= 0
      ? !0
      : !!t.isMultiline
  }
  parseSearchPaths(t) {
    const e = (m) => $r(m) || /^\.\.?([\/\\]|$)/.test(m),
      r = (Array.isArray(t) ? t : t$t(t)).map((m) => {
        const f = this.f.resolvedUserHome
        return f ? _Pt(m, f.scheme === G.file ? f.fsPath : f.path) : m
      }),
      a = o7(r, (m) => (e(m) ? "searchPaths" : "exprSegments")),
      o = (a.exprSegments || [])
        .map((m) => Gn(m, "/"))
        .map((m) => Gn(m, "\\"))
        .map((m) => (m[0] === "." && (m = "*" + m), e$t(m))),
      c = {},
      l = this.o(a.searchPaths || [])
    l && l.length && (c.searchPaths = l)
    const u = o.flat(),
      d = TH(...u)
    return d && (c.pattern = d), c
  }
  n(t, e) {
    return e.disregardExcludeSettings
      ? void 0
      : FTt(t, !e.disregardSearchExcludeSettings)
  }
  o(t) {
    if (!t || !t.length) return []
    const e = t.flatMap((r) => {
        let { pathPortion: a, globPortion: o } = ZPt(r)
        return o && (o = kH(o)), this.q(a).flatMap((l) => this.r(l, o))
      }),
      s = new Map()
    return (
      e.forEach((r) => {
        const a = r.searchPath.toString(),
          o = s.get(a)
        o
          ? r.pattern &&
            ((o.pattern = o.pattern || {}), (o.pattern[r.pattern] = !0))
          : s.set(a, {
              searchPath: r.searchPath,
              pattern: r.pattern ? TH(r.pattern) : void 0,
            })
      }),
      Array.from(s.values())
    )
  }
  q(t) {
    if ($r(t)) {
      const e = this.b.getWorkspace().folders
      return e[0] && e[0].uri.scheme !== G.file
        ? [{ searchPath: e[0].uri.with({ path: t }) }]
        : [{ searchPath: S.file(Xr(t)) }]
    }
    if (this.b.getWorkbenchState() === 2) {
      const e = this.b.getWorkspace().folders[0].uri
      if (((t = pB(t)), t.startsWith("../") || t === "..")) {
        const r = Wt.resolve(e.path, t)
        return [{ searchPath: e.with({ path: r }) }]
      }
      const s = kH(t)
      return [{ searchPath: e, pattern: s }]
    } else {
      if (t === "./" || t === ".\\") return []
      {
        const e = t.replace(/^\.[\/\\]/, ""),
          r = this.b
            .getWorkspace()
            .folders.map((a) => {
              const o = e.match(new RegExp(`^${Vn(a.name)}(?:/(.*)|$)`))
              return o ? { match: o, folder: a } : null
            })
            .filter(Wa)
        if (r.length)
          return r.map((a) => {
            const o = a.match[1]
            return { searchPath: a.folder.uri, pattern: o && kH(o) }
          })
        {
          const a = t.match(/\.[\/\\](.+)[\/\\]?/),
            o = a ? a[1] : t,
            c = g(13193, null, o)
          throw new Error(c)
        }
      }
    }
  }
  r(t, e) {
    const s = t.pattern && e ? `${t.pattern}/${e}` : t.pattern || e,
      r = [{ searchPath: t.searchPath, pattern: s }]
    return (
      s &&
        !s.endsWith("**") &&
        r.push({ searchPath: t.searchPath, pattern: s + "/**" }),
      r
    )
  }
  t(t, e, s) {
    const r = this.u(Bq(t.searchPath), e, s, !1)
    return r ? { ...r, includePattern: t.pattern } : null
  }
  u(t, e, s, r) {
    let a
    const o = S.isUri(t) ? t : t.uri
    let c = e.excludePattern?.map((p) => {
      const v = e.excludePattern && KPt(p) ? p.uri : void 0
      return !v || !(S.isUri(t) && this.g.extUri.isEqual(t, v)) ? v : void 0
    })
    if ((c?.length || (c = [void 0]), s.searchPaths)) {
      const p = s.searchPaths.filter((v) => HG(v.searchPath, o))[0]
      if (p && !p.pattern) return null
      p && (a = p.pattern)
    }
    const l = this.a.getValue({ resource: o }),
      d = { ...(this.n(l, e) || {}), ...(a || {}) },
      m = S.isUri(t) ? xr(t) : t.name,
      f = c
        .map((p) =>
          Object.keys(d).length > 0 ? { folder: p, pattern: d } : void 0,
        )
        .filter((p) => p)
    return {
      folder: o,
      folderName: r ? m : void 0,
      excludePattern: f,
      fileEncoding: l.files && l.files.encoding,
      disregardIgnoreFiles:
        typeof e.disregardIgnoreFiles == "boolean"
          ? e.disregardIgnoreFiles
          : !l.search.useIgnoreFiles,
      disregardGlobalIgnoreFiles:
        typeof e.disregardGlobalIgnoreFiles == "boolean"
          ? e.disregardGlobalIgnoreFiles
          : !l.search.useGlobalIgnoreFiles,
      disregardParentIgnoreFiles:
        typeof e.disregardParentIgnoreFiles == "boolean"
          ? e.disregardParentIgnoreFiles
          : !l.search.useParentIgnoreFiles,
      ignoreSymlinks:
        typeof e.ignoreSymlinks == "boolean"
          ? e.ignoreSymlinks
          : !l.search.followSymlinks,
    }
  }
}
dst = __decorate(
  [
    __param(0, dn),
    __param(1, s6),
    __param(2, Vbt),
    __param(3, Rt),
    __param(4, XPt),
    __param(5, zK),
  ],
  dst,
)
function ZPt(i) {
  const t = i.match(/[\*\{\}\(\)\[\]\?]/)
  if (t) {
    const e = t.index,
      s = i.substr(0, e).match(/[/|\\][^/\\]*$/)
    if (s) {
      let r = i.substr(0, s.index)
      return (
        r.match(/[/\\]/) || (r += "/"),
        { pathPortion: r, globPortion: i.substr((s.index || 0) + 1) }
      )
    }
  }
  return { pathPortion: i }
}
function TH(...i) {
  return i.length
    ? i.reduce((t, e) => ((t[e] = !0), t), Object.create(null))
    : void 0
}
function t$t(i) {
  return Eh(i, ",")
    .map((t) => t.trim())
    .filter((t) => !!t.length)
}
function e$t(i) {
  return [`**/${i}/**`, `**/${i}`].map((e) => e.replace(/\*\*\/\*\*/g, "**"))
}
function pB(i) {
  return i.replace(/\\/g, "/")
}
function kH(i) {
  return pB(i).replace(/^\.\//, "").replace(/\/+$/g, "")
}
var i$t = 7e3
function s$t(i, t) {
  const e = t.activationEvents
  if (!e) return Promise.resolve(void 0)
  const s = [],
    r = []
  for (const d of e)
    if (/^workspaceContains:/.test(d)) {
      const m = d.substr(18)
      m.indexOf("*") >= 0 || m.indexOf("?") >= 0 || i.forceUsingSearch
        ? r.push(m)
        : s.push(m)
    }
  if (s.length === 0 && r.length === 0) return Promise.resolve(void 0)
  const { promise: a, resolve: o } = YG(),
    c = (d) => o({ activationEvent: d }),
    l = Promise.all(s.map((d) => r$t(i, d, c))).then(() => {}),
    u = n$t(i, t.identifier, r, c)
  return (
    Promise.all([l, u]).then(() => {
      o(void 0)
    }),
    a
  )
}
async function r$t(i, t, e) {
  for (const s of i.folders)
    if (await i.exists(He(S.revive(s), t))) {
      e(`workspaceContains:${t}`)
      return
    }
}
async function n$t(i, t, e, s) {
  if (e.length === 0) return Promise.resolve(void 0)
  const r = new fe(),
    a = i.checkExists(i.folders, e, r.token),
    o = setTimeout(async () => {
      r.cancel(),
        i.logService.info(
          `Not activating extension '${t.value}': Timed out while searching for 'workspaceContains' pattern ${e.join(",")}`,
        )
    }, i$t)
  let c = !1
  try {
    c = await a
  } catch (l) {
    Ms(l) || $e(l)
  }
  r.dispose(), clearTimeout(o), c && s(`workspaceContains:${e.join(",")}`)
}
var mst = class {
    constructor(i) {
      ;(this.b = new J()),
        (this.onDidChangePassword = this.b.event),
        (this.a = i.getProxy(K.MainThreadSecretState))
    }
    async $onDidChangePassword(i) {
      this.b.fire(i)
    }
    get(i, t) {
      return this.a.$getPassword(i, t)
    }
    store(i, t, e) {
      return this.a.$setPassword(i, t, e)
    }
    delete(i, t) {
      return this.a.$deletePassword(i, t)
    }
  },
  SH = X("IExtHostSecretState"),
  a$t = class {
    #t
    constructor(i, t) {
      ;(this.disposables = new gt()),
        (this.a = ae.toKey(i.identifier)),
        (this.#t = t),
        (this.onDidChange = Qt.map(
          Qt.filter(
            this.#t.onDidChangePassword,
            (e) => e.extensionId === this.a,
          ),
          (e) => ({ key: e.key }),
          this.disposables,
        ))
    }
    dispose() {
      this.disposables.dispose()
    }
    get(i) {
      return this.#t.get(this.a, i)
    }
    store(i, t) {
      return this.#t.store(this.a, i, t)
    }
    delete(i) {
      return this.#t.delete(this.a, i)
    }
  },
  EH = class {
    constructor(t, e, s) {
      ;(this.f = s),
        (this.d = new Map()),
        (this.a = e.getProxy(K.MainThreadLocalization)),
        (this.b = t.environment.appLanguage),
        (this.c = this.b === qn)
    }
    getMessage(t, e) {
      const { message: s, args: r, comment: a } = e
      if (this.c) return uG(s, r ?? {})
      let o = s
      a && a.length > 0 && (o += `/${Array.isArray(a) ? a.join("") : a}`)
      const c = this.d.get(t)?.contents[o]
      return (
        c ||
          this.f.warn(
            `Using default string since no string found in i18n bundle that has the key: ${o}`,
          ),
        uG(c ?? s, r ?? {})
      )
    }
    getBundle(t) {
      return this.d.get(t)?.contents
    }
    getBundleUri(t) {
      return this.d.get(t)?.uri
    }
    async initializeLocalizedMessages(t) {
      if (this.c || (!t.l10n && !t.isBuiltin) || this.d.has(t.identifier.value))
        return
      let e
      const s = await this.g(t)
      if (!s) {
        this.f.error(
          `No bundle location found for extension ${t.identifier.value}`,
        )
        return
      }
      try {
        const r = await this.a.$fetchBundleContents(s),
          a = JSON.parse(r)
        e = t.isBuiltin ? a.contents?.bundle : a
      } catch (r) {
        this.f.error(
          `Failed to load translations for ${t.identifier.value} from ${s}: ${r.message}`,
        )
        return
      }
      e && this.d.set(t.identifier.value, { contents: e, uri: s })
    }
    async g(t) {
      if (t.isBuiltin) {
        const e = await this.a.$fetchBuiltInBundleUri(
          t.identifier.value,
          this.b,
        )
        return S.revive(e)
      }
      return t.l10n
        ? S.joinPath(t.extensionLocation, t.l10n, `bundle.l10n.${this.b}.json`)
        : void 0
    }
  }
EH = __decorate([__param(0, ti), __param(1, Ot), __param(2, Rt)], EH)
var IH = X("IExtHostLocalizationService"),
  PH = X("IExtHostManagedSockets"),
  $H = class {
    constructor(t) {
      ;(this.b = 0),
        (this.c = null),
        (this.d = new Map()),
        (this.a = t.getProxy(K.MainThreadManagedSockets))
    }
    setFactory(t, e) {
      for (const s of this.d.values()) s.dispose()
      this.c && this.a.$unregisterSocketFactory(this.c.socketFactoryId),
        (this.c = new o$t(t, e)),
        this.a.$registerSocketFactory(this.c.socketFactoryId)
    }
    async $openRemoteSocket(t) {
      if (!this.c || this.c.socketFactoryId !== t)
        throw new Error(`No socket factory with id ${t}`)
      const e = ++this.b,
        s = await this.c.makeConnection(),
        r = new gt()
      return (
        this.d.set(e, new c$t(e, s, r)),
        r.add(et(() => this.d.delete(e))),
        r.add(
          s.onDidEnd(() => {
            this.a.$onDidManagedSocketEnd(e), r.dispose()
          }),
        ),
        r.add(
          s.onDidClose((a) => {
            this.a.$onDidManagedSocketClose(e, a?.stack ?? a?.message),
              r.dispose()
          }),
        ),
        r.add(
          s.onDidReceiveMessage((a) =>
            this.a.$onDidManagedSocketHaveData(e, Q.wrap(a)),
          ),
        ),
        e
      )
    }
    $remoteSocketWrite(t, e) {
      this.d.get(t)?.actual.send(e.buffer)
    }
    $remoteSocketEnd(t) {
      const e = this.d.get(t)
      e && (e.actual.end(), e.dispose())
    }
    async $remoteSocketDrain(t) {
      await this.d.get(t)?.actual.drain?.()
    }
  }
$H = __decorate([__param(0, Ot)], $H)
var o$t = class {
    constructor(i, t) {
      ;(this.socketFactoryId = i), (this.makeConnection = t)
    }
  },
  c$t = class extends at {
    constructor(i, t, e) {
      super(), (this.socketId = i), (this.actual = t), this.D(e)
    }
  },
  xH,
  fst = X("IHostUtils"),
  NH = (xH = class extends at {
    constructor(t, e, s, r, a, o, c, l, u, d, m, f, p) {
      super(),
        (this.Y = f),
        (this.Z = p),
        (this.a = this.D(new J())),
        (this.onDidChangeRemoteConnectionData = this.a.event),
        (this.R = new Map()),
        (this.W = !1),
        (this.ib = !1),
        (this.c = e),
        (this.g = s),
        (this.f = c),
        (this.j = r),
        (this.m = a),
        (this.q = o),
        (this.s = u),
        (this.t = d),
        (this.u = m),
        (this.w = this.g.getProxy(K.MainThreadWorkspace)),
        (this.y = this.g.getProxy(K.MainThreadTelemetry)),
        (this.z = this.g.getProxy(K.MainThreadExtensionService)),
        (this.C = new Ns()),
        (this.F = new Ns()),
        (this.G = new Ns()),
        (this.H = new Ns()),
        (this.I = new u$t(this.f.extensions.activationEvents)),
        (this.L = new em(this.I, this.f.extensions.allExtensions))
      const v = new no(this.f.extensions.myExtensions)
      ;(this.J = new em(this.I, vst(this.L, v))),
        qa &&
          (this.q.info(
            `Creating extension host with the following global extensions: ${Ol(this.L)}`,
          ),
          this.q.info(
            `Creating extension host with the following local extensions: ${Ol(this.J)}`,
          )),
        (this.M = new Iit(this.g, this.q)),
        (this.N = new mst(this.g)),
        (this.O = l),
        (this.h = this.B.add(
          t.createChild(new Aq([tH, this.M], [SH, this.N])),
        )),
        (this.P = this.D(
          new KM(
            this.J,
            this.L,
            {
              onExtensionActivationError: (b, k, E) => {
                this.z.$onExtensionActivationError(b, xu(k), E)
              },
              actualActivateExtension: async (b, k) => {
                if (em.isHostExtension(b, this.J, this.L))
                  return await this.z.$activateExtension(b, k), new dPt()
                const E = this.J.getExtensionDescription(b)
                return this.fb(E, k)
              },
            },
            this.q,
          ),
        )),
        (this.Q = null),
        (this.S = Object.create(null)),
        (this.U = !1),
        (this.X = this.f.remote.connectionData)
    }
    getRemoteConnectionData() {
      return this.X
    }
    async initialize() {
      try {
        await this.wb(),
          this.C.open(),
          await this.j.waitForInitializeCall(),
          Ae("code/extHost/ready"),
          this.F.open(),
          this.f.autoStart && this.ub()
      } catch (t) {
        $e(t)
      }
    }
    async $() {
      this.O.onWillDeactivateAll()
      let t = []
      try {
        t = this.J.getAllExtensionDescriptions()
          .map((a) => a.identifier)
          .filter((a) => this.isActivated(a))
          .map((a) => this.eb(a))
      } catch {}
      await Promise.all(t)
    }
    terminate(t, e = 0) {
      if (this.W) return
      ;(this.W = !0),
        this.q.info(`Extension host terminating: ${t}`),
        this.q.flush(),
        this.t.dispose(),
        this.P.dispose(),
        c7((r) => {
          this.q.error(r)
        }),
        this.g.dispose()
      const s = this.$()
      Promise.race([Fi(5e3), s]).finally(() => {
        this.c.pid
          ? this.q.info(
              `Extension host with pid ${this.c.pid} exiting with code ${e}`,
            )
          : this.q.info(`Extension host exiting with code ${e}`),
          this.q.flush(),
          this.q.dispose(),
          this.c.exit(e)
      })
    }
    isActivated(t) {
      return this.G.isOpen() ? this.P.isActivated(t) : !1
    }
    async getExtension(t) {
      const e = await this.z.$getExtension(t)
      return (
        e && {
          ...e,
          identifier: new ae(e.identifier.value),
          extensionLocation: S.revive(e.extensionLocation),
        }
      )
    }
    ab(t, e) {
      return this.P.activateByEvent(t, e)
    }
    bb(t, e) {
      return this.P.activateById(t, e)
    }
    activateByIdWithErrors(t, e) {
      return this.bb(t, e).then(() => {
        const s = this.P.getActivatedExtension(t)
        if (s.activationFailed) return Promise.reject(s.activationFailedError)
      })
    }
    getExtensionRegistry() {
      return this.G.wait().then((t) => this.J)
    }
    getExtensionExports(t) {
      if (this.G.isOpen()) return this.P.getActivatedExtension(t).exports
      try {
        return this.P.getActivatedExtension(t).exports
      } catch {
        return null
      }
    }
    async cb(t) {
      if (t.scheme === G.file && this.c.fsRealpath) {
        const e = t.fsPath
        this.R.has(e) || this.R.set(e, this.c.fsRealpath(e))
        const s = await this.R.get(e)
        return S.file(s)
      }
      return t
    }
    async getExtensionPathIndex() {
      return (
        this.Q ||
          (this.Q = this.db(this.J.getAllExtensionDescriptions()).then(
            (t) => new l$t(t),
          )),
        this.Q
      )
    }
    async db(t) {
      const e = ea.forUris((s) => J7.ignorePathCasing(s))
      return (
        await Promise.all(
          t.map(async (s) => {
            if (this.xb(s)) {
              const r = await this.cb(s.extensionLocation)
              e.set(r, s)
            }
          }),
        ),
        e
      )
    }
    eb(t) {
      let e = Promise.resolve(void 0)
      if (!this.G.isOpen() || !this.P.isActivated(t)) return e
      const s = this.P.getActivatedExtension(t)
      if (!s) return e
      try {
        typeof s.module.deactivate == "function" &&
          (e = Promise.resolve(s.module.deactivate()).then(
            void 0,
            (r) => (this.q.error(r), Promise.resolve(void 0)),
          ))
      } catch (r) {
        this.q.error(
          `An error occurred when deactivating the extension '${t.value}':`,
        ),
          this.q.error(r)
      }
      try {
        s.disposable.dispose()
      } catch (r) {
        this.q.error(
          `An error occurred when disposing the subscriptions for extension '${t.value}':`,
        ),
          this.q.error(r)
      }
      return e
    }
    async fb(t, e) {
      return (
        this.f.remote.isRemote
          ? this.z.$onWillActivateExtension(t.identifier)
          : await this.z.$onWillActivateExtension(t.identifier),
        this.hb(t, e).then(
          (s) => {
            const r = s.activationTimes
            return (
              this.z.$onDidActivateExtension(
                t.identifier,
                r.codeLoadingTime,
                r.activateCallTime,
                r.activateResolvedTime,
                e,
              ),
              this.gb(t, e, "success", r),
              s
            )
          },
          (s) => {
            throw (this.gb(t, e, "failure"), s)
          },
        )
      )
    }
    gb(t, e, s, r) {
      const a = gst(t, e)
      this.y.$publicLog2("extensionActivationTimes", {
        ...a,
        ...(r || {}),
        outcome: s,
      })
    }
    hb(t, e) {
      const s = gst(t, e)
      this.y.$publicLog2("activatePlugin", s)
      const r = this.xb(t)
      if (!r) return Promise.resolve(new hPt(aB.NONE))
      this.q.info(
        `ExtensionService#_doActivateExtension ${t.identifier.value}, startup: ${e.startup}, activationEvent: '${e.activationEvent}'${t.identifier.value !== e.extensionId.value ? `, root cause: ${e.extensionId.value}` : ""}`,
      ),
        this.q.flush()
      const a = new gt(),
        o = new Eit(e.startup)
      return Promise.all([
        this.yb(t, He(t.extensionLocation, r), o),
        this.jb(t, a),
      ])
        .then(
          (c) => (
            Ae(`code/extHost/willActivateExtension/${t.identifier.value}`),
            xH.kb(this.q, t.identifier, c[0], c[1], a, o)
          ),
        )
        .then(
          (c) => (
            Ae(`code/extHost/didActivateExtension/${t.identifier.value}`), c
          ),
        )
    }
    jb(t, e) {
      const s = this.Z.createLanguageModelAccessInformation(t),
        r = e.add(new mPt(t, this.M)),
        a = e.add(new Pit(t.identifier.value, !1, this.M)),
        o = e.add(new a$t(t, this.N)),
        c = t.isUnderDevelopment
          ? this.f.environment.extensionTestsLocationURI
            ? ll.Test
            : ll.Development
          : ll.Production,
        l = this.f.remote.isRemote ? So.Workspace : So.UI
      return (
        this.q.trace(
          `ExtensionService#loadExtensionContext ${t.identifier.value}`,
        ),
        Promise.all([r.whenReady, a.whenReady, this.O.whenReady]).then(() => {
          const u = this
          let d, m
          const f = hi(t, "ipc")
            ? this.f.messagePorts?.get(ae.toKey(t.identifier))
            : void 0
          return Object.freeze({
            globalState: r,
            workspaceState: a,
            secrets: o,
            subscriptions: [],
            get languageModelAccessInformation() {
              return s
            },
            get extensionUri() {
              return t.extensionLocation
            },
            get extensionPath() {
              return t.extensionLocation.fsPath
            },
            asAbsolutePath(p) {
              return se(t.extensionLocation.fsPath, p)
            },
            get storagePath() {
              return u.O.workspaceValue(t)?.fsPath
            },
            get globalStoragePath() {
              return u.O.globalValue(t).fsPath
            },
            get logPath() {
              return se(u.f.logsLocation.fsPath, t.identifier.value)
            },
            get logUri() {
              return S.joinPath(u.f.logsLocation, t.identifier.value)
            },
            get storageUri() {
              return u.O.workspaceValue(t)
            },
            get globalStorageUri() {
              return u.O.globalValue(t)
            },
            get extensionMode() {
              return c
            },
            get extension() {
              return d === void 0 && (d = new om(u, t.identifier, t, l, !1)), d
            },
            get extensionRuntime() {
              return _(t, "extensionRuntime"), u.extensionRuntime
            },
            get environmentVariableCollection() {
              return u.t.getEnvironmentVariableCollection(t)
            },
            get messagePassingProtocol() {
              if (!m) {
                if (!f) return
                const p = Qt.buffer(
                  Qt.fromDOMEventEmitter(f, "message", (v) => v.data),
                )
                f.start(),
                  (m = {
                    onDidReceiveMessage: p,
                    postMessage: f.postMessage.bind(f),
                  })
              }
              return m
            },
            get isDevelopment() {
              return u.ib
            },
          })
        })
      )
    }
    static kb(t, e, s, r, a, o) {
      return (
        (s = s || { activate: void 0, deactivate: void 0 }),
        this.lb(t, e, s, r, o).then(
          (c) =>
            new oB(
              !1,
              null,
              o.build(),
              s,
              c,
              et(() => {
                a.dispose(), Hs(r.subscriptions)
              }),
            ),
        )
      )
    }
    static lb(t, e, s, r, a) {
      if (typeof s.activate == "function")
        try {
          a.activateCallStart(),
            t.trace(`ExtensionService#_callActivateOptional ${e.value}`)
          const o = typeof global == "object" ? global : self,
            c = s.activate.apply(o, [r])
          return (
            a.activateCallStop(),
            a.activateResolveStart(),
            Promise.resolve(c).then((l) => (a.activateResolveStop(), l))
          )
        } catch (o) {
          return Promise.reject(o)
        }
      else return Promise.resolve(s)
    }
    mb(t, e) {
      this.bb(t.identifier, {
        startup: !1,
        extensionId: t.identifier,
        activationEvent: e,
      }).then(void 0, (s) => {
        this.q.error(s)
      })
    }
    nb(t, e = 0) {
      const r = Date.now()
      eG(() => {
        for (let a = e; a < t.length; a += 1) {
          const o = t[a]
          for (const c of o.activationEvents ?? [])
            if (c === "onStartupFinished")
              if (Date.now() - r > 50) {
                this.nb(t, a)
                break
              } else this.mb(o, c)
        }
      })
    }
    ob() {
      this.z.$setPerformanceMarks(mvt()),
        this.m.getConfigProvider().then((t) => {
          const e = t
              .getConfiguration("extensions.experimental")
              .get("deferredStartupFinishedActivation"),
            s = this.J.getAllExtensionDescriptions()
          if (e) this.nb(s)
          else
            for (const r of s)
              if (r.activationEvents)
                for (const a of r.activationEvents)
                  a === "onStartupFinished" && this.mb(r, a)
        })
    }
    pb() {
      const t = this.ab("*", !0).then(void 0, (o) => {
        this.q.error(o)
      })
      this.D(this.j.onDidChangeWorkspace((o) => this.qb(o.added)))
      const e = this.j.workspace ? this.j.workspace.folders : [],
        s = this.qb(e),
        r = this.sb(),
        a = Promise.all([r, t, s]).then(() => {})
      return (
        Promise.race([a, Fi(1e4)]).then(() => {
          this.ob()
        }),
        a
      )
    }
    qb(t) {
      return t.length === 0
        ? Promise.resolve(void 0)
        : Promise.all(
            this.J.getAllExtensionDescriptions().map((e) => this.rb(t, e)),
          ).then(() => {})
    }
    async rb(t, e) {
      if (this.isActivated(e.identifier)) return
      const s = !this.f.remote.isRemote && !!this.f.remote.authority,
        r = {
          logService: this.q,
          folders: t.map((o) => o.uri),
          forceUsingSearch: s || !this.c.fsExists,
          exists: (o) => this.c.fsExists(o.fsPath),
          checkExists: (o, c, l) => this.w.$checkExists(o, c, l),
        },
        a = await s$t(r, e)
      if (a)
        return this.bb(e.identifier, {
          startup: !0,
          extensionId: e.identifier,
          activationEvent: a.activationEvent,
        }).then(void 0, (o) => this.q.error(o))
    }
    async sb() {
      if (this.f.remote.authority)
        return this.ab(
          `onResolveRemoteAuthority:${this.f.remote.authority}`,
          !1,
        )
    }
    async $extensionTestsExecute() {
      await this.H.wait()
      try {
        return await this.tb()
      } catch (t) {
        throw (console.error(t), t)
      }
    }
    async tb() {
      const {
        extensionDevelopmentLocationURI: t,
        extensionTestsLocationURI: e,
      } = this.f.environment
      if (!t || !e) throw new Error(g(2758, null))
      const s = await this.yb(null, e, new Eit(!1))
      if (!s || typeof s.run != "function")
        throw new Error(g(2759, null, e.toString()))
      return new Promise((r, a) => {
        const o = (u, d) => {
            u
              ? (qa && this.q.error("Test runner called back with error", u),
                a(u))
              : (qa &&
                  (d
                    ? this.q.info(`Test runner called back with ${d} failures.`)
                    : this.q.info(
                        "Test runner called back with successful outcome.",
                      )),
                r(typeof d == "number" && d > 0 ? 1 : 0))
          },
          c = Vs(e),
          l = s.run(c, o)
        l &&
          l.then &&
          l
            .then(() => {
              qa && this.q.info("Test runner finished successfully."), r(0)
            })
            .catch((u) => {
              qa && this.q.error("Test runner finished with error", u),
                a(u instanceof Error && u.stack ? u.stack : String(u))
            })
      })
    }
    ub() {
      if (this.U) throw new Error("Extension host is already started!")
      return (
        (this.U = !0),
        this.F.wait()
          .then(() => this.G.open())
          .then(() =>
            Promise.race([this.P.waitForActivatingExtensions(), Fi(1e3)]),
          )
          .then(() => this.pb())
          .then(() => {
            this.H.open(), this.q.info("Eager extensions activated")
          })
      )
    }
    registerRemoteAuthorityResolver(t, e) {
      return (
        (this.S[t] = e),
        et(() => {
          delete this.S[t]
        })
      )
    }
    async getRemoteExecServer(t) {
      const { resolver: e } = await this.vb(t)
      return e?.resolveExecServer?.(t, { resolveAttempt: 0 })
    }
    async vb(t) {
      const e = t.indexOf("+")
      if (e === -1)
        throw new Mc(
          "Not an authority that can be resolved!",
          Gi.InvalidAuthority,
        )
      const s = t.substr(0, e)
      return (
        await this.C.wait(),
        await this.ab(`onResolveRemoteAuthority:${s}`, !1),
        { authorityPrefix: s, resolver: this.S[s] }
      )
    }
    async $resolveAuthority(t, e) {
      const s = ss.create(!1),
        r = () => `[resolveAuthority(${ttt(t)},${e})][${s.elapsed()}ms] `,
        a = (P) => this.q.info(`${r()}${P}`),
        o = (P) => this.q.warn(`${r()}${P}`),
        c = (P, C = void 0) => this.q.error(`${r()}${P}`, C),
        l = (P) => {
          if (P instanceof Mc)
            return {
              type: "error",
              error: { code: P._code, message: P._message, detail: P._detail },
            }
          throw P
        },
        u = async (P) => {
          a(`activating resolver for ${P}...`)
          const { resolver: C, authorityPrefix: R } = await this.vb(P)
          if (!C)
            throw (
              (c(`no resolver for ${R}`),
              new Mc(
                `No remote extension installed to resolve ${R}.`,
                Gi.NoResolverFound,
              ))
            )
          return { resolver: C, authorityPrefix: R, remoteAuthority: P }
        },
        d = t.split(/@|%40/g).reverse()
      a(`activating remote resolvers ${d.join(" -> ")}`)
      let m
      try {
        m = await Promise.all(d.map(u)).catch(async (P) => {
          if (!(P instanceof Mc) || P._code !== Gi.InvalidAuthority) throw P
          return (
            o(`resolving nested authorities failed: ${P.message}`), [await u(t)]
          )
        })
      } catch (P) {
        return l(P)
      }
      const f = new ZG()
      f.cancelAndSet(() => a("waiting..."), 1e3)
      let p, v
      for (const [
        P,
        { authorityPrefix: C, resolver: R, remoteAuthority: D },
      ] of m.entries())
        try {
          if (P === m.length - 1)
            a("invoking final resolve()..."),
              Ae(`code/extHost/willResolveAuthority/${C}`),
              (p = await R.resolve(D, { resolveAttempt: e, execServer: v })),
              Ae(`code/extHost/didResolveAuthorityOK/${C}`),
              a("setting tunnel factory..."),
              this.D(
                await this.s.setTunnelFactory(
                  R,
                  G6.isManagedResolvedAuthority(p) ? p : void 0,
                ),
              )
          else {
            if (
              (a(`invoking resolveExecServer() for ${D}`),
              Ae(`code/extHost/willResolveExecServer/${C}`),
              (v = await R.resolveExecServer?.(D, {
                resolveAttempt: e,
                execServer: v,
              })),
              !v)
            )
              throw new Mc(
                `Exec server was not available for ${D}`,
                Gi.NoResolverFound,
              )
            Ae(`code/extHost/didResolveExecServerOK/${C}`)
          }
        } catch (V) {
          return (
            Ae(`code/extHost/didResolveAuthorityError/${C}`),
            c("returned an error", V),
            f.dispose(),
            l(V)
          )
        }
      f.dispose()
      const b = {
          environmentTunnels: p.environmentTunnels,
          features: p.tunnelFeatures
            ? {
                elevation: p.tunnelFeatures.elevation,
                privacyOptions: p.tunnelFeatures.privacyOptions,
                protocol:
                  p.tunnelFeatures.protocol === void 0
                    ? !0
                    : p.tunnelFeatures.protocol,
              }
            : void 0,
        },
        k = {
          extensionHostEnv: p.extensionHostEnv,
          isTrusted: p.isTrusted,
          authenticationSession:
            p.authenticationSessionForInitializingExtensions
              ? {
                  id: p.authenticationSessionForInitializingExtensions.id,
                  providerId:
                    p.authenticationSessionForInitializingExtensions.providerId,
                }
              : void 0,
        }
      a(
        `returned ${G6.isManagedResolvedAuthority(p) ? "managed authority" : `${p.host}:${p.port}`}`,
      )
      let E
      if (G6.isManagedResolvedAuthority(p)) {
        const P = e
        this.Y.setFactory(P, p.makeConnection),
          (E = {
            authority: t,
            connectTo: new ZZ(P),
            connectionToken: p.connectionToken,
          })
      } else
        E = {
          authority: t,
          connectTo: new rTt(p.host, p.port),
          connectionToken: p.connectionToken,
        }
      return {
        type: "ok",
        value: { authority: E, options: k, tunnelInformation: b },
      }
    }
    async $getCanonicalURI(t, e) {
      this.q.info(`$getCanonicalURI invoked for authority (${ttt(t)})`)
      const { resolver: s } = await this.vb(t)
      if (!s) return null
      const r = S.revive(e)
      if (typeof s.getCanonicalURI > "u") return r
      const a = await Ci(() => s.getCanonicalURI(r))
      return a || r
    }
    async $startExtensionHost(t) {
      t.toAdd.forEach(
        (o) => (o.extensionLocation = S.revive(o.extensionLocation)),
      )
      const { globalRegistry: e, myExtensions: s } = pst(
          this.I,
          this.L,
          this.J,
          t,
        ),
        r = await this.db(s)
      return (
        (await this.getExtensionPathIndex()).setSearchTree(r),
        this.L.set(e.getAllExtensionDescriptions()),
        this.J.set(s),
        qa &&
          (this.q.info(`$startExtensionHost: global extensions: ${Ol(this.L)}`),
          this.q.info(`$startExtensionHost: local extensions: ${Ol(this.J)}`)),
        this.ub()
      )
    }
    $activateByEvent(t, e) {
      return e === 1
        ? this.C.wait().then((s) => this.ab(t, !1))
        : this.G.wait().then((s) => this.ab(t, !1))
    }
    async $activate(t, e) {
      return (
        await this.G.wait(),
        this.J.getExtensionDescription(t) ? (await this.bb(t, e), !0) : !1
      )
    }
    async $deltaExtensions(t) {
      t.toAdd.forEach(
        (o) => (o.extensionLocation = S.revive(o.extensionLocation)),
      )
      const { globalRegistry: e, myExtensions: s } = pst(
          this.I,
          this.L,
          this.J,
          t,
        ),
        r = await this.db(s)
      return (
        (await this.getExtensionPathIndex()).setSearchTree(r),
        this.L.set(e.getAllExtensionDescriptions()),
        this.J.set(s),
        qa &&
          (this.q.info(`$deltaExtensions: global extensions: ${Ol(this.L)}`),
          this.q.info(`$deltaExtensions: local extensions: ${Ol(this.J)}`)),
        Promise.resolve(void 0)
      )
    }
    async $test_latency(t) {
      return t
    }
    async $test_up(t) {
      return t.byteLength
    }
    async $test_down(t) {
      const e = Q.alloc(t),
        s = Math.random() % 256
      for (let r = 0; r < t; r++) e.writeUInt8(s, r)
      return e
    }
    async $updateRemoteConnectionData(t) {
      ;(this.X = t), this.a.fire()
    }
  })
NH = xH = __decorate(
  [
    __param(0, t6),
    __param(1, fst),
    __param(2, Ot),
    __param(3, dr),
    __param(4, Ds),
    __param(5, Rt),
    __param(6, ti),
    __param(7, iH),
    __param(8, uB),
    __param(9, Pn),
    __param(10, IH),
    __param(11, PH),
    __param(12, pH),
  ],
  NH,
)
function pst(i, t, e, s) {
  i.addActivationEvents(s.addActivationEvents)
  const r = new em(i, t.getAllExtensionDescriptions())
  r.deltaExtensions(s.toAdd, s.toRemove)
  const a = new no(e.getAllExtensionDescriptions().map((c) => c.identifier))
  for (const c of s.myToRemove) a.delete(c)
  for (const c of s.myToAdd) a.add(c)
  const o = vst(r, a)
  return { globalRegistry: r, myExtensions: o }
}
function gst(i, t) {
  return {
    id: i.identifier.value,
    name: i.name,
    extensionVersion: i.version,
    publisherDisplayName: i.publisher,
    activationEvents: i.activationEvents ? i.activationEvents.join(",") : null,
    isBuiltin: i.isBuiltin,
    reason: t.activationEvent,
    reasonId: t.extensionId.value,
  }
}
function Ol(i) {
  return i
    .getAllExtensionDescriptions()
    .map((t) => t.identifier.value)
    .join(",")
}
var $n = X("IExtHostExtensionService"),
  om = class {
    #t
    #e
    #i
    constructor(i, t, e, s, r) {
      ;(this.#t = i),
        (this.#e = t),
        (this.#i = e.identifier),
        (this.id = e.identifier.value),
        (this.extensionUri = e.extensionLocation),
        (this.extensionPath = Xr(Vs(e.extensionLocation))),
        (this.packageJSON = e),
        (this.extensionKind = s),
        (this.isFromDifferentExtensionHost = r)
    }
    get isActive() {
      return this.#t.isActivated(this.#i)
    }
    get exports() {
      if (
        !(this.packageJSON.api === "none" || this.isFromDifferentExtensionHost)
      )
        return this.#t.getExtensionExports(this.#i)
    }
    async activate() {
      if (this.isFromDifferentExtensionHost)
        throw new Error("Cannot activate foreign extension")
      return (
        await this.#t.activateByIdWithErrors(this.#i, {
          startup: !1,
          extensionId: this.#e,
          activationEvent: "api",
        }),
        this.exports
      )
    }
  }
function vst(i, t) {
  return i.getAllExtensionDescriptions().filter((e) => t.has(e.identifier))
}
var l$t = class {
    constructor(i) {
      this.a = i
    }
    setSearchTree(i) {
      this.a = i
    }
    findSubstr(i) {
      return this.a.findSubstr(i)
    }
    forEach(i) {
      return this.a.forEach(i)
    }
  },
  u$t = class {
    constructor(i) {
      ;(this.a = new hn()), this.addActivationEvents(i)
    }
    readActivationEvents(i) {
      return this.a.get(i.identifier) ?? []
    }
    addActivationEvents(i) {
      for (const t of Object.keys(i)) this.a.set(t, i[t])
    }
  },
  wst = class {
    static async installEarlyHandler(i) {
      Error.stackTraceLimit = 100
      const t = i.get(Rt),
        s = i.get(Ot).getProxy(K.MainThreadErrors)
      c7((r) => {
        t.error(r)
        const a = xu(r)
        s.$onUnexpectedError(a)
      })
    }
    static async installFullHandler(i) {
      const t = i.get(Rt),
        e = i.get(Ot),
        s = i.get($n),
        r = i.get(dB),
        a = e.getProxy(K.MainThreadExtensionService),
        o = e.getProxy(K.MainThreadErrors),
        c = await s.getExtensionPathIndex(),
        l = new WeakMap()
      function u(f, p) {
        if (l.has(f)) return l.get(f).stack
        let v = "",
          b,
          k
        for (const P of p)
          (v += `
	at ${P.toString()}`),
            (k = P.getFileName()),
            !b && k && (b = c.findSubstr(S.file(k)))
        const E = `${f.name || "Error"}: ${f.message || ""}${v}`
        return l.set(f, { extensionIdentifier: b?.identifier, stack: E }), E
      }
      const d = Symbol("prepareStackTrace wrapped")
      let m = u
      Object.defineProperty(Error, "prepareStackTrace", {
        configurable: !1,
        get() {
          return m
        },
        set(f) {
          if (f === u || !f || f[d]) {
            m = f || u
            return
          }
          ;(m = function (p, v) {
            return u(p, v), f.call(Error, p, v)
          }),
            Object.assign(m, { [d]: !0 })
        },
      }),
        c7((f) => {
          t.error(f)
          const p = xu(f),
            v = l.get(f)
          if (!v?.extensionIdentifier) {
            o.$onUnexpectedError(p)
            return
          }
          a.$onExtensionRuntimeError(v.extensionIdentifier, p)
          const b = r.onExtensionError(v.extensionIdentifier, f)
          t.trace("forwarded error to extension?", b, v)
        })
    }
  },
  h$t = class hut {
    constructor(t, e, s, r, a) {
      ;(this.a = s), (this.b = new hwt(t, null, r)), (e = hut.e(e, this.b))
      const o = new Aq(...Owt())
      o.set(ti, { _serviceBrand: void 0, ...e, messagePorts: a }),
        o.set(Ot, new Mwt(this.b)),
        o.set(ah, new Hwt(r)),
        o.set(fst, s)
      const c = new Uwt(o, !0)
      c.invokeFunction(wst.installEarlyHandler),
        (this.d = c.invokeFunction((l) => l.get(Rt))),
        Ae("code/extHost/didCreateServices"),
        this.a.pid
          ? this.d.info(`Extension host with pid ${this.a.pid} started`)
          : this.d.info("Extension host started"),
        this.d.trace("initData", e),
        (this.c = c.invokeFunction((l) => l.get($n))),
        this.c.initialize(),
        c.invokeFunction(wst.installFullHandler)
    }
    async asBrowserUri(t) {
      const e = this.b.getProxy(K.MainThreadExtensionService)
      return S.revive(await e.$asBrowserUri(t))
    }
    terminate(t) {
      this.c.terminate(t)
    }
    static e(t, e) {
      t.extensions.allExtensions.forEach((r) => {
        r.extensionLocation = S.revive(
          e.transformIncomingURIs(r.extensionLocation),
        )
      }),
        (t.environment.appRoot = S.revive(
          e.transformIncomingURIs(t.environment.appRoot),
        ))
      const s = t.environment.extensionDevelopmentLocationURI
      return (
        s &&
          (t.environment.extensionDevelopmentLocationURI = s.map((r) =>
            S.revive(e.transformIncomingURIs(r)),
          )),
        (t.environment.extensionTestsLocationURI = S.revive(
          e.transformIncomingURIs(t.environment.extensionTestsLocationURI),
        )),
        (t.environment.globalStorageHome = S.revive(
          e.transformIncomingURIs(t.environment.globalStorageHome),
        )),
        (t.environment.workspaceStorageHome = S.revive(
          e.transformIncomingURIs(t.environment.workspaceStorageHome),
        )),
        (t.environment.extensionTelemetryLogResource = S.revive(
          e.transformIncomingURIs(t.environment.extensionTelemetryLogResource),
        )),
        (t.nlsBaseUrl = S.revive(e.transformIncomingURIs(t.nlsBaseUrl))),
        (t.logsLocation = S.revive(e.transformIncomingURIs(t.logsLocation))),
        (t.workspace = e.transformIncomingURIs(t.workspace)),
        t
      )
    }
  }
function d$t(i) {
  return {
    transformIncoming: (t) =>
      t.scheme === "vscode-remote"
        ? { scheme: "file", path: t.path, query: t.query, fragment: t.fragment }
        : t.scheme === "file"
          ? {
              scheme: "vscode-local",
              path: t.path,
              query: t.query,
              fragment: t.fragment,
            }
          : t,
    transformOutgoing: (t) =>
      t.scheme === "file"
        ? {
            scheme: "vscode-remote",
            authority: i,
            path: t.path,
            query: t.query,
            fragment: t.fragment,
          }
        : t.scheme === "vscode-local"
          ? {
              scheme: "file",
              path: t.path,
              query: t.query,
              fragment: t.fragment,
            }
          : t,
    transformOutgoingScheme: (t) =>
      t === "file" ? "vscode-remote" : t === "vscode-local" ? "file" : t,
  }
}
function m$t(i) {
  return new rwt(d$t(i))
}
var yst
;(function (i) {
  ;(i[(i.IPC = 1)] = "IPC"),
    (i[(i.Socket = 2)] = "Socket"),
    (i[(i.MessagePort = 3)] = "MessagePort")
})(yst || (yst = {}))
var gB = class dut {
    static {
      this.ENV_KEY = "VSCODE_EXTHOST_IPC_HOOK"
    }
    constructor(t) {
      ;(this.pipeName = t), (this.type = 1)
    }
    serialize(t) {
      t[dut.ENV_KEY] = this.pipeName
    }
  },
  CH = class mut {
    constructor() {
      this.type = 2
    }
    static {
      this.ENV_KEY = "VSCODE_EXTHOST_WILL_SEND_SOCKET"
    }
    serialize(t) {
      t[mut.ENV_KEY] = "1"
    }
  },
  JH = class fut {
    constructor() {
      this.type = 3
    }
    static {
      this.ENV_KEY = "VSCODE_WILL_SEND_MESSAGE_PORT"
    }
    serialize(t) {
      t[fut.ENV_KEY] = "1"
    }
  }
function f$t(i) {
  delete i[gB.ENV_KEY], delete i[CH.ENV_KEY], delete i[JH.ENV_KEY]
}
function p$t(i) {
  if (i[gB.ENV_KEY]) return LH(i, new gB(i[gB.ENV_KEY]))
  if (i[CH.ENV_KEY]) return LH(i, new CH())
  if (i[JH.ENV_KEY]) return LH(i, new JH())
  throw new Error("No connection information defined in environment!")
}
function LH(i, t) {
  return f$t(i), t
}
var VYt = new W("inOutput", !1),
  GYt = new W("activeLogOutput", !1),
  zYt = new W("activeLogOutput.levelSettable", !1),
  YYt = new W("activeLogOutput.level", ""),
  QYt = new W("activeLogOutput.levelIsDefault", !1),
  XYt = new W("outputView.scrollLock", !1),
  KYt = X("outputService"),
  cm
;(function (i) {
  ;(i[(i.Append = 1)] = "Append"),
    (i[(i.Replace = 2)] = "Replace"),
    (i[(i.Clear = 3)] = "Clear")
})(cm || (cm = {}))
var g$t = { OutputChannels: "workbench.contributions.outputChannels" },
  v$t = class {
    constructor() {
      ;(this.a = new Map()),
        (this.b = new J()),
        (this.onDidRegisterChannel = this.b.event),
        (this.c = new J()),
        (this.onDidRemoveChannel = this.c.event)
    }
    registerChannel(i) {
      this.a.has(i.id) || (this.a.set(i.id, i), this.b.fire(i.id))
    }
    getChannels() {
      const i = []
      return this.a.forEach((t) => i.push(t)), i
    }
    getChannel(i) {
      return this.a.get(i)
    }
    removeChannel(i) {
      this.a.delete(i), this.c.fire(i)
    }
  }
Si.add(g$t.OutputChannels, new v$t())
var ZYt = new W("activeOutputChannel", ""),
  bst = class extends Fq {
    constructor(i, t, e, s, r) {
      super(),
        (this.id = i),
        (this.name = t),
        (this.q = e),
        (this.r = s),
        (this.extension = r),
        (this.n = 0),
        (this.visible = !1),
        this.setLevel(e.getLevel()),
        this.D(e.onDidChangeLogLevel((a) => this.setLevel(a))),
        this.D(et(() => this.r.$dispose(this.id)))
    }
    get logLevel() {
      return this.getLevel()
    }
    appendLine(i) {
      this.append(
        i +
          `
`,
      )
    }
    append(i) {
      this.info(i)
    }
    clear() {
      const i = this.n
      this.q.flush(), this.r.$update(this.id, cm.Clear, i)
    }
    replace(i) {
      const t = this.n
      this.info(i),
        this.r.$update(this.id, cm.Replace, t),
        this.visible && this.q.flush()
    }
    show(i, t) {
      this.q.flush(), this.r.$reveal(this.id, !!(typeof i == "boolean" ? i : t))
    }
    hide() {
      this.r.$close(this.id)
    }
    m(i, t) {
      ;(this.n += Q.fromString(t).byteLength),
        Rwt(this.q, i, t),
        this.visible && (this.q.flush(), this.r.$update(this.id, cm.Append))
    }
  },
  w$t = class extends bst {
    appendLine(i) {
      this.append(i)
    }
  },
  RH = class {
    constructor(t, e, s, r, a, o) {
      ;(this.i = e),
        (this.j = s),
        (this.k = r),
        (this.l = a),
        (this.m = o),
        (this.d = new Map()),
        (this.f = 1),
        (this.g = new Map()),
        (this.h = null),
        (this.a = t.getProxy(K.MainThreadOutputService)),
        (this.b = this.k.extUri.joinPath(
          e.logsLocation,
          `output_logging_${qPt(new Date()).replace(/-|:|\.\d+Z$/g, "")}`,
        ))
    }
    $setVisibleChannel(t) {
      this.h = t
      for (const [e, s] of this.g) s.visible = e === this.h
    }
    createOutputChannel(t, e, s) {
      if (((t = t.trim()), !t))
        throw new Error("illegal argument `name`. must not be falsy")
      const r = typeof e == "object" && e.log,
        a = _t(e) ? e : void 0
      if (_t(a) && !a.trim())
        throw new Error("illegal argument `languageId`. must not be empty")
      let o
      const c = this.i.environment.extensionLogLevel?.find(([d]) =>
        ae.equals(s.identifier, d),
      )?.[1]
      c && (o = _wt(c))
      const l = new gt(),
        u = r ? this.o(t, o, s, l) : this.n(t, a, s, l)
      return (
        u.then((d) => {
          this.g.set(d.id, d),
            (d.visible = d.id === this.h),
            l.add(et(() => this.g.delete(d.id)))
        }),
        r ? this.r(t, o ?? this.m.getLevel(), u, l) : this.q(t, u, l)
      )
    }
    async n(t, e, s, r) {
      this.c ||
        (this.c = this.j.value.createDirectory(this.b).then(() => this.b))
      const a = await this.c,
        o = this.k.extUri.joinPath(
          a,
          `${this.f++}-${t.replace(/[\\/:\*\?"<>\|]/g, "")}.log`,
        ),
        c = r.add(
          this.l.createLogger(o, {
            logLevel: "always",
            donotRotate: !0,
            donotUseFormatters: !0,
            hidden: !0,
          }),
        ),
        l = await this.a.$register(t, o, e, s.identifier.value)
      return (
        r.add(et(() => this.l.deregisterLogger(o))), new bst(l, t, c, this.a, s)
      )
    }
    async o(t, e, s, r) {
      const a = await this.p(s),
        o = t.replace(/[\\/:\*\?"<>\|]/g, ""),
        c = this.k.extUri.joinPath(a, `${o}.log`),
        l = `${s.identifier.value}.${o}`,
        u = r.add(
          this.l.createLogger(c, {
            id: l,
            name: t,
            logLevel: e,
            extensionId: s.identifier.value,
          }),
        )
      return (
        r.add(et(() => this.l.deregisterLogger(c))), new w$t(l, t, u, this.a, s)
      )
    }
    p(t) {
      let e = this.d.get(t.identifier.value)
      if (!e) {
        const s = this.k.extUri.joinPath(
          this.i.logsLocation,
          t.identifier.value,
        )
        this.d.set(
          t.identifier.value,
          (e = (async () => {
            try {
              await this.j.value.createDirectory(s)
            } catch (r) {
              if (p6(r) !== dt.FileExists) throw r
            }
            return s
          })()),
        )
      }
      return e
    }
    q(t, e, s) {
      const r = () => {
        if (s.isDisposed) throw new Error("Channel has been closed")
      }
      return (
        e.then((a) => s.add(a)),
        {
          get name() {
            return t
          },
          append(a) {
            r(), e.then((o) => o.append(a))
          },
          appendLine(a) {
            r(), e.then((o) => o.appendLine(a))
          },
          clear() {
            r(), e.then((a) => a.clear())
          },
          replace(a) {
            r(), e.then((o) => o.replace(a))
          },
          show(a, o) {
            r(), e.then((c) => c.show(a, o))
          },
          hide() {
            r(), e.then((a) => a.hide())
          },
          dispose() {
            s.dispose()
          },
        }
      )
    }
    r(t, e, s, r) {
      const a = () => {
          if (r.isDisposed) throw new Error("Channel has been closed")
        },
        o = r.add(new J())
      function c(l) {
        ;(e = l), o.fire(l)
      }
      return (
        s.then((l) => {
          l.logLevel !== e && c(l.logLevel),
            r.add(l.onDidChangeLogLevel((u) => c(u)))
        }),
        {
          ...this.q(t, s, r),
          get logLevel() {
            return e
          },
          onDidChangeLogLevel: o.event,
          trace(l, ...u) {
            a(), s.then((d) => d.trace(l, ...u))
          },
          debug(l, ...u) {
            a(), s.then((d) => d.debug(l, ...u))
          },
          info(l, ...u) {
            a(), s.then((d) => d.info(l, ...u))
          },
          warn(l, ...u) {
            a(), s.then((d) => d.warn(l, ...u))
          },
          error(l, ...u) {
            a(), s.then((d) => d.error(l, ...u))
          },
        }
      )
    }
  }
RH = __decorate(
  [
    __param(0, Ot),
    __param(1, ti),
    __param(2, im),
    __param(3, Nc),
    __param(4, $c),
    __param(5, Rt),
  ],
  RH,
)
var Tst = X("IExtHostOutputService"),
  lm,
  DH = class {
    static {
      lm = this
    }
    static {
      this.c = 0
    }
    static {
      this.d = 250
    }
    constructor(t, e) {
      ;(this.h = e),
        (this.f = new Map()),
        (this.g = t.getProxy(K.MainThreadDecorations))
    }
    registerFileDecorationProvider(t, e) {
      const s = lm.c++
      this.f.set(s, { provider: t, extensionDescription: e }),
        this.g.$registerDecorationProvider(s, e.identifier.value)
      const r =
        t.onDidChangeFileDecorations &&
        t.onDidChangeFileDecorations((a) => {
          if (!a) {
            this.g.$onDidChange(s, null)
            return
          }
          const o = Ir(a)
          if (o.length <= lm.d) {
            this.g.$onDidChange(s, o)
            return
          }
          this.h.warn(
            "[Decorations] CAPPING events from decorations provider",
            e.identifier.value,
            o.length,
          )
          const c = o.map((d) => ({ uri: d, rank: Rdt(d.path, "/") })),
            l = Jht(c, (d, m) => d.rank - m.rank || Ha(d.uri.path, m.uri.path)),
            u = []
          t: for (const d of l) {
            let m
            for (const f of d) {
              const p = Ui(f.uri.path)
              if (m !== p && ((m = p), u.push(f.uri) >= lm.d)) break t
            }
          }
          this.g.$onDidChange(s, u)
        })
      return new Ht(() => {
        r?.dispose(), this.g.$unregisterDecorationProvider(s), this.f.delete(s)
      })
    }
    async $provideDecorations(t, e, s) {
      if (!this.f.has(t)) return Object.create(null)
      const r = Object.create(null),
        { provider: a, extensionDescription: o } = this.f.get(t)
      return (
        await Promise.all(
          e.map(async (c) => {
            try {
              const { uri: l, id: u } = c,
                d = await Promise.resolve(
                  a.provideFileDecoration(S.revive(l), s),
                )
              if (!d) return
              try {
                lU.validate(d),
                  d.badge &&
                    typeof d.badge != "string" &&
                    _(o, "codiconDecoration"),
                  (r[u] = [d.propagate, d.tooltip, d.badge, d.color])
              } catch (m) {
                this.h.warn(
                  `INVALID decoration from extension '${o.identifier.value}': ${m}`,
                )
              }
            } catch (l) {
              this.h.error(l)
            }
          }),
        ),
        r
      )
    }
  }
DH = lm = __decorate([__param(0, Ot), __param(1, Rt)], DH)
var kst = X("IExtHostDecorations"),
  y$t = class {
    constructor(i) {
      ;(this.a = i),
        (this.b = new Uint32Array(i.length)),
        (this.c = new Int32Array(1)),
        (this.c[0] = -1)
    }
    getCount() {
      return this.a.length
    }
    insertValues(i, t) {
      i = _l(i)
      const e = this.a,
        s = this.b,
        r = t.length
      return r === 0
        ? !1
        : ((this.a = new Uint32Array(e.length + r)),
          this.a.set(e.subarray(0, i), 0),
          this.a.set(e.subarray(i), i + r),
          this.a.set(t, i),
          i - 1 < this.c[0] && (this.c[0] = i - 1),
          (this.b = new Uint32Array(this.a.length)),
          this.c[0] >= 0 && this.b.set(s.subarray(0, this.c[0] + 1)),
          !0)
    }
    setValue(i, t) {
      return (
        (i = _l(i)),
        (t = _l(t)),
        this.a[i] === t
          ? !1
          : ((this.a[i] = t), i - 1 < this.c[0] && (this.c[0] = i - 1), !0)
      )
    }
    removeValues(i, t) {
      ;(i = _l(i)), (t = _l(t))
      const e = this.a,
        s = this.b
      if (i >= e.length) return !1
      const r = e.length - i
      return (
        t >= r && (t = r),
        t === 0
          ? !1
          : ((this.a = new Uint32Array(e.length - t)),
            this.a.set(e.subarray(0, i), 0),
            this.a.set(e.subarray(i + t), i),
            (this.b = new Uint32Array(this.a.length)),
            i - 1 < this.c[0] && (this.c[0] = i - 1),
            this.c[0] >= 0 && this.b.set(s.subarray(0, this.c[0] + 1)),
            !0)
      )
    }
    getTotalSum() {
      return this.a.length === 0 ? 0 : this.d(this.a.length - 1)
    }
    getPrefixSum(i) {
      return i < 0 ? 0 : ((i = _l(i)), this.d(i))
    }
    d(i) {
      if (i <= this.c[0]) return this.b[i]
      let t = this.c[0] + 1
      t === 0 && ((this.b[0] = this.a[0]), t++),
        i >= this.a.length && (i = this.a.length - 1)
      for (let e = t; e <= i; e++) this.b[e] = this.b[e - 1] + this.a[e]
      return (this.c[0] = Math.max(this.c[0], i)), this.b[i]
    }
    getIndexOf(i) {
      ;(i = Math.floor(i)), this.getTotalSum()
      let t = 0,
        e = this.a.length - 1,
        s = 0,
        r = 0,
        a = 0
      for (; t <= e; )
        if (
          ((s = (t + (e - t) / 2) | 0),
          (r = this.b[s]),
          (a = r - this.a[s]),
          i < a)
        )
          e = s - 1
        else if (i >= r) t = s + 1
        else break
      return new b$t(s, i - a)
    }
  },
  b$t = class {
    constructor(i, t) {
      ;(this.index = i),
        (this.remainder = t),
        (this._prefixSumIndexOfResultBrand = void 0),
        (this.index = i),
        (this.remainder = t)
    }
  },
  T$t = class {
    constructor(i, t, e, s) {
      ;(this.a = i),
        (this.b = t),
        (this.c = e),
        (this.d = s),
        (this.f = null),
        (this.g = null)
    }
    dispose() {
      this.b.length = 0
    }
    get version() {
      return this.d
    }
    getText() {
      return this.g === null && (this.g = this.b.join(this.c)), this.g
    }
    onEvents(i) {
      i.eol && i.eol !== this.c && ((this.c = i.eol), (this.f = null))
      const t = i.changes
      for (const e of t)
        this.k(e.range),
          this.l(new ws(e.range.startLineNumber, e.range.startColumn), e.text)
      ;(this.d = i.versionId), (this.g = null)
    }
    h() {
      if (!this.f) {
        const i = this.c.length,
          t = this.b.length,
          e = new Uint32Array(t)
        for (let s = 0; s < t; s++) e[s] = this.b[s].length + i
        this.f = new y$t(e)
      }
    }
    j(i, t) {
      ;(this.b[i] = t),
        this.f && this.f.setValue(i, this.b[i].length + this.c.length)
    }
    k(i) {
      if (i.startLineNumber === i.endLineNumber) {
        if (i.startColumn === i.endColumn) return
        this.j(
          i.startLineNumber - 1,
          this.b[i.startLineNumber - 1].substring(0, i.startColumn - 1) +
            this.b[i.startLineNumber - 1].substring(i.endColumn - 1),
        )
        return
      }
      this.j(
        i.startLineNumber - 1,
        this.b[i.startLineNumber - 1].substring(0, i.startColumn - 1) +
          this.b[i.endLineNumber - 1].substring(i.endColumn - 1),
      ),
        this.b.splice(i.startLineNumber, i.endLineNumber - i.startLineNumber),
        this.f &&
          this.f.removeValues(
            i.startLineNumber,
            i.endLineNumber - i.startLineNumber,
          )
    }
    l(i, t) {
      if (t.length === 0) return
      const e = mG(t)
      if (e.length === 1) {
        this.j(
          i.lineNumber - 1,
          this.b[i.lineNumber - 1].substring(0, i.column - 1) +
            e[0] +
            this.b[i.lineNumber - 1].substring(i.column - 1),
        )
        return
      }
      ;(e[e.length - 1] += this.b[i.lineNumber - 1].substring(i.column - 1)),
        this.j(
          i.lineNumber - 1,
          this.b[i.lineNumber - 1].substring(0, i.column - 1) + e[0],
        )
      const s = new Uint32Array(e.length - 1)
      for (let r = 1; r < e.length; r++)
        this.b.splice(i.lineNumber + r - 1, 0, e[r]),
          (s[r - 1] = e[r].length + this.c.length)
      this.f && this.f.insertValues(i.lineNumber, s)
    }
  },
  FH = new Map()
function k$t(i, t) {
  t ? FH.set(i, t) : FH.delete(i)
}
function S$t(i) {
  return FH.get(i)
}
var E$t = class extends T$t {
    constructor(i, t, e, s, r, a, o) {
      super(t, e, s, r), (this.o = i), (this.p = a), (this.q = o), (this.n = !1)
    }
    dispose() {
      Vi(!this.n), (this.n = !0), (this.q = !1)
    }
    equalLines(i) {
      return Er(this.b, i)
    }
    get document() {
      if (!this.m) {
        const i = this
        this.m = {
          get uri() {
            return i.a
          },
          get fileName() {
            return i.a.fsPath
          },
          get isUntitled() {
            return i.a.scheme === G.untitled
          },
          get languageId() {
            return i.p
          },
          get version() {
            return i.d
          },
          get isClosed() {
            return i.n
          },
          get isDirty() {
            return i.q
          },
          save() {
            return i.r()
          },
          getText(t) {
            return t ? i.s(t) : i.getText()
          },
          get eol() {
            return i.c ===
              `
`
              ? nr.LF
              : nr.CRLF
          },
          get lineCount() {
            return i.b.length
          },
          lineAt(t) {
            return i.t(t)
          },
          offsetAt(t) {
            return i.u(t)
          },
          positionAt(t) {
            return i.v(t)
          },
          validateRange(t) {
            return i.w(t)
          },
          validatePosition(t) {
            return i.x(t)
          },
          getWordRangeAtPosition(t, e) {
            return i.y(t, e)
          },
          [Symbol.for("debug.description")]() {
            return `TextDocument(${i.a.toString()})`
          },
        }
      }
      return Object.freeze(this.m)
    }
    _acceptLanguageId(i) {
      Vi(!this.n), (this.p = i)
    }
    _acceptIsDirty(i) {
      Vi(!this.n), (this.q = i)
    }
    r() {
      return this.n
        ? Promise.reject(new Error("Document has been closed"))
        : this.o.$trySaveDocument(this.a)
    }
    s(i) {
      const t = this.w(i)
      if (t.isEmpty) return ""
      if (t.isSingleLine)
        return this.b[t.start.line].substring(
          t.start.character,
          t.end.character,
        )
      const e = this.c,
        s = t.start.line,
        r = t.end.line,
        a = []
      a.push(this.b[s].substring(t.start.character))
      for (let o = s + 1; o < r; o++) a.push(this.b[o])
      return a.push(this.b[r].substring(0, t.end.character)), a.join(e)
    }
    t(i) {
      let t
      if (
        (i instanceof Ft ? (t = i.line) : typeof i == "number" && (t = i),
        typeof t != "number" ||
          t < 0 ||
          t >= this.b.length ||
          Math.floor(t) !== t)
      )
        throw new Error("Illegal value for `line`")
      return new I$t(t, this.b[t], t === this.b.length - 1)
    }
    u(i) {
      return (
        (i = this.x(i)), this.h(), this.f.getPrefixSum(i.line - 1) + i.character
      )
    }
    v(i) {
      ;(i = Math.floor(i)), (i = Math.max(0, i)), this.h()
      const t = this.f.getIndexOf(i),
        e = this.b[t.index].length
      return new Ft(t.index, Math.min(t.remainder, e))
    }
    w(i) {
      if (!(i instanceof Nt)) throw new Error("Invalid argument")
      const t = this.x(i.start),
        e = this.x(i.end)
      return t === i.start && e === i.end
        ? i
        : new Nt(t.line, t.character, e.line, e.character)
    }
    x(i) {
      if (!(i instanceof Ft)) throw new Error("Invalid argument")
      if (this.b.length === 0) return i.with(0, 0)
      let { line: t, character: e } = i,
        s = !1
      if (t < 0) (t = 0), (e = 0), (s = !0)
      else if (t >= this.b.length)
        (t = this.b.length - 1), (e = this.b[t].length), (s = !0)
      else {
        const r = this.b[t].length
        e < 0 ? ((e = 0), (s = !0)) : e > r && ((e = r), (s = !0))
      }
      return s ? new Ft(t, e) : i
    }
    y(i, t) {
      const e = this.x(i)
      if (!t) t = S$t(this.p)
      else if (dG(t))
        throw new Error(
          `[getWordRangeAtPosition]: ignoring custom regexp '${t.source}' because it matches the empty string.`,
        )
      const s = YY(e.character + 1, GY(t), this.b[e.line], 0)
      if (s) return new Nt(e.line, s.startColumn - 1, e.line, s.endColumn - 1)
    }
  },
  I$t = class {
    constructor(i, t, e) {
      ;(this.a = i), (this.b = t), (this.c = e)
    }
    get lineNumber() {
      return this.a
    }
    get text() {
      return this.b
    }
    get range() {
      return new Nt(this.a, 0, this.a, this.b.length)
    }
    get rangeIncludingLineBreak() {
      return this.c ? this.range : new Nt(this.a, 0, this.a + 1, 0)
    }
    get firstNonWhitespaceCharacterIndex() {
      return /^(\s*)/.exec(this.b)[1].length
    }
    get isEmptyOrWhitespace() {
      return this.firstNonWhitespaceCharacterIndex === this.b.length
    }
  },
  vB = class {
    constructor(i) {
      ;(this.a = i), (this.b = 0)
    }
    nextId() {
      return this.a + ++this.b
    }
  },
  iQt = new vB("id#"),
  P$t = class put {
    static {
      this.c = new vB("TextEditorDecorationType")
    }
    constructor(t, e, s) {
      const r = put.c.nextId()
      t.$registerTextEditorDecorationType(e.identifier, r, FU.from(s)),
        (this.value = Object.freeze({
          key: r,
          dispose() {
            t.$removeTextEditorDecorationType(r)
          },
        }))
    }
  },
  $$t = class {
    constructor(i, t) {
      ;(this.g = []),
        (this.h = void 0),
        (this.j = !1),
        (this.c = i),
        (this.d = i.version),
        (this.e = t.undoStopBefore),
        (this.f = t.undoStopAfter)
    }
    finalize() {
      return (
        (this.j = !0),
        {
          documentVersionId: this.d,
          edits: this.g,
          setEndOfLine: this.h,
          undoStopBefore: this.e,
          undoStopAfter: this.f,
        }
      )
    }
    k() {
      if (this.j) throw new Error("Edit is only valid while callback runs")
    }
    replace(i, t) {
      this.k()
      let e = null
      if (i instanceof Ft) e = new Nt(i, i)
      else if (i instanceof Nt) e = i
      else throw new Error("Unrecognized location")
      this.l(e, t, !1)
    }
    insert(i, t) {
      this.k(), this.l(new Nt(i, i), t, !0)
    }
    delete(i) {
      this.k()
      let t = null
      if (i instanceof Nt) t = i
      else throw new Error("Unrecognized location")
      this.l(t, null, !0)
    }
    l(i, t, e) {
      const s = this.c.validateRange(i)
      this.g.push({ range: s, text: t, forceMoveMarkers: e })
    }
    setEndOfLine(i) {
      if ((this.k(), i !== nr.LF && i !== nr.CRLF)) throw Lt("endOfLine")
      this.h = i
    }
  },
  x$t = class {
    constructor(i, t, e, s) {
      ;(this.c = i), (this.d = t), this._accept(e), (this.e = s)
      const r = this
      this.value = {
        get tabSize() {
          return r.f
        },
        set tabSize(a) {
          r.n(a)
        },
        get indentSize() {
          return r.g
        },
        set indentSize(a) {
          r.p(a)
        },
        get insertSpaces() {
          return r.j
        },
        set insertSpaces(a) {
          r.s(a)
        },
        get cursorStyle() {
          return r.k
        },
        set cursorStyle(a) {
          r.t(a)
        },
        get lineNumbers() {
          return r.l
        },
        set lineNumbers(a) {
          r.u(a)
        },
      }
    }
    _accept(i) {
      ;(this.f = i.tabSize),
        (this.g = i.indentSize),
        (this.h = i.originalIndentSize),
        (this.j = i.insertSpaces),
        (this.k = i.cursorStyle),
        (this.l = vl.to(i.lineNumbers))
    }
    m(i) {
      if (i === "auto") return "auto"
      if (typeof i == "number") {
        const t = Math.floor(i)
        return t > 0 ? t : null
      }
      if (typeof i == "string") {
        const t = parseInt(i, 10)
        return isNaN(t) ? null : t > 0 ? t : null
      }
      return null
    }
    n(i) {
      const t = this.m(i)
      if (t !== null) {
        if (typeof t == "number") {
          if (this.f === t) return
          this.f = t
        }
        this.v("setTabSize", this.c.$trySetOptions(this.d, { tabSize: t }))
      }
    }
    o(i) {
      if (i === "tabSize") return "tabSize"
      if (typeof i == "number") {
        const t = Math.floor(i)
        return t > 0 ? t : null
      }
      if (typeof i == "string") {
        const t = parseInt(i, 10)
        return isNaN(t) ? null : t > 0 ? t : null
      }
      return null
    }
    p(i) {
      const t = this.o(i)
      if (t !== null) {
        if (typeof t == "number") {
          if (this.h === t) return
          ;(this.g = t), (this.h = t)
        }
        this.v(
          "setIndentSize",
          this.c.$trySetOptions(this.d, { indentSize: t }),
        )
      }
    }
    q(i) {
      return i === "auto" ? "auto" : i === "false" ? !1 : !!i
    }
    s(i) {
      const t = this.q(i)
      if (typeof t == "boolean") {
        if (this.j === t) return
        this.j = t
      }
      this.v(
        "setInsertSpaces",
        this.c.$trySetOptions(this.d, { insertSpaces: t }),
      )
    }
    t(i) {
      this.k !== i &&
        ((this.k = i),
        this.v(
          "setCursorStyle",
          this.c.$trySetOptions(this.d, { cursorStyle: i }),
        ))
    }
    u(i) {
      this.l !== i &&
        ((this.l = i),
        this.v(
          "setLineNumbers",
          this.c.$trySetOptions(this.d, { lineNumbers: vl.from(i) }),
        ))
    }
    assign(i) {
      const t = {}
      let e = !1
      if (typeof i.tabSize < "u") {
        const s = this.m(i.tabSize)
        s === "auto"
          ? ((e = !0), (t.tabSize = s))
          : typeof s == "number" &&
            this.f !== s &&
            ((this.f = s), (e = !0), (t.tabSize = s))
      }
      if (typeof i.indentSize < "u") {
        const s = this.o(i.indentSize)
        s === "tabSize"
          ? ((e = !0), (t.indentSize = s))
          : typeof s == "number" &&
            this.h !== s &&
            ((this.g = s), (this.h = s), (e = !0), (t.indentSize = s))
      }
      if (typeof i.insertSpaces < "u") {
        const s = this.q(i.insertSpaces)
        s === "auto"
          ? ((e = !0), (t.insertSpaces = s))
          : this.j !== s && ((this.j = s), (e = !0), (t.insertSpaces = s))
      }
      typeof i.cursorStyle < "u" &&
        this.k !== i.cursorStyle &&
        ((this.k = i.cursorStyle), (e = !0), (t.cursorStyle = i.cursorStyle)),
        typeof i.lineNumbers < "u" &&
          this.l !== i.lineNumbers &&
          ((this.l = i.lineNumbers),
          (e = !0),
          (t.lineNumbers = vl.from(i.lineNumbers))),
        e && this.v("setOptions", this.c.$trySetOptions(this.d, t))
    }
    v(i, t) {
      t.catch((e) => {
        this.e.warn(`ExtHostTextEditorOptions '${i}' failed:'`), this.e.warn(e)
      })
    }
  },
  N$t = class {
    constructor(i, t, e, s, r, a, o, c) {
      ;(this.id = i),
        (this.k = t),
        (this.l = e),
        (this.g = !1),
        (this.h = new Set()),
        (this.c = r),
        (this.d = new x$t(this.k, this.id, a, e)),
        (this.e = o),
        (this.f = c)
      const l = this
      this.value = Object.freeze({
        get document() {
          return s.value
        },
        set document(u) {
          throw new Ba("document")
        },
        get selection() {
          return l.c && l.c[0]
        },
        set selection(u) {
          if (!(u instanceof fn)) throw Lt("selection")
          ;(l.c = [u]), l.m()
        },
        get selections() {
          return l.c
        },
        set selections(u) {
          if (!Array.isArray(u) || u.some((d) => !(d instanceof fn)))
            throw Lt("selections")
          ;(l.c = u), l.m()
        },
        get visibleRanges() {
          return l.e
        },
        set visibleRanges(u) {
          throw new Ba("visibleRanges")
        },
        get diffInformation() {
          return l.j
        },
        get options() {
          return l.d.value
        },
        set options(u) {
          l.g || l.d.assign(u)
        },
        get viewColumn() {
          return l.f
        },
        set viewColumn(u) {
          throw new Ba("viewColumn")
        },
        edit(u, d = { undoStopBefore: !0, undoStopAfter: !0 }) {
          if (l.g)
            return Promise.reject(
              new Error("TextEditor#edit not possible on closed editors"),
            )
          const m = new $$t(s.value, d)
          return u(m), l.n(m)
        },
        insertSnippet(u, d, m = { undoStopBefore: !0, undoStopAfter: !0 }) {
          if (l.g)
            return Promise.reject(
              new Error(
                "TextEditor#insertSnippet not possible on closed editors",
              ),
            )
          let f
          if (!d || (Array.isArray(d) && d.length === 0))
            f = l.c.map((p) => U.from(p))
          else if (d instanceof Ft) {
            const { lineNumber: p, column: v } = Kt.from(d)
            f = [
              {
                startLineNumber: p,
                startColumn: v,
                endLineNumber: p,
                endColumn: v,
              },
            ]
          } else if (d instanceof Nt) f = [U.from(d)]
          else {
            f = []
            for (const p of d)
              if (p instanceof Nt) f.push(U.from(p))
              else {
                const { lineNumber: v, column: b } = Kt.from(p)
                f.push({
                  startLineNumber: v,
                  startColumn: b,
                  endLineNumber: v,
                  endColumn: b,
                })
              }
          }
          return t.$tryInsertSnippet(i, s.value.version, u.value, f, m)
        },
        setDecorations(u, d) {
          const m = d.length === 0
          ;(m && !l.h.has(u.key)) ||
            (m ? l.h.delete(u.key) : l.h.add(u.key),
            l.o(() => {
              if (Ltt(d)) return t.$trySetDecorations(i, u.key, JTt(d))
              {
                const f = new Array(4 * d.length)
                for (let p = 0, v = d.length; p < v; p++) {
                  const b = d[p]
                  ;(f[4 * p] = b.start.line + 1),
                    (f[4 * p + 1] = b.start.character + 1),
                    (f[4 * p + 2] = b.end.line + 1),
                    (f[4 * p + 3] = b.end.character + 1)
                }
                return t.$trySetDecorationsFast(i, u.key, f)
              }
            }))
        },
        revealRange(u, d) {
          l.o(() => t.$tryRevealRange(i, U.from(u), d || nO.Default))
        },
        show(u) {
          t.$tryShowEditor(i, ii.from(u))
        },
        hide() {
          t.$tryHideEditor(i)
        },
        [Symbol.for("debug.description")]() {
          return `TextEditor(${this.document.uri.toString()})`
        },
      })
    }
    dispose() {
      Vi(!this.g), (this.g = !0)
    }
    _acceptOptions(i) {
      Vi(!this.g), this.d._accept(i)
    }
    _acceptVisibleRanges(i) {
      Vi(!this.g), (this.e = i)
    }
    _acceptViewColumn(i) {
      Vi(!this.g), (this.f = i)
    }
    _acceptSelections(i) {
      Vi(!this.g), (this.c = i)
    }
    _acceptDiffInformation(i) {
      Vi(!this.g), (this.j = i)
    }
    async m() {
      const i = this.c.map(or.from)
      return (
        await this.o(() => this.k.$trySetSelections(this.id, i)), this.value
      )
    }
    n(i) {
      const t = i.finalize()
      if (t.edits.length === 0 && !t.setEndOfLine) return Promise.resolve(!0)
      const e = t.edits.map((r) => r.range)
      e.sort((r, a) =>
        r.end.line === a.end.line
          ? r.end.character === a.end.character
            ? r.start.line === a.start.line
              ? r.start.character - a.start.character
              : r.start.line - a.start.line
            : r.end.character - a.end.character
          : r.end.line - a.end.line,
      )
      for (let r = 0, a = e.length - 1; r < a; r++) {
        const o = e[r].end
        if (e[r + 1].start.isBefore(o))
          return Promise.reject(
            new Error("Overlapping ranges are not allowed!"),
          )
      }
      const s = t.edits.map((r) => ({
        range: U.from(r.range),
        text: r.text,
        forceMoveMarkers: r.forceMoveMarkers,
      }))
      return this.k.$tryApplyEdits(this.id, t.documentVersionId, s, {
        setEndOfLine:
          typeof t.setEndOfLine == "number" ? wl.from(t.setEndOfLine) : void 0,
        undoStopBefore: t.undoStopBefore,
        undoStopAfter: t.undoStopAfter,
      })
    }
    o(i) {
      return this.g
        ? (this.l.warn("TextEditor is closed/disposed"),
          Promise.resolve(void 0))
        : i().then(
            () => this,
            (t) => (
              (t instanceof Error && t.name === "DISPOSED") || this.l.warn(t),
              null
            ),
          )
    }
  },
  C$t = class {
    constructor(i) {
      ;(this.value = i), (this.a = 0)
    }
    ref() {
      this.a++
    }
    unref() {
      return --this.a === 0
    }
  },
  AH = class {
    constructor(t, e) {
      ;(this.h = t),
        (this.i = e),
        (this.a = null),
        (this.b = new Map()),
        (this.c = new oi()),
        (this.d = new J()),
        (this.e = new J()),
        (this.f = new J()),
        (this.g = new J()),
        (this.onDidAddDocuments = this.d.event),
        (this.onDidRemoveDocuments = this.e.event),
        (this.onDidChangeVisibleTextEditors = this.f.event),
        (this.onDidChangeActiveTextEditor = this.g.event)
    }
    $acceptDocumentsAndEditorsDelta(t) {
      this.acceptDocumentsAndEditorsDelta(t)
    }
    acceptDocumentsAndEditorsDelta(t) {
      const e = [],
        s = [],
        r = []
      if (t.removedDocuments)
        for (const a of t.removedDocuments) {
          const o = S.revive(a),
            c = this.c.get(o)
          c?.unref() && (this.c.delete(o), e.push(c.value))
        }
      if (t.addedDocuments)
        for (const a of t.addedDocuments) {
          const o = S.revive(a.uri)
          let c = this.c.get(o)
          if (
            c &&
            o.scheme !== G.vscodeNotebookCell &&
            o.scheme !== G.vscodeInteractiveInput
          )
            throw new Error(`document '${o} already exists!'`)
          c ||
            ((c = new C$t(
              new E$t(
                this.h.getProxy(K.MainThreadDocuments),
                o,
                a.lines,
                a.EOL,
                a.versionId,
                a.languageId,
                a.isDirty,
              ),
            )),
            this.c.set(o, c),
            s.push(c.value)),
            c.ref()
        }
      if (t.removedEditors)
        for (const a of t.removedEditors) {
          const o = this.b.get(a)
          this.b.delete(a), o && r.push(o)
        }
      if (t.addedEditors)
        for (const a of t.addedEditors) {
          const o = S.revive(a.documentUri)
          Vi(this.c.has(o), `document '${o}' does not exist`),
            Vi(!this.b.has(a.id), `editor '${a.id}' already exists!`)
          const c = this.c.get(o).value,
            l = new N$t(
              a.id,
              this.h.getProxy(K.MainThreadTextEditors),
              this.i,
              new as(() => c.document),
              a.selections.map(or.to),
              a.options,
              a.visibleRanges.map((u) => U.to(u)),
              typeof a.editorPosition == "number"
                ? ii.to(a.editorPosition)
                : void 0,
            )
          this.b.set(a.id, l)
        }
      t.newActiveEditor !== void 0 &&
        (Vi(
          t.newActiveEditor === null || this.b.has(t.newActiveEditor),
          `active editor '${t.newActiveEditor}' does not exist`,
        ),
        (this.a = t.newActiveEditor)),
        Hs(e),
        Hs(r),
        t.removedDocuments && this.e.fire(e),
        t.addedDocuments && this.d.fire(s),
        (t.removedEditors || t.addedEditors) &&
          this.f.fire(this.allEditors().map((a) => a.value)),
        t.newActiveEditor !== void 0 && this.g.fire(this.activeEditor())
    }
    getDocument(t) {
      return this.c.get(t)?.value
    }
    allDocuments() {
      return ms.map(this.c.values(), (t) => t.value)
    }
    getEditor(t) {
      return this.b.get(t)
    }
    activeEditor(t) {
      if (!this.a) return
      const e = this.b.get(this.a)
      return t ? e : e?.value
    }
    allEditors() {
      return [...this.b.values()]
    }
  }
AH = __decorate([__param(0, Ot), __param(1, Rt)], AH)
var Fo = X("IExtHostDocumentsAndEditors"),
  um = X("IExtHostApiDeprecationService"),
  _H = class {
    constructor(t, e) {
      ;(this.c = e),
        (this.a = new Set()),
        (this.b = t.getProxy(K.MainThreadTelemetry))
    }
    report(t, e, s) {
      const r = this.d(t, e)
      this.a.has(r) ||
        (this.a.add(r),
        e.isUnderDevelopment &&
          this.c.warn(`[Deprecation Warning] '${t}' is deprecated. ${s}`),
        this.b.$publicLog2("extHostDeprecatedApiUsage", {
          extensionId: e.identifier.value,
          apiId: t,
        }))
    }
    d(t, e) {
      return `${t}-${e.identifier.value}`
    }
  }
_H = __decorate([__param(0, Ot), __param(1, Rt)], _H)
var nQt = Object.freeze(
    new (class {
      report(i, t, e) {}
    })(),
  ),
  J$t = {
    activeComment: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts",
    },
    aiRelatedInformation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts",
    },
    aiTextSearchProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts",
      version: 2,
    },
    authLearnMore: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts",
    },
    authSession: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts",
    },
    canonicalUriProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts",
    },
    chatEditing: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatEditing.d.ts",
    },
    chatParticipantAdditions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts",
    },
    chatParticipantPrivate: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts",
      version: 2,
    },
    chatProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts",
    },
    chatReferenceBinaryData: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceBinaryData.d.ts",
    },
    chatTab: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts",
    },
    chatVariableResolver: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatVariableResolver.d.ts",
    },
    codeActionAI: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts",
    },
    codeActionRanges: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts",
    },
    codiconDecoration: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts",
    },
    commentReactor: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts",
    },
    commentReveal: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts",
    },
    commentThreadApplicability: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts",
    },
    commentingRangeHint: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts",
    },
    commentsDraftState: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts",
    },
    contribAccessibilityHelpContent: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts",
    },
    contribChatParticipantDetection: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribChatParticipantDetection.d.ts",
    },
    contribCommentEditorActionsMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts",
    },
    contribCommentPeekContext: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts",
    },
    contribCommentThreadAdditionalMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts",
    },
    contribCommentsViewThreadMenus: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts",
    },
    contribDebugCreateConfiguration: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDebugCreateConfiguration.d.ts",
    },
    contribDiffEditorGutterToolBarMenus: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts",
    },
    contribEditSessions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts",
    },
    contribEditorContentMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts",
    },
    contribLabelFormatterWorkspaceTooltip: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts",
    },
    contribMenuBarHome: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts",
    },
    contribMergeEditorMenus: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts",
    },
    contribMultiDiffEditorMenus: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts",
    },
    contribNotebookStaticPreloads: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts",
    },
    contribRemoteHelp: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts",
    },
    contribShareMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts",
    },
    contribSourceControlHistoryItemMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts",
    },
    contribSourceControlHistoryTitleMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryTitleMenu.d.ts",
    },
    contribSourceControlInputBoxMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts",
    },
    contribSourceControlTitleMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts",
    },
    contribStatusBarItems: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts",
    },
    contribViewContainerTitle: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewContainerTitle.d.ts",
    },
    contribViewsRemote: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts",
    },
    contribViewsWelcome: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts",
    },
    control: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.control.d.ts",
    },
    createFileSystemWatcher: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.createFileSystemWatcher.d.ts",
    },
    cursor: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.cursor.d.ts",
    },
    cursorNoDeps: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.cursorNoDeps.d.ts",
    },
    customEditorMove: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts",
    },
    debugVisualization: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts",
    },
    defaultChatParticipant: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts",
      version: 2,
    },
    diffCommand: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts",
    },
    diffContentOptions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts",
    },
    documentFiltersExclusive: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts",
    },
    documentPaste: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentPaste.d.ts",
    },
    editSessionIdentityProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts",
    },
    editorHoverVerbosityLevel: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts",
    },
    editorInsets: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts",
    },
    embeddings: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts",
    },
    extensionRuntime: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts",
    },
    extensionsAny: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts",
    },
    externalUriOpener: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts",
    },
    fileComments: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileComments.d.ts",
    },
    fileSearchProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts",
    },
    fileSearchProvider2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider2.d.ts",
    },
    findFiles2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts",
      version: 2,
    },
    findTextInFiles: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts",
    },
    findTextInFiles2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles2.d.ts",
    },
    fsChunks: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts",
    },
    idToken: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts",
    },
    inlineCompletionsAdditions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts",
    },
    inlineEdit: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineEdit.d.ts",
    },
    interactive: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts",
    },
    interactiveWindow: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts",
    },
    ipc: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts",
    },
    languageModelSystem: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts",
    },
    languageStatusText: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts",
    },
    mappedEditsProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts",
    },
    multiDocumentHighlightProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts",
    },
    nativeWindowHandle: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.nativeWindowHandle.d.ts",
    },
    newSymbolNamesProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts",
    },
    notebookCellExecution: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts",
    },
    notebookCellExecutionState: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecutionState.d.ts",
    },
    notebookControllerAffinityHidden: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts",
    },
    notebookDeprecated: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts",
    },
    notebookExecution: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts",
    },
    notebookKernelSource: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts",
    },
    notebookLiveShare: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts",
    },
    notebookMessaging: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts",
    },
    notebookMime: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts",
    },
    notebookReplDocument: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookReplDocument.d.ts",
    },
    notebookVariableProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts",
    },
    portsAttributes: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts",
    },
    profileContentHandlers: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts",
    },
    quickDiffProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts",
    },
    quickInputButtonLocation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts",
    },
    quickPickItemTooltip: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts",
    },
    quickPickSortByLabel: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts",
    },
    resolvers: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts",
    },
    scmActionButton: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts",
    },
    scmHistoryProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts",
    },
    scmMultiDiffEditor: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts",
    },
    scmRemotes: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmRemotes.d.ts",
    },
    scmSelectedProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts",
    },
    scmTextDocument: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts",
    },
    scmValidation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts",
    },
    shareProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts",
    },
    showLocal: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.showLocal.d.ts",
    },
    speech: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts",
    },
    tabInputMultiDiff: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts",
    },
    tabInputTextMerge: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts",
    },
    taskPresentationGroup: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts",
    },
    telemetry: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts",
    },
    terminalCompletionProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalCompletionProvider.d.ts",
    },
    terminalDataWriteEvent: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts",
    },
    terminalDimensions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts",
    },
    terminalExecuteCommandEvent: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts",
    },
    terminalQuickFixProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts",
    },
    terminalSelection: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts",
    },
    testObserver: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts",
    },
    testRelatedCode: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts",
    },
    textEditorDiffInformation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textEditorDiffInformation.d.ts",
    },
    textSearchComplete2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchComplete2.d.ts",
    },
    textSearchProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts",
    },
    textSearchProvider2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider2.d.ts",
    },
    timeline: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts",
    },
    tokenInformation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts",
    },
    treeViewActiveItem: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts",
    },
    treeViewMarkdownMessage: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts",
    },
    treeViewReveal: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts",
    },
    tunnelFactory: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts",
    },
    tunnels: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts",
    },
    valueSelectionInQuickPick: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.valueSelectionInQuickPick.d.ts",
    },
    workspaceTrust: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts",
    },
  },
  wB = Object.freeze(J$t),
  OH = Si.as(b6.JSONContribution),
  L$t = class Q3 {
    static a(t) {
      const e = new no()
      for (let s = 0, r = t.length; s < r; s++)
        e.add(t[s].description.identifier)
      return e
    }
    static compute(t, e) {
      if (!t || !t.length) return new Q3(e, [])
      if (!e || !e.length) return new Q3([], t)
      const s = this.a(t),
        r = this.a(e),
        a = e.filter((c) => !s.has(c.description.identifier)),
        o = t.filter((c) => !r.has(c.description.identifier))
      return new Q3(a, o)
    }
    constructor(t, e) {
      ;(this.added = t), (this.removed = e)
    }
  },
  R$t = class {
    constructor(i, t, e) {
      ;(this.name = i),
        (this.defaultExtensionKind = t),
        (this.canHandleResolver = e),
        (this.a = null),
        (this.b = null),
        (this.c = null)
    }
    setHandler(i) {
      if (this.a !== null) throw new Error("Handler already set!")
      return (
        (this.a = i),
        this.d(),
        {
          dispose: () => {
            this.a = null
          },
        }
      )
    }
    acceptUsers(i) {
      ;(this.c = L$t.compute(this.b, i)), (this.b = i), this.d()
    }
    d() {
      if (!(this.a === null || this.b === null || this.c === null))
        try {
          this.a(this.b, this.c)
        } catch (i) {
          $e(i)
        }
    }
  },
  D$t = {
    type: "string",
    enum: ["ui", "workspace"],
    enumDescriptions: [g(12894, null), g(12895, null)],
  },
  Sst = "vscode://schemas/vscode-extensions",
  BH = {
    properties: {
      engines: {
        type: "object",
        description: g(12896, null),
        properties: {
          vscode: {
            type: "string",
            description: g(12897, null),
            default: "^1.22.0",
          },
        },
      },
      publisher: { description: g(12898, null), type: "string" },
      displayName: { description: g(12899, null), type: "string" },
      categories: {
        description: g(12900, null),
        type: "array",
        uniqueItems: !0,
        items: {
          oneOf: [
            { type: "string", enum: H0t },
            {
              type: "string",
              const: "Languages",
              deprecationMessage: g(12901, null),
            },
          ],
        },
      },
      galleryBanner: {
        type: "object",
        description: g(12902, null),
        properties: {
          color: { description: g(12903, null), type: "string" },
          theme: {
            description: g(12904, null),
            type: "string",
            enum: ["dark", "light"],
          },
        },
      },
      contributes: {
        description: g(12905, null),
        type: "object",
        properties: {},
        default: {},
      },
      preview: { type: "boolean", description: g(12906, null) },
      enableProposedApi: {
        type: "boolean",
        deprecationMessage: g(12907, null),
      },
      enabledApiProposals: {
        markdownDescription: g(12908, null),
        type: "array",
        uniqueItems: !0,
        items: {
          type: "string",
          enum: Object.keys(wB).map((i) => i),
          markdownEnumDescriptions: Object.values(wB).map((i) => i.proposal),
        },
      },
      api: {
        markdownDescription: g(12909, null),
        type: "string",
        enum: ["none"],
        enumDescriptions: [g(12910, null)],
      },
      activationEvents: {
        description: g(12911, null),
        type: "array",
        items: {
          type: "string",
          defaultSnippets: [
            {
              label: "onWebviewPanel",
              description: g(12912, null),
              body: "onWebviewPanel:viewType",
            },
            {
              label: "onLanguage",
              description: g(12913, null),
              body: "onLanguage:${1:languageId}",
            },
            {
              label: "onCommand",
              description: g(12914, null),
              body: "onCommand:${2:commandId}",
            },
            { label: "onDebug", description: g(12915, null), body: "onDebug" },
            {
              label: "onDebugInitialConfigurations",
              description: g(12916, null),
              body: "onDebugInitialConfigurations",
            },
            {
              label: "onDebugDynamicConfigurations",
              description: g(12917, null),
              body: "onDebugDynamicConfigurations",
            },
            {
              label: "onDebugResolve",
              description: g(12918, null),
              body: "onDebugResolve:${6:type}",
            },
            {
              label: "onDebugAdapterProtocolTracker",
              description: g(12919, null),
              body: "onDebugAdapterProtocolTracker:${6:type}",
            },
            {
              label: "workspaceContains",
              description: g(12920, null),
              body: "workspaceContains:${4:filePattern}",
            },
            {
              label: "onStartupFinished",
              description: g(12921, null),
              body: "onStartupFinished",
            },
            {
              label: "onTaskType",
              description: g(12922, null),
              body: "onTaskType:${1:taskType}",
            },
            {
              label: "onFileSystem",
              description: g(12923, null),
              body: "onFileSystem:${1:scheme}",
            },
            {
              label: "onEditSession",
              description: g(12924, null),
              body: "onEditSession:${1:scheme}",
            },
            {
              label: "onSearch",
              description: g(12925, null),
              body: "onSearch:${7:scheme}",
            },
            {
              label: "onView",
              body: "onView:${5:viewId}",
              description: g(12926, null),
            },
            { label: "onUri", body: "onUri", description: g(12927, null) },
            {
              label: "onOpenExternalUri",
              body: "onOpenExternalUri",
              description: g(12928, null),
            },
            {
              label: "onCustomEditor",
              body: "onCustomEditor:${9:viewType}",
              description: g(12929, null),
            },
            {
              label: "onNotebook",
              body: "onNotebook:${1:type}",
              description: g(12930, null),
            },
            {
              label: "onAuthenticationRequest",
              body: "onAuthenticationRequest:${11:authenticationProviderId}",
              description: g(12931, null),
            },
            {
              label: "onRenderer",
              description: g(12932, null),
              body: "onRenderer:${11:rendererId}",
            },
            {
              label: "onTerminalProfile",
              body: "onTerminalProfile:${1:terminalId}",
              description: g(12933, null),
            },
            {
              label: "onTerminalQuickFixRequest",
              body: "onTerminalQuickFixRequest:${1:quickFixId}",
              description: g(12934, null),
            },
            {
              label: "onWalkthrough",
              body: "onWalkthrough:${1:walkthroughID}",
              description: g(12935, null),
            },
            {
              label: "onIssueReporterOpened",
              body: "onIssueReporterOpened",
              description: g(12936, null),
            },
            {
              label: "onChatParticipant",
              body: "onChatParticipant:${1:participantId}",
              description: g(12937, null),
            },
            {
              label: "onLanguageModelTool",
              body: "onLanguageModelTool:${1:toolId}",
              description: g(12938, null),
            },
            {
              label: "onTerminalCompletionsRequested",
              body: "onTerminalCompletionsRequested",
              description: g(12939, null),
            },
            { label: "*", description: g(12940, null), body: "*" },
          ],
        },
      },
      badges: {
        type: "array",
        description: g(12941, null),
        items: {
          type: "object",
          required: ["url", "href", "description"],
          properties: {
            url: { type: "string", description: g(12942, null) },
            href: { type: "string", description: g(12943, null) },
            description: { type: "string", description: g(12944, null) },
          },
        },
      },
      markdown: {
        type: "string",
        description: g(12945, null),
        enum: ["github", "standard"],
        default: "github",
      },
      qna: {
        default: "marketplace",
        description: g(12946, null),
        anyOf: [
          { type: ["string", "boolean"], enum: ["marketplace", !1] },
          { type: "string" },
        ],
      },
      extensionDependencies: {
        description: g(12947, null),
        type: "array",
        uniqueItems: !0,
        items: { type: "string", pattern: QM },
      },
      extensionPack: {
        description: g(12948, null),
        type: "array",
        uniqueItems: !0,
        items: { type: "string", pattern: QM },
      },
      extensionKind: {
        description: g(12949, null),
        type: "array",
        items: D$t,
        default: ["workspace"],
        defaultSnippets: [
          { body: ["ui"], description: g(12950, null) },
          { body: ["workspace"], description: g(12951, null) },
          { body: ["ui", "workspace"], description: g(12952, null) },
          { body: ["workspace", "ui"], description: g(12953, null) },
          { body: [], description: g(12954, null) },
        ],
      },
      capabilities: {
        description: g(12955, null),
        type: "object",
        properties: {
          virtualWorkspaces: {
            description: g(12956, null),
            type: ["boolean", "object"],
            defaultSnippets: [
              {
                label: "limited",
                body: { supported: "${1:limited}", description: "${2}" },
              },
              { label: "false", body: { supported: !1, description: "${2}" } },
            ],
            default: (!0).valueOf,
            properties: {
              supported: {
                markdownDescription: g(12957, null),
                type: ["string", "boolean"],
                enum: ["limited", !0, !1],
                enumDescriptions: [
                  g(12958, null),
                  g(12959, null),
                  g(12960, null),
                ],
              },
              description: {
                type: "string",
                markdownDescription: g(12961, null),
              },
            },
          },
          untrustedWorkspaces: {
            description: g(12962, null),
            type: "object",
            required: ["supported"],
            defaultSnippets: [
              { body: { supported: "${1:limited}", description: "${2}" } },
            ],
            properties: {
              supported: {
                markdownDescription: g(12963, null),
                type: ["string", "boolean"],
                enum: ["limited", !0, !1],
                enumDescriptions: [
                  g(12964, null),
                  g(12965, null),
                  g(12966, null),
                ],
              },
              restrictedConfigurations: {
                description: g(12967, null),
                type: "array",
                items: { type: "string" },
              },
              description: {
                type: "string",
                markdownDescription: g(12968, null),
              },
            },
          },
        },
      },
      sponsor: {
        description: g(12969, null),
        type: "object",
        defaultSnippets: [{ body: { url: "${1:https:}" } }],
        properties: { url: { description: g(12970, null), type: "string" } },
      },
      scripts: {
        type: "object",
        properties: {
          "vscode:prepublish": { description: g(12971, null), type: "string" },
          "vscode:uninstall": { description: g(12972, null), type: "string" },
        },
      },
      icon: { type: "string", description: g(12973, null) },
      l10n: { type: "string", description: g(12974, null) },
      pricing: {
        type: "string",
        markdownDescription: g(12975, null),
        enum: ["Free", "Trial"],
        default: "Free",
      },
    },
  },
  F$t = class {
    constructor() {
      this.a = new Map()
    }
    registerExtensionPoint(i) {
      if (this.a.has(i.extensionPoint))
        throw new Error("Duplicate extension point: " + i.extensionPoint)
      const t = new R$t(
        i.extensionPoint,
        i.defaultExtensionKind,
        i.canHandleResolver,
      )
      return (
        this.a.set(i.extensionPoint, t),
        i.activationEventsGenerator &&
          cPt.register(i.extensionPoint, i.activationEventsGenerator),
        (BH.properties.contributes.properties[i.extensionPoint] = i.jsonSchema),
        OH.registerSchema(Sst, BH),
        t
      )
    }
    getExtensionPoints() {
      return Array.from(this.a.values())
    }
  },
  Est = { ExtensionsRegistry: "ExtensionsRegistry" }
Si.add(Est.ExtensionsRegistry, new F$t())
var A$t = Si.as(Est.ExtensionsRegistry)
OH.registerSchema(Sst, BH),
  OH.registerSchema(W0t, {
    properties: {
      extensionEnabledApiProposals: {
        description: g(12976, null),
        type: "object",
        properties: {},
        additionalProperties: {
          anyOf: [
            {
              type: "array",
              uniqueItems: !0,
              items: {
                type: "string",
                enum: Object.keys(wB),
                markdownEnumDescriptions: Object.values(wB).map(
                  (i) => i.proposal,
                ),
              },
            },
          ],
        },
      },
    },
  })
var _$t = {
    type: "object",
    additionalProperties: !1,
    properties: {
      type: { type: "string", description: g(10421, null) },
      required: { type: "array", items: { type: "string" } },
      properties: {
        type: "object",
        description: g(10422, null),
        additionalProperties: {
          $ref: "http://json-schema.org/draft-07/schema#",
        },
      },
      when: {
        type: "string",
        markdownDescription: g(10423, null),
        default: "",
      },
    },
  },
  qH
;(function (i) {
  function t(e, s, r) {
    if (!e) return
    const a = _t(e.type) ? e.type : void 0
    if (!a || a.length === 0) {
      r.error(g(10424, null))
      return
    }
    const o = []
    if (Array.isArray(e.required))
      for (const c of e.required) _t(c) && o.push(c)
    return {
      extensionId: s.value,
      taskType: a,
      required: o,
      properties: e.properties ? pe(e.properties) : {},
      when: e.when ? ui.deserialize(e.when) : void 0,
    }
  }
  i.from = t
})(qH || (qH = {}))
var O$t = A$t.registerExtensionPoint({
    extensionPoint: "taskDefinitions",
    activationEventsGenerator: (i, t) => {
      for (const e of i) e.type && t.push(`onTaskType:${e.type}`)
    },
    jsonSchema: { description: g(10425, null), type: "array", items: _$t },
  }),
  B$t = class {
    constructor() {
      ;(this.d = new J()),
        (this.onDefinitionsChanged = this.d.event),
        (this.a = Object.create(null)),
        (this.b = new Promise((i, t) => {
          O$t.setHandler((e, s) => {
            this.c = void 0
            try {
              for (const r of s.removed) {
                const a = r.value
                for (const o of a)
                  this.a && o.type && this.a[o.type] && delete this.a[o.type]
              }
              for (const r of s.added) {
                const a = r.value
                for (const o of a) {
                  const c = qH.from(o, r.description.identifier, r.collector)
                  c && (this.a[c.taskType] = c)
                }
              }
              ;(s.removed.length > 0 || s.added.length > 0) && this.d.fire()
            } catch {}
            i(void 0)
          })
        }))
    }
    onReady() {
      return this.b
    }
    get(i) {
      return this.a[i]
    }
    all() {
      return Object.keys(this.a).map((i) => this.a[i])
    }
    getJsonSchema() {
      if (this.c === void 0) {
        const i = []
        for (const t of this.all()) {
          const e = { type: "object", additionalProperties: !1 }
          t.required.length > 0 && (e.required = t.required.slice(0)),
            t.properties !== void 0
              ? (e.properties = pe(t.properties))
              : (e.properties = Object.create(null)),
            (e.properties.type = { type: "string", enum: [t.taskType] }),
            i.push(e)
        }
        this.c = { oneOf: i }
      }
      return this.c
    }
  },
  q$t = new B$t(),
  U$t = "settings",
  aQt = new W("taskRunning", !1, g(10426, null)),
  oQt = p7(10428, "Tasks"),
  yB
;(function (i) {
  ;(i[(i.Escape = 1)] = "Escape"),
    (i[(i.Strong = 2)] = "Strong"),
    (i[(i.Weak = 3)] = "Weak")
})(yB || (yB = {})),
  (function (i) {
    function t(e) {
      if (!e) return i.Strong
      switch (e.toLowerCase()) {
        case "escape":
          return i.Escape
        case "strong":
          return i.Strong
        case "weak":
          return i.Weak
        default:
          return i.Strong
      }
    }
    i.from = t
  })(yB || (yB = {}))
var Ist
;(function (i) {
  i.defaults = { cwd: "${workspaceFolder}" }
})(Ist || (Ist = {}))
var hm
;(function (i) {
  ;(i[(i.Always = 1)] = "Always"),
    (i[(i.Silent = 2)] = "Silent"),
    (i[(i.Never = 3)] = "Never")
})(hm || (hm = {})),
  (function (i) {
    function t(e) {
      switch (e.toLowerCase()) {
        case "always":
          return i.Always
        case "silent":
          return i.Silent
        case "never":
          return i.Never
        default:
          return i.Always
      }
    }
    i.fromString = t
  })(hm || (hm = {}))
var dm
;(function (i) {
  ;(i[(i.Never = 1)] = "Never"),
    (i[(i.OnProblem = 2)] = "OnProblem"),
    (i[(i.Always = 3)] = "Always")
})(dm || (dm = {})),
  (function (i) {
    function t(e) {
      switch (e.toLowerCase()) {
        case "always":
          return i.Always
        case "never":
          return i.Never
        case "onproblem":
          return i.OnProblem
        default:
          return i.OnProblem
      }
    }
    i.fromString = t
  })(dm || (dm = {}))
var mm
;(function (i) {
  ;(i[(i.Shared = 1)] = "Shared"),
    (i[(i.Dedicated = 2)] = "Dedicated"),
    (i[(i.New = 3)] = "New")
})(mm || (mm = {})),
  (function (i) {
    function t(e) {
      switch (e.toLowerCase()) {
        case "shared":
          return i.Shared
        case "dedicated":
          return i.Dedicated
        case "new":
          return i.New
        default:
          return i.Shared
      }
    }
    i.fromString = t
  })(mm || (mm = {}))
var Pst
;(function (i) {
  i.defaults = {
    echo: !0,
    reveal: hm.Always,
    revealProblems: dm.Never,
    focus: !1,
    panel: mm.Shared,
    showReuseMessage: !0,
    clear: !1,
  }
})(Pst || (Pst = {}))
var bB
;(function (i) {
  ;(i[(i.Shell = 1)] = "Shell"),
    (i[(i.Process = 2)] = "Process"),
    (i[(i.CustomExecution = 3)] = "CustomExecution")
})(bB || (bB = {})),
  (function (i) {
    function t(s) {
      switch (s.toLowerCase()) {
        case "shell":
          return i.Shell
        case "process":
          return i.Process
        case "customExecution":
          return i.CustomExecution
        default:
          return i.Process
      }
    }
    i.fromString = t
    function e(s) {
      switch (s) {
        case i.Shell:
          return "shell"
        case i.Process:
          return "process"
        case i.CustomExecution:
          return "customExecution"
        default:
          return "process"
      }
    }
    i.toString = e
  })(bB || (bB = {}))
var $st
;(function (i) {
  function t(e) {
    return _t(e) ? e : e.value
  }
  i.value = t
})($st || ($st = {}))
var xst
;(function (i) {
  ;(i.Clean = { _id: "clean", isDefault: !1 }),
    (i.Build = { _id: "build", isDefault: !1 }),
    (i.Rebuild = { _id: "rebuild", isDefault: !1 }),
    (i.Test = { _id: "test", isDefault: !1 })
  function t(s) {
    return (
      s === i.Clean._id ||
      s === i.Build._id ||
      s === i.Rebuild._id ||
      s === i.Test._id
    )
  }
  i.is = t
  function e(s) {
    if (s !== void 0)
      return _t(s) ? (t(s) ? { _id: s, isDefault: !1 } : void 0) : s
  }
  i.from = e
})(xst || (xst = {}))
var Nst
;(function (i) {
  ;(i[(i.Global = 1)] = "Global"),
    (i[(i.Workspace = 2)] = "Workspace"),
    (i[(i.Folder = 3)] = "Folder")
})(Nst || (Nst = {}))
var Cst
;(function (i) {
  ;(i.Workspace = "workspace"),
    (i.Extension = "extension"),
    (i.InMemory = "inMemory"),
    (i.WorkspaceFile = "workspaceFile"),
    (i.User = "user")
  function t(e) {
    switch (e) {
      case i.User:
        return 2
      case i.WorkspaceFile:
        return 5
      default:
        return 6
    }
  }
  i.toConfigurationTarget = t
})(Cst || (Cst = {}))
var Jst
;(function (i) {
  ;(i.parallel = "parallel"), (i.sequence = "sequence")
})(Jst || (Jst = {}))
var UH
;(function (i) {
  ;(i[(i.default = 1)] = "default"), (i[(i.folderOpen = 2)] = "folderOpen")
})(UH || (UH = {}))
var Lst
;(function (i) {
  i.defaults = { reevaluateOnRerun: !0, runOn: UH.default, instanceLimit: 1 }
})(Lst || (Lst = {}))
var TB
;(function (i) {
  ;(i[(i.Process = 1)] = "Process"), (i[(i.Terminal = 2)] = "Terminal")
})(TB || (TB = {})),
  (function (i) {
    i._default = i.Terminal
  })(TB || (TB = {}))
var Rst
;(function (i) {
  ;(i[(i.V0_1_0 = 1)] = "V0_1_0"), (i[(i.V2_0_0 = 2)] = "V2_0_0")
})(Rst || (Rst = {}))
var Dst
;(function (i) {
  ;(i.DependsOnStarted = "dependsOnStarted"),
    (i.AcquiredInput = "acquiredInput"),
    (i.Start = "start"),
    (i.ProcessStarted = "processStarted"),
    (i.Active = "active"),
    (i.Inactive = "inactive"),
    (i.Changed = "changed"),
    (i.Terminated = "terminated"),
    (i.ProcessEnded = "processEnded"),
    (i.End = "end")
})(Dst || (Dst = {}))
var Fst
;(function (i) {
  ;(i.SingleRun = "singleRun"), (i.Background = "background")
})(Fst || (Fst = {}))
var Ast
;(function (i) {
  ;(i[(i.System = 0)] = "System"),
    (i[(i.User = 1)] = "User"),
    (i[(i.FolderOpen = 2)] = "FolderOpen"),
    (i[(i.ConfigurationChange = 3)] = "ConfigurationChange"),
    (i[(i.Reconnect = 4)] = "Reconnect")
})(Ast || (Ast = {}))
var _st
;(function (i) {
  function t(l) {
    return {
      taskId: l._id,
      taskName: l.configurationProperties.name,
      runType: l.configurationProperties.isBackground
        ? "background"
        : "singleRun",
      group: l.configurationProperties.group,
      __task: l,
    }
  }
  function e(l, u, d) {
    return { ...t(l), kind: "start", terminalId: u, resolvedVariables: d }
  }
  i.start = e
  function s(l, u, d) {
    return { ...t(l), kind: "processStarted", terminalId: u, processId: d }
  }
  i.processStarted = s
  function r(l, u, d) {
    return { ...t(l), kind: "processEnded", terminalId: u, exitCode: d }
  }
  i.processEnded = r
  function a(l, u, d) {
    return { ...t(l), kind: "terminated", exitReason: d, terminalId: u }
  }
  i.terminated = a
  function o(l, u, d) {
    return { ...t(u), kind: l, terminalId: d }
  }
  i.general = o
  function c() {
    return { kind: "changed" }
  }
  i.changed = c
})(_st || (_st = {}))
var kB
;(function (i) {
  function t(s) {
    const r = Object.keys(s).sort()
    let a = ""
    for (const o of r) {
      let c = s[o]
      c instanceof Object
        ? (c = t(c))
        : typeof c == "string" && (c = c.replace(/,/g, ",,")),
        (a += o + "," + c + ",")
    }
    return a
  }
  function e(s) {
    const a = { _key: t(s), type: s.taskType }
    return Object.assign(a, s), a
  }
  i.create = e
})(kB || (kB = {}))
var Ost
;(function (i) {
  ;(i.AutoDetect = "task.autoDetect"),
    (i.SaveBeforeRun = "task.saveBeforeRun"),
    (i.ShowDecorations = "task.showDecorations"),
    (i.ProblemMatchersNeverPrompt = "task.problemMatchers.neverPrompt"),
    (i.SlowProviderWarning = "task.slowProviderWarning"),
    (i.QuickOpenHistory = "task.quickOpen.history"),
    (i.QuickOpenDetail = "task.quickOpen.detail"),
    (i.QuickOpenSkip = "task.quickOpen.skip"),
    (i.QuickOpenShowAll = "task.quickOpen.showAll"),
    (i.AllowAutomaticTasks = "task.allowAutomaticTasks"),
    (i.Reconnection = "task.reconnection"),
    (i.VerboseLogging = "task.verboseLogging")
})(Ost || (Ost = {}))
var Bst
;(function (i) {
  ;(i.Tasks = "tasks"),
    (i.SuppressTaskName = "tasks.suppressTaskName"),
    (i.Windows = "tasks.windows"),
    (i.Osx = "tasks.osx"),
    (i.Linux = "tasks.linux"),
    (i.ShowOutput = "tasks.showOutput"),
    (i.IsShellCommand = "tasks.isShellCommand"),
    (i.ServiceTestSetting = "tasks.service.testSetting")
})(Bst || (Bst = {}))
var qst
;(function (i) {
  function t(e, s) {
    const r = q$t.get(e.type)
    if (r === void 0) {
      const l = pe(e)
      return delete l._key, kB.create(l)
    }
    const a = Object.create(null)
    a.type = r.taskType
    const o = new Set()
    r.required.forEach((l) => o.add(l))
    const c = r.properties
    for (const l of Object.keys(c)) {
      const u = e[l]
      if (u != null) a[l] = u
      else if (o.has(l)) {
        const d = c[l]
        if (d.default !== void 0) a[l] = pe(d.default)
        else
          switch (d.type) {
            case "boolean":
              a[l] = !1
              break
            case "number":
            case "integer":
              a[l] = 0
              break
            case "string":
              a[l] = ""
              break
            default:
              s.error(g(10427, null, JSON.stringify(e, void 0, 0), l))
              return
          }
      }
    }
    return kB.create(a)
  }
  i.createTaskIdentifier = t
})(qst || (qst = {}))
var SB
;(function (i) {
  function t(s) {
    if (s != null) return s
  }
  i.from = t
  function e(s) {
    if (s != null) return s
  }
  i.to = e
})(SB || (SB = {}))
var EB
;(function (i) {
  function t(s) {
    if (s != null) return s
  }
  i.from = t
  function e(s) {
    if (s != null) return s
  }
  i.to = e
})(EB || (EB = {}))
var MH
;(function (i) {
  function t(s) {
    if (s != null) return s
  }
  i.from = t
  function e(s) {
    if (s != null) return s
  }
  i.to = e
})(MH || (MH = {}))
var fm
;(function (i) {
  function t(r) {
    if (r) {
      const a = r
      return a && !!a.process
    } else return !1
  }
  i.is = t
  function e(r) {
    if (r == null) return
    const a = { process: r.process, args: r.args }
    return r.options && (a.options = MH.from(r.options)), a
  }
  i.from = e
  function s(r) {
    if (r != null) return new Kc(r.process, r.args, r.options)
  }
  i.to = s
})(fm || (fm = {}))
var HH
;(function (i) {
  function t(s) {
    if (s != null) return s
  }
  i.from = t
  function e(s) {
    if (s != null) return s
  }
  i.to = e
})(HH || (HH = {}))
var pm
;(function (i) {
  function t(r) {
    if (r) {
      const a = r
      return a && (!!a.commandLine || !!a.command)
    } else return !1
  }
  i.is = t
  function e(r) {
    if (r == null) return
    const a = {}
    return (
      r.commandLine !== void 0
        ? (a.commandLine = r.commandLine)
        : ((a.command = r.command), (a.args = r.args)),
      r.options && (a.options = HH.from(r.options)),
      a
    )
  }
  i.from = e
  function s(r) {
    if (!(r == null || (r.command === void 0 && r.commandLine === void 0)))
      return r.commandLine
        ? new wo(r.commandLine, r.options)
        : new wo(r.command, r.args ? r.args : [], r.options)
  }
  i.to = s
})(pm || (pm = {}))
var fr
;(function (i) {
  function t(r) {
    if (r) {
      const a = r
      return a && a.customExecution === "customExecution"
    } else return !1
  }
  i.is = t
  function e(r) {
    return { customExecution: "customExecution" }
  }
  i.from = e
  function s(r, a) {
    return a.get(r)
  }
  i.to = s
})(fr || (fr = {}))
var WH
;(function (i) {
  function t(e, s) {
    let r
    return (
      e.scope !== void 0 && typeof e.scope != "number"
        ? (r = e.scope.uri)
        : e.scope !== void 0 &&
          typeof e.scope == "number" &&
          (e.scope === ca.Workspace && s && s.workspaceFile
            ? (r = s.workspaceFile)
            : (r = U$t)),
      { id: e._id, workspaceFolder: r }
    )
  }
  i.from = t
})(WH || (WH = {}))
var jH
;(function (i) {
  function t(e) {
    if (e != null) return { _id: e.id, isDefault: e.isDefault }
  }
  i.from = t
})(jH || (jH = {}))
var Mr
;(function (i) {
  function t(r, a) {
    if (r == null) return []
    const o = []
    for (const c of r) {
      const l = e(c, a)
      l && o.push(l)
    }
    return o
  }
  i.fromMany = t
  function e(r, a) {
    if (r == null) return
    let o
    r.execution instanceof Kc
      ? (o = fm.from(r.execution))
      : r.execution instanceof wo
        ? (o = pm.from(r.execution))
        : r.execution && r.execution instanceof K2 && (o = fr.from(r.execution))
    const c = SB.from(r.definition)
    let l
    return (
      r.scope
        ? typeof r.scope == "number"
          ? (l = r.scope)
          : (l = r.scope.uri)
        : (l = ca.Workspace),
      !c || !l
        ? void 0
        : {
            _id: r._id,
            definition: c,
            name: r.name,
            source: {
              extensionId: a.identifier.value,
              label: r.source,
              scope: l,
            },
            execution: o,
            isBackground: r.isBackground,
            group: jH.from(r.group),
            presentationOptions: EB.from(r.presentationOptions),
            problemMatchers: Ir(r.problemMatchers),
            hasDefinedMatchers: r.hasDefinedMatchers,
            runOptions: r.runOptions ? r.runOptions : { reevaluateOnRerun: !0 },
            detail: r.detail,
          }
    )
  }
  i.from = e
  async function s(r, a, o) {
    if (r == null) return
    let c
    fm.is(r.execution)
      ? (c = fm.to(r.execution))
      : pm.is(r.execution)
        ? (c = pm.to(r.execution))
        : fr.is(r.execution) && (c = fr.to(r._id, o))
    const l = SB.to(r.definition)
    let u
    if (
      (r.source &&
        (r.source.scope !== void 0
          ? typeof r.source.scope == "number"
            ? (u = r.source.scope)
            : (u = await a.resolveWorkspaceFolder(S.revive(r.source.scope)))
          : (u = ca.Workspace)),
      !l || !u)
    )
      return
    const d = new uO(l, u, r.name, r.source.label, c, r.problemMatchers)
    return (
      r.isBackground !== void 0 && (d.isBackground = r.isBackground),
      r.group !== void 0 &&
        ((d.group = qh.from(r.group._id)),
        d.group &&
          r.group.isDefault &&
          ((d.group = new qh(d.group.id, d.group.label)),
          r.group.isDefault === !0 && (d.group.isDefault = r.group.isDefault))),
      r.presentationOptions &&
        (d.presentationOptions = EB.to(r.presentationOptions)),
      r._id && (d._id = r._id),
      r.detail && (d.detail = r.detail),
      d
    )
  }
  i.to = s
})(Mr || (Mr = {}))
var VH
;(function (i) {
  function t(s) {
    return s
  }
  i.from = t
  function e(s) {
    if (s) return Object.assign(Object.create(null), s)
  }
  i.to = e
})(VH || (VH = {}))
var GH = class {
    #t
    constructor(i, t, e) {
      ;(this._id = t), (this.a = e), (this.#t = i)
    }
    get task() {
      return this.a
    }
    terminate() {
      this.#t.terminateTask(this)
    }
    fireDidStartProcess(i) {}
    fireDidEndProcess(i) {}
  },
  IB = class {
    constructor(t, e, s, r, a, o, c, l) {
      ;(this.q = new J()),
        (this.r = new J()),
        (this.s = new J()),
        (this.u = new J()),
        (this.a = t.getProxy(K.MainThreadTask)),
        (this.b = s),
        (this.c = r),
        (this.d = a),
        (this.e = o),
        (this.h = 0),
        (this.j = new Map()),
        (this.k = new Map()),
        (this.l = new Map()),
        (this.m = new Map()),
        (this.n = new Set()),
        (this.o = new Map()),
        (this.f = c),
        (this.g = l),
        this.a.$registerSupportedExecutions(!0)
    }
    registerTaskProvider(t, e, s) {
      if (!s) return new Ht(() => {})
      const r = this.x()
      return (
        this.j.set(r, { type: e, provider: s, extension: t }),
        this.a.$registerTaskProvider(r, e),
        new Ht(() => {
          this.j.delete(r), this.a.$unregisterTaskProvider(r)
        })
      )
    }
    registerTaskSystem(t, e) {
      this.a.$registerTaskSystem(t, e)
    }
    fetchTasks(t) {
      return this.a.$fetchTasks(VH.from(t)).then(async (e) => {
        const s = []
        for (const r of e) {
          const a = await Mr.to(r, this.b, this.m)
          a && s.push(a)
        }
        return s
      })
    }
    get taskExecutions() {
      const t = []
      return this.k.forEach((e) => t.push(e)), t
    }
    terminateTask(t) {
      if (!(t instanceof GH))
        throw new Error("No valid task execution provided")
      return this.a.$terminateTask(t._id)
    }
    get onDidStartTask() {
      return this.q.event
    }
    async $onDidStartTask(t, e, s) {
      const r = this.m.get(t.id)
      r &&
        (this.o.set(t.id, r),
        this.e.attachPtyToTerminal(e, await r.callback(s))),
        (this.p = t.id),
        this.q.fire({ execution: await this.z(t) })
    }
    get onDidEndTask() {
      return this.r.event
    }
    async $OnDidEndTask(t) {
      if (!this.l.has(t.id)) return
      const e = await this.z(t)
      this.l.delete(t.id),
        this.k.delete(t.id),
        this.B(t),
        this.r.fire({ execution: e })
    }
    get onDidStartTaskProcess() {
      return this.s.event
    }
    async $onDidStartTaskProcess(t) {
      const e = await this.z(t.id)
      this.s.fire({ execution: e, processId: t.processId })
    }
    get onDidEndTaskProcess() {
      return this.u.event
    }
    async $onDidEndTaskProcess(t) {
      const e = await this.z(t.id)
      this.u.fire({ execution: e, exitCode: t.exitCode })
    }
    $provideTasks(t, e) {
      const s = this.j.get(t)
      if (!s) return Promise.reject(new Error("no handler found"))
      const r = [],
        a = Ci(() => s.provider.provideTasks(ce.None)).then((o) =>
          this.v(e, r, s, o),
        )
      return new Promise((o) => {
        a.then((c) => {
          Promise.all(r).then(() => {
            o(c)
          })
        })
      })
    }
    async $resolveTask(t, e) {
      const s = this.j.get(t)
      if (!s) return Promise.reject(new Error("no handler found"))
      if (e.definition.type !== s.type)
        throw new Error(
          `Unexpected: Task of type [${e.definition.type}] cannot be resolved by provider of type [${s.type}].`,
        )
      const r = await Mr.to(e, this.b, this.m)
      if (!r) throw new Error("Unexpected: Task cannot be resolved.")
      const a = await s.provider.resolveTask(r, ce.None)
      if (!a) return
      this.A(a, s)
      const o = Mr.from(a, s.extension)
      if (!o) throw new Error("Unexpected: Task cannot be resolved.")
      if (a.definition !== r.definition)
        throw new Error(
          "Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.",
        )
      return fr.is(o.execution) && (await this.y(o, a, !0)), await this.w(o)
    }
    x() {
      return this.h++
    }
    async y(t, e, s) {
      const r = await this.a.$createTaskId(t)
      !s && !this.m.has(r) && (this.n.add(r), this.o.set(r, e.execution)),
        this.m.set(r, e.execution)
    }
    async z(t, e) {
      if (typeof t == "string") {
        const a = this.l.get(t)
        if (!a)
          throw new xs("Unexpected: The specified task is missing an execution")
        return a
      }
      const s = this.l.get(t.id)
      if (s) return s
      let r
      return (
        e
          ? (r = Promise.resolve(new GH(this, t.id, e)))
          : (r = Mr.to(t.task, this.b, this.m).then((a) => {
              if (!a) throw new xs("Unexpected: Task does not exist.")
              return new GH(this, t.id, a)
            })),
        this.l.set(t.id, r),
        r.then((a) => (this.k.set(t.id, a), a))
      )
    }
    A(t, e) {
      t._deprecated &&
        this.g.report(
          "Task.constructor",
          e.extension,
          "Use the Task constructor that takes a `scope` instead.",
        )
    }
    B(t) {
      this.o.get(t.id) && this.o.delete(t.id),
        this.n.has(t.id) &&
          this.p !== t.id &&
          (this.m.delete(t.id), this.n.delete(t.id))
      const s = this.n.values()
      let r = s.next()
      for (; !r.done; )
        !this.o.has(r.value) &&
          this.p !== r.value &&
          (this.m.delete(r.value), this.n.delete(r.value)),
          (r = s.next())
    }
  }
IB = __decorate(
  [
    __param(0, Ot),
    __param(1, ti),
    __param(2, dr),
    __param(3, Fo),
    __param(4, Ds),
    __param(5, Pn),
    __param(6, Rt),
    __param(7, um),
  ],
  IB,
)
var zH = class extends IB {
  constructor(t, e, s, r, a, o, c, l) {
    super(t, e, s, r, a, o, c, l),
      this.registerTaskSystem(G.vscodeRemote, {
        scheme: G.vscodeRemote,
        authority: "",
        platform: mdt(0),
      })
  }
  async executeTask(t, e) {
    if (!e.execution)
      throw new Error("Tasks to execute must include an execution")
    const s = Mr.from(e, t)
    if (s === void 0) throw new Error("Task is not valid")
    if (fr.is(s.execution)) await this.y(s, e, !1)
    else throw new h7()
    const r = await this.z(await this.a.$getTaskExecution(s), e)
    return (
      this.a.$executeTask(s).catch((a) => {
        throw new Error(a)
      }),
      r
    )
  }
  v(t, e, s, r) {
    const a = []
    if (r)
      for (const o of r) {
        if ((this.A(o, s), !o.definition || !t[o.definition.type])) {
          const l = o.source ? o.source : "No task source"
          this.f.warn(
            `The task [${l}, ${o.name}] uses an undefined task type. The task will be ignored in the future.`,
          )
        }
        const c = Mr.from(o, s.extension)
        c && fr.is(c.execution)
          ? (a.push(c), e.push(this.y(c, o, !0)))
          : this.f.warn("Only custom execution tasks supported.")
      }
    return { tasks: a, extension: s.extension }
  }
  async w(t) {
    if (fr.is(t.execution)) return t
    this.f.warn("Only custom execution tasks supported.")
  }
  async $resolveVariables(t, e) {
    return { process: void 0, variables: Object.create(null) }
  }
  async $jsonTasksSupported() {
    return !1
  }
  async $findExecutable(t, e, s) {}
}
zH = __decorate(
  [
    __param(0, Ot),
    __param(1, ti),
    __param(2, dr),
    __param(3, Fo),
    __param(4, Ds),
    __param(5, Pn),
    __param(6, Rt),
    __param(7, um),
  ],
  zH,
)
var YH = X("IExtHostTask"),
  Ust = class {
    constructor() {
      ;(this.f = new Map()),
        (this.m = []),
        (this.n = new J()),
        (this.o = new J()),
        (this.d = 1)
    }
    get onError() {
      return this.n.event
    }
    get onExit() {
      return this.o.event
    }
    onMessage(i) {
      this.k &&
        this.n.fire(
          new Error("attempt to set more than one 'Message' callback"),
        ),
        (this.k = i)
    }
    onEvent(i) {
      this.j &&
        this.n.fire(new Error("attempt to set more than one 'Event' callback")),
        (this.j = i)
    }
    onRequest(i) {
      this.g &&
        this.n.fire(
          new Error("attempt to set more than one 'Request' callback"),
        ),
        (this.g = i)
    }
    sendResponse(i) {
      i.seq > 0
        ? this.n.fire(
            new Error(
              `attempt to send more than one response for command ${i.command}`,
            ),
          )
        : this.u("response", i)
    }
    sendRequest(i, t, e, s) {
      const r = { command: i }
      if (
        (t && Object.keys(t).length > 0 && (r.arguments = t),
        this.u("request", r),
        typeof s == "number")
      ) {
        const a = setTimeout(() => {
          clearTimeout(a)
          const o = this.f.get(r.seq)
          if (o) {
            this.f.delete(r.seq)
            const c = {
              type: "response",
              seq: 0,
              request_seq: r.seq,
              success: !1,
              command: i,
              message: g(6137, null, s, i),
            }
            o(c)
          }
        }, s)
      }
      return e && this.f.set(r.seq, e), r.seq
    }
    acceptMessage(i) {
      this.k ? this.k(i) : (this.m.push(i), this.m.length === 1 && this.s())
    }
    q(i, t) {
      return i.type !== "event" || t.type !== "event"
    }
    async s() {
      let i
      for (; this.m.length; ) {
        if (
          ((!i || this.q(this.m[0], i)) && (await Fi(0)),
          (i = this.m.shift()),
          !i)
        )
          return
        switch (i.type) {
          case "event":
            this.j?.(i)
            break
          case "request":
            this.g?.(i)
            break
          case "response": {
            const t = i,
              e = this.f.get(t.request_seq)
            e && (this.f.delete(t.request_seq), e(t))
            break
          }
        }
      }
    }
    u(i, t) {
      ;(t.type = i), (t.seq = this.d++), this.sendMessage(t)
    }
    async w() {
      if (this.f.size === 0) return Promise.resolve()
      const i = new Map()
      this.f.forEach((t, e) => i.set(e, t)),
        await Fi(500),
        i.forEach((t, e) => {
          t({
            type: "response",
            seq: 0,
            request_seq: e,
            success: !1,
            command: "canceled",
            message: "canceled",
          }),
            this.f.delete(e)
        })
    }
    getPendingRequestIds() {
      return Array.from(this.f.keys())
    }
    dispose() {
      this.m = []
    }
  }
function M$t(i) {
  return i.type && (i.label || i.program || i.runtime)
}
var H$t = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/
function W$t(i) {
  return !!(i && i.match(H$t))
}
function Mst(i) {
  if (
    typeof i.path == "string" &&
    !(typeof i.sourceReference == "number" && i.sourceReference > 0)
  ) {
    if (W$t(i.path)) return S.parse(i.path)
    if ($r(i.path)) return S.file(i.path)
  }
  return i.path
}
function Hst(i) {
  if (typeof i.path == "object") {
    const t = S.revive(i.path)
    if (t) return t.scheme === G.file ? t.fsPath : t.toString()
  }
  return i.path
}
function j$t(i, t) {
  const e = t ? Mst : Hst,
    s = pe(i)
  return (
    Wst(s, (r, a) => {
      r && a && (a.path = e(a))
    }),
    s
  )
}
function V$t(i, t) {
  const e = t ? Mst : Hst,
    s = pe(i)
  return (
    Wst(s, (r, a) => {
      !r && a && (a.path = e(a))
    }),
    s
  )
}
function Wst(i, t) {
  switch (i.type) {
    case "event": {
      const e = i
      switch (e.event) {
        case "output":
          t(!1, e.body.source)
          break
        case "loadedSource":
          t(!1, e.body.source)
          break
        case "breakpoint":
          t(!1, e.body.breakpoint.source)
          break
        default:
          break
      }
      break
    }
    case "request": {
      const e = i
      switch (e.command) {
        case "setBreakpoints":
          t(!0, e.arguments.source)
          break
        case "breakpointLocations":
          t(!0, e.arguments.source)
          break
        case "source":
          t(!0, e.arguments.source)
          break
        case "gotoTargets":
          t(!0, e.arguments.source)
          break
        case "launchVSCode":
          e.arguments.args.forEach((s) => t(!1, s))
          break
        default:
          break
      }
      break
    }
    case "response": {
      const e = i
      if (e.success && e.body)
        switch (e.command) {
          case "stackTrace":
            e.body.stackFrames.forEach((s) => t(!1, s.source))
            break
          case "loadedSources":
            e.body.sources.forEach((s) => t(!1, s))
            break
          case "scopes":
            e.body.scopes.forEach((s) => t(!1, s.source))
            break
          case "setFunctionBreakpoints":
            e.body.breakpoints.forEach((s) => t(!1, s.source))
            break
          case "setBreakpoints":
            e.body.breakpoints.forEach((s) => t(!1, s.source))
            break
          case "disassemble":
            e.body?.instructions.forEach((r) => t(!1, r.location))
            break
          case "locations":
            t(!1, e.body?.source)
            break
          default:
            break
        }
      break
    }
  }
}
var Bl = X("IExtHostEditorTabs"),
  jst = class {
    constructor(i, t, e) {
      ;(this.e = e), (this.d = t), this.acceptDtoUpdate(i)
    }
    get apiObject() {
      if (!this.a) {
        const i = this,
          t = {
            get isActive() {
              return i.b.id === i.e()
            },
            get label() {
              return i.b.label
            },
            get input() {
              return i.c
            },
            get isDirty() {
              return i.b.isDirty
            },
            get isPinned() {
              return i.b.isPinned
            },
            get isPreview() {
              return i.b.isPreview
            },
            get group() {
              return i.d.apiObject
            },
          }
        this.a = Object.freeze(t)
      }
      return this.a
    }
    get tabId() {
      return this.b.id
    }
    acceptDtoUpdate(i) {
      ;(this.b = i), (this.c = this.f())
    }
    f() {
      switch (this.b.input.kind) {
        case 1:
          return new vU(S.revive(this.b.input.uri))
        case 2:
          return new RO(
            S.revive(this.b.input.original),
            S.revive(this.b.input.modified),
          )
        case 3:
          return new btt(
            S.revive(this.b.input.base),
            S.revive(this.b.input.input1),
            S.revive(this.b.input.input2),
            S.revive(this.b.input.result),
          )
        case 6:
          return new wU(S.revive(this.b.input.uri), this.b.input.viewType)
        case 7:
          return new Ttt(this.b.input.viewType)
        case 4:
          return new yU(S.revive(this.b.input.uri), this.b.input.notebookType)
        case 5:
          return new bU(
            S.revive(this.b.input.original),
            S.revive(this.b.input.modified),
            this.b.input.notebookType,
          )
        case 8:
          return new ktt()
        case 9:
          return new Stt(
            S.revive(this.b.input.uri),
            S.revive(this.b.input.inputBoxUri),
          )
        case 10:
          return new Ett()
        case 11:
          return new Itt(
            this.b.input.diffEditors.map(
              (i) => new RO(S.revive(i.original), S.revive(i.modified)),
            ),
          )
        default:
          return
      }
    }
  },
  G$t = class {
    constructor(i, t) {
      ;(this.c = []), (this.d = ""), (this.b = i), (this.e = t)
      for (const e of i.tabs)
        e.isActive && (this.d = e.id),
          this.c.push(new jst(e, this, () => this.activeTabId()))
    }
    get apiObject() {
      if (!this.a) {
        const i = this,
          t = {
            get isActive() {
              return i.b.groupId === i.e()
            },
            get viewColumn() {
              return ii.to(i.b.viewColumn)
            },
            get activeTab() {
              return i.c.find((e) => e.tabId === i.d)?.apiObject
            },
            get tabs() {
              return Object.freeze(i.c.map((e) => e.apiObject))
            },
          }
        this.a = Object.freeze(t)
      }
      return this.a
    }
    get groupId() {
      return this.b.groupId
    }
    get tabs() {
      return this.c
    }
    acceptGroupDtoUpdate(i) {
      this.b = i
    }
    acceptTabOperation(i) {
      if (i.kind === 0) {
        const e = new jst(i.tabDto, this, () => this.activeTabId())
        return (
          this.c.splice(i.index, 0, e),
          i.tabDto.isActive && (this.d = e.tabId),
          e
        )
      } else if (i.kind === 1) {
        const e = this.c.splice(i.index, 1)[0]
        if (!e)
          throw new Error(
            `Tab close updated received for index ${i.index} which does not exist`,
          )
        return e.tabId === this.d && (this.d = ""), e
      } else if (i.kind === 3) {
        if (i.oldIndex === void 0)
          throw new Error("Invalid old index on move IPC")
        const e = this.c.splice(i.oldIndex, 1)[0]
        if (!e)
          throw new Error(
            `Tab move updated received for index ${i.oldIndex} which does not exist`,
          )
        return this.c.splice(i.index, 0, e), e
      }
      const t = this.c.find((e) => e.tabId === i.tabDto.id)
      if (!t) throw new Error("INVALID tab")
      return (
        i.tabDto.isActive
          ? (this.d = i.tabDto.id)
          : this.d === i.tabDto.id && !i.tabDto.isActive && (this.d = ""),
        t.acceptDtoUpdate(i.tabDto),
        t
      )
    }
    activeTabId() {
      return this.d
    }
  },
  QH = class {
    constructor(t) {
      ;(this.b = new J()),
        (this.c = new J()),
        (this.e = []),
        (this.a = t.getProxy(K.MainThreadEditorTabs))
    }
    get tabGroups() {
      if (!this.f) {
        const t = this,
          e = {
            onDidChangeTabGroups: t.c.event,
            onDidChangeTabs: t.b.event,
            get all() {
              return Object.freeze(t.e.map((s) => s.apiObject))
            },
            get activeTabGroup() {
              const s = t.d
              return hc(t.e.find((a) => a.groupId === s)?.apiObject)
            },
            close: async (s, r) => {
              const a = Array.isArray(s) ? s : [s]
              return a.length ? (z$t(a[0]) ? this.j(a, r) : this.i(a, r)) : !0
            },
          }
        this.f = Object.freeze(e)
      }
      return this.f
    }
    $acceptEditorTabModel(t) {
      const e = new Set(this.e.map((u) => u.groupId)),
        s = new Set(t.map((u) => u.groupId)),
        r = kht(e, s),
        a = this.e
          .filter((u) => r.removed.includes(u.groupId))
          .map((u) => u.apiObject),
        o = [],
        c = []
      this.e = t.map((u) => {
        const d = new G$t(u, () => this.d)
        return (
          r.added.includes(d.groupId)
            ? o.push(d.apiObject)
            : c.push(d.apiObject),
          d
        )
      })
      const l = hc(t.find((u) => u.isActive === !0)?.groupId)
      l !== void 0 && this.d !== l && (this.d = l),
        this.c.fire(Object.freeze({ opened: o, closed: a, changed: c }))
    }
    $acceptTabGroupUpdate(t) {
      const e = this.e.find((s) => s.groupId === t.groupId)
      if (!e)
        throw new Error("Update Group IPC call received before group creation.")
      e.acceptGroupDtoUpdate(t),
        t.isActive && (this.d = t.groupId),
        this.c.fire(
          Object.freeze({ changed: [e.apiObject], opened: [], closed: [] }),
        )
    }
    $acceptTabOperation(t) {
      const e = this.e.find((r) => r.groupId === t.groupId)
      if (!e)
        throw new Error("Update Tabs IPC call received before group creation.")
      const s = e.acceptTabOperation(t)
      switch (t.kind) {
        case 0:
          this.b.fire(
            Object.freeze({ opened: [s.apiObject], closed: [], changed: [] }),
          )
          return
        case 1:
          this.b.fire(
            Object.freeze({ opened: [], closed: [s.apiObject], changed: [] }),
          )
          return
        case 3:
        case 2:
          this.b.fire(
            Object.freeze({ opened: [], closed: [], changed: [s.apiObject] }),
          )
          return
      }
    }
    g(t) {
      for (const e of this.e)
        for (const s of e.tabs) if (s.apiObject === t) return s
    }
    h(t) {
      return this.e.find((e) => e.apiObject === t)
    }
    async i(t, e) {
      const s = []
      for (const r of t) {
        const a = this.g(r)
        if (!a) throw new Error("Tab close: Invalid tab not found!")
        s.push(a.tabId)
      }
      return this.a.$closeTab(s, e)
    }
    async j(t, e) {
      const s = []
      for (const r of t) {
        const a = this.h(r)
        if (!a) throw new Error("Group close: Invalid group not found!")
        s.push(a.groupId)
      }
      return this.a.$closeGroup(s, e)
    }
  }
QH = __decorate([__param(0, Ot)], QH)
function z$t(i) {
  return i.tabs !== void 0
}
var Y$t = 0,
  Vst = new WeakMap(),
  gm = X("IExtHostTesting"),
  XH = class extends at {
    constructor(t, e, s, r) {
      super(),
        (this.z = e),
        (this.C = s),
        (this.F = r),
        (this.f = this.D(new J())),
        (this.g = new Map()),
        (this.q = this.D(new J())),
        (this.w = new Set()),
        (this.y = new Map()),
        (this.onResultsChanged = this.f.event),
        (this.results = []),
        (this.h = t.getProxy(K.MainThreadTesting)),
        (this.m = new ext(this.h)),
        (this.j = new K$t(this.h, e)),
        s.registerArgumentProcessor({
          processArgument: (a) => {
            switch (a?.$mid) {
              case 16: {
                const o = a,
                  c = o.tests[o.tests.length - 1].item.extId
                return (
                  this.g.get(jt.root(c))?.collection.tree.get(c)?.actual ??
                  $it(a)
                )
              }
              case 18: {
                const { test: o, message: c } = a,
                  l = o.item.extId
                return {
                  test:
                    this.g.get(jt.root(l))?.collection.tree.get(l)?.actual ??
                    $it({ $mid: 16, tests: [o] }),
                  message: kl.to(c),
                }
              }
              default:
                return a
            }
          },
        }),
        s.registerCommand(!1, "testing.getExplorerSelection", async () => {
          const a = await s.executeCommand("_testing.getExplorerSelection"),
            o = (c) => {
              const l = this.g.get(jt.root(c))
              if (l)
                return jt.isRoot(c)
                  ? l.controller
                  : l.collection.tree.get(c)?.actual
            }
          return {
            include: a?.include.map(o).filter(Wa) || [],
            exclude: a?.exclude.map(o).filter(Wa) || [],
          }
        })
    }
    createTestController(t, e, s, r) {
      if (this.g.has(e))
        throw new Error(
          `Attempt to insert a duplicate controller with ID "${e}"`,
        )
      const a = new gt(),
        o = a.add(new IPt(e, s, this.F))
      o.root.label = s
      const c = new Map(),
        l = new Set(),
        u = this.h,
        d = () => {
          let p = 0
          r && (p |= 2)
          const v = f.relatedCodeProvider
          return (
            v &&
              (v?.provideRelatedTests && (p |= 8),
              v?.provideRelatedCode && (p |= 4)),
            p
          )
        },
        m = {
          items: o.root.children,
          get label() {
            return s
          },
          set label(p) {
            ;(s = p), (o.root.label = p), u.$updateController(e, { label: s })
          },
          get refreshHandler() {
            return r
          },
          set refreshHandler(p) {
            ;(r = p), u.$updateController(e, { capabilities: d() })
          },
          get id() {
            return e
          },
          get relatedCodeProvider() {
            return f.relatedCodeProvider
          },
          set relatedCodeProvider(p) {
            _(t, "testRelatedCode"),
              (f.relatedCodeProvider = p),
              u.$updateController(e, { capabilities: d() })
          },
          createRunProfile: (p, v, b, k, E, P) => {
            let C = nn(p)
            for (; c.has(C); ) C++
            return new Qst(this.h, c, l, this.q.event, e, C, p, v, b, k, E, P)
          },
          createTestItem(p, v, b) {
            return new rm(e, p, v, b)
          },
          createTestRun: (p, v, b = !0) =>
            this.j.createTestRun(t, e, o, p, v, b),
          invalidateTestResults: (p) => {
            if (p === void 0) this.h.$markTestRetired(void 0)
            else {
              const v = p instanceof Array ? p : [p]
              this.h.$markTestRetired(
                v.map((b) => jt.fromExtHostTestItem(b, e).toString()),
              )
            }
          },
          set resolveHandler(p) {
            o.resolveHandler = p
          },
          get resolveHandler() {
            return o.resolveHandler
          },
          dispose: () => {
            a.dispose()
          },
        },
        f = {
          controller: m,
          collection: o,
          profiles: c,
          extension: t,
          activeProfiles: l,
        }
      return (
        u.$registerTestController(e, s, d()),
        a.add(et(() => u.$unregisterTestController(e))),
        this.g.set(e, f),
        a.add(et(() => this.g.delete(e))),
        a.add(
          o.onDidGenerateDiff((p) => u.$publishDiff(e, p.map(H6.serialize))),
        ),
        m
      )
    }
    createTestObserver() {
      return this.m.checkout()
    }
    async runTests(t, e = ce.None) {
      const s = zst(t)
      if (!s)
        throw new Error(
          "The request passed to `vscode.test.runTests` must include a profile",
        )
      const r = this.g.get(s.controllerId)
      if (!r) throw new Error("Controller not found")
      await this.h.$runTests(
        {
          preserveFocus: t.preserveFocus ?? !0,
          group: Sl.from(s.kind),
          targets: [
            {
              testIds: t.include?.map((a) =>
                jt.fromExtHostTestItem(a, r.collection.root.id).toString(),
              ) ?? [r.collection.root.id],
              profileId: s.profileId,
              controllerId: s.controllerId,
            },
          ],
          exclude: t.exclude?.map((a) => a.id),
        },
        e,
      )
    }
    registerTestFollowupProvider(t) {
      return (
        this.w.add(t),
        {
          dispose: () => {
            this.w.delete(t)
          },
        }
      )
    }
    async $getTestsRelatedToCode(t, e, s) {
      const r = this.F.getDocument(S.revive(t))
      if (!r) return []
      const a = Kt.to(e),
        o = []
      return (
        await Promise.all(
          [...this.g.values()].map(async (c) => {
            let l
            try {
              l = await c.relatedCodeProvider?.provideRelatedTests?.(
                r.document,
                a,
                s,
              )
            } catch (u) {
              s.isCancellationRequested ||
                this.z.warn(
                  `Error thrown while providing related tests for ${c.controller.label}`,
                  u,
                )
            }
            if (l) {
              for (const u of l)
                o.push(jt.fromExtHostTestItem(u, c.controller.id).toString())
              c.collection.flushDiff()
            }
          }),
        ),
        o
      )
    }
    async $getCodeRelatedToTest(t, e) {
      const s = this.g.get(jt.root(t))
      if (!s) return []
      const r = s.collection.tree.get(t)
      return r
        ? ((
            await s.relatedCodeProvider?.provideRelatedCode?.(r.actual, e)
          )?.map(Qi.from) ?? [])
        : []
    }
    $syncTests() {
      for (const { collection: t } of this.g.values()) t.flushDiff()
      return Promise.resolve()
    }
    async $getCoverageDetails(t, e, s) {
      return (await this.j.getCoverageDetails(t, e, s))?.map(gd.fromDetails)
    }
    async $disposeRun(t) {
      this.j.disposeTestRun(t)
    }
    $configureRunProfile(t, e) {
      this.g.get(t)?.profiles.get(e)?.configureHandler?.()
    }
    $setDefaultRunProfiles(t) {
      const e = new Map()
      for (const [s, r] of Object.entries(t)) {
        const a = this.g.get(s)
        if (!a) continue
        const o = new Map(),
          c = r.filter((u) => !a.activeProfiles.has(u)),
          l = [...a.activeProfiles].filter((u) => !r.includes(u))
        for (const u of c) o.set(u, !0), a.activeProfiles.add(u)
        for (const u of l) o.set(u, !1), a.activeProfiles.delete(u)
        o.size && e.set(s, o)
      }
      this.q.fire(e)
    }
    async $refreshTests(t, e) {
      await this.g.get(t)?.controller.refreshHandler?.(e)
    }
    $publishTestResults(t) {
      ;(this.results = Object.freeze(
        t
          .map((e) => {
            const s = tM.to(e),
              r = e.tasks.findIndex((a) => a.hasCoverage)
            return (
              r !== -1 &&
                (s.getDetailedCoverage = (a, o = ce.None) =>
                  this.h
                    .$getCoverageDetails(e.id, r, a, o)
                    .then((c) => c.map(gd.to))),
              Vst.set(s, e.id),
              s
            )
          })
          .concat(this.results)
          .sort((e, s) => s.completedAt - e.completedAt)
          .slice(0, 32),
      )),
        this.f.fire()
    }
    async $expandTest(t, e) {
      const s = this.g.get(jt.fromString(t).controllerId)?.collection
      s && (await s.expand(t, e < 0 ? 1 / 0 : e), s.flushDiff())
    }
    $acceptDiff(t) {
      this.m.applyDiff(
        t.map((e) => H6.deserialize({ asCanonicalUri: (s) => s }, e)),
      )
    }
    async $runControllerTests(t, e) {
      return Promise.all(t.map((s) => this.G(s, !1, e)))
    }
    async $startContinuousRun(t, e) {
      const s = new fe(e),
        r = await Promise.all(t.map((a) => this.G(a, !0, s.token)))
      return (
        !e.isCancellationRequested &&
          !r.some((a) => a.error) &&
          (await new Promise((a) => e.onCancellationRequested(a))),
        s.dispose(!0),
        r
      )
    }
    async $provideTestFollowups(t, e) {
      const s = this.results.find((o) => Vst.get(o) === t.resultId),
        r = s && ixt(jt.fromString(t.extId), s?.results)
      if (!r) return []
      let a = []
      return (
        await Promise.all(
          [...this.w].map(async (o) => {
            try {
              const c = await o.provideFollowup(
                s,
                r,
                t.taskIndex,
                t.messageIndex,
                e,
              )
              c && (a = a.concat(c))
            } catch (c) {
              this.z.error(
                "Error thrown while providing followup for test message",
                c,
              )
            }
          }),
        ),
        e.isCancellationRequested
          ? []
          : a.map((o) => {
              const c = Y$t++
              return this.y.set(c, o), { title: o.title, id: c }
            })
      )
    }
    $disposeTestFollowups(t) {
      for (const e of t) this.y.delete(e)
    }
    $executeTestFollowup(t) {
      const e = this.y.get(t)
      return e
        ? this.C.executeCommand(e.command, ...(e.arguments || []))
        : Promise.resolve()
    }
    $cancelExtensionTestRun(t, e) {
      t === void 0 ? this.j.cancelAllRuns() : this.j.cancelRunById(t, e)
    }
    getMetadataForRun(t) {
      for (const e of this.j.trackers) {
        const s = e.getTaskIdForRun(t)
        if (s) return { taskId: s, runId: e.id }
      }
    }
    async G(t, e, s) {
      const r = this.g.get(t.controllerId)
      if (!r) return {}
      const { collection: a, profiles: o, extension: c } = r,
        l = o.get(t.profileId)
      if (!l) return {}
      const u = t.testIds.map((p) => a.tree.get(p)).filter(Wa),
        d = t.excludeExtIds
          .map((p) => r.collection.tree.get(p))
          .filter(Wa)
          .filter((p) => u.some((v) => v.fullId.compare(p.fullId) === 2))
      if (!u.length) return {}
      const m = new xO(
          u.some((p) => p.actual instanceof aH)
            ? void 0
            : u.map((p) => p.actual),
          d.map((p) => p.actual),
          l,
          e,
        ),
        f =
          Wbt(t) &&
          this.j.prepareForMainThreadTestRun(
            c,
            m,
            Yst.fromInternal(t, r.collection),
            l,
            s,
          )
      try {
        return await l.runHandler(m, s), {}
      } catch (p) {
        return { error: String(p) }
      } finally {
        f &&
          f.hasRunningTasks &&
          !s.isCancellationRequested &&
          (await Qt.toPromise(f.onEnd))
      }
    }
  }
XH = __decorate(
  [__param(0, Ot), __param(1, Rt), __param(2, mr), __param(3, Fo)],
  XH,
)
var Q$t = 1e4,
  Gst
;(function (i) {
  ;(i[(i.Running = 0)] = "Running"),
    (i[(i.Cancelling = 1)] = "Cancelling"),
    (i[(i.Ended = 2)] = "Ended")
})(Gst || (Gst = {}))
var X$t = class extends at {
    get hasRunningTasks() {
      return this.g > 0
    }
    get id() {
      return this.z.id
    }
    constructor(i, t, e, s, r, a) {
      super(),
        (this.z = i),
        (this.C = t),
        (this.F = e),
        (this.G = s),
        (this.H = r),
        (this.f = 0),
        (this.g = 0),
        (this.h = new Map()),
        (this.j = new Set()),
        (this.q = this.D(new J())),
        (this.y = new Map()),
        (this.onEnd = this.q.event),
        (this.m = this.D(new fe(a)))
      const o = this.D(new tn(() => this.I(), Q$t))
      this.D(this.m.token.onCancellationRequested(() => o.schedule()))
      const c = new J()
      ;(this.w = c.event),
        this.D(
          et(() => {
            c.fire(), c.dispose()
          }),
        )
    }
    getTaskIdForRun(i) {
      for (const [t, { run: e }] of this.h) if (e === i) return t
    }
    cancel(i) {
      i
        ? this.h.get(i)?.cts.cancel()
        : this.f === 0
          ? (this.m.cancel(), (this.f = 1))
          : this.f === 1 && this.I()
    }
    async getCoverageDetails(i, t, e) {
      const [, s] = jt.fromString(i).path,
        r = this.y.get(i)
      if (!r) return []
      const { report: a, extIds: o } = r,
        c = this.h.get(s)
      if (!c) throw new Error("unreachable: run task was not found")
      let l
      if (t && a instanceof LO) {
        const d = o.indexOf(t)
        if (d === -1) return []
        l = a.includesTests[d]
      }
      return (
        (await (l
          ? this.G?.loadDetailedCoverageForTest?.(c.run, a, l, e)
          : this.G?.loadDetailedCoverage?.(c.run, a, e))) ?? []
      )
    }
    createRun(i) {
      const t = this.z.id,
        e = this.z.controllerId,
        s = Ze(),
        r =
          (u) =>
          (d, ...m) => {
            if (o) {
              this.F.warn(
                `Setting the state of test "${d.id}" is a no-op after the run ends.`,
              )
              return
            }
            this.L(d), u(d, ...m)
          },
        a = (u, d) => {
          const m = d instanceof Array ? d.map(kl.from) : [kl.from(d)]
          if (u.uri && u.range) {
            const f = { range: U.from(u.range), uri: u.uri }
            for (const p of m) p.location = p.location || f
          }
          this.C.$appendTestMessagesInRun(
            t,
            s,
            jt.fromExtHostTestItem(u, e).toString(),
            m,
          )
        }
      let o = !1
      const c = this.D(new fe(this.m.token)),
        l = {
          isPersisted: this.z.isPersisted,
          token: c.token,
          name: i,
          onDidDispose: this.w,
          addCoverage: (u) => {
            if (o) return
            const d = u instanceof LO ? u.includesTests : []
            if (d.length) for (const p of d) this.L(p)
            const m = u.uri.toString(),
              f = new jt([t, s, m]).toString()
            this.y.set(f, {
              report: u,
              extIds: d.map((p) => jt.fromExtHostTestItem(p, e).toString()),
            }),
              this.C.$appendCoverage(t, s, gd.fromFile(e, f, u))
          },
          enqueued: r((u) => {
            this.C.$updateTestStateInRun(
              t,
              s,
              jt.fromExtHostTestItem(u, e).toString(),
              1,
            )
          }),
          skipped: r((u) => {
            this.C.$updateTestStateInRun(
              t,
              s,
              jt.fromExtHostTestItem(u, e).toString(),
              5,
            )
          }),
          started: r((u) => {
            this.C.$updateTestStateInRun(
              t,
              s,
              jt.fromExtHostTestItem(u, e).toString(),
              2,
            )
          }),
          errored: r((u, d, m) => {
            a(u, d),
              this.C.$updateTestStateInRun(
                t,
                s,
                jt.fromExtHostTestItem(u, e).toString(),
                6,
                m,
              )
          }),
          failed: r((u, d, m) => {
            a(u, d),
              this.C.$updateTestStateInRun(
                t,
                s,
                jt.fromExtHostTestItem(u, e).toString(),
                4,
                m,
              )
          }),
          passed: r((u, d) => {
            this.C.$updateTestStateInRun(
              t,
              s,
              jt.fromExtHostTestItem(u, this.z.controllerId).toString(),
              3,
              d,
            )
          }),
          appendOutput: (u, d, m) => {
            o ||
              (m && this.L(m),
              this.C.$appendOutputToRun(
                t,
                s,
                Q.fromString(u),
                d && Qi.from(d),
                m && jt.fromExtHostTestItem(m, e).toString(),
              ))
          },
          end: () => {
            o ||
              ((o = !0),
              this.C.$finishedTestRunTask(t, s),
              --this.g || this.J())
          },
        }
      return (
        this.g++,
        this.h.set(s, { run: l, cts: c }),
        this.C.$startedTestRunTask(t, {
          id: s,
          ctrlId: this.z.controllerId,
          name: i || this.H.displayName || this.H.identifier.value,
          running: !0,
        }),
        l
      )
    }
    I() {
      for (const { run: i } of this.h.values()) i.end()
    }
    J() {
      this.f !== 2 && ((this.f = 2), this.q.fire())
    }
    L(i) {
      if (!(i instanceof rm)) throw new W6(i.id)
      if (this.j.has(jt.fromExtHostTestItem(i, this.z.controllerId).toString()))
        return
      const t = [],
        e = this.z.colllection.root
      for (;;) {
        const s = fa.from(i)
        if (
          (t.unshift(s), this.j.has(s.extId) || (this.j.add(s.extId), i === e))
        )
          break
        i = i.parent || e
      }
      this.C.$addTestsToRun(this.z.controllerId, this.z.id, t)
    }
    dispose() {
      this.J(), super.dispose()
    }
  },
  K$t = class {
    get trackers() {
      return this.f.values()
    }
    constructor(i, t) {
      ;(this.h = i), (this.j = t), (this.f = new Map()), (this.g = new Map())
    }
    getCoverageDetails(i, t, e) {
      const s = jt.root(i)
      return this.g.get(s)?.getCoverageDetails(i, t, e) || []
    }
    disposeTestRun(i) {
      this.g.get(i)?.dispose(), this.g.delete(i)
      for (const [t, { id: e }] of this.f) e === i && this.f.delete(t)
    }
    prepareForMainThreadTestRun(i, t, e, s, r) {
      return this.k(t, e, s, i, r)
    }
    cancelRunById(i, t) {
      this.g.get(i)?.cancel(t)
    }
    cancelAllRuns() {
      for (const i of this.f.values()) i.cancel()
    }
    createTestRun(i, t, e, s, r, a) {
      const o = this.f.get(s)
      if (o) return o.createRun(r)
      const c = Yst.fromPublic(t, e, s, a),
        l = zst(s)
      this.h.$startedExtensionTestRun({
        controllerId: t,
        continuous: !!s.continuous,
        profile: l && { group: Sl.from(l.kind), id: l.profileId },
        exclude:
          s.exclude?.map((d) =>
            jt.fromExtHostTestItem(d, e.root.id).toString(),
          ) ?? [],
        id: c.id,
        include: s.include?.map((d) =>
          jt.fromExtHostTestItem(d, e.root.id).toString(),
        ) ?? [e.root.id],
        preserveFocus: s.preserveFocus ?? !0,
        persist: a,
      })
      const u = this.k(s, c, s.profile, i)
      return (
        Qt.once(u.onEnd)(() => {
          this.h.$finishedExtensionTestRun(c.id)
        }),
        u.createRun(r)
      )
    }
    k(i, t, e, s, r) {
      const a = new X$t(t, this.h, this.j, e, s, r)
      return this.f.set(i, a), this.g.set(a.id, a), a
    }
  },
  zst = (i) => {
    if (i.profile) {
      if (!(i.profile instanceof Qst))
        throw new Error(
          "TestRunRequest.profile is not an instance created from TestController.createRunProfile",
        )
      return i.profile
    }
  },
  Yst = class wV {
    static fromPublic(t, e, s, r) {
      return new wV(t, Ze(), r, e)
    }
    static fromInternal(t, e) {
      return new wV(t.controllerId, t.runId, !0, e)
    }
    constructor(t, e, s, r) {
      ;(this.controllerId = t),
        (this.id = e),
        (this.isPersisted = s),
        (this.colllection = r)
    }
  },
  Z$t = class {
    get isEmpty() {
      return this.f.size === 0 && this.h.size === 0 && this.g.size === 0
    }
    constructor(i) {
      ;(this.k = i),
        (this.f = new Set()),
        (this.g = new Set()),
        (this.h = new Set()),
        (this.j = new Set())
    }
    add(i) {
      this.f.add(i)
    }
    update(i) {
      Object.assign(i.revived, fa.toPlain(i.item)),
        this.f.has(i) || this.g.add(i)
    }
    remove(i) {
      if (this.f.has(i)) {
        this.f.delete(i)
        return
      }
      this.g.delete(i)
      const t = jt.parentId(i.item.extId)
      if (t && this.j.has(t.toString())) {
        this.j.add(i.item.extId)
        return
      }
      this.h.add(i)
    }
    getChangeEvent() {
      const { f: i, g: t, h: e } = this
      return {
        get added() {
          return [...i].map((s) => s.revived)
        },
        get updated() {
          return [...t].map((s) => s.revived)
        },
        get removed() {
          return [...e].map((s) => s.revived)
        },
      }
    }
    complete() {
      this.isEmpty || this.k.fire(this.getChangeEvent())
    }
  },
  txt = class extends jbt {
    constructor() {
      super(...arguments),
        (this.z = new J()),
        (this.onDidChangeTests = this.z.event)
    }
    get rootTests() {
      return this.h
    }
    getMirroredTestDataById(i) {
      return this.g.get(i)
    }
    getMirroredTestDataByReference(i) {
      return this.g.get(i.id)
    }
    y(i, t) {
      return {
        ...i,
        revived: fa.toPlain(i.item),
        depth: t ? t.depth + 1 : 0,
        children: new Set(),
      }
    }
    x() {
      return new Z$t(this.z)
    }
  },
  ext = class {
    constructor(i) {
      this.g = i
    }
    checkout() {
      this.f || (this.f = this.h())
      const i = this.f
      return (
        i.observers++,
        {
          onDidChangeTest: i.tests.onDidChangeTests,
          get tests() {
            return [...i.tests.rootTests].map((t) => t.revived)
          },
          dispose: d_(() => {
            --i.observers === 0 &&
              (this.g.$unsubscribeFromDiffs(), (this.f = void 0))
          }),
        }
      )
    }
    getMirroredTestDataByReference(i) {
      return this.f?.tests.getMirroredTestDataByReference(i)
    }
    applyDiff(i) {
      this.f?.tests.apply(i)
    }
    h() {
      const i = new txt({ asCanonicalUri: (t) => t })
      return this.g.$subscribeToDiffs(), { observers: 0, tests: i }
    }
  },
  vm = (i, t, e, s) => {
    e
      ? Object.assign(e, s)
      : t.$updateTestRunConfig(i.controllerId, i.profileId, s)
  },
  Qst = class extends gtt {
    #t
    #e
    #i
    #s
    #n
    get label() {
      return this.g
    }
    set label(i) {
      i !== this.g && ((this.g = i), vm(this, this.#t, this.#s, { label: i }))
    }
    get supportsContinuousRun() {
      return this.j
    }
    set supportsContinuousRun(i) {
      i !== this.j &&
        ((this.j = i), vm(this, this.#t, this.#s, { supportsContinuousRun: i }))
    }
    get isDefault() {
      return this.#e.has(this.profileId)
    }
    set isDefault(i) {
      i !== this.isDefault &&
        (i ? this.#e.add(this.profileId) : this.#e.delete(this.profileId),
        vm(this, this.#t, this.#s, { isDefault: i }))
    }
    get tag() {
      return this._tag
    }
    set tag(i) {
      i?.id !== this._tag?.id &&
        ((this._tag = i),
        vm(this, this.#t, this.#s, {
          tag: i ? cr.namespace(this.controllerId, i.id) : null,
        }))
    }
    get configureHandler() {
      return this.f
    }
    set configureHandler(i) {
      i !== this.f &&
        ((this.f = i),
        vm(this, this.#t, this.#s, { hasConfigurationHandler: !!i }))
    }
    get onDidChangeDefault() {
      return Qt.chain(this.#i, (i) =>
        i.map((t) => t.get(this.controllerId)?.get(this.profileId)).filter(Wa),
      )
    }
    constructor(i, t, e, s, r, a, o, c, l, u = !1, d = void 0, m = !1) {
      super(r, a, c),
        (this.g = o),
        (this.runHandler = l),
        (this._tag = d),
        (this.j = m),
        (this.#t = i),
        (this.#n = t),
        (this.#e = e),
        (this.#i = s),
        t.set(a, this)
      const f = Sl.from(c)
      u && e.add(a),
        (this.#s = {
          profileId: a,
          controllerId: r,
          tag: d ? cr.namespace(this.controllerId, d.id) : null,
          label: o,
          group: f,
          isDefault: u,
          hasConfigurationHandler: !1,
          supportsContinuousRun: m,
        }),
        queueMicrotask(() => {
          this.#s &&
            (this.#t.$publishTestRunProfile(this.#s), (this.#s = void 0))
        })
    }
    dispose() {
      this.#n?.delete(this.profileId) &&
        ((this.#n = void 0),
        this.#t.$removeTestProfile(this.controllerId, this.profileId)),
        (this.#s = void 0)
    }
  }
function ixt(i, t) {
  for (let e = 0; e < i.path.length; e++) {
    const s = t.find((r) => r.id === i.path[e])
    if (!s) return
    if (e === i.path.length - 1) return s
    t = s.children
  }
}
var dQt = X("configurationResolverService"),
  we
;(function (i) {
  ;(i.Unknown = "unknown"),
    (i.Env = "env"),
    (i.Config = "config"),
    (i.Command = "command"),
    (i.Input = "input"),
    (i.ExtensionInstallFolder = "extensionInstallFolder"),
    (i.WorkspaceFolder = "workspaceFolder"),
    (i.Cwd = "cwd"),
    (i.WorkspaceFolderBasename = "workspaceFolderBasename"),
    (i.UserHome = "userHome"),
    (i.LineNumber = "lineNumber"),
    (i.SelectedText = "selectedText"),
    (i.File = "file"),
    (i.FileWorkspaceFolder = "fileWorkspaceFolder"),
    (i.FileWorkspaceFolderBasename = "fileWorkspaceFolderBasename"),
    (i.RelativeFile = "relativeFile"),
    (i.RelativeFileDirname = "relativeFileDirname"),
    (i.FileDirname = "fileDirname"),
    (i.FileExtname = "fileExtname"),
    (i.FileBasename = "fileBasename"),
    (i.FileBasenameNoExtension = "fileBasenameNoExtension"),
    (i.FileDirnameBasename = "fileDirnameBasename"),
    (i.ExecPath = "execPath"),
    (i.ExecInstallFolder = "execInstallFolder"),
    (i.PathSeparator = "pathSeparator"),
    (i.PathSeparatorAlias = "/")
})(we || (we = {}))
var Ki = class extends xs {
    constructor(i, t) {
      super(t), (this.variable = i)
    }
  },
  sxt = class X3 {
    static {
      this.VARIABLE_LHS = "${"
    }
    static {
      this.VARIABLE_REGEXP = /\$\{(.*?)\}/g
    }
    constructor(t, e, s, r) {
      ;(this.h = new Map()),
        (this.a = t),
        (this.b = e),
        (this.g = s),
        r && (this.c = r.then((a) => this.i(a)))
    }
    i(t) {
      if (ie) {
        const e = Object.create(null)
        return (
          Object.keys(t).forEach((s) => {
            e[s.toLowerCase()] = t[s]
          }),
          e
        )
      }
      return t
    }
    resolveWithEnvironment(t, e, s) {
      return this.l({ env: this.i(t), userHome: void 0 }, e ? e.uri : void 0, s)
    }
    async resolveAsync(t, e) {
      const s = { env: await this.c, userHome: await this.g }
      return this.l(s, t ? t.uri : void 0, e)
    }
    async j(t, e, s, r) {
      const a = pe(e)
      ie && a.windows
        ? Object.keys(a.windows).forEach((c) => (a[c] = a.windows[c]))
        : Ke && a.osx
          ? Object.keys(a.osx).forEach((c) => (a[c] = a.osx[c]))
          : De &&
            a.linux &&
            Object.keys(a.linux).forEach((c) => (a[c] = a.linux[c])),
        delete a.windows,
        delete a.osx,
        delete a.linux
      const o = { env: await this.c, userHome: await this.g }
      return this.l(o, t ? t.uri : void 0, a, s, r)
    }
    async resolveAnyAsync(t, e, s) {
      return this.j(t, e, s)
    }
    async resolveAnyMap(t, e, s) {
      const r = new Map()
      return { newConfig: await this.j(t, e, s, r), resolvedVariables: r }
    }
    resolveWithInteractionReplace(t, e, s, r) {
      throw new Error("resolveWithInteractionReplace not implemented.")
    }
    resolveWithInteraction(t, e, s, r) {
      throw new Error("resolveWithInteraction not implemented.")
    }
    contributeVariable(t, e) {
      if (this.h.has(t))
        throw new Error("Variable " + t + " is contributed twice.")
      this.h.set(t, e)
    }
    async l(t, e, s, r, a) {
      if (_t(s)) return this.m(t, e, s, r, a)
      if (Array.isArray(s))
        return Promise.all(s.map((o) => this.l(t, e, o, r, a)))
      if (Je(s)) {
        const o = Object.create(null),
          c = await Promise.all(
            Object.keys(s).map(async (l) => [
              await this.m(t, e, l, r, a),
              await this.l(t, e, s[l], r, a),
            ]),
          )
        for (const [l, u] of c) o[l] = u
        return o
      }
      return s
    }
    m(t, e, s, r, a) {
      return _dt(s, X3.VARIABLE_REGEXP, async (o, c) => {
        if (c.includes(X3.VARIABLE_LHS)) return o
        let l = await this.o(t, o, c, e, r)
        return (
          a?.set(c, l),
          l !== o &&
            _t(l) &&
            l.match(X3.VARIABLE_REGEXP) &&
            (l = await this.m(t, e, l, r, a)),
          l
        )
      })
    }
    n(t) {
      return this.b ? this.b.getUriLabel(t, { noPrefix: !0 }) : t.fsPath
    }
    async o(t, e, s, r, a) {
      let o
      const c = s.split(":")
      c.length > 1 && ((s = c[0]), (o = c[1]))
      const l = (m) => {
          const f = this.a.getFilePath()
          if (f) return am(f)
          throw new Ki(m, g(12720, null, e))
        },
        u = (m) => {
          const f = l(m)
          if (this.a.getWorkspaceFolderPathForFile) {
            const p = this.a.getWorkspaceFolderPathForFile()
            if (p) return am(p)
          }
          throw new Ki(m, g(12721, null, e, ke(f)))
        },
        d = (m) => {
          if (o) {
            const f = this.a.getFolderUri(o)
            if (f) return f
            throw new Ki(m, g(12722, null, e, o))
          }
          if (r) return r
          throw this.a.getWorkspaceFolderCount() > 1
            ? new Ki(m, g(12723, null, e))
            : new Ki(m, g(12724, null, e))
        }
      switch (s) {
        case "env":
          if (o) {
            if (t.env) {
              const m = t.env[ie ? o.toLowerCase() : o]
              if (_t(m)) return m
            }
            return ""
          }
          throw new Ki(we.Env, g(12725, null, e))
        case "config":
          if (o) {
            const m = this.a.getConfigurationValue(r, o)
            if (Fe(m)) throw new Ki(we.Config, g(12726, null, e, o))
            if (Je(m)) throw new Ki(we.Config, g(12727, null, e, o))
            return m
          }
          throw new Ki(we.Config, g(12728, null, e))
        case "command":
          return this.p(we.Command, e, o, a, "command")
        case "input":
          return this.p(we.Input, e, o, a, "input")
        case "extensionInstallFolder":
          if (o) {
            const m = await this.a.getExtension(o)
            if (!m)
              throw new Ki(we.ExtensionInstallFolder, g(12729, null, e, o))
            return this.n(m.extensionLocation)
          }
          throw new Ki(we.ExtensionInstallFolder, g(12730, null, e))
        default:
          switch (s) {
            case "workspaceRoot":
            case "workspaceFolder":
              return am(this.n(d(we.WorkspaceFolder)))
            case "cwd":
              return r || o ? am(this.n(d(we.Cwd))) : Ma()
            case "workspaceRootFolderName":
            case "workspaceFolderBasename":
              return am(ke(this.n(d(we.WorkspaceFolderBasename))))
            case "userHome": {
              if (t.userHome) return t.userHome
              throw new Ki(we.UserHome, g(12731, null, e))
            }
            case "lineNumber": {
              const m = this.a.getLineNumber()
              if (m) return m
              throw new Ki(we.LineNumber, g(12732, null, e))
            }
            case "selectedText": {
              const m = this.a.getSelectedText()
              if (m) return m
              throw new Ki(we.SelectedText, g(12733, null, e))
            }
            case "file":
              return l(we.File)
            case "fileWorkspaceFolder":
              return u(we.FileWorkspaceFolder)
            case "fileWorkspaceFolderBasename":
              return ke(u(we.FileWorkspaceFolderBasename))
            case "relativeFile":
              return r || o
                ? uc(this.n(d(we.RelativeFile)), l(we.RelativeFile))
                : l(we.RelativeFile)
            case "relativeFileDirname": {
              const m = Ui(l(we.RelativeFileDirname))
              if (r || o) {
                const f = uc(this.n(d(we.RelativeFileDirname)), m)
                return f.length === 0 ? "." : f
              }
              return m
            }
            case "fileDirname":
              return Ui(l(we.FileDirname))
            case "fileExtname":
              return S_(l(we.FileExtname))
            case "fileBasename":
              return ke(l(we.FileBasename))
            case "fileBasenameNoExtension": {
              const m = ke(l(we.FileBasenameNoExtension))
              return m.slice(0, m.length - S_(m).length)
            }
            case "fileDirnameBasename":
              return ke(Ui(l(we.FileDirnameBasename)))
            case "execPath": {
              const m = this.a.getExecPath()
              return m || e
            }
            case "execInstallFolder": {
              const m = this.a.getAppRoot()
              return m || e
            }
            case "pathSeparator":
            case "/":
              return xe
            default:
              try {
                const m = o ? `${s}:${o}` : s
                return this.p(we.Unknown, e, m, a, void 0)
              } catch {
                return e
              }
          }
      }
    }
    p(t, e, s, r, a) {
      if (s && r) {
        const o = a === void 0 ? r[s] : r[a + ":" + s]
        if (typeof o == "string") return o
        throw new Ki(t, g(12734, null, e))
      }
      return e
    }
  },
  ql = X("IExtHostVariableResolverProvider"),
  rxt = class extends sxt {
    constructor(i, t, e, s, r, a, o) {
      function c() {
        if (e) {
          const l = e.activeEditor()
          if (l) return l.document.uri
          const u = s.tabGroups.all.find((d) => d.isActive)?.activeTab
          if (u !== void 0) {
            if (u.input instanceof RO || u.input instanceof bU)
              return u.input.modified
            if (
              u.input instanceof vU ||
              u.input instanceof yU ||
              u.input instanceof wU
            )
              return u.input.uri
          }
        }
      }
      super(
        {
          getFolderUri: (l) => {
            const u = a.folders.filter((d) => d.name === l)
            if (u && u.length > 0) return u[0].uri
          },
          getWorkspaceFolderCount: () => a.folders.length,
          getConfigurationValue: (l, u) => r.getConfiguration(void 0, l).get(u),
          getAppRoot: () => Ma(),
          getExecPath: () => Mn.VSCODE_EXEC_PATH,
          getFilePath: () => {
            const l = c()
            if (l) return Xr(l.fsPath)
          },
          getWorkspaceFolderPathForFile: () => {
            if (t) {
              const l = c()
              if (l) {
                const u = t.getWorkspaceFolder(l)
                if (u) return Xr(u.uri.fsPath)
              }
            }
          },
          getSelectedText: () => {
            if (e) {
              const l = e.activeEditor()
              if (l && !l.selection.isEmpty)
                return l.document.getText(l.selection)
            }
          },
          getLineNumber: () => {
            if (e) {
              const l = e.activeEditor()
              if (l) return String(l.selection.end.line + 1)
            }
          },
          getExtension: (l) => i.getExtension(l),
        },
        void 0,
        o ? Promise.resolve(o) : void 0,
        Promise.resolve(Mn),
      )
    }
  },
  PB = class extends at {
    constructor(t, e, s, r, a) {
      super(),
        (this.b = t),
        (this.c = e),
        (this.g = s),
        (this.h = r),
        (this.j = a),
        (this.a = new as(async () => {
          const o = await this.h.getConfigProvider(),
            l = { folders: (await this.c.getWorkspaceFolders2()) || [] }
          return (
            this.D(
              this.c.onDidChangeWorkspace(async (u) => {
                l.folders = (await this.c.getWorkspaceFolders2()) || []
              }),
            ),
            new rxt(this.b, this.c, this.g, this.j, o, l, this.m())
          )
        }))
    }
    getResolver() {
      return this.a.value
    }
    m() {}
  }
PB = __decorate(
  [
    __param(0, $n),
    __param(1, dr),
    __param(2, Fo),
    __param(3, Ds),
    __param(4, Bl),
  ],
  PB,
)
var KH = X("IExtHostDebugService"),
  $B = class extends at {
    get onDidStartDebugSession() {
      return this.w.event
    }
    get onDidTerminateDebugSession() {
      return this.y.event
    }
    get onDidChangeActiveDebugSession() {
      return this.z.event
    }
    get activeDebugSession() {
      return this.C?.api
    }
    get onDidReceiveDebugSessionCustomEvent() {
      return this.F.event
    }
    get activeDebugConsole() {
      return this.G.value
    }
    constructor(t, e, s, r, a, o, c, l) {
      super(),
        (this.Z = e),
        (this.$ = s),
        (this.ab = r),
        (this.bb = a),
        (this.cb = o),
        (this.db = c),
        (this.eb = l),
        (this.u = new Map()),
        (this.O = 0),
        (this.P = new Map()),
        (this.Q = new Map()),
        (this.R = new WeakMap()),
        (this.S = new Map()),
        (this.W = new Map()),
        (this.X = 0),
        (this.f = 0),
        (this.g = []),
        (this.h = 0),
        (this.j = []),
        (this.m = 0),
        (this.n = []),
        (this.M = new Map()),
        (this.N = new Map()),
        (this.w = this.D(new J())),
        (this.y = this.D(new J())),
        (this.z = this.D(new J())),
        (this.F = this.D(new J())),
        (this.q = t.getProxy(K.MainThreadDebugService)),
        (this.I = this.D(new J())),
        (this.L = this.D(new J())),
        (this.G = new axt(this.q)),
        (this.H = new Map()),
        this.$.getExtensionRegistry().then((u) => {
          this.D(
            u.onDidChange((d) => {
              this.gb(u)
            }),
          ),
            this.gb(u)
        }),
        (this.Y = t.getProxy(K.MainThreadTelemetry))
    }
    async $getVisualizerTreeItem(t, e) {
      const s = this.hb(e)
      if (!s) return
      const r = await this.Q.get(t)?.getTreeItem?.(s)
      return r ? this.fb(t, r) : void 0
    }
    registerDebugVisualizationTree(t, e, s) {
      const r = ae.toKey(t.identifier),
        a = this.zb(r, e)
      if (this.P.has(a))
        throw new Error(
          `A debug visualization provider with id '${e}' is already registered`,
        )
      return (
        this.Q.set(a, s),
        this.q.$registerDebugVisualizerTree(a, !!s.editItem),
        et(() => {
          this.q.$unregisterDebugVisualizerTree(a), this.Q.delete(e)
        })
      )
    }
    async $getVisualizerTreeItemChildren(t, e) {
      const s = this.S.get(e)?.item
      return s
        ? (await this.Q.get(t)?.getChildren?.(s))?.map((a) => this.fb(t, a)) ||
            []
        : []
    }
    async $editVisualizerTreeItem(t, e) {
      const s = this.S.get(t)
      if (!s) return
      const r = await this.Q.get(s.provider)?.editItem?.(s.item, e)
      return this.fb(s.provider, r || s.item)
    }
    $disposeVisualizedTree(t) {
      const e = this.S.get(t)
      if (!e) return
      const s = [e.children]
      for (const r of s)
        if (r)
          for (const a of r) s.push(this.S.get(a)?.children), this.S.delete(a)
    }
    fb(t, e) {
      let s = this.R.get(e)
      return (
        s ||
          ((s = this.O++),
          this.R.set(e, s),
          this.S.set(s, { provider: t, item: e })),
        lM.from(e, s)
      )
    }
    asDebugSourceUri(t, e) {
      const s = t
      if (typeof s.sourceReference == "number" && s.sourceReference > 0) {
        let r = `debug:${encodeURIComponent(s.path || "")}`,
          a = "?"
        return (
          e && ((r += `${a}session=${encodeURIComponent(e.id)}`), (a = "&")),
          (r += `${a}ref=${s.sourceReference}`),
          S.parse(r)
        )
      } else {
        if (s.path) return S.file(s.path)
        throw new Error(
          "cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.",
        )
      }
    }
    gb(t) {
      const e = []
      for (const s of t.getAllExtensionDescriptions())
        if (s.contributes) {
          const r = s.contributes.debuggers
          if (r && r.length > 0) for (const a of r) M$t(a) && e.push(a.type)
        }
      this.q.$registerDebugTypes(e)
    }
    get activeStackItem() {
      return this.J
    }
    get onDidChangeActiveStackItem() {
      return this.L.event
    }
    get onDidChangeBreakpoints() {
      return this.I.event
    }
    get breakpoints() {
      const t = []
      return this.H.forEach((e) => t.push(e)), t
    }
    async $resolveDebugVisualizer(t, e) {
      const s = this.W.get(t)
      if (!s) throw new Error(`No debug visualizer found with id '${t}'`)
      let { v: r, provider: a, extensionId: o } = s
      if (
        (r.visualization ||
          ((r = (await a.resolveDebugVisualization?.(r, e)) || r), (s.v = r)),
        !r.visualization)
      )
        throw new Error(
          `No visualization returned from resolveDebugVisualization in '${a}'`,
        )
      return this.Ab(o, r.visualization)
    }
    async $executeDebugVisualizerCommand(t) {
      const e = this.W.get(t)
      if (!e) throw new Error(`No debug visualizer found with id '${t}'`)
      const s = e.v.visualization
      s &&
        "command" in s &&
        this.db.executeCommand(s.command, ...(s.arguments || []))
    }
    hb(t) {
      const e = this.u.get(t.sessionId)
      return (
        e && {
          session: e.api,
          variable: t.variable,
          containerId: t.containerId,
          frameId: t.frameId,
          threadId: t.threadId,
        }
      )
    }
    async $provideDebugVisualizers(t, e, s, r) {
      const a = this.hb(s),
        o = this.zb(t, e),
        c = this.P.get(o)
      if (!a || !c) return []
      const l = await c.provideDebugVisualization(a, r)
      return l
        ? l.map((u) => {
            const d = ++this.X
            this.W.set(d, { v: u, provider: c, extensionId: t })
            const m = u.iconPath ? this.Bb(u.iconPath) : void 0
            return {
              id: d,
              name: u.name,
              iconClass: m?.iconClass,
              iconPath: m?.iconPath,
              visualization: this.Ab(t, u.visualization),
            }
          })
        : []
    }
    $disposeDebugVisualizers(t) {
      for (const e of t) this.W.delete(e)
    }
    registerDebugVisualizationProvider(t, e, s) {
      if (!t.contributes?.debugVisualizers?.some((o) => o.id === e))
        throw new Error(
          `Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${e})`,
        )
      const r = ae.toKey(t.identifier),
        a = this.zb(r, e)
      if (this.P.has(a))
        throw new Error(
          `A debug visualization provider with id '${e}' is already registered`,
        )
      return (
        this.P.set(a, s),
        this.q.$registerDebugVisualizer(r, e),
        et(() => {
          this.q.$unregisterDebugVisualizer(r, e), this.P.delete(e)
        })
      )
    }
    addBreakpoints(t) {
      const e = t.filter((a) => {
        const o = a.id
        return this.H.has(o) ? !1 : (this.H.set(o, a), !0)
      })
      this.wb(e, [], [])
      const s = [],
        r = new Map()
      for (const a of e)
        if (a instanceof To) {
          let o = r.get(a.location.uri.toString())
          o ||
            ((o = { type: "sourceMulti", uri: a.location.uri, lines: [] }),
            r.set(a.location.uri.toString(), o),
            s.push(o)),
            o.lines.push({
              id: a.id,
              enabled: a.enabled,
              condition: a.condition,
              hitCondition: a.hitCondition,
              logMessage: a.logMessage,
              line: a.location.range.start.line,
              character: a.location.range.start.character,
              mode: a.mode,
            })
        } else
          a instanceof ko &&
            s.push({
              type: "function",
              id: a.id,
              enabled: a.enabled,
              hitCondition: a.hitCondition,
              logMessage: a.logMessage,
              condition: a.condition,
              functionName: a.functionName,
              mode: a.mode,
            })
      return this.q.$registerBreakpoints(s)
    }
    removeBreakpoints(t) {
      const e = t.filter((o) => this.H.delete(o.id))
      this.wb([], e, [])
      const s = e.filter((o) => o instanceof To).map((o) => o.id),
        r = e.filter((o) => o instanceof ko).map((o) => o.id),
        a = e.filter((o) => o instanceof fO).map((o) => o.id)
      return this.q.$unregisterBreakpoints(s, r, a)
    }
    startDebugging(t, e, s) {
      const r = s.testRun && this.eb.getMetadataForRun(s.testRun)
      return this.q.$startDebugging(t ? t.uri : void 0, e, {
        parentSessionID: s.parentSession ? s.parentSession.id : void 0,
        lifecycleManagedByParent: s.lifecycleManagedByParent,
        repl:
          s.consoleMode === bO.MergeWithParent ? "mergeWithParent" : "separate",
        noDebug: s.noDebug,
        compact: s.compact,
        suppressSaveBeforeStart: s.suppressSaveBeforeStart,
        testRun: r && { runId: r.runId, taskId: r.taskId },
        suppressDebugStatusbar: s.suppressDebugStatusbar ?? s.debugUI?.simple,
        suppressDebugToolbar: s.suppressDebugToolbar ?? s.debugUI?.simple,
        suppressDebugView: s.suppressDebugView ?? s.debugUI?.simple,
      })
    }
    stopDebugging(t) {
      return this.q.$stopDebugging(t ? t.id : void 0)
    }
    registerDebugConfigurationProvider(t, e, s) {
      if (!e) return new Ht(() => {})
      const r = this.f++
      return (
        this.g.push({ type: t, handle: r, provider: e }),
        this.q.$registerDebugConfigurationProvider(
          t,
          s,
          !!e.provideDebugConfigurations,
          !!e.resolveDebugConfiguration,
          !!e.resolveDebugConfigurationWithSubstitutedVariables,
          r,
        ),
        new Ht(() => {
          ;(this.g = this.g.filter((a) => a.provider !== e)),
            this.q.$unregisterDebugConfigurationProvider(r)
        })
      )
    }
    registerDebugAdapterDescriptorFactory(t, e, s) {
      if (!s) return new Ht(() => {})
      if (!this.sb(t, e))
        throw new Error(
          `a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${e}' debugger.`,
        )
      if (this.pb(e))
        throw new Error(
          "a DebugAdapterDescriptorFactory can only be registered once per a type.",
        )
      const r = this.h++
      return (
        this.j.push({ type: e, handle: r, factory: s }),
        this.q.$registerDebugAdapterDescriptorFactory(e, r),
        new Ht(() => {
          ;(this.j = this.j.filter((a) => a.factory !== s)),
            this.q.$unregisterDebugAdapterDescriptorFactory(r)
        })
      )
    }
    registerDebugAdapterTrackerFactory(t, e) {
      if (!e) return new Ht(() => {})
      const s = this.m++
      return (
        this.n.push({ type: t, handle: s, factory: e }),
        new Ht(() => {
          this.n = this.n.filter((r) => r.factory !== e)
        })
      )
    }
    async $runInTerminal(t, e) {
      return Promise.resolve(void 0)
    }
    async $substituteVariables(t, e) {
      let s
      const r = await this.yb(t)
      return (
        r &&
          (s = {
            uri: r.uri,
            name: r.name,
            index: r.index,
            toResource: () => {
              throw new Error("Not implemented")
            },
          }),
        (await this.cb.getResolver()).resolveAnyAsync(s, e)
      )
    }
    ib(t, e) {
      if (t instanceof Wh) return new cxt(t.implementation)
    }
    jb() {}
    async $startDASession(t, e) {
      const s = this,
        r = await this.xb(e)
      return this.ub(this.pb(r.type), r).then((a) => {
        if (!a)
          throw new Error(
            `Couldn't find a debug adapter descriptor for debug type '${r.type}' (extension might have failed to activate)`,
          )
        const o = this.ib(a, r)
        if (!o)
          throw new Error(
            `Couldn't create a debug adapter for type '${r.type}'.`,
          )
        const c = o
        return (
          this.M.set(t, c),
          this.tb(r).then(
            (l) => (
              l && this.N.set(t, l),
              c.onMessage(async (u) => {
                if (u.type === "request" && u.command === "handshake") {
                  const d = u,
                    m = {
                      type: "response",
                      seq: 0,
                      command: d.command,
                      request_seq: d.seq,
                      success: !0,
                    }
                  this.U || (this.U = this.jb())
                  try {
                    if (this.U) {
                      const f = await this.U.sign(d.arguments.value)
                      ;(m.body = { signature: f }), c.sendResponse(m)
                    } else throw new Error("no signer")
                  } catch (f) {
                    ;(m.success = !1),
                      (m.message = f.message),
                      c.sendResponse(m)
                  }
                } else {
                  l && l.onDidSendMessage && l.onDidSendMessage(u)
                  try {
                    u = V$t(u, !0)
                  } catch (d) {
                    const m = u.type + "_" + (u.command ?? u.event ?? "")
                    throw (
                      (this.Y.$publicLog2("debugProtocolMessageError", {
                        type: m,
                        from: r.type,
                      }),
                      d)
                    )
                  }
                  s.q.$acceptDAMessage(t, u)
                }
              }),
              c.onError((u) => {
                l && l.onError && l.onError(u),
                  this.q.$acceptDAError(t, u.name, u.message, u.stack)
              }),
              c.onExit((u) => {
                l && l.onExit && l.onExit(u ?? void 0, void 0),
                  this.q.$acceptDAExit(t, u ?? void 0, void 0)
              }),
              l && l.onWillStartSession && l.onWillStartSession(),
              c.startSession()
            ),
          )
        )
      })
    }
    $sendDAMessage(t, e) {
      e = j$t(e, !1)
      const s = this.N.get(t)
      s && s.onWillReceiveMessage && s.onWillReceiveMessage(e),
        this.M.get(t)?.sendMessage(e)
    }
    $stopDASession(t) {
      const e = this.N.get(t)
      this.N.delete(t), e && e.onWillStopSession && e.onWillStopSession()
      const s = this.M.get(t)
      return this.M.delete(t), s ? s.stopSession() : Promise.resolve(void 0)
    }
    $acceptBreakpointsDelta(t) {
      const e = [],
        s = [],
        r = []
      if (t.added)
        for (const a of t.added) {
          const o = a.id
          if (o && !this.H.has(o)) {
            let c
            if (a.type === "function")
              c = new ko(
                a.functionName,
                a.enabled,
                a.condition,
                a.hitCondition,
                a.logMessage,
                a.mode,
              )
            else if (a.type === "data")
              c = new fO(
                a.label,
                a.dataId,
                a.canPersist,
                a.enabled,
                a.hitCondition,
                a.condition,
                a.logMessage,
                a.mode,
              )
            else {
              const l = S.revive(a.uri)
              c = new To(
                new ys(l, new Ft(a.line, a.character)),
                a.enabled,
                a.condition,
                a.hitCondition,
                a.logMessage,
                a.mode,
              )
            }
            vTt(c, o), this.H.set(o, c), e.push(c)
          }
        }
      if (t.removed)
        for (const a of t.removed) {
          const o = this.H.get(a)
          o && (this.H.delete(a), s.push(o))
        }
      if (t.changed) {
        for (const a of t.changed)
          if (a.id) {
            const o = this.H.get(a.id)
            if (o) {
              if (o instanceof ko && a.type === "function") {
                const c = o
                ;(c.enabled = a.enabled),
                  (c.condition = a.condition),
                  (c.hitCondition = a.hitCondition),
                  (c.logMessage = a.logMessage),
                  (c.functionName = a.functionName)
              } else if (o instanceof To && a.type === "source") {
                const c = o
                ;(c.enabled = a.enabled),
                  (c.condition = a.condition),
                  (c.hitCondition = a.hitCondition),
                  (c.logMessage = a.logMessage),
                  (c.location = new ys(
                    S.revive(a.uri),
                    new Ft(a.line, a.character),
                  ))
              }
              r.push(o)
            }
          }
      }
      this.wb(e, s, r)
    }
    async $acceptStackFrameFocus(t) {
      let e
      if (t) {
        const s = await this.xb(t.sessionId)
        t.kind === "thread"
          ? (e = new htt(s.api, t.threadId))
          : (e = new utt(s.api, t.threadId, t.frameId))
      }
      ;(this.J = e), this.L.fire(this.J)
    }
    $provideDebugConfigurations(t, e, s) {
      return Ci(async () => {
        const r = this.rb(t)
        if (!r) throw new Error("no DebugConfigurationProvider found")
        if (!r.provideDebugConfigurations)
          throw new Error(
            "DebugConfigurationProvider has no method provideDebugConfigurations",
          )
        const a = await this.yb(e)
        return r.provideDebugConfigurations(a, s)
      }).then((r) => {
        if (!r)
          throw new Error(
            "nothing returned from DebugConfigurationProvider.provideDebugConfigurations",
          )
        return r
      })
    }
    $resolveDebugConfiguration(t, e, s, r) {
      return Ci(async () => {
        const a = this.rb(t)
        if (!a) throw new Error("no DebugConfigurationProvider found")
        if (!a.resolveDebugConfiguration)
          throw new Error(
            "DebugConfigurationProvider has no method resolveDebugConfiguration",
          )
        const o = await this.yb(e)
        return a.resolveDebugConfiguration(o, s, r)
      })
    }
    $resolveDebugConfigurationWithSubstitutedVariables(t, e, s, r) {
      return Ci(async () => {
        const a = this.rb(t)
        if (!a) throw new Error("no DebugConfigurationProvider found")
        if (!a.resolveDebugConfigurationWithSubstitutedVariables)
          throw new Error(
            "DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables",
          )
        const o = await this.yb(e)
        return a.resolveDebugConfigurationWithSubstitutedVariables(o, s, r)
      })
    }
    async $provideDebugAdapter(t, e) {
      const s = this.qb(t)
      if (!s)
        return Promise.reject(
          new Error("no adapter descriptor factory found for handle"),
        )
      const r = await this.xb(e)
      return this.ub(s, r).then((a) => {
        if (!a)
          throw new Error(
            `Couldn't find a debug adapter descriptor for debug type '${r.type}'`,
          )
        return this.kb(a)
      })
    }
    async $acceptDebugSessionStarted(t) {
      const e = await this.xb(t)
      this.w.fire(e.api)
    }
    async $acceptDebugSessionTerminated(t) {
      const e = await this.xb(t)
      e && (this.y.fire(e.api), this.u.delete(e.id))
    }
    async $acceptDebugSessionActiveChanged(t) {
      ;(this.C = t ? await this.xb(t) : void 0), this.z.fire(this.C?.api)
    }
    async $acceptDebugSessionNameChanged(t, e) {
      ;(await this.xb(t))?._acceptNameChanged(e)
    }
    async $acceptDebugSessionCustomEvent(t, e) {
      const r = {
        session: (await this.xb(t)).api,
        event: e.event,
        body: e.body,
      }
      this.F.fire(r)
    }
    kb(t) {
      if (t instanceof sl) return this.lb(t)
      if (t instanceof rl) return this.mb(t)
      if (t instanceof Hh) return this.nb(t)
      if (t instanceof Wh) return this.ob(t)
      throw new Error("convertToDto unexpected type")
    }
    lb(t) {
      return {
        type: "executable",
        command: t.command,
        args: t.args,
        options: t.options,
      }
    }
    mb(t) {
      return { type: "server", port: t.port, host: t.host }
    }
    nb(t) {
      return { type: "pipeServer", path: t.path }
    }
    ob(t) {
      return { type: "implementation" }
    }
    pb(t) {
      const e = this.j.filter((s) => s.type === t)
      if (e.length > 0) return e[0].factory
    }
    qb(t) {
      const e = this.j.filter((s) => s.handle === t)
      if (e.length > 0) return e[0].factory
    }
    rb(t) {
      const e = this.g.filter((s) => s.handle === t)
      if (e.length > 0) return e[0].provider
    }
    sb(t, e) {
      if (t.contributes) {
        const s = t.contributes.debuggers
        if (s && s.length > 0) {
          for (const r of s) if (r.label && r.type && r.type === e) return !0
        }
      }
      return !1
    }
    tb(t) {
      const s = t.configuration.type,
        r = this.n
          .filter((a) => a.type === s || a.type === "*")
          .map((a) =>
            Ci(() => a.factory.createDebugAdapterTracker(t.api)).then(
              (o) => o,
              (o) => null,
            ),
          )
      return Promise.race([
        Promise.all(r).then((a) => {
          const o = Ue(a)
          if (o.length > 0) return new oxt(o)
        }),
        new Promise((a) => setTimeout(() => a(void 0), 1e3)),
      ]).catch((a) => {})
    }
    async ub(t, e) {
      const s = e.configuration.debugServer
      if (typeof s == "number") return Promise.resolve(new rl(s))
      if (t) {
        const a = await this.$.getExtensionRegistry()
        return Ci(() =>
          t.createDebugAdapterDescriptor(e.api, this.vb(e, a)),
        ).then((o) => {
          if (o) return o
        })
      }
      const r = await this.$.getExtensionRegistry()
      return Promise.resolve(this.vb(e, r))
    }
    vb(t, e) {}
    wb(t, e, s) {
      ;(t.length > 0 || e.length > 0 || s.length > 0) &&
        this.I.fire(Object.freeze({ added: t, removed: e, changed: s }))
    }
    async xb(t) {
      if (t)
        if (typeof t == "string") {
          const e = this.u.get(t)
          if (e) return e
        } else {
          let e = this.u.get(t.id)
          if (!e) {
            const s = await this.yb(t.folderUri),
              r = t.parent ? this.u.get(t.parent) : void 0
            ;(e = new nxt(
              this.q,
              t.id,
              t.type,
              t.name,
              s,
              t.configuration,
              r?.api,
            )),
              this.u.set(e.id, e),
              this.q.$sessionCached(e.id)
          }
          return e
        }
      throw new Error("cannot find session")
    }
    yb(t) {
      if (t) {
        const e = S.revive(t)
        return this.Z.resolveWorkspaceFolder(e)
      }
      return Promise.resolve(void 0)
    }
    zb(t, e) {
      return `${t}\0${e}`
    }
    Ab(t, e) {
      if (e) {
        if ("title" in e && "command" in e) return { type: 0 }
        if ("treeId" in e) return { type: 1, id: `${t}\0${e.treeId}` }
        throw new Error("Unsupported debug visualization type")
      }
    }
    Bb(t) {
      const e = this.Cb(t)
      let s, r
      return (
        "id" in e ? (r = gi.asClassName(e)) : (s = e),
        { iconPath: s, iconClass: r }
      )
    }
    Cb(t) {
      if (t instanceof Ji) return { id: t.id }
      const e = typeof t == "object" && "dark" in t ? t.dark : t,
        s = typeof t == "object" && "light" in t ? t.light : t
      return {
        dark: typeof e == "string" ? S.file(e) : e,
        light: typeof s == "string" ? S.file(s) : s,
      }
    }
  }
$B = __decorate(
  [
    __param(0, Ot),
    __param(1, dr),
    __param(2, $n),
    __param(3, Ds),
    __param(4, Bl),
    __param(5, ql),
    __param(6, mr),
    __param(7, gm),
  ],
  $B,
)
var nxt = class {
    constructor(i, t, e, s, r, a, o) {
      ;(this.f = i),
        (this.g = t),
        (this.h = e),
        (this.j = s),
        (this.k = r),
        (this.l = a),
        (this.m = o)
    }
    get api() {
      const i = this
      return (this.d ??= Object.freeze({
        id: i.g,
        type: i.h,
        get name() {
          return i.j
        },
        set name(t) {
          ;(i.j = t), i.f.$setDebugSessionName(i.g, t)
        },
        parentSession: i.m,
        workspaceFolder: i.k,
        configuration: i.l,
        customRequest(t, e) {
          return i.f.$customDebugAdapterRequest(i.g, t, e)
        },
        getDebugProtocolBreakpoint(t) {
          return i.f.$getDebugProtocolBreakpoint(i.g, t.id)
        },
      }))
    }
    get id() {
      return this.g
    }
    get type() {
      return this.h
    }
    _acceptNameChanged(i) {
      this.j = i
    }
    get configuration() {
      return this.l
    }
  },
  axt = class {
    constructor(i) {
      this.value = Object.freeze({
        append(t) {
          i.$appendDebugConsole(t)
        },
        appendLine(t) {
          this.append(
            t +
              `
`,
          )
        },
      })
    }
  },
  oxt = class {
    constructor(i) {
      this.d = i
    }
    onWillStartSession() {
      this.d.forEach((i) =>
        i.onWillStartSession ? i.onWillStartSession() : void 0,
      )
    }
    onWillReceiveMessage(i) {
      this.d.forEach((t) =>
        t.onWillReceiveMessage ? t.onWillReceiveMessage(i) : void 0,
      )
    }
    onDidSendMessage(i) {
      this.d.forEach((t) =>
        t.onDidSendMessage ? t.onDidSendMessage(i) : void 0,
      )
    }
    onWillStopSession() {
      this.d.forEach((i) =>
        i.onWillStopSession ? i.onWillStopSession() : void 0,
      )
    }
    onError(i) {
      this.d.forEach((t) => (t.onError ? t.onError(i) : void 0))
    }
    onExit(i, t) {
      this.d.forEach((e) => (e.onExit ? e.onExit(i, t) : void 0))
    }
  },
  cxt = class extends Ust {
    constructor(i) {
      super(),
        (this.h = i),
        i.onDidSendMessage((t) => {
          this.acceptMessage(t)
        })
    }
    startSession() {
      return Promise.resolve(void 0)
    }
    sendMessage(i) {
      this.h.handleMessage(i)
    }
    stopSession() {
      return this.h.dispose(), Promise.resolve(void 0)
    }
  },
  ZH = class extends $B {
    constructor(t, e, s, r, a, o, c, l) {
      super(t, e, s, r, a, o, c, l)
    }
  }
ZH = __decorate(
  [
    __param(0, Ot),
    __param(1, dr),
    __param(2, $n),
    __param(3, Ds),
    __param(4, Bl),
    __param(5, ql),
    __param(6, mr),
    __param(7, gm),
  ],
  ZH,
)
function lxt(i) {
  return "uri" in i && "ranges" in i && "preview" in i
}
function uxt(i) {
  return i.folderOptions.map((t) => ({
    folder: t.folder,
    excludes: t.excludes.map((e) => (typeof e == "string" ? e : e.pattern)),
    includes: t.includes,
    useGlobalIgnoreFiles: t.useIgnoreFiles.global,
    useIgnoreFiles: t.useIgnoreFiles.local,
    useParentIgnoreFiles: t.useIgnoreFiles.parent,
    followSymlinks: t.followSymlinks,
    maxResults: i.maxResults,
    session: i.session,
  }))
}
var Xst = class {
  constructor(i) {
    this.a = i
  }
  provideFileSearchResults(i, t, e) {
    return (async () => {
      const r = uxt(t)
      return Promise.all(
        r.map((a) => this.a.provideFileSearchResults({ pattern: i }, a, e)),
      )
    })().then((r) => Ue(r).flat())
  }
}
function hxt(i) {
  return i.folderOptions.map((t) => ({
    folder: t.folder,
    excludes: t.excludes.map((e) => (typeof e == "string" ? e : e.pattern)),
    includes: t.includes,
    useGlobalIgnoreFiles: t.useIgnoreFiles.global,
    useIgnoreFiles: t.useIgnoreFiles.local,
    useParentIgnoreFiles: t.useIgnoreFiles.parent,
    followSymlinks: t.followSymlinks,
    maxResults: i.maxResults,
    previewOptions: Kst(i.previewOptions),
    maxFileSize: i.maxFileSize,
    encoding: t.encoding,
    afterContext: i.surroundingContext,
    beforeContext: i.surroundingContext,
  }))
}
function Kst(i) {
  return {
    matchLines: i?.matchLines ?? gM.matchLines,
    charsPerLine: i?.charsPerLine ?? gM.charsPerLine,
  }
}
function dxt(i) {
  if (lxt(i)) {
    const t = Ir(i.ranges).map((e, s) => {
      const a = Ir(i.preview.matches)[s]
      return { sourceRange: e, previewRange: a }
    })
    return new Tn(i.uri, t, i.preview.text)
  } else return new k8(i.uri, i.text, i.lineNumber)
}
var mxt = class {
  constructor(i) {
    this.a = i
  }
  provideTextSearchResults(i, t, e, s) {
    const r = (c) => {
      fxt(c) && e.report(dxt(c))
    }
    return (async () =>
      Ue(
        await Promise.all(
          hxt(t).map((c) =>
            this.a.provideTextSearchResults(i, c, { report: (l) => r(l) }, s),
          ),
        ),
      ).reduce((c, l) => ({ limitHit: c.limitHit || l.limitHit }), {
        limitHit: !1,
      }))().then((c) => ({ limitHit: c.limitHit, message: Ue(Ir(c.message)) }))
  }
}
function fxt(i) {
  if (pxt(i)) {
    if (Array.isArray(i.ranges)) {
      if (!Array.isArray(i.preview.matches))
        return (
          console.warn(
            "INVALID - A text search provider match's`ranges` and`matches` properties must have the same type.",
          ),
          !1
        )
      if (i.preview.matches.length !== i.ranges.length)
        return (
          console.warn(
            "INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.",
          ),
          !1
        )
    } else if (Array.isArray(i.preview.matches))
      return (
        console.warn(
          "INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.",
        ),
        !1
      )
  }
  return !0
}
function pxt(i) {
  return !!i.preview
}
var Zst = class extends ea {
    constructor(i, t, e = () => !1) {
      const s = new XQ(e, () => !1)
      super(s)
      const r = new oi()
      i.forEach((a, o) => {
        const c = a.folder.with({ query: "", fragment: "" })
        r.has(c) ? r.get(c).push({ fq: a, i: o }) : r.set(c, [{ fq: a, i: o }])
      }),
        r.forEach((a, o) => {
          const c = new Map()
          for (const l of a) {
            const u = t(l.fq, l.i)
            c.set(this.l(l.fq.folder), u)
          }
          super.set(o, c)
        })
    }
    findQueryFragmentAwareSubstr(i) {
      const t = super.findSubstr(i.with({ query: "", fragment: "" }))
      if (!t) return
      const e = this.l(i)
      return t.get(e)
    }
    forEachFolderQueryInfo(i) {
      return this.forEach((t) => t.forEach((e) => i(e)))
    }
    l(i) {
      let t = ""
      return i.query && (t += i.query), i.fragment && (t += "#" + i.fragment), t
    }
  },
  gxt = class {
    constructor(i, t, e) {
      ;(this.l = i),
        (this.o = t),
        (this.p = e),
        (this.f = !1),
        (this.g = 0),
        (this.h = !1),
        (this.a = i.filePattern),
        (this.b = i.includePattern && sr(i.includePattern)),
        (this.c = i.maxResults || void 0),
        (this.d = i.exists),
        (this.j = new Set()),
        (this.k = i.excludePattern && sr(i.excludePattern))
    }
    cancel() {
      ;(this.h = !0), this.j.forEach((i) => i.cancel()), (this.j = new Set())
    }
    search(i) {
      const t = this.l.folderQueries || []
      return new Promise((e, s) => {
        const r = (a) => {
          this.g++, i(a)
        }
        if (this.h) return e({ limitHit: this.f })
        this.l.extraFileResources &&
          this.l.extraFileResources.forEach((a) => {
            const o = a.toString(),
              c = ke(o)
            ;(this.k && this.k(o, c)) || this.w(r, { base: a, basename: c })
          }),
          this.q(t, r).then(
            (a) => {
              e({ limitHit: this.f, stats: a || void 0 })
            },
            (a) => {
              s(new Error(Zs(a)))
            },
          )
      })
    }
    async q(i, t) {
      const e = new fe(),
        s = i.map((u) => this.r(u)),
        r = this.o instanceof Xst ? this.p?.tokenSource.token : this.p?.obj,
        a = {
          folderOptions: s,
          maxResults: this.l.maxResults ?? E8,
          session: r,
        },
        o = (u) => {
          const d = new jtt(this.l, u),
            m = !d.hasSiblingExcludeClauses()
          return {
            queryTester: d,
            noSiblingsClauses: m,
            folder: u.folder,
            tree: this.s(),
          }
        },
        c = new Zst(i, o)
      let l
      try {
        this.j.add(e), (l = ss.create())
        const u = await this.o.provideFileSearchResults(
            this.l.filePattern || "",
            a,
            e.token,
          ),
          d = l.elapsed(),
          m = ss.create()
        return (this.h && !this.f) ||
          (u &&
            u.forEach((f) => {
              const p = c.findQueryFragmentAwareSubstr(f),
                v = Wt.relative(p.folder.path, f.path)
              if (p.noSiblingsClauses) {
                const b = ke(f.path)
                this.w(t, { base: p.folder, relativePath: v, basename: b })
                return
              }
              this.u(p.tree, p.folder, v, t)
            }),
          this.h && !this.f)
          ? null
          : (c.forEachFolderQueryInfo((f) => {
              this.v(f.tree, f.queryTester, t)
            }),
            { providerTime: d, postProcessTime: m.elapsed() })
      } finally {
        e.dispose(), this.j.delete(e)
      }
    }
    r(i) {
      const t = Pl(this.l.includePattern, i.includePattern)
      let e = i.excludePattern?.map((r) => ({
        folder: r.folder,
        patterns: Pl(this.l.excludePattern, r.pattern),
      }))
      e?.length ||
        (e = [{ folder: void 0, patterns: Pl(this.l.excludePattern, void 0) }])
      const s = Gtt(e)
      return {
        folder: i.folder,
        excludes: s,
        includes: t,
        useIgnoreFiles: {
          local: !i.disregardIgnoreFiles,
          parent: !i.disregardParentIgnoreFiles,
          global: !i.disregardGlobalIgnoreFiles,
        },
        followSymlinks: !i.ignoreSymlinks,
      }
    }
    s() {
      const i = { rootEntries: [], pathToEntries: Object.create(null) }
      return (i.pathToEntries["."] = i.rootEntries), i
    }
    u({ pathToEntries: i }, t, e, s) {
      if (e === this.a) {
        const a = ke(this.a)
        this.w(s, { base: t, relativePath: this.a, basename: a })
      }
      function r(a) {
        const o = ke(a),
          c = Ui(a)
        let l = i[c]
        l || ((l = i[c] = []), r(c)),
          l.push({ base: t, relativePath: a, basename: o })
      }
      r(e)
    }
    v({ rootEntries: i, pathToEntries: t }, e, s) {
      const r = this,
        a = this.a
      function o(c) {
        const l = pM(() => c.map((u) => u.basename))
        for (let u = 0, d = c.length; u < d; u++) {
          const m = c[u],
            { relativePath: f, basename: p } = m
          if (e.matchesExcludesSync(f, p, a !== p ? l : void 0)) continue
          const v = t[f]
          if (v) o(v)
          else {
            if (f === a) continue
            r.w(s, m)
          }
          if (r.f) break
        }
      }
      o(i)
    }
    w(i, t) {
      ;(!this.b || (t.relativePath && this.b(t.relativePath, t.basename))) &&
        ((this.d || (this.c && this.g >= this.c)) &&
          ((this.f = !0), this.cancel()),
        this.f || i(t))
    }
  },
  vxt = class {
    constructor() {
      ;(this.a = new Object()), (this.tokenSource = new fe())
    }
    get obj() {
      if (this.a) return this.a
      throw new Error("Session object has been dereferenced.")
    }
    cancel() {
      this.tokenSource.cancel(), (this.a = void 0)
    }
  },
  wxt = class gut {
    constructor() {
      this.b = new Map()
    }
    static {
      this.a = 512
    }
    fileSearch(t, e, s, r) {
      const a = this.c(t.cacheKey),
        o = new gxt(t, e, a)
      let c = 0
      const l = (u) => {
        ;(c += u.length), s(u.map((d) => this.d(d)))
      }
      return this.f(o, gut.a, l, r).then((u) => ({
        limitHit: u.limitHit,
        stats: u.stats
          ? {
              fromCache: !1,
              type: "fileSearchProvider",
              resultCount: c,
              detailStats: u.stats,
            }
          : void 0,
        messages: [],
      }))
    }
    clearCache(t) {
      this.b.get(t)?.cancel(), this.b.delete(t)
    }
    c(t) {
      if (t) return this.b.has(t) || this.b.set(t, new vxt()), this.b.get(t)
    }
    d(t) {
      return t.relativePath
        ? { resource: He(t.base, t.relativePath) }
        : { resource: t.base }
    }
    f(t, e, s, r) {
      const a = r.onCancellationRequested(() => {
          t.cancel()
        }),
        o = (l) => {
          l && (c.push(l), e > 0 && c.length >= e && (s(c), (c = [])))
        }
      let c = []
      return t.search(o).then(
        (l) => (c.length && s(c), a.dispose(), l),
        (l) => (c.length && s(c), a.dispose(), Promise.reject(l)),
      )
    }
  },
  tW = class {
    constructor(i, t, e) {
      ;(this.f = i),
        (this.g = t),
        (this.h = e),
        (this.b = null),
        (this.c = !1),
        (this.d = 0)
    }
    get j() {
      return this.f.query
    }
    search(i, t) {
      const e = this.j.folderQueries || [],
        s = new fe(t)
      return new Promise((r, a) => {
        this.b = new bxt(i)
        let o = !1
        const c = (l, u) => {
          if (!o && !this.c) {
            const d = this.l(l)
            l instanceof Tn &&
              typeof this.j.maxResults == "number" &&
              this.d + d > this.j.maxResults &&
              ((this.c = !0),
              (o = !0),
              s.cancel(),
              (l = this.m(l, this.j.maxResults - this.d)))
            const m = this.l(l)
            this.d += m
            const f = l instanceof Tn
            ;(m > 0 || !f) && this.b.add(l, u)
          }
        }
        this.n(e, c, s.token).then(
          (l) => {
            s.dispose(),
              this.b.flush(),
              r({
                limitHit: this.c || l?.limitHit,
                messages: this.k(l),
                stats: { type: this.h },
              })
          },
          (l) => {
            s.dispose()
            const u = Zs(l)
            a(new Error(u))
          },
        )
      })
    }
    k(i) {
      return i?.message
        ? Array.isArray(i.message)
          ? i.message
          : [i.message]
        : []
    }
    l(i) {
      return i instanceof Tn
        ? Array.isArray(i.ranges)
          ? i.ranges.length
          : 1
        : 0
    }
    m(i, t) {
      return new Tn(i.uri, i.ranges.slice(0, t), i.previewText)
    }
    async n(i, t, e) {
      const s = new Zst(
          i,
          (u, d) => ({
            queryTester: new jtt(this.j, u),
            folder: u.folder,
            folderIdx: d,
          }),
          () => !0,
        ),
        r = [],
        a = {
          report: (u) => {
            if (u.uri === void 0)
              throw Error(
                "Text search result URI is undefined. Please check provider implementation.",
              )
            const d = s.findQueryFragmentAwareSubstr(u.uri),
              m =
                d.folder.scheme === G.file
                  ? OTt(() => this.g.readdir(C_(u.uri)))
                  : void 0,
              f = WG(d.folder, u.uri)
            if (f) {
              const p = d.queryTester.includedInQuery(f, ke(f), m)
              Kr(p)
                ? r.push(
                    p.then((v) => {
                      v && t(u, d.folderIdx)
                    }),
                  )
                : p && t(u, d.folderIdx)
            }
          },
        },
        c = {
          folderOptions: i.map((u) => this.o(u)),
          maxFileSize: this.j.maxFileSize,
          maxResults: this.j.maxResults ?? E8,
          previewOptions: this.j.previewOptions ?? gM,
          surroundingContext: this.j.surroundingContext ?? 0,
        }
      "usePCRE2" in this.j && (c.usePCRE2 = this.j.usePCRE2)
      let l
      return (
        this.f.query.type === 3
          ? (l = await this.f.provider.provideAITextSearchResults(
              this.f.query.contentPattern,
              c,
              a,
              e,
            ))
          : (l = await this.f.provider.provideTextSearchResults(
              yxt(this.f.query.contentPattern),
              c,
              a,
              e,
            )),
        r.length && (await Promise.all(r)),
        l
      )
    }
    o(i) {
      const t = Pl(this.j.includePattern, i.includePattern)
      let e = i.excludePattern?.map((a) => ({
        folder: a.folder,
        patterns: Pl(this.j.excludePattern, a.pattern),
      }))
      ;(!e || e.length === 0) &&
        (e = [{ folder: void 0, patterns: Pl(this.j.excludePattern, void 0) }])
      const s = Gtt(e)
      return {
        folder: S.from(i.folder),
        excludes: s,
        includes: t,
        useIgnoreFiles: {
          local: !i.disregardIgnoreFiles,
          parent: !i.disregardParentIgnoreFiles,
          global: !i.disregardGlobalIgnoreFiles,
        },
        followSymlinks: !i.ignoreSymlinks,
        encoding:
          (i.fileEncoding && this.g.toCanonicalName(i.fileEncoding)) ?? "",
      }
    }
  }
function yxt(i) {
  return {
    isCaseSensitive: i.isCaseSensitive || !1,
    isRegExp: i.isRegExp || !1,
    isWordMatch: i.isWordMatch || !1,
    isMultiline: i.isMultiline || !1,
    pattern: i.pattern,
  }
}
var bxt = class {
  constructor(i) {
    ;(this.g = i),
      (this.c = -1),
      (this.f = null),
      (this.b = new kxt(512, (t) => this.j(t)))
  }
  add(i, t) {
    this.f &&
      (this.c !== t || !HG(this.d, i.uri)) &&
      (this.h(), (this.f = null)),
      this.f || ((this.c = t), (this.f = { resource: i.uri, results: [] })),
      this.f.results.push(Txt(i))
  }
  h() {
    const i = this.f && this.f.results ? this.f.results.length : 0
    this.b.addItem(this.f, i)
  }
  flush() {
    this.h(), this.b.flush()
  }
  j(i) {
    this.g(i)
  }
}
function Txt(i) {
  return i instanceof Tn
    ? {
        previewText: i.previewText,
        rangeLocations: i.ranges.map((t) => ({
          preview: {
            startLineNumber: t.previewRange.start.line,
            startColumn: t.previewRange.start.character,
            endLineNumber: t.previewRange.end.line,
            endColumn: t.previewRange.end.character,
          },
          source: {
            startLineNumber: t.sourceRange.start.line,
            startColumn: t.sourceRange.start.character,
            endLineNumber: t.sourceRange.end.line,
            endColumn: t.sourceRange.end.character,
          },
        })),
      }
    : { text: i.text, lineNumber: i.lineNumber }
}
var kxt = class yV {
    static {
      this.b = 4e3
    }
    static {
      this.c = 50
    }
    constructor(t, e) {
      ;(this.j = t), (this.k = e), (this.d = 0), (this.f = []), (this.g = 0)
    }
    addItem(t, e) {
      t && this.l(t, e)
    }
    addItems(t, e) {
      t && this.m(t, e)
    }
    l(t, e) {
      this.f.push(t), (this.g += e), this.n()
    }
    m(t, e) {
      ;(this.f = this.f.concat(t)), (this.g += e), this.n()
    }
    n() {
      this.d < yV.c
        ? this.flush()
        : this.g >= this.j
          ? this.flush()
          : this.h ||
            (this.h = setTimeout(() => {
              this.flush()
            }, yV.b))
    }
    flush() {
      this.g &&
        ((this.d += this.g),
        this.k(this.f),
        (this.f = []),
        (this.g = 0),
        this.h && (clearTimeout(this.h), (this.h = 0)))
    }
  },
  eW = X("IExtHostSearch"),
  xB = class {
    constructor(t, e, s) {
      ;(this.o = t),
        (this.q = e),
        (this.s = s),
        (this.c = this.o.getProxy(K.MainThreadSearch)),
        (this.e = 0),
        (this.g = new Map()),
        (this.h = new Set()),
        (this.i = new Map()),
        (this.j = new Set()),
        (this.k = new Map()),
        (this.l = new Set()),
        (this.n = new wxt())
    }
    t(t) {
      return this.q.transformOutgoingScheme(t)
    }
    registerTextSearchProviderOld(t, e) {
      if (this.h.has(t))
        throw new Error(
          `a text search provider for the scheme '${t}' is already registered`,
        )
      this.h.add(t)
      const s = this.e++
      return (
        this.g.set(s, new mxt(e)),
        this.c.$registerTextSearchProvider(s, this.t(t)),
        et(() => {
          this.h.delete(t), this.g.delete(s), this.c.$unregisterProvider(s)
        })
      )
    }
    registerTextSearchProvider(t, e) {
      if (this.h.has(t))
        throw new Error(
          `a text search provider for the scheme '${t}' is already registered`,
        )
      this.h.add(t)
      const s = this.e++
      return (
        this.g.set(s, e),
        this.c.$registerTextSearchProvider(s, this.t(t)),
        et(() => {
          this.h.delete(t), this.g.delete(s), this.c.$unregisterProvider(s)
        })
      )
    }
    registerAITextSearchProvider(t, e) {
      if (this.j.has(t))
        throw new Error(
          `an AI text search provider for the scheme '${t}'is already registered`,
        )
      this.j.add(t)
      const s = this.e++
      return (
        this.i.set(s, e),
        this.c.$registerAITextSearchProvider(s, this.t(t)),
        et(() => {
          this.j.delete(t), this.i.delete(s), this.c.$unregisterProvider(s)
        })
      )
    }
    registerFileSearchProviderOld(t, e) {
      if (this.l.has(t))
        throw new Error(
          `a file search provider for the scheme '${t}' is already registered`,
        )
      this.l.add(t)
      const s = this.e++
      return (
        this.k.set(s, new Xst(e)),
        this.c.$registerFileSearchProvider(s, this.t(t)),
        et(() => {
          this.l.delete(t), this.k.delete(s), this.c.$unregisterProvider(s)
        })
      )
    }
    registerFileSearchProvider(t, e) {
      if (this.l.has(t))
        throw new Error(
          `a file search provider for the scheme '${t}' is already registered`,
        )
      this.l.add(t)
      const s = this.e++
      return (
        this.k.set(s, e),
        this.c.$registerFileSearchProvider(s, this.t(t)),
        et(() => {
          this.l.delete(t), this.k.delete(s), this.c.$unregisterProvider(s)
        })
      )
    }
    $provideFileSearchResults(t, e, s, r) {
      const a = NB(s),
        o = this.k.get(t)
      if (o)
        return this.n.fileSearch(
          a,
          o,
          (c) => {
            this.c.$handleFileMatch(
              t,
              e,
              c.map((l) => l.resource),
            )
          },
          r,
        )
      throw new Error("unknown provider: " + t)
    }
    async doInternalFileSearchWithCustomCallback(t, e, s) {
      return { messages: [] }
    }
    $clearCache(t) {
      return this.n.clearCache(t), Promise.resolve(void 0)
    }
    $provideTextSearchResults(t, e, s, r) {
      const a = this.g.get(t)
      if (!a || !a.provideTextSearchResults)
        throw new Error(`Unknown Text Search Provider ${t}`)
      const o = NB(s)
      return this.v(o, a).search((l) => this.c.$handleTextMatch(t, e, l), r)
    }
    $provideAITextSearchResults(t, e, s, r) {
      const a = this.i.get(t)
      if (!a || !a.provideAITextSearchResults)
        throw new Error(`Unknown AI Text Search Provider ${t}`)
      const o = NB(s)
      return this.w(o, a).search((l) => this.c.$handleTextMatch(t, e, l), r)
    }
    $enableExtensionHostSearch() {}
    async $getAIName(t) {
      const e = this.i.get(t)
      if (!(!e || !e.provideAITextSearchResults)) return e.name ?? "AI"
    }
    v(t, e) {
      return new tW(
        { query: t, provider: e },
        { readdir: (s) => Promise.resolve([]), toCanonicalName: (s) => s },
        "textSearchProvider",
      )
    }
    w(t, e) {
      return new tW(
        { query: t, provider: e },
        { readdir: (s) => Promise.resolve([]), toCanonicalName: (s) => s },
        "aiTextSearchProvider",
      )
    }
  }
xB = __decorate([__param(0, Ot), __param(1, ah), __param(2, Rt)], xB)
function NB(i) {
  return {
    ...i,
    folderQueries: i.folderQueries && i.folderQueries.map(Sxt),
    extraFileResources:
      i.extraFileResources && i.extraFileResources.map((t) => S.revive(t)),
  }
}
function Sxt(i) {
  return ki(i)
}
var iW,
  sW = class {
    static {
      iW = this
    }
    static {
      this.a = { focused: !0, active: !0 }
    }
    getState() {
      const t = this.f
      return {
        get focused() {
          return t.focused
        },
        get active() {
          return t.active
        },
      }
    }
    constructor(t, e) {
      ;(this.c = new J()),
        (this.onDidChangeWindowState = this.c.event),
        (this.f = iW.a),
        t.handle && (this.d = W_(t.handle).buffer),
        (this.b = e.getProxy(K.MainThreadWindow)),
        this.b.$getInitialState().then(({ isFocused: s, isActive: r }) => {
          this.onDidChangeWindowProperty("focused", s),
            this.onDidChangeWindowProperty("active", r)
        })
    }
    get nativeHandle() {
      return this.d
    }
    $onDidChangeActiveNativeWindowHandle(t) {
      this.d = t ? W_(t).buffer : void 0
    }
    $onDidChangeWindowFocus(t) {
      this.onDidChangeWindowProperty("focused", t)
    }
    $onDidChangeWindowActive(t) {
      this.onDidChangeWindowProperty("active", t)
    }
    onDidChangeWindowProperty(t, e) {
      e !== this.f[t] && ((this.f = { ...this.f, [t]: e }), this.c.fire(this.f))
    }
    openUri(t, e) {
      let s
      if (typeof t == "string") {
        s = t
        try {
          t = S.parse(t)
        } catch {
          return Promise.reject(`Invalid uri - '${t}'`)
        }
      }
      return E_(t.scheme)
        ? Promise.reject("Invalid scheme - cannot be empty")
        : t.scheme === G.command
          ? Promise.reject(`Invalid scheme '${t.scheme}'`)
          : this.b.$openUri(t, s, e)
    }
    async asExternalUri(t, e) {
      if (E_(t.scheme))
        return Promise.reject("Invalid scheme - cannot be empty")
      const s = await this.b.$asExternalUri(t, e)
      return S.from(s)
    }
  }
sW = iW = __decorate([__param(0, ti), __param(1, Ot)], sW)
var trt = X("IExtHostWindow"),
  CB = class extends Fwt {
    constructor(t, e) {
      super(
        e.logLevel,
        e.logsLocation,
        e.loggers.map((s) => ki(s)),
      ),
        (this.r = t.getProxy(K.MainThreadLogger))
    }
    $setLogLevel(t, e) {
      e ? this.setLogLevel(S.revive(e), t) : this.setLogLevel(t)
    }
    setVisibility(t, e) {
      super.setVisibility(t, e), this.r.$setVisibility(t, e)
    }
    q(t, e, s) {
      return new Ext(this.r, t, e, s)
    }
  }
CB = __decorate([__param(0, Ot), __param(1, ti)], CB)
var Ext = class extends Fq {
    constructor(i, t, e, s) {
      super(s?.logLevel === "always"),
        (this.r = i),
        (this.s = t),
        (this.n = !1),
        (this.q = []),
        this.setLevel(e),
        this.r.$createLogger(t, s).then(() => {
          this.u(this.q), (this.n = !0)
        })
    }
    m(i, t) {
      const e = [[i, t]]
      this.n ? this.u(e) : this.q.push(...e)
    }
    u(i) {
      this.r.$log(this.s, i)
    }
    flush() {
      this.r.$flush(this.s)
    }
  },
  rW = X("IExtHostTerminalShellIntegration"),
  nW = class extends at {
    constructor(t, e) {
      super(),
        (this.h = e),
        (this.b = new Map()),
        (this.c = new J()),
        (this.onDidChangeTerminalShellIntegration = this.c.event),
        (this.f = new J()),
        (this.onDidStartTerminalShellExecution = this.f.event),
        (this.g = new J()),
        (this.onDidEndTerminalShellExecution = this.g.event),
        (this.a = t.getProxy(K.MainThreadTerminalShellIntegration)),
        this.D(
          et(() => {
            for (const [s, r] of this.b) r.dispose()
            this.b.clear()
          }),
        )
    }
    $shellIntegrationChange(t) {
      const e = this.h.getTerminalById(t)
      if (!e) return
      const s = e.value
      let r = this.b.get(t)
      r ||
        ((r = new Ixt(e.value, this.f)),
        this.b.set(t, r),
        r.store.add(e.onWillDispose(() => this.b.get(t)?.dispose())),
        r.store.add(
          r.onDidRequestShellExecution((a) => this.a.$executeCommand(t, a)),
        ),
        r.store.add(r.onDidRequestEndExecution((a) => this.g.fire(a))),
        r.store.add(
          r.onDidRequestChangeShellIntegration((a) => this.c.fire(a)),
        ),
        (e.shellIntegration = r.value)),
        this.c.fire({ terminal: s, shellIntegration: r.value })
    }
    $shellExecutionStart(t, e, s, r, a) {
      this.b.has(t) || this.$shellIntegrationChange(t)
      const o = { value: e, confidence: s, isTrusted: r }
      this.b.get(t)?.startShellExecution(o, S.revive(a))
    }
    $shellExecutionEnd(t, e, s, r, a) {
      const o = { value: e, confidence: s, isTrusted: r }
      this.b.get(t)?.endShellExecution(o, a)
    }
    $shellExecutionData(t, e) {
      this.b.get(t)?.emitData(e)
    }
    $cwdChange(t, e) {
      this.b.get(t)?.setCwd(S.revive(e))
    }
    $closeTerminal(t) {
      this.b.get(t)?.dispose(), this.b.delete(t)
    }
  }
nW = __decorate([__param(0, Ot), __param(1, Pn)], nW)
var Ixt = class extends at {
    get currentExecution() {
      return this.a
    }
    constructor(i, t) {
      super(),
        (this.j = i),
        (this.m = t),
        (this.b = !1),
        (this.store = this.D(new gt())),
        (this.f = this.D(new J())),
        (this.onDidRequestChangeShellIntegration = this.f.event),
        (this.g = this.D(new J())),
        (this.onDidRequestShellExecution = this.g.event),
        (this.h = this.D(new J())),
        (this.onDidRequestEndExecution = this.h.event)
      const e = this
      this.value = {
        get cwd() {
          return e.c
        },
        executeCommand(s, r) {
          let a = s
          if (r)
            for (const l of r)
              !l.match(/["'`]/) && l.match(/\s/)
                ? (a += ` "${l}"`)
                : (a += ` ${l}`)
          e.g.fire(a)
          const o = { value: a, confidence: lO.High, isTrusted: !0 },
            c = e.startShellExecution(o, e.c, !0).value
          return (e.b = !0), c
        },
      }
    }
    startShellExecution(i, t, e) {
      if (this.b && this.a) this.b = !1
      else {
        this.a &&
          (this.a.endExecution(void 0),
          this.h.fire({
            terminal: this.j,
            shellIntegration: this.value,
            execution: this.a.value,
            exitCode: void 0,
          }))
        const s = (this.a = new Pxt(i, t ?? this.c))
        e
          ? queueMicrotask(() =>
              this.m.fire({
                terminal: this.j,
                shellIntegration: this.value,
                execution: s.value,
              }),
            )
          : this.m.fire({
              terminal: this.j,
              shellIntegration: this.value,
              execution: this.a.value,
            })
      }
      return this.a
    }
    emitData(i) {
      this.currentExecution?.emitData(i)
    }
    endShellExecution(i, t) {
      this.a &&
        (this.a.endExecution(i),
        this.h.fire({
          terminal: this.j,
          shellIntegration: this.value,
          execution: this.a.value,
          exitCode: t,
        }),
        (this.a = void 0))
    }
    setCwd(i) {
      let t = !1
      S.isUri(this.c)
        ? (t = !S.isUri(i) || this.c.toString() !== i.toString())
        : this.c !== i && (t = !0),
        t &&
          ((this.c = i),
          this.f.fire({ terminal: this.j, shellIntegration: this.value }))
    }
  },
  Pxt = class {
    constructor(i, t) {
      ;(this.c = i), (this.cwd = t), (this.b = !1)
      const e = this
      this.value = {
        get commandLine() {
          return e.c
        },
        get cwd() {
          return e.cwd
        },
        read() {
          return e.d()
        },
      }
    }
    d() {
      if (!this.a) {
        if (this.b) return Mu.EMPTY
        this.a = new $xt()
      }
      return this.a.createIterable()
    }
    emitData(i) {
      this.a?.emitData(i)
    }
    endExecution(i) {
      i && (this.c = i),
        this.a?.endExecution(),
        (this.a = void 0),
        (this.b = !0)
    }
  },
  $xt = class extends at {
    constructor() {
      super(...arguments), (this.b = [])
    }
    createIterable() {
      this.a || (this.a = new Ns())
      const i = this.a
      return new Mu(async (e) => {
        this.b.push(e), await i.wait()
      })
    }
    emitData(i) {
      for (const t of this.b) t.emitOne(i)
    }
    endExecution() {
      this.a?.open(), (this.a = void 0)
    }
  },
  aW = class extends at {
    constructor(t) {
      super(),
        (this.b = new J()),
        (this.onProcessConfigUpdate = this.b.event),
        (this.a = t.getProxy(K.MainThreadCursor))
    }
    processConfigUpdate(t) {
      this.b.fire(t)
    }
    async sendEnvelope(t, e) {
      await this.a.$sendEnvelope(t, e)
    }
    async sendScopeUpdate(t, e) {
      await this.a.$sendScopeUpdate(t, e)
    }
    async setClientTracingConfig(t) {
      throw new Error("Method not implemented.")
    }
    async setIsPrivacyMode(t) {
      throw new Error("Method not implemented.")
    }
    async setUser(t, e) {
      throw new Error("Method not implemented.")
    }
  }
aW = __decorate([__param(0, Ot)], aW)
var ert = X("IExtHostTracingService")
Ut(IH, EH, 1),
  Ut($c, CB, 1),
  Ut(um, _H, 1),
  Ut(mr, cH, 0),
  Ut(mH, fH, 0),
  Ut(pH, gH, 0),
  Ut(Ds, zM, 0),
  Ut(im, eH, 0),
  Ut(gm, XH, 0),
  Ut(KH, ZH, 0),
  Ut(kst, DH, 0),
  Ut(Fo, AH, 0),
  Ut(PH, $H, 0),
  Ut(Nc, eyt, 0),
  Ut(Tst, RH, 1),
  Ut(eW, xB, 0),
  Ut(tH, Iit, 0),
  Ut(YH, zH, 0),
  Ut(Pn, hH, 0),
  Ut(rW, nW, 0),
  Ut(uB, hB, 0),
  Ut(trt, sW, 0),
  Ut(dr, WM, 0),
  Ut(SH, mst, 0),
  Ut(dB, oH, 0),
  Ut(Bl, QH, 0),
  Ut(ql, PB, 0),
  Ut(ert, aW, 0)
var oW = class extends mB {
  constructor(t, e) {
    super(!0, t, e)
  }
  createTerminal(t, e, s) {
    return this.createTerminalFromOptions({
      name: t,
      shellPath: e,
      shellArgs: s,
    })
  }
  createTerminalFromOptions(t, e) {
    const s = new lH(this.a, Ze(), t, t.name)
    return this.f.push(s), s.create(t, this.S(t, e)), s.value
  }
}
oW = __decorate([__param(0, mr), __param(1, Ot)], oW)
import { promises as irt } from "fs"
var srt
;(function (i) {
  ;(i[(i.stdout = 0)] = "stdout"), (i[(i.stderr = 1)] = "stderr")
})(srt || (srt = {}))
var rrt
;(function (i) {
  ;(i[(i.Success = 0)] = "Success"),
    (i[(i.Unknown = 1)] = "Unknown"),
    (i[(i.AccessDenied = 2)] = "AccessDenied"),
    (i[(i.ProcessNotFound = 3)] = "ProcessNotFound")
})(rrt || (rrt = {}))
function xxt(i, ...t) {
  const e = t.reduce((a, o) => ((a[o] = !0), a), {}),
    s = [
      /^ELECTRON_.+$/,
      /^VSCODE_(?!(PORTABLE|SHELL_LOGIN|ENV_REPLACE|ENV_APPEND|ENV_PREPEND)).+$/,
      /^SNAP(|_.*)$/,
      /^GDK_PIXBUF_.+$/,
    ]
  Object.keys(i)
    .filter((a) => !e[a])
    .forEach((a) => {
      for (let o = 0; o < s.length; o++)
        if (a.search(s[o]) !== -1) {
          delete i[a]
          break
        }
    })
}
function Nxt(i) {
  i && (delete i.DEBUG, De && delete i.LD_PRELOAD)
}
function nrt(i = Mn) {
  return i.comspec || "cmd.exe"
}
function Cxt(i) {
  let t = [],
    e = !1
  const s = function (r) {
    if (e) {
      t.push(r)
      return
    }
    ;(!i.send(r, (o) => {
      if ((o && console.error(o), (e = !1), t.length > 0)) {
        const c = t.slice(0)
        ;(t = []), c.forEach((l) => s(l))
      }
    }) ||
      ie) &&
      (e = !0)
  }
  return { send: s }
}
var wm
;(function (i) {
  async function t(e, s, r) {
    if ($r(e)) return e
    if (
      (s === void 0 && (s = Ma()),
      Ui(e) !== "." ||
        (r === void 0 && _t(Mn.PATH) && (r = Mn.PATH.split(lG)),
        r === void 0 || r.length === 0))
    )
      return se(s, e)
    async function o(c) {
      if (await re.exists(c)) {
        let l
        try {
          l = await irt.stat(c)
        } catch (u) {
          u.message.startsWith("EACCES") && (l = await irt.lstat(c))
        }
        return l ? !l.isDirectory() : !1
      }
      return !1
    }
    for (const c of r) {
      let l
      if (($r(c) ? (l = se(c, e)) : (l = se(s, c, e)), await o(l))) return l
      let u = l + ".com"
      if ((await o(u)) || ((u = l + ".exe"), await o(u))) return u
    }
    return se(s, e)
  }
  i.findExecutable = t
})(wm || (wm = {}))
import { homedir as Jxt } from "os"
var cW = class extends IB {
  constructor(t, e, s, r, a, o, c, l, u) {
    super(t, e, s, r, a, o, c, l),
      (this.C = s),
      (this.D = u),
      e.remote.isRemote && e.remote.authority
        ? this.registerTaskSystem(G.vscodeRemote, {
            scheme: G.vscodeRemote,
            authority: e.remote.authority,
            platform: process.platform,
          })
        : this.registerTaskSystem(G.file, {
            scheme: G.file,
            authority: "",
            platform: process.platform,
          }),
      this.a.$registerSupportedExecutions(!0, !0, !0)
  }
  async executeTask(t, e) {
    const s = e
    if (!e.execution && s._id === void 0)
      throw new Error("Tasks to execute must include an execution")
    if (s._id !== void 0) {
      const r = WH.from(s, this.C),
        a = await this.a.$getTaskExecution(r)
      if (a.task === void 0)
        throw new Error("Task from execution DTO is undefined")
      const o = await this.z(a, e)
      return this.a.$executeTask(r).catch(() => {}), o
    } else {
      const r = Mr.from(e, t)
      if (r === void 0) return Promise.reject(new Error("Task is not valid"))
      fr.is(r.execution) && (await this.y(r, e, !1))
      const a = await this.z(await this.a.$getTaskExecution(r), e)
      return this.a.$executeTask(r).catch(() => {}), a
    }
  }
  v(t, e, s, r) {
    const a = []
    if (r)
      for (const o of r) {
        this.A(o, s),
          (!o.definition || !t[o.definition.type]) &&
            this.f.warn(
              `The task [${o.source}, ${o.name}] uses an undefined task type. The task will be ignored in the future.`,
            )
        const c = Mr.from(o, s.extension)
        c && (a.push(c), fr.is(c.execution) && e.push(this.y(c, o, !0)))
      }
    return { tasks: a, extension: s.extension }
  }
  async w(t) {
    return t
  }
  async G(t) {
    let e = t && t.length > 0 ? t[0] : void 0
    if (!e) {
      const s = S.file(Jxt())
      e = new Oq({ uri: s, name: xr(s), index: 0 })
    }
    return {
      uri: e.uri,
      name: e.name,
      index: e.index,
      toResource: () => {
        throw new Error("Not implemented")
      },
    }
  }
  async $resolveVariables(t, e) {
    const s = S.revive(t),
      r = { process: void 0, variables: Object.create(null) },
      a = await this.b.resolveWorkspaceFolder(s),
      o = (await this.b.getWorkspaceFolders2()) ?? [],
      c = await this.D.getResolver(),
      l = a
        ? {
            uri: a.uri,
            name: a.name,
            index: a.index,
            toResource: () => {
              throw new Error("Not implemented")
            },
          }
        : await this.G(o)
    for (const u of e.variables) r.variables[u] = await c.resolveAsync(l, u)
    if (e.process !== void 0) {
      let u
      if (e.process.path !== void 0) {
        u = e.process.path.split(lG)
        for (let d = 0; d < u.length; d++) u[d] = await c.resolveAsync(l, u[d])
      }
      r.process = await wm.findExecutable(
        await c.resolveAsync(l, e.process.name),
        e.process.cwd !== void 0
          ? await c.resolveAsync(l, e.process.cwd)
          : void 0,
        u,
      )
    }
    return r
  }
  async $jsonTasksSupported() {
    return !0
  }
  async $findExecutable(t, e, s) {
    return wm.findExecutable(t, e, s)
  }
}
cW = __decorate(
  [
    __param(0, Ot),
    __param(1, ti),
    __param(2, dr),
    __param(3, Fo),
    __param(4, Ds),
    __param(5, Pn),
    __param(6, Rt),
    __param(7, um),
    __param(8, ql),
  ],
  cW,
)
import * as Ul from "child_process"
var IQt = X("externalTerminal"),
  JB = "Terminal.app",
  art = g(1908, null),
  lW = class {
    async getDefaultTerminalForPlatforms() {
      return {
        windows: uW.getDefaultTerminalWindows(),
        linux: await ort.getDefaultTerminalLinuxReady(),
        osx: "xterm",
      }
    }
  },
  uW = class On extends lW {
    static {
      this.CMD = "cmd.exe"
    }
    openTerminal(t, e) {
      return this.spawnTerminal(Ul, t, nrt(), e)
    }
    spawnTerminal(t, e, s, r) {
      const a = e.windowsExec || On.getDefaultTerminalWindows()
      r && r[1] === ":" && (r = r[0].toUpperCase() + r.substr(1))
      const o = ke(a, ".exe").toLowerCase()
      if (o === "cmder")
        return t.spawn(a, r ? [r] : void 0), Promise.resolve(void 0)
      const c = ["/c", "start", "/wait"]
      return (
        a.indexOf(" ") >= 0 && c.push(a),
        c.push(a),
        o === "wt" && c.push("-d ."),
        new Promise((l, u) => {
          const d = Ml(process),
            m = t.spawn(s, c, { cwd: r, env: d, detached: !0 })
          m.on("error", u), m.on("exit", () => l())
        })
      )
    }
    async runInTerminal(t, e, s, r, a) {
      const o =
          "windowsExec" in a && a.windowsExec
            ? a.windowsExec
            : On.getDefaultTerminalWindows(),
        c = await On.getWtExePath()
      return new Promise((l, u) => {
        const d = `"${e} - ${art}"`,
          m = `"${s.join('" "')}" & pause`,
          f = Object.assign({}, Ml(process), r)
        Object.keys(f)
          .filter((E) => f[E] === null)
          .forEach((E) => delete f[E])
        const p = { cwd: e, env: f, windowsVerbatimArguments: !0 }
        let v, b
        ke(o, ".exe") === "wt"
          ? ((v = o), (b = ["-d", ".", On.CMD, "/c", m]))
          : c
            ? ((v = c), (b = ["-d", ".", o, "/c", m]))
            : ((v = On.CMD),
              (b = ["/c", "start", d, "/wait", o, "/c", `"${m}"`])),
          Ul.spawn(v, b, p).on("error", (E) => {
            u(hW(E))
          }),
          l(void 0)
      })
    }
    static getDefaultTerminalWindows() {
      if (!On._DEFAULT_TERMINAL_WINDOWS) {
        const t = !!process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432")
        On._DEFAULT_TERMINAL_WINDOWS = `${process.env.windir ? process.env.windir : "C:\\Windows"}\\${t ? "Sysnative" : "System32"}\\cmd.exe`
      }
      return On._DEFAULT_TERMINAL_WINDOWS
    }
    static async getWtExePath() {
      try {
        const t = await wm.findExecutable("wt")
        return (await re.exists(t)) ? t : void 0
      } catch {
        return
      }
    }
  }
__decorate([SY], uW, "getWtExePath", null)
var Lxt = class vut extends lW {
    static {
      this.OSASCRIPT = "/usr/bin/osascript"
    }
    openTerminal(t, e) {
      return this.spawnTerminal(Ul, t, e)
    }
    runInTerminal(t, e, s, r, a) {
      const o = a.osxExec || JB
      return new Promise((c, l) => {
        if (o === JB || o === "iTerm.app") {
          const u = o === JB ? "TerminalHelper" : "iTermHelper",
            m = [
              UG.asFileUri(
                `vs/workbench/contrib/externalTerminal/node/${u}.scpt`,
              ).fsPath,
              "-t",
              t || art,
              "-w",
              e,
            ]
          for (const v of s) m.push("-a"), m.push(v)
          if (r) {
            const v = Object.assign({}, Ml(process), r)
            for (const b in v) {
              const k = v[b]
              k === null
                ? (m.push("-u"), m.push(b))
                : (m.push("-e"), m.push(`${b}=${k}`))
            }
          }
          let f = ""
          const p = Ul.spawn(vut.OSASCRIPT, m)
          p.on("error", (v) => {
            l(hW(v))
          }),
            p.stderr.on("data", (v) => {
              f += v.toString()
            }),
            p.on("exit", (v) => {
              if (v === 0) c(void 0)
              else if (f) {
                const b = f.split(
                  `
`,
                  1,
                )
                l(new Error(b[0]))
              } else l(new Error(g(1909, null, u, v)))
            })
        } else l(new Error(g(1910, null, o)))
      })
    }
    spawnTerminal(t, e, s) {
      const r = e.osxExec || JB
      return new Promise((a, o) => {
        const c = ["-a", r]
        s && c.push(s)
        const l = Ml(process),
          u = t.spawn("/usr/bin/open", c, { cwd: s, env: l })
        u.on("error", o), u.on("exit", () => a())
      })
    }
  },
  ort = class Da extends lW {
    static {
      this.WAIT_MESSAGE = g(1911, null)
    }
    openTerminal(t, e) {
      return this.spawnTerminal(Ul, t, e)
    }
    runInTerminal(t, e, s, r, a) {
      const o = a.linuxExec
        ? Promise.resolve(a.linuxExec)
        : Da.getDefaultTerminalLinuxReady()
      return new Promise((c, l) => {
        const u = []
        o.then((d) => {
          d.indexOf("gnome-terminal") >= 0 ? u.push("-x") : u.push("-e"),
            u.push("bash"),
            u.push("-c")
          const m = `${Rxt(s)}; echo; read -p "${Da.WAIT_MESSAGE}" -n1;`
          u.push(`''${m}''`)
          const f = Object.assign({}, Ml(process), r)
          Object.keys(f)
            .filter((k) => f[k] === null)
            .forEach((k) => delete f[k])
          const p = { cwd: e, env: f }
          let v = ""
          const b = Ul.spawn(d, u, p)
          b.on("error", (k) => {
            l(hW(k))
          }),
            b.stderr.on("data", (k) => {
              v += k.toString()
            }),
            b.on("exit", (k) => {
              if (k === 0) c(void 0)
              else if (v) {
                const E = v.split(
                  `
`,
                  1,
                )
                l(new Error(E[0]))
              } else l(new Error(g(1912, null, d, k)))
            })
        })
      })
    }
    static async getDefaultTerminalLinuxReady() {
      if (!Da._DEFAULT_TERMINAL_LINUX_READY)
        if (!De) Da._DEFAULT_TERMINAL_LINUX_READY = Promise.resolve("xterm")
        else {
          const t = await re.exists("/etc/debian_version")
          Da._DEFAULT_TERMINAL_LINUX_READY = new Promise((e) => {
            t
              ? e("x-terminal-emulator")
              : process.env.DESKTOP_SESSION === "gnome" ||
                  process.env.DESKTOP_SESSION === "gnome-classic"
                ? e("gnome-terminal")
                : process.env.DESKTOP_SESSION === "kde-plasma"
                  ? e("konsole")
                  : process.env.COLORTERM
                    ? e(process.env.COLORTERM)
                    : process.env.TERM
                      ? e(process.env.TERM)
                      : e("xterm")
          })
        }
      return Da._DEFAULT_TERMINAL_LINUX_READY
    }
    spawnTerminal(t, e, s) {
      const r = e.linuxExec
        ? Promise.resolve(e.linuxExec)
        : Da.getDefaultTerminalLinuxReady()
      return new Promise((a, o) => {
        r.then((c) => {
          const l = Ml(process),
            u = t.spawn(c, [], { cwd: s, env: l })
          u.on("error", o), u.on("exit", () => a())
        })
      })
    }
  }
function Ml(i) {
  const t = { ...i.env }
  return xxt(t), t
}
function hW(i) {
  return "errno" in i &&
    i.errno === "ENOENT" &&
    "path" in i &&
    typeof i.path == "string"
    ? new Error(g(1913, null, i.path))
    : i
}
function Rxt(i) {
  let t = ""
  for (const e of i)
    e.indexOf(" ") >= 0 ? (t += '"' + e + '"') : (t += e), (t += " ")
  return t
}
var Dxt = class wut {
    constructor() {
      this.b = new Map()
    }
    static {
      this.a = 1
    }
    async createNewMessage(t) {
      try {
        const e = await this.c()
        if (e) {
          const s = String(wut.a++)
          return this.b.set(s, e), { id: s, data: e.createNewMessage(t) }
        }
      } catch {}
      return { id: "", data: t }
    }
    async validate(t, e) {
      if (!t.id) return !0
      const s = this.b.get(t.id)
      if (!s) return !1
      this.b.delete(t.id)
      try {
        return s.validate(e) === "ok"
      } catch {
        return !1
      } finally {
        s.dispose?.()
      }
    }
    async sign(t) {
      try {
        return await this.d(t)
      } catch {}
      return t
    }
  },
  crt = class extends Dxt {
    c() {
      return this.h().then((i) => new i.validator())
    }
    d(i) {
      return this.h().then((t) => new t.signer().sign(i))
    }
    async h() {
      const i = "vsda",
        { default: t } = await import(i)
      return t
    }
  }
import * as dW from "child_process"
import * as lrt from "net"
var urt = class vu extends Ust {
    static {
      this.b = `\r
\r
`
    }
    static {
      this.i = /\r?\n/
    }
    static {
      this.l = /: */
    }
    constructor() {
      super(), (this.r = Buffer.allocUnsafe(0)), (this.t = -1)
    }
    v(t, e) {
      ;(this.p = e),
        (this.r = Buffer.allocUnsafe(0)),
        (this.t = -1),
        t.on("data", (s) => this.x(s))
    }
    sendMessage(t) {
      if (this.p) {
        const e = JSON.stringify(t)
        this.p.write(
          `Content-Length: ${Buffer.byteLength(e, "utf8")}${vu.b}${e}`,
          "utf8",
        )
      }
    }
    x(t) {
      for (this.r = Buffer.concat([this.r, t]); ; ) {
        if (this.t >= 0) {
          if (this.r.length >= this.t) {
            const e = this.r.toString("utf8", 0, this.t)
            if (((this.r = this.r.slice(this.t)), (this.t = -1), e.length > 0))
              try {
                this.acceptMessage(JSON.parse(e))
              } catch (s) {
                this.n.fire(
                  new Error(
                    (s.message || s) +
                      `
` +
                      e,
                  ),
                )
              }
            continue
          }
        } else {
          const e = this.r.indexOf(vu.b)
          if (e !== -1) {
            const r = this.r.toString("utf8", 0, e).split(vu.i)
            for (const a of r) {
              const o = a.split(vu.l)
              o[0] === "Content-Length" && (this.t = Number(o[1]))
            }
            this.r = this.r.slice(e + vu.b.length)
            continue
          }
        }
        break
      }
    }
  },
  hrt = class extends urt {
    startSession() {
      return new Promise((i, t) => {
        let e = !1
        ;(this.y = this.z(() => {
          this.v(this.y, this.y), i(), (e = !0)
        })),
          this.y.on("close", () => {
            e
              ? this.n.fire(new Error("connection closed"))
              : t(new Error("connection closed"))
          }),
          this.y.on("error", (s) => {
            e ? this.n.fire(s) : t(s)
          })
      })
    }
    async stopSession() {
      await this.w(), this.y && (this.y.end(), (this.y = void 0))
    }
  },
  Fxt = class extends hrt {
    constructor(i) {
      super(), (this.A = i)
    }
    z(i) {
      return lrt.createConnection(this.A.port, this.A.host || "127.0.0.1", i)
    }
  },
  Axt = class extends hrt {
    constructor(i) {
      super(), (this.A = i)
    }
    z(i) {
      return lrt.createConnection(this.A.path, i)
    }
  },
  drt = class tc extends urt {
    constructor(t, e) {
      super(), (this.z = t), (this.A = e)
    }
    async startSession() {
      const t = this.z.command,
        e = this.z.args,
        s = this.z.options || {}
      try {
        if (t)
          if ($r(t)) {
            if (!(await re.exists(t))) throw new Error(g(6276, null, t))
          } else t.indexOf("/") < 0 && t.indexOf("\\") < 0
        else throw new Error(g(6277, null, this.A))
        let r = process.env
        if (
          (s.env &&
            Object.keys(s.env).length > 0 &&
            (r = en(pe(process.env), s.env)),
          t === "node")
        )
          if (Array.isArray(e) && e.length > 0) {
            const a =
                !!process.env.ELECTRON_RUN_AS_NODE ||
                !!process.versions.electron,
              o = {
                env: r,
                execArgv: a
                  ? [
                      "-e",
                      "delete process.env.ELECTRON_RUN_AS_NODE;require(process.argv[1])",
                    ]
                  : [],
                silent: !0,
              }
            s.cwd && (o.cwd = s.cwd)
            const c = dW.fork(e[0], e.slice(1), o)
            if (!c.pid) throw new Error(g(6278, null, e[0]))
            this.y = c
          } else throw new Error(g(6279, null))
        else {
          let a = t,
            o = e
          const c = { env: r }
          s.cwd && (c.cwd = s.cwd),
            ie &&
              (t.endsWith(".bat") || t.endsWith(".cmd")) &&
              ((c.shell = !0),
              (a = `"${t}"`),
              (o = e.map((l) => ((l = l.replace(/"/g, '\\"')), `"${l}"`)))),
            (this.y = dW.spawn(a, o, c))
        }
        this.y.on("error", (a) => {
          this.n.fire(a)
        }),
          this.y.on("exit", (a, o) => {
            this.o.fire(a)
          }),
          this.y.stdout.on("close", () => {
            this.n.fire(new Error("read error"))
          }),
          this.y.stdout.on("error", (a) => {
            this.n.fire(a)
          }),
          this.y.stdin.on("error", (a) => {
            this.n.fire(a)
          }),
          this.y.stderr.resume(),
          this.v(this.y.stdout, this.y.stdin)
      } catch (r) {
        this.n.fire(r)
      }
    }
    async stopSession() {
      return this.y
        ? (await this.w(),
          ie
            ? new Promise((t, e) => {
                const s = dW.exec(
                  `taskkill /F /T /PID ${this.y.pid}`,
                  function (r, a, o) {
                    if (r) return e(r)
                  },
                )
                s.on("exit", t), s.on("error", e)
              })
            : (this.y.kill("SIGTERM"), Promise.resolve(void 0)))
        : Promise.resolve(void 0)
    }
    static B(t, e) {
      if (!t) return
      const s = Object.create(null)
      t.runtime &&
        (t.runtime.indexOf("./") === 0
          ? (s.runtime = se(e, t.runtime))
          : (s.runtime = t.runtime)),
        t.runtimeArgs && (s.runtimeArgs = t.runtimeArgs),
        t.program &&
          ($r(t.program)
            ? (s.program = t.program)
            : (s.program = se(e, t.program))),
        t.args && (s.args = t.args)
      const r = t
      return (
        r.win && (s.win = tc.B(r.win, e)),
        r.winx86 && (s.winx86 = tc.B(r.winx86, e)),
        r.windows && (s.windows = tc.B(r.windows, e)),
        r.osx && (s.osx = tc.B(r.osx, e)),
        r.linux && (s.linux = tc.B(r.linux, e)),
        s
      )
    }
    static platformAdapterExecutable(t, e) {
      let s = Object.create(null)
      e = e.toLowerCase()
      for (const u of t)
        if (u.contributes) {
          const d = u.contributes.debuggers
          d &&
            d.length > 0 &&
            d
              .filter((m) => typeof m.type == "string" && Ws(m.type, e))
              .forEach((m) => {
                const f = tc.B(m, u.extensionLocation.fsPath)
                s = en(s, f, u.isBuiltin)
              })
        }
      let r
      ie && !process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432")
        ? (r = s.winx86 || s.win || s.windows)
        : ie
          ? (r = s.win || s.windows)
          : Ke
            ? (r = s.osx)
            : De && (r = s.linux),
        (r = r || s)
      const a = r.program || s.program,
        o = r.args || s.args,
        c = r.runtime || s.runtime,
        l = r.runtimeArgs || s.runtimeArgs
      if (c)
        return {
          type: "executable",
          command: c,
          args: (l || [])
            .concat(typeof a == "string" ? [a] : [])
            .concat(o || []),
        }
      if (a) return { type: "executable", command: a, args: o || [] }
    }
  }
import * as _xt from "child_process"
function Oxt(i, t) {
  return new Promise((e, s) => {
    let r = ""
    const a = _xt.spawn(i, t)
    a.pid &&
      a.stdout.on("data", (o) => {
        r += o.toString()
      }),
      a.on("error", (o) => {
        s(o)
      }),
      a.on("close", (o) => {
        e(r)
      })
  })
}
async function Bxt(i) {
  if (i)
    if (ie) {
      const t = await import("@vscode/windows-process-tree")
      return new Promise((e) => {
        t.getProcessTree(i, (s) => {
          e(!!s && s.children.length > 0)
        })
      })
    } else
      return Oxt("/usr/bin/pgrep", ["-lP", String(i)]).then(
        (t) => {
          const e = t.trim()
          return !(e.length === 0 || e.indexOf(" tmux") >= 0)
        },
        (t) => !0,
      )
  return Promise.resolve(!0)
}
var mrt
;(function (i) {
  ;(i[(i.cmd = 0)] = "cmd"),
    (i[(i.powershell = 1)] = "powershell"),
    (i[(i.bash = 2)] = "bash")
})(mrt || (mrt = {}))
function qxt(i, t, e, s, r) {
  i = i.trim().toLowerCase()
  let a
  i.indexOf("powershell") >= 0 || i.indexOf("pwsh") >= 0
    ? (a = 1)
    : i.indexOf("cmd.exe") >= 0
      ? (a = 0)
      : i.indexOf("bash") >= 0
        ? (a = 2)
        : ie
          ? (a = 0)
          : (a = 2)
  let o,
    c = " "
  switch (a) {
    case 1:
      if (
        ((o = (l) => (
          (l = l.replace(/\'/g, "''")),
          l.length > 0 && l.charAt(l.length - 1) === "\\"
            ? `'${l}\\'`
            : `'${l}'`
        )),
        s)
      ) {
        const l = LG(s)
        l && (c += `${l}:; `), (c += `cd ${o(s)}; `)
      }
      if (r)
        for (const l in r) {
          const u = r[l]
          u === null
            ? (c += `Remove-Item env:${l}; `)
            : (c += `\${env:${l}}='${u}'; `)
        }
      if (t.length > 0) {
        const l = t.shift(),
          u = e ? l : o(l)
        c += u[0] === "'" ? `& ${u} ` : `${u} `
        for (const d of t)
          (c += d === "<" || d === ">" || e ? d : o(d)), (c += " ")
      }
      break
    case 0:
      if (
        ((o = (l) => (
          (l = l.replace(/\"/g, '""')),
          (l = l.replace(/([><!^&|])/g, "^$1")),
          ' "'.split("").some((u) => l.includes(u)) || l.length === 0
            ? `"${l}"`
            : l
        )),
        s)
      ) {
        const l = LG(s)
        l && (c += `${l}: && `), (c += `cd ${o(s)} && `)
      }
      if (r) {
        c += 'cmd /C "'
        for (const l in r) {
          let u = r[l]
          u === null
            ? (c += `set "${l}=" && `)
            : ((u = u.replace(/[&^|<>]/g, (d) => `^${d}`)),
              (c += `set "${l}=${u}" && `))
        }
      }
      for (const l of t)
        (c += l === "<" || l === ">" || e ? l : o(l)), (c += " ")
      r && (c += '"')
      break
    case 2: {
      o = (u) => (
        (u = u.replace(/(["'\\\$!><#()\[\]*&^| ;{}?`])/g, "\\$1")),
        u.length === 0 ? '""' : u
      )
      const l = (u) =>
        /[^\w@%\/+=,.:^-]/.test(u) ? `'${u.replace(/'/g, "'\\''")}'` : u
      if ((s && (c += `cd ${o(s)} ; `), r)) {
        c += "/usr/bin/env"
        for (const u in r) {
          const d = r[u]
          d === null ? (c += ` -u ${l(u)}`) : (c += ` ${l(`${u}=${d}`)}`)
        }
        c += " "
      }
      for (const u of t)
        (c += u === "<" || u === ">" || e ? u : o(u)), (c += " ")
      break
    }
  }
  return c
}
var mW = class extends $B {
  constructor(t, e, s, r, a, o, c, l, u, d) {
    super(t, e, s, r, c, l, u, d),
      (this.Fb = a),
      (this.Gb = o),
      (this.Db = new Mxt())
  }
  ib(t, e) {
    return t instanceof sl
      ? new drt(this.lb(t), e.type)
      : t instanceof rl
        ? new Fxt(this.mb(t))
        : t instanceof Hh
          ? new Axt(this.nb(t))
          : super.ib(t, e)
  }
  vb(t, e) {
    const s = drt.platformAdapterExecutable(
      e.getAllExtensionDescriptions(),
      t.type,
    )
    if (s) return new sl(s.command, s.args, s.options)
  }
  jb() {
    return new crt()
  }
  async $runInTerminal(t, e) {
    if (t.kind === "integrated") {
      this.Eb ||
        (this.Eb = this.D(
          this.Fb.onDidCloseTerminal((v) => {
            this.Db.onTerminalClosed(v)
          }),
        ))
      const s = await this.ab.getConfigProvider(),
        r = this.Fb.getDefaultShell(!0),
        a = this.Fb.getDefaultShellArgs(!0),
        o = t.title || g(2788, null),
        c = JSON.stringify({ shell: r, shellArgs: a })
      let l = await this.Db.checkout(c, o),
        u,
        d = !1
      if (l) u = t.cwd
      else {
        const v = {
          shellPath: r,
          shellArgs: a,
          cwd: t.cwd,
          name: o,
          iconPath: new Ji("debug"),
        }
        ;(d = !0),
          (l = this.Fb.createTerminalFromOptions(v, {
            isFeatureTerminal: !0,
            forceShellIntegration: !0,
            useShellEnvironment: !0,
          })),
          this.Db.insert(l, c)
      }
      l.show(!0)
      const m = await l.processId
      if (d) {
        let v
        ;(function (k) {
          ;(k[(k.DataDebounce = 500)] = "DataDebounce"),
            (k[(k.MaxDelay = 5e3)] = "MaxDelay")
        })(v || (v = {}))
        const b = new gt()
        await new Promise((k) => {
          const E = b.add(new tn(k, 500))
          b.add(
            this.Fb.onDidWriteTerminalData((P) => {
              P.terminal === l && E.schedule()
            }),
          ),
            b.add(
              this.Gb.onDidChangeTerminalShellIntegration((P) => {
                P.terminal === l && k()
              }),
            ),
            b.add(XG(k, 5e3))
        }),
          b.dispose()
      } else
        l.state.isInteractedWith &&
          !l.shellIntegration &&
          (l.sendText(""), await Fi(200)),
          s.getConfiguration("debug.terminal").get("clearBeforeReusing") &&
            (r.indexOf("powershell") >= 0 ||
            r.indexOf("pwsh") >= 0 ||
            r.indexOf("cmd.exe") >= 0
              ? l.sendText("cls")
              : r.indexOf("bash") >= 0
                ? l.sendText("clear")
                : ie
                  ? l.sendText("cls")
                  : l.sendText("clear"))
      const f = qxt(r, t.args, !!t.argsCanBeInterpretedByShell, u, t.env)
      l.shellIntegration ? l.shellIntegration.executeCommand(f) : l.sendText(f)
      const p = this.onDidTerminateDebugSession((v) => {
        v.id === e && (this.Db.free(l), p.dispose())
      })
      return m
    } else if (t.kind === "external")
      return Uxt(t, await this.ab.getConfigProvider())
    return super.$runInTerminal(t, e)
  }
}
mW = __decorate(
  [
    __param(0, Ot),
    __param(1, dr),
    __param(2, $n),
    __param(3, Ds),
    __param(4, Pn),
    __param(5, rW),
    __param(6, Bl),
    __param(7, ql),
    __param(8, mr),
    __param(9, gm),
  ],
  mW,
)
var ym = void 0
function Uxt(i, t) {
  if (!ym)
    if (ie) ym = new uW()
    else if (Ke) ym = new Lxt()
    else if (De) ym = new ort()
    else throw new Error("external terminals not supported on this platform")
  const e = t.getConfiguration("terminal")
  return ym.runInTerminal(i.title, i.cwd, i.args, i.env || {}, e.external || {})
}
var Mxt = class yut {
    constructor() {
      this.b = new Map()
    }
    static {
      this.a = 1e3
    }
    async checkout(t, e, s = !1) {
      const a = [...this.b.entries()].map(([o, c]) =>
        Zr(async (l) => {
          if (
            o.name !== e ||
            (c.lastUsedAt !== -1 && (await Bxt(await o.processId)))
          )
            return null
          const u = Date.now()
          return c.lastUsedAt + yut.a > u || l.isCancellationRequested
            ? null
            : c.config !== t
              ? (s && o.dispose(), null)
              : ((c.lastUsedAt = u), o)
        }),
      )
      return await Rmt(a, (o) => !!o)
    }
    insert(t, e) {
      this.b.set(t, { lastUsedAt: Date.now(), config: e })
    }
    free(t) {
      const e = this.b.get(t)
      e && (e.lastUsedAt = -1)
    }
    onTerminalClosed(t) {
      this.b.delete(t)
    }
  },
  frt = new as(() => {
    const i = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" })
    return { collator: i, collatorIsNumeric: i.resolvedOptions().numeric }
  }),
  $Qt = new as(() => ({
    collator: new Intl.Collator(void 0, { numeric: !0 }),
  })),
  xQt = new as(() => ({
    collator: new Intl.Collator(void 0, { numeric: !0, sensitivity: "accent" }),
  }))
function prt(i, t, e = !1) {
  const s = i || "",
    r = t || "",
    a = frt.value.collator.compare(s, r)
  return frt.value.collatorIsNumeric && a === 0 && s !== r
    ? s < r
      ? -1
      : 1
    : a
}
function Hxt(i, t, e = !1) {
  return (
    e || ((i = i && i.toLowerCase()), (t = t && t.toLowerCase())),
    i === t ? 0 : i < t ? -1 : 1
  )
}
function LB(i, t, e = !1) {
  const s = i.split(xe),
    r = t.split(xe),
    a = s.length - 1,
    o = r.length - 1
  let c, l
  for (let u = 0; ; u++) {
    if (((c = a === u), (l = o === u), c && l)) return prt(s[u], r[u], e)
    if (c) return -1
    if (l) return 1
    const d = Hxt(s[u], r[u], e)
    if (d !== 0) return d
  }
}
function fW(i, t, e) {
  const s = i.toLowerCase(),
    r = t.toLowerCase(),
    a = Wxt(i, t, e)
  if (a) return a
  const o = s.endsWith(e),
    c = r.endsWith(e)
  if (o !== c) return o ? -1 : 1
  const l = prt(s, r)
  return l !== 0 ? l : s.localeCompare(r)
}
function Wxt(i, t, e) {
  const s = i.toLowerCase(),
    r = t.toLowerCase(),
    a = s.startsWith(e),
    o = r.startsWith(e)
  if (a !== o) return a ? -1 : 1
  if (a && o) {
    if (s.length < r.length) return -1
    if (s.length > r.length) return 1
  }
  return 0
}
var RB = 0,
  grt = [RB, []]
function vrt(i, t, e, s) {
  if (!i || !t) return grt
  const r = i.length,
    a = t.length
  if (r < a) return grt
  const o = i.toLowerCase()
  return jxt(t, e, a, i, o, r, s)
}
function jxt(i, t, e, s, r, a, o) {
  const c = [],
    l = []
  for (let f = 0; f < e; f++) {
    const p = f * a,
      v = p - a,
      b = f > 0,
      k = i[f],
      E = t[f]
    for (let P = 0; P < a; P++) {
      const C = P > 0,
        R = p + P,
        D = R - 1,
        V = v + P - 1,
        tt = C ? c[D] : 0,
        Z = b && C ? c[V] : 0,
        M = b && C ? l[V] : 0
      let rt
      !Z && b ? (rt = 0) : (rt = Vxt(k, E, s, r, P, M)),
        rt && Z + rt >= tt && (o || b || r.startsWith(t, P))
          ? ((l[R] = M + 1), (c[R] = Z + rt))
          : ((l[R] = RB), (c[R] = tt))
    }
  }
  const u = []
  let d = e - 1,
    m = a - 1
  for (; d >= 0 && m >= 0; ) {
    const f = d * a + m
    l[f] === RB || (u.push(m), d--), m--
  }
  return [c[e * a - 1], u.reverse()]
}
function Vxt(i, t, e, s, r, a) {
  let o = 0
  if (!Gxt(t, s[r])) return o
  if (((o += 1), a > 0 && (o += a * 5), i === e[r] && (o += 1), r === 0)) o += 8
  else {
    const c = zxt(e.charCodeAt(r - 1))
    c ? (o += c) : ch(e.charCodeAt(r)) && a === 0 && (o += 2)
  }
  return o
}
function Gxt(i, t) {
  return i === t ? !0 : i === "/" || i === "\\" ? t === "/" || t === "\\" : !1
}
function zxt(i) {
  switch (i) {
    case 47:
    case 92:
      return 5
    case 95:
    case 45:
    case 46:
    case 32:
    case 39:
    case 34:
    case 58:
      return 4
    default:
      return 0
  }
}
var DB = Object.freeze({ score: 0 }),
  FB = 1 << 18,
  pW = 1 << 17,
  gW = 65536
function Yxt(i, t, e, s) {
  const r = s.values ? s.values : [s]
  return nn({
    [s.normalized]: {
      values: r.map((o) => ({
        value: o.normalized,
        expectContiguousMatch: o.expectContiguousMatch,
      })),
      label: i,
      description: t,
      allowNonContiguousMatches: e,
    },
  })
}
function wrt(i, t, e, s, r) {
  if (!i || !t.normalized) return DB
  const a = s.getItemLabel(i)
  if (!a) return DB
  const o = s.getItemDescription(i),
    c = Yxt(a, o, e, t),
    l = r[c]
  if (l) return l
  const u = Qxt(a, o, s.getItemPath(i), t, e)
  return (r[c] = u), u
}
function Qxt(i, t, e, s, r) {
  const a = !e || !s.containsPathSeparator
  return e && (De ? s.pathNormalized === e : Ws(s.pathNormalized, e))
    ? {
        score: FB,
        labelMatch: [{ start: 0, end: i.length }],
        descriptionMatch: t ? [{ start: 0, end: t.length }] : void 0,
      }
    : s.values && s.values.length > 1
      ? Xxt(i, t, e, s.values, a, r)
      : yrt(i, t, e, s, a, r)
}
function Xxt(i, t, e, s, r, a) {
  let o = 0
  const c = [],
    l = []
  for (const u of s) {
    const {
      score: d,
      labelMatch: m,
      descriptionMatch: f,
    } = yrt(i, t, e, u, r, a)
    if (d === RB) return DB
    ;(o += d), m && c.push(...m), f && l.push(...f)
  }
  return { score: o, labelMatch: Trt(c), descriptionMatch: Trt(l) }
}
function yrt(i, t, e, s, r, a) {
  if (r || !t) {
    const [o, c] = vrt(
      i,
      s.normalized,
      s.normalizedLowercase,
      a && !s.expectContiguousMatch,
    )
    if (o) {
      const l = Uq(s.normalized, i)
      let u
      if (l) {
        u = pW
        const d = Math.round((s.normalized.length / i.length) * 100)
        u += d
      } else u = gW
      return { score: u + o, labelMatch: l || brt(c) }
    }
  }
  if (t) {
    let o = t
    e && (o = `${t}${xe}`)
    const c = o.length,
      l = `${o}${i}`,
      [u, d] = vrt(
        l,
        s.normalized,
        s.normalizedLowercase,
        a && !s.expectContiguousMatch,
      )
    if (u) {
      const m = brt(d),
        f = [],
        p = []
      return (
        m.forEach((v) => {
          v.start < c && v.end > c
            ? (f.push({ start: 0, end: v.end - c }),
              p.push({ start: v.start, end: c }))
            : v.start >= c
              ? f.push({ start: v.start - c, end: v.end - c })
              : p.push(v)
        }),
        { score: u, labelMatch: f, descriptionMatch: p }
      )
    }
  }
  return DB
}
function brt(i) {
  const t = []
  if (!i) return t
  let e
  for (const s of i)
    e && e.end === s
      ? (e.end += 1)
      : ((e = { start: s, end: s + 1 }), t.push(e))
  return t
}
function Trt(i) {
  const t = i.sort((r, a) => r.start - a.start),
    e = []
  let s
  for (const r of t)
    !s || !Kxt(s, r)
      ? ((s = r), e.push(r))
      : ((s.start = Math.min(s.start, r.start)),
        (s.end = Math.max(s.end, r.end)))
  return e
}
function Kxt(i, t) {
  return !(i.end < t.start || t.end < i.start)
}
function Zxt(i, t, e, s, r, a) {
  const o = wrt(i, e, s, r, a),
    c = wrt(t, e, s, r, a),
    l = o.score,
    u = c.score
  if ((l === FB || u === FB) && l !== u) return l === FB ? -1 : 1
  if (l > gW || u > gW) {
    if (l !== u) return l > u ? -1 : 1
    if (l < pW && u < pW) {
      const k = tNt(o.labelMatch, c.labelMatch)
      if (k !== 0) return k
    }
    const v = r.getItemLabel(i) || "",
      b = r.getItemLabel(t) || ""
    if (v.length !== b.length) return v.length - b.length
  }
  if (l !== u) return l > u ? -1 : 1
  const d = Array.isArray(o.labelMatch) && o.labelMatch.length > 0,
    m = Array.isArray(c.labelMatch) && c.labelMatch.length > 0
  if (d && !m) return -1
  if (m && !d) return 1
  const f = krt(i, o, r),
    p = krt(t, c, r)
  return f && p && f !== p ? (p > f ? -1 : 1) : eNt(i, t, e, r)
}
function krt(i, t, e) {
  let s = -1,
    r = -1
  if (
    (t.descriptionMatch && t.descriptionMatch.length
      ? (s = t.descriptionMatch[0].start)
      : t.labelMatch && t.labelMatch.length && (s = t.labelMatch[0].start),
    t.labelMatch && t.labelMatch.length)
  ) {
    if (
      ((r = t.labelMatch[t.labelMatch.length - 1].end),
      t.descriptionMatch && t.descriptionMatch.length)
    ) {
      const a = e.getItemDescription(i)
      a && (r += a.length)
    }
  } else
    t.descriptionMatch &&
      t.descriptionMatch.length &&
      (r = t.descriptionMatch[t.descriptionMatch.length - 1].end)
  return r - s
}
function tNt(i, t) {
  if ((!i && !t) || ((!i || !i.length) && (!t || !t.length))) return 0
  if (!t || !t.length) return -1
  if (!i || !i.length) return 1
  const e = i[0].start,
    r = i[i.length - 1].end - e,
    a = t[0].start,
    c = t[t.length - 1].end - a
  return r === c ? 0 : c < r ? 1 : -1
}
function eNt(i, t, e, s) {
  const r = s.getItemLabel(i) || "",
    a = s.getItemLabel(t) || "",
    o = s.getItemDescription(i),
    c = s.getItemDescription(t),
    l = r.length + (o ? o.length : 0),
    u = a.length + (c ? c.length : 0)
  if (l !== u) return l - u
  const d = s.getItemPath(i),
    m = s.getItemPath(t)
  return d && m && d.length !== m.length
    ? d.length - m.length
    : r !== a
      ? fW(r, a, e.normalized)
      : o && c && o !== c
        ? fW(o, c, e.normalized)
        : d && m && d !== m
          ? fW(d, m, e.normalized)
          : 0
}
function Srt(i) {
  return i.startsWith('"') && i.endsWith('"')
}
var iNt = " "
function vW(i) {
  typeof i != "string" && (i = "")
  const t = i.toLowerCase(),
    { pathNormalized: e, normalized: s, normalizedLowercase: r } = Ert(i),
    a = e.indexOf(xe) >= 0,
    o = Srt(i)
  let c
  const l = i.split(iNt)
  if (l.length > 1)
    for (const u of l) {
      const d = Srt(u),
        { pathNormalized: m, normalized: f, normalizedLowercase: p } = Ert(u)
      f &&
        (c || (c = []),
        c.push({
          original: u,
          originalLowercase: u.toLowerCase(),
          pathNormalized: m,
          normalized: f,
          normalizedLowercase: p,
          expectContiguousMatch: d,
        }))
    }
  return {
    original: i,
    originalLowercase: t,
    pathNormalized: e,
    normalized: s,
    normalizedLowercase: r,
    values: c,
    containsPathSeparator: a,
    expectContiguousMatch: o,
  }
}
function Ert(i) {
  let t
  ie ? (t = i.replace(/\//g, xe)) : (t = i.replace(/\\/g, xe))
  const e = Fdt(t).replace(/\s|"/g, "")
  return {
    pathNormalized: t,
    normalized: e,
    normalizedLowercase: e.toLowerCase(),
  }
}
import * as sNt from "child_process"
import * as wW from "fs"
import { StringDecoder as Irt } from "string_decoder"
import * as rNt from "child_process"
function AB(i) {
  return i.startsWith("**") || i.startsWith("/") ? i : `/${i}`
}
function nNt(i) {
  return new mM(i.start.line, i.start.character, i.end.line, i.end.character)
}
function Prt(i) {
  return new Dtt(i.startLineNumber, i.startColumn, i.endLineNumber, i.endColumn)
}
var _B = class {
  constructor(t, e) {
    ;(this.a = t), (this.b = e)
  }
  appendLine(t) {
    this.b.debug(`${this.a}#search`, t)
  }
}
_B = __decorate([__param(1, Rt)], _B)
import { rgPath as aNt } from "@vscode/ripgrep"
var $rt = aNt.replace(/\bnode_modules\.asar\b/, "node_modules.asar.unpacked")
function oNt(i, t, e, s, r) {
  const a = cNt(i, t, e, s, r),
    o = t.folder.fsPath
  return {
    cmd: rNt.spawn($rt, a.args, { cwd: o }),
    rgDiskPath: $rt,
    siblingClauses: a.siblingClauses,
    rgArgs: a,
    cwd: o,
  }
}
function cNt(i, t, e, s, r) {
  const a = ["--files", "--hidden", "--case-sensitive", "--no-require-git"]
  uNt([t], e, !1).forEach((c) => {
    const l = AB(c)
    if ((a.push("-g", l), Ke)) {
      const u = dY(l)
      u !== l && a.push("-g", u)
    }
  })
  const o = lNt([t], s, void 0, !1)
  return (
    o.globArgs.forEach((c) => {
      const l = `!${AB(c)}`
      if ((a.push("-g", l), Ke)) {
        const u = dY(l)
        u !== l && a.push("-g", u)
      }
    }),
    t.disregardIgnoreFiles !== !1
      ? a.push("--no-ignore")
      : t.disregardParentIgnoreFiles !== !1 && a.push("--no-ignore-parent"),
    t.ignoreSymlinks || a.push("--follow"),
    i.exists && a.push("--quiet"),
    r && a.push("--threads", `${r}`),
    a.push("--no-config"),
    t.disregardGlobalIgnoreFiles && a.push("--no-ignore-global"),
    { args: a, siblingClauses: o.siblingClauses }
  )
}
function lNt(i, t, e, s = !0) {
  const r = []
  let a = {}
  return (
    i.forEach((o) => {
      const c = Object.assign({}, o.excludePattern || {}, t || {}),
        l = xrt(c, s ? o.folder.fsPath : void 0, e)
      r.push(...l.globArgs),
        l.siblingClauses && (a = Object.assign(a, l.siblingClauses))
    }),
    { globArgs: r, siblingClauses: a }
  )
}
function uNt(i, t, e = !0) {
  const s = []
  return (
    i.forEach((r) => {
      const a = Object.assign({}, t || {}, r.includePattern || {}),
        o = xrt(a, e ? r.folder.fsPath : void 0)
      s.push(...o.globArgs)
    }),
    s
  )
}
function xrt(i, t, e) {
  const s = [],
    r = {}
  return (
    Object.keys(i).forEach((a) => {
      if ((e && e.has(a)) || !a) return
      const o = i[a]
      ;(a = dNt(t ? hNt(t, a) : a)),
        a.startsWith("\\\\")
          ? (a = "\\\\" + a.substr(2).replace(/\\/g, "/"))
          : (a = a.replace(/\\/g, "/")),
        typeof o == "boolean" && o
          ? (a.startsWith("\\\\") && (a += "**"), s.push(mNt(a)))
          : o && o.when && (r[a] = o)
    }),
    { globArgs: s, siblingClauses: r }
  )
}
function hNt(i, t) {
  return $r(t) ? t : se(i, t)
}
function dNt(i) {
  return (i = Gn(i, "\\")), Gn(i, "/")
}
function mNt(i) {
  return P7(i).toLowerCase() === "c:/" ? i.replace(/^c:[/\\]/i, "/") : i
}
var OB = new Set()
process.on("exit", () => {
  OB.forEach((i) => i())
})
var fNt = class {
    constructor(i) {
      ;(this.c = null),
        (this.h = null),
        (this.l = !1),
        (this.m = null),
        (this.r = null),
        (this.s = 0),
        (this.a = i),
        (this.b = i.filePattern || ""),
        (this.d = i.includePattern && sr(i.includePattern)),
        (this.f = i.maxResults || null),
        (this.g = !!i.exists),
        (this.v = Object.create(null)),
        (this.k = 0),
        (this.j = !1),
        (this.o = 0),
        (this.p = 0),
        (this.q = []),
        this.b &&
          (this.c = i.shouldGlobMatchFilePattern
            ? null
            : vW(this.b).normalizedLowercase),
        (this.u = i.excludePattern && sr(i.excludePattern)),
        (this.t = new Map()),
        i.folderQueries.forEach((t) => {
          const e = {}
          t.excludePattern?.forEach((r) => {
            Object.assign(e, r.pattern || {}, this.a.excludePattern || {})
          }),
            t.excludePattern?.length ||
              Object.assign(e, this.a.excludePattern || {})
          const s = t.folder.fsPath
          i.folderQueries
            .map((r) => r.folder.fsPath)
            .filter((r) => r !== s)
            .forEach((r) => {
              ja(r, s) && (e[uc(s, r)] = !0)
            }),
            this.t.set(s, new pNt(e, s))
        })
    }
    cancel() {
      ;(this.l = !0), OB.forEach((i) => i())
    }
    walk(i, t, e, s, r, a) {
      if (((this.m = ss.create(!1)), this.l)) return a(null, this.j)
      t.forEach((o) => {
        const c = ke(o.fsPath)
        ;(this.u && this.u(o.fsPath, c)) ||
          this.J(s, { relativePath: o.fsPath, searchPath: void 0 })
      }),
        (this.r = ss.create(!1)),
        this.w(
          i,
          (o, c) => {
            this.x(this.y, this, o, e, s, r, (l) => {
              if (l) {
                const u = Zs(l)
                console.error(u), this.q.push(u), c(l, void 0)
              } else c(null, void 0)
            })
          },
          (o, c) => {
            this.m.stop()
            const l = o ? Ue(o)[0] : null
            a(l, this.j)
          },
        )
    }
    w(i, t, e) {
      const s = new Array(i.length),
        r = new Array(i.length)
      let a = !1,
        o = 0
      if (i.length === 0) return e(null, [])
      i.forEach((c, l) => {
        t(c, (u, d) => {
          if (
            (u
              ? ((a = !0), (s[l] = null), (r[l] = u))
              : ((s[l] = d), (r[l] = null)),
            ++o === i.length)
          )
            return e(a ? r : null, s)
        })
      })
    }
    x(i, t, ...e) {
      try {
        i.apply(t, e)
      } catch (s) {
        e[e.length - 1](s)
      }
    }
    y(i, t, e, s, r) {
      const a = i.folder.fsPath,
        o = Ke,
        c = () => f && f.kill()
      OB.add(c)
      let l = (k) => {
          OB.delete(c), (l = () => {}), r(k)
        },
        u = ""
      const d = this.D(),
        m = oNt(
          this.a,
          i,
          this.a.includePattern,
          this.t.get(i.folder.fsPath).expression,
          t,
        ),
        f = m.cmd,
        p = !Object.keys(m.siblingClauses).length,
        v = m.rgArgs.args.map((k) => (k.match(/^-/) ? k : `'${k}'`)).join(" ")
      let b = `${m.rgDiskPath} ${v}
 - cwd: ${m.cwd}`
      m.rgArgs.siblingClauses &&
        (b += `
 - Sibling clauses: ${JSON.stringify(m.rgArgs.siblingClauses)}`),
        s({ message: b }),
        (this.s = 0),
        this.z(f, "utf8", s, (k, E, P) => {
          if (k) {
            l(k)
            return
          }
          if (this.j) {
            l()
            return
          }
          const R = (u + (o ? V_(E || "") : E)).split(`
`)
          if (P) {
            const D = R.length
            ;(R[D - 1] = R[D - 1].trim()), R[D - 1] || R.pop()
          } else u = R.pop() || ""
          if (
            R.length &&
            R[0].indexOf(`
`) !== -1
          ) {
            l(new Error("Splitting up files failed"))
            return
          }
          if (((this.s += R.length), p)) {
            for (const D of R)
              if (
                (this.J(e, {
                  base: a,
                  relativePath: D,
                  searchPath: this.N(i, D),
                }),
                this.j)
              ) {
                c()
                break
              }
            ;(P || this.j) && l()
            return
          }
          this.G(i, d, a, R, e), P && (this.H(d, a, e), l())
        })
    }
    spawnFindCmd(i) {
      const t = this.t.get(i.folder.fsPath),
        e = t.getBasenameTerms(),
        s = t.getPathTerms(),
        r = ["-L", "."]
      if (e.length || s.length) {
        r.push("-not", "(", "(")
        for (const a of e) r.push("-name", a), r.push("-o")
        for (const a of s) r.push("-path", a), r.push("-o")
        r.pop(), r.push(")", "-prune", ")")
      }
      return (
        r.push("-type", "f"), sNt.spawn("find", r, { cwd: i.folder.fsPath })
      )
    }
    readStdout(i, t, e) {
      let s = ""
      this.z(
        i,
        t,
        () => {},
        (r, a, o) => {
          if (r) {
            e(r)
            return
          }
          ;(s += a), o && e(null, s)
        },
      )
    }
    z(i, t, e, s) {
      let r = (c, l, u) => {
          ;(c || u) && ((r = () => {}), this.r?.stop()), s(c, l, u)
        },
        a = !1
      i.stdout
        ? (this.A(i.stdout, t, r), i.stdout.once("data", () => (a = !0)))
        : e({ message: "stdout is null" })
      let o
      i.stderr ? (o = this.B(i.stderr)) : e({ message: "stderr is null" }),
        i.on("error", (c) => {
          r(c)
        }),
        i.on("close", (c) => {
          let l
          !a && (l = this.C(o, t)) && gNt(l)
            ? r(
                new Error(
                  `command failed with error code ${c}: ${this.C(o, t)}`,
                ),
              )
            : (this.g && c === 0 && (this.j = !0), r(null, "", !0))
        })
    }
    A(i, t, e) {
      const s = new Irt(t)
      return (
        i.on("data", (r) => {
          e(null, s.write(r))
        }),
        s
      )
    }
    B(i) {
      const t = []
      return (
        i.on("data", (e) => {
          t.push(e)
        }),
        t
      )
    }
    C(i, t) {
      const e = new Irt(t)
      return i.map((s) => e.write(s)).join("")
    }
    D() {
      const i = { rootEntries: [], pathToEntries: Object.create(null) }
      return (i.pathToEntries["."] = i.rootEntries), i
    }
    G(i, { pathToEntries: t }, e, s, r) {
      s.indexOf(this.b) !== -1 &&
        this.J(r, {
          base: e,
          relativePath: this.b,
          searchPath: this.N(i, this.b),
        })
      const a = (o) => {
        const c = ke(o),
          l = Ui(o)
        let u = t[l]
        u || ((u = t[l] = []), a(l)),
          u.push({
            base: e,
            relativePath: o,
            basename: c,
            searchPath: this.N(i, o),
          })
      }
      s.forEach(a)
    }
    H({ rootEntries: i, pathToEntries: t }, e, s) {
      const r = this,
        a = this.t.get(e),
        o = this.b
      function c(l) {
        r.o++
        const u = pM(() => l.map((d) => d.basename))
        for (let d = 0, m = l.length; d < m; d++) {
          const f = l[d],
            { relativePath: p, basename: v } = f
          if (a.test(p, v, o !== v ? u : void 0)) continue
          const b = t[p]
          if (b) c(b)
          else {
            if ((r.p++, p === o)) continue
            r.J(s, f)
          }
          if (r.j) break
        }
      }
      c(i)
    }
    getStats() {
      return {
        cmdTime: this.r.elapsed(),
        fileWalkTime: this.m.elapsed(),
        directoriesWalked: this.o,
        filesWalked: this.p,
        cmdResultCount: this.s,
      }
    }
    I(i, t, e, s, r) {
      const a = i.folder,
        o = pM(() => e)
      this.w(
        e,
        (c, l) => {
          if (this.l || this.j) return l(null)
          const u = t ? [t, c].join(xe) : c
          if (
            this.t
              .get(i.folder.fsPath)
              .test(u, c, this.a.filePattern !== c ? o : void 0)
          )
            return l(null)
          const d = [a.fsPath, u].join(xe)
          wW.lstat(d, (m, f) => {
            if (m || this.l || this.j) return l(null)
            this.L(d, f, (p, v) =>
              p || this.l || this.j
                ? l(null)
                : v.isDirectory()
                  ? (this.o++,
                    this.M(d, f, (b, k) =>
                      b || this.l || this.j || ((k = k || ""), this.v[k])
                        ? l(null)
                        : ((this.v[k] = !0),
                          re.readdir(d).then(
                            (E) => {
                              if (this.l || this.j) return l(null)
                              this.I(i, u, E, s, (P) => l(P || null))
                            },
                            (E) => {
                              l(null)
                            },
                          )),
                    ))
                  : (this.p++,
                    u === this.b ||
                      (this.h && ps(v.size) && v.size > this.h) ||
                      this.J(s, {
                        base: a.fsPath,
                        relativePath: u,
                        searchPath: this.N(i, u),
                      }),
                    l(null, void 0)),
            )
          })
        },
        (c) => {
          const l = c && Ue(c)
          return r(l && l.length > 0 ? l[0] : void 0)
        },
      )
    }
    J(i, t) {
      this.K(t) &&
        (!this.d || this.d(t.relativePath, ke(t.relativePath))) &&
        (this.k++,
        (this.g || (this.f && this.k > this.f)) && (this.j = !0),
        this.j || i(t))
    }
    K(i) {
      if (this.b) {
        if (this.b === "*") return !0
        if (this.c) return fM(i, this.c)
        if (this.b) return fM(i, this.b, !1)
      }
      return !0
    }
    L(i, t, e) {
      return t.isSymbolicLink() ? wW.stat(i, e) : e(null, t)
    }
    M(i, t, e) {
      return t.isSymbolicLink()
        ? wW.realpath(i, (s, r) => (s ? e(s) : e(null, r)))
        : e(null, i)
    }
    N(i, t) {
      return i.folderName ? se(i.folderName, t) : t
    }
  },
  Nrt = class {
    constructor(i, t) {
      ;(this.a = i.folderQueries),
        (this.b = i.extraFileResources || []),
        (this.d = t),
        (this.c = new fNt(i))
    }
    search(i, t, e) {
      this.c.walk(this.a, this.b, this.d, i, t, (s, r) => {
        e(s, { limitHit: r, stats: this.c.getStats(), messages: [] })
      })
    }
    cancel() {
      this.c.cancel()
    }
  },
  pNt = class {
    constructor(i, t) {
      ;(this.expression = i), (this.c = t), this.d(i)
    }
    d(i) {
      let t, e
      Object.keys(i)
        .filter((s) => i[s])
        .forEach((s) => {
          $r(s)
            ? ((t = t || sZ()), (t[s] = i[s]))
            : ((e = e || sZ()), (e[s] = i[s]))
        }),
        (this.a = t && sr(t, { trimForExclusions: !0 })),
        (this.b = e && sr(e, { trimForExclusions: !0 }))
    }
    test(i, t, e) {
      return (
        (this.b && this.b(i, t, e)) || (this.a && this.a(se(this.c, i), t, e))
      )
    }
    getBasenameTerms() {
      const i = []
      return this.a && i.push(...uZ(this.a)), this.b && i.push(...uZ(this.b)), i
    }
    getPathTerms() {
      const i = []
      return this.a && i.push(...hZ(this.a)), this.b && i.push(...hZ(this.b)), i
    }
  }
function gNt(i) {
  const t = i.trim().split(`
`),
    e = t[0].trim()
  if (e.startsWith("Error parsing regex")) return e
  if (e.startsWith("regex parse error")) return Ydt(t[t.length - 1].trim())
  if (
    e.startsWith("error parsing glob") ||
    e.startsWith("unsupported encoding")
  )
    return e.charAt(0).toUpperCase() + e.substr(1)
  if (e === "Literal '\\n' not allowed.")
    return "Literal '\\n' currently not supported"
  if (e.startsWith("Literal ")) return e
}
import * as vNt from "child_process"
import { EventEmitter as wNt } from "events"
import { StringDecoder as yNt } from "string_decoder"
import { RegExpParser as bNt, RegExpVisitor as TNt } from "vscode-regexpp"
import { rgPath as kNt } from "@vscode/ripgrep"
var Crt = kNt.replace(/\bnode_modules\.asar\b/, "node_modules.asar.unpacked"),
  Jrt = class {
    constructor(i, t) {
      ;(this.a = i), (this.b = t)
    }
    provideTextSearchResults(i, t, e, s) {
      return Promise.all(
        t.folderOptions.map((r) => {
          const a = {
            folderOptions: r,
            numThreads: this.b,
            maxResults: t.maxResults,
            previewOptions: t.previewOptions,
            maxFileSize: t.maxFileSize,
            surroundingContext: t.surroundingContext,
          }
          return this.provideTextSearchResultsWithRgOptions(i, a, e, s)
        }),
      ).then((r) => ({ limitHit: r.some((o) => !!o && o.limitHit) }))
    }
    provideTextSearchResultsWithRgOptions(i, t, e, s) {
      return (
        this.a.appendLine(
          `provideTextSearchResults ${i.pattern}, ${JSON.stringify({ ...t, folder: t.folderOptions.folder.toString() })}`,
        ),
        new Promise((r, a) => {
          s.onCancellationRequested(() => v())
          const o = { ...t, numThreads: this.b },
            c = PNt(i, o),
            l = t.folderOptions.folder.fsPath,
            u = c.map((C) => (C.match(/^-/) ? C : `'${C}'`)).join(" ")
          this.a.appendLine(`${Crt} ${u}
 - cwd: ${l}`)
          let d = vNt.spawn(Crt, c, { cwd: l })
          d.on("error", (C) => {
            console.error(C),
              this.a.appendLine("Error: " + (C && C.message)),
              a(Wtt(new Jo(C && C.message, va.rgProcessError)))
          })
          let m = !1
          const f = new INt(
            t.maxResults ?? E8,
            t.folderOptions.folder,
            Kst(t.previewOptions),
          )
          f.on("result", (C) => {
            ;(m = !0), (k = ""), e.report(C)
          })
          let p = !1
          const v = () => {
            ;(p = !0), d?.kill(), f?.cancel()
          }
          let b = !1
          f.on("hitLimit", () => {
            ;(b = !0), v()
          })
          let k = ""
          d.stdout.on("data", (C) => {
            f.handleData(C), m || (k += C)
          })
          let E = !1
          d.stdout.once("data", () => (E = !0))
          let P = ""
          d.stderr.on("data", (C) => {
            const R = C.toString()
            this.a.appendLine(R), P.length + R.length < 1e6 && (P += R)
          }),
            d.on("close", () => {
              if (
                (this.a.appendLine(
                  E ? "Got data from stdout" : "No data from stdout",
                ),
                this.a.appendLine(
                  m ? "Got result from parser" : "No result from parser",
                ),
                k && this.a.appendLine(`Got data without result: ${k}`),
                this.a.appendLine(""),
                p)
              )
                r({ limitHit: b })
              else {
                f.flush(), (d = null)
                let C
                P && !E && (C = SNt(P))
                  ? a(Wtt(new Jo(C.message, C.code)))
                  : r({ limitHit: b })
              }
            })
        })
      )
    }
  }
function SNt(i) {
  const t = i.split(`
`),
    e = t[0].trim()
  if (t.some((r) => r.startsWith("regex parse error")))
    return new Jo(ENt(t), va.regexParseError)
  const s = e.match(/grep config error: unknown encoding: (.*)/)
  if (s) return new Jo(`Unknown encoding: ${s[1]}`, va.unknownEncoding)
  if (e.startsWith("error parsing glob"))
    return new Jo(e.charAt(0).toUpperCase() + e.substr(1), va.globParseError)
  if (e.startsWith("the literal"))
    return new Jo(e.charAt(0).toUpperCase() + e.substr(1), va.invalidLiteral)
  if (e.startsWith("PCRE2: error compiling pattern"))
    return new Jo(e, va.regexParseError)
}
function ENt(i) {
  const t = ["Regex parse error"],
    e = i.filter((s) => s.startsWith("PCRE2:"))
  if (e.length >= 1) {
    const s = e[0].replace("PCRE2:", "")
    if (s.indexOf(":") !== -1 && s.split(":").length >= 2) {
      const r = s.split(":")[1]
      t.push(":" + r)
    }
  }
  return t.join("")
}
var INt = class extends wNt {
  constructor(i, t, e) {
    super(),
      (this.g = i),
      (this.h = t),
      (this.j = e),
      (this.a = ""),
      (this.b = !1),
      (this.c = !1),
      (this.f = 0),
      (this.d = new yNt())
  }
  cancel() {
    this.b = !0
  }
  flush() {
    this.k(this.d.end())
  }
  on(i, t) {
    return super.on(i, t), this
  }
  handleData(i) {
    if (this.b) return
    const t = typeof i == "string" ? i : this.d.write(i)
    this.k(t)
  }
  k(i) {
    let t = i.indexOf(`
`)
    const e = this.a + i
    if (t >= 0) t += this.a.length
    else {
      this.a = e
      return
    }
    let s = 0
    for (; t >= 0; )
      this.m(e.substring(s, t).trim()),
        (s = t + 1),
        (t = e.indexOf(
          `
`,
          s,
        ))
    this.a = e.substring(s)
  }
  m(i) {
    if (this.b || !i) return
    let t
    try {
      t = JSON.parse(i)
    } catch {
      throw new Error(`malformed line from rg: ${i}`)
    }
    if (t.type === "match") {
      const e = bm(t.data.path),
        s = S.joinPath(this.h, e),
        r = this.n(t.data, s)
      this.p(r), this.c && (this.cancel(), this.emit("hitLimit"))
    } else if (t.type === "context") {
      const e = bm(t.data.path),
        s = S.joinPath(this.h, e)
      this.o(t.data, s).forEach((a) => this.p(a))
    }
  }
  n(i, t) {
    const e = i.line_number - 1,
      s = bm(i.lines),
      r = Buffer.from(s)
    let a = 0,
      o = 0,
      c = e
    i.submatches.length === 0 &&
      i.submatches.push(
        s.length
          ? { start: 0, end: 1, match: { text: s[0] } }
          : { start: 0, end: 0, match: { text: "" } },
      )
    const l = Ue(
        i.submatches.map((m, f) => {
          if (this.c) return null
          this.f++, this.f >= this.g && (this.c = !0)
          const p = bm(m.match),
            v = r.slice(a, m.start).toString(),
            b = Lrt(v),
            k = b.numLines > 0 ? b.lastLineLength : b.lastLineLength + o,
            E = Lrt(p),
            P = b.numLines + c,
            C = E.numLines + P,
            R = E.numLines > 0 ? E.lastLineLength : E.lastLineLength + k
          return (a = m.end), (o = R), (c = C), new Dtt(P, k, C, R)
        }),
      ),
      u = m_(l, nNt),
      d = new qtt(s, u, this.j)
    return new Tn(
      t,
      d.rangeLocations.map((m) => ({
        sourceRange: Prt(m.source),
        previewRange: Prt(m.preview),
      })),
      d.previewText,
    )
  }
  o(i, t) {
    const e = bm(i.lines),
      s = i.line_number
    return e
      .replace(/\r?\n$/, "")
      .split(
        `
`,
      )
      .map((r, a) => new k8(t, r, s + a))
  }
  p(i) {
    this.emit("result", i)
  }
}
function bm(i) {
  return i.bytes ? Buffer.from(i.bytes, "base64").toString() : i.text
}
function Lrt(i) {
  const t = /\n/g
  let e = 0,
    s = -1,
    r
  for (; (r = t.exec(i)); ) e++, (s = r.index)
  const a = s >= 0 ? i.length - s - 1 : i.length
  return { numLines: e, lastLineLength: a }
}
function PNt(i, t) {
  const e = ["--hidden", "--no-require-git"]
  e.push(i.isCaseSensitive ? "--case-sensitive" : "--ignore-case")
  const { doubleStarIncludes: s, otherIncludes: r } = o7(
    t.folderOptions.includes,
    (o) => (o.startsWith("**") ? "doubleStarIncludes" : "otherIncludes"),
  )
  if (r && r.length) {
    const o = new Set()
    r.forEach((c) => {
      o.add(c)
    }),
      e.push("-g", "!*"),
      o.forEach((c) => {
        $Nt(c)
          .map(AB)
          .forEach((l) => {
            e.push("-g", l)
          })
      })
  }
  s &&
    s.length &&
    s.forEach((o) => {
      e.push("-g", o)
    }),
    t.folderOptions.excludes
      .map((o) => (typeof o == "string" ? o : o.pattern))
      .map(AB)
      .forEach((o) => e.push("-g", `!${o}`)),
    t.maxFileSize && e.push("--max-filesize", t.maxFileSize + ""),
    t.folderOptions.useIgnoreFiles.local
      ? t.folderOptions.useIgnoreFiles.parent || e.push("--no-ignore-parent")
      : e.push("--no-ignore"),
    t.folderOptions.followSymlinks && e.push("--follow"),
    t.folderOptions.encoding &&
      t.folderOptions.encoding !== "utf8" &&
      e.push("--encoding", t.folderOptions.encoding),
    t.numThreads && e.push("--threads", `${t.numThreads}`),
    i.pattern === "--" && ((i.isRegExp = !0), (i.pattern = "\\-\\-")),
    i.isMultiline &&
      !i.isRegExp &&
      ((i.pattern = Vn(i.pattern)), (i.isRegExp = !0)),
    t.usePCRE2 && e.push("--pcre2"),
    e.push("--crlf"),
    i.isRegExp && ((i.pattern = xNt(i.pattern)), e.push("--engine", "auto"))
  let a
  if (i.isWordMatch) {
    const c = hG(i.pattern, !!i.isRegExp, {
      wholeWord: i.isWordMatch,
    }).source.replace(/\\\//g, "/")
    e.push("--regexp", c)
  } else if (i.isRegExp) {
    let o = NNt(i.pattern)
    ;(o = CNt(o)), e.push("--regexp", o)
  } else (a = i.pattern), e.push("--fixed-strings")
  return (
    e.push("--no-config"),
    t.folderOptions.useIgnoreFiles.global || e.push("--no-ignore-global"),
    e.push("--json"),
    i.isMultiline && e.push("--multiline"),
    t.surroundingContext &&
      (e.push("--before-context", t.surroundingContext + ""),
      e.push("--after-context", t.surroundingContext + "")),
    e.push("--"),
    a && e.push(a),
    e.push("."),
    e
  )
}
function $Nt(i) {
  return Drt(i).flatMap((e) => {
    const s = Eh(e, "/")
    return s.map((r, a) => s.slice(0, a + 1).join("/"))
  })
}
function xNt(i) {
  const t = /((?:[^\\]|^)(?:\\\\)*)\\u([a-z0-9]{4})/gi
  for (; i.match(t); ) i = i.replace(t, "$1\\x{$2}")
  const e = /((?:[^\\]|^)(?:\\\\)*)\\u\{([a-z0-9]{4})\}/gi
  for (; i.match(e); ) i = i.replace(e, "$1\\x{$2}")
  return i
}
var Rrt = (i) => i.type === "Assertion" && i.kind === "lookbehind"
function NNt(i) {
  let t
  try {
    t = new bNt().parsePattern(i)
  } catch {
    return i
  }
  let e = "",
    s = 0
  const r = (c, l, u) => {
      ;(e += i.slice(s, c) + u), (s = l)
    },
    a = []
  return (
    new TNt({
      onCharacterEnter(c) {
        if (c.raw !== "\\n") return
        const l = a[0]
        if (!l) r(c.start, c.end, "\\r?\\n")
        else if (!a.some(Rrt))
          if (l.type === "CharacterClass")
            if (l.negate) {
              const u =
                i.slice(l.start + 2, c.start) + i.slice(c.end, l.end - 1)
              l.parent?.type === "Quantifier"
                ? r(l.start, l.end, u ? `[^${u}]` : ".")
                : r(l.start, l.end, "(?!\\r?\\n" + (u ? `|[${u}]` : "") + ")")
            } else {
              const u =
                i.slice(l.start + 1, c.start) + i.slice(c.end, l.end - 1)
              r(l.start, l.end, u === "" ? "\\r?\\n" : `(?:[${u}]|\\r?\\n)`)
            }
          else l.type === "Quantifier" && r(c.start, c.end, "(?:\\r?\\n)")
      },
      onQuantifierEnter(c) {
        a.unshift(c)
      },
      onQuantifierLeave() {
        a.shift()
      },
      onCharacterClassRangeEnter(c) {
        a.unshift(c)
      },
      onCharacterClassRangeLeave() {
        a.shift()
      },
      onCharacterClassEnter(c) {
        a.unshift(c)
      },
      onCharacterClassLeave() {
        a.shift()
      },
      onAssertionEnter(c) {
        Rrt(c) && a.push(c)
      },
      onAssertionLeave(c) {
        a[0] === c && a.shift()
      },
    }).visit(t),
    (e += i.slice(s)),
    e
  )
}
function CNt(i) {
  return i.replace(/\n/g, "\\r?\\n")
}
function JNt(i) {
  let t = !1,
    e = !1,
    s = "",
    r = ""
  for (let a = 0; a < i.length; a++) {
    const o = i[a]
    switch (o) {
      case "\\":
        e ? (t ? (r += "\\" + o) : (s += "\\" + o), (e = !1)) : (e = !0)
        break
      case "{":
        if (e) t ? (r += o) : (s += o), (e = !1)
        else {
          if (t) return { strInBraces: s + "{" + r + "{" + i.substring(a + 1) }
          t = !0
        }
        break
      case "}":
        if (e) t ? (r += o) : (s += o), (e = !1)
        else {
          if (t)
            return {
              fixedStart: s,
              strInBraces: r,
              fixedEnd: i.substring(a + 1),
            }
          s += o
        }
        break
      default:
        t ? (r += (e ? "\\" : "") + o) : (s += (e ? "\\" : "") + o), (e = !1)
        break
    }
  }
  return { strInBraces: s + (t ? "{" + r : "") }
}
function Drt(i) {
  const { fixedStart: t, strInBraces: e, fixedEnd: s } = JNt(i)
  if (t === void 0 || s === void 0) return [e]
  let r = Eh(e, ",")
  r.length || (r = [""])
  const a = Drt(s)
  return r.flatMap((o) => {
    const c = t + o
    return a.map((l) => c + l)
  })
}
var LNt = class {
    constructor(i, t, e) {
      ;(this.id = i), (this.dependencies = t), (this.callback = e)
    }
  },
  Ao
;(function (i) {
  ;(i[(i.Uninitialized = 1)] = "Uninitialized"),
    (i[(i.InitializedInternal = 2)] = "InitializedInternal"),
    (i[(i.InitializedExternal = 3)] = "InitializedExternal")
})(Ao || (Ao = {}))
var AQt = class but {
    static {
      this.INSTANCE = new but()
    }
    constructor() {
      ;(this.a =
        typeof self == "object" &&
        self.constructor &&
        self.constructor.name === "DedicatedWorkerGlobalScope"),
        (this.b = typeof document == "object"),
        (this.c = []),
        (this.d = Ao.Uninitialized)
    }
    g() {
      if (this.d === Ao.Uninitialized) {
        if (globalThis.define) {
          this.d = Ao.InitializedExternal
          return
        }
      } else return
      ;(this.d = Ao.InitializedInternal),
        (globalThis.define = (t, e, s) => {
          typeof t != "string" && ((s = e), (e = t), (t = null)),
            (typeof e != "object" || !Array.isArray(e)) &&
              ((s = e), (e = null)),
            this.c.push(new LNt(t, e, s))
        }),
        (globalThis.define.amd = !0),
        this.b
          ? (this.f =
              globalThis._VSCODE_WEB_PACKAGE_TTP ??
              window.trustedTypes?.createPolicy("amdLoader", {
                createScriptURL(t) {
                  if (
                    t.startsWith(window.location.origin) ||
                    t.startsWith(`${G.vscodeFileResource}://${qG}`)
                  )
                    return t
                  throw new Error(
                    `[trusted_script_src] Invalid script url: ${t}`,
                  )
                },
              }))
          : this.a &&
            (this.f =
              globalThis._VSCODE_WEB_PACKAGE_TTP ??
              globalThis.trustedTypes?.createPolicy("amdLoader", {
                createScriptURL(t) {
                  return t
                },
              }))
    }
    async load(t) {
      if ((this.g(), this.d === Ao.InitializedExternal))
        return new Promise((o) => {
          const c = Ze()
          globalThis.define(c, [t], function (l) {
            o(l)
          })
        })
      const e = await (this.a ? this.i(t) : this.b ? this.h(t) : this.j(t))
      if (!e) {
        console.warn(`Did not receive a define call from script ${t}`)
        return
      }
      const s = {},
        r = [],
        a = []
      if (Array.isArray(e.dependencies))
        for (const o of e.dependencies) o === "exports" ? r.push(s) : a.push(o)
      if (a.length > 0)
        throw new Error(
          `Cannot resolve dependencies for script ${t}. The dependencies are: ${a.join(", ")}`,
        )
      return typeof e.callback == "function"
        ? (e.callback(...r) ?? s)
        : e.callback
    }
    h(t) {
      return new Promise((e, s) => {
        const r = document.createElement("script")
        r.setAttribute("async", "async"),
          r.setAttribute("type", "text/javascript")
        const a = () => {
            r.removeEventListener("load", o), r.removeEventListener("error", c)
          },
          o = (l) => {
            a(), e(this.c.pop())
          },
          c = (l) => {
            a(), s(l)
          }
        r.addEventListener("load", o),
          r.addEventListener("error", c),
          this.f && (t = this.f.createScriptURL(t)),
          r.setAttribute("src", t),
          window.document.getElementsByTagName("head")[0].appendChild(r)
      })
    }
    async i(t) {
      return (
        this.f && (t = this.f.createScriptURL(t)), await import(t), this.c.pop()
      )
    }
    async j(t) {
      try {
        const e = (await import("fs")).default,
          s = (await import("vm")).default,
          r = (await import("module")).default,
          a = S.parse(t).fsPath,
          o = e.readFileSync(a).toString(),
          c = r.wrap(o.replace(/^#!.*/, ""))
        return new s.Script(c).runInThisContext().apply(), this.c.pop()
      } catch (e) {
        throw e
      }
    }
  },
  _Qt = 512 * 8,
  OQt = 512 * 128,
  Frt
;(function (i) {
  i[(i.STREAM_IS_BINARY = 1)] = "STREAM_IS_BINARY"
})(Frt || (Frt = {}))
function RNt(i) {
  switch (i) {
    case "shiftjis":
      return "shift-jis"
    case "utf16le":
      return "utf-16le"
    case "utf16be":
      return "utf-16be"
    case "big5hkscs":
      return "big5-hkscs"
    case "eucjp":
      return "euc-jp"
    case "euckr":
      return "euc-kr"
    case "koi8r":
      return "koi8-r"
    case "koi8u":
      return "koi8-u"
    case "macroman":
      return "x-mac-roman"
    case "utf8bom":
      return "utf8"
    default: {
      const t = i.match(/windows(\d+)/)
      return t ? "windows-" + t[1] : i
    }
  }
}
var yW = {
    utf8: {
      labelLong: "UTF-8",
      labelShort: "UTF-8",
      order: 1,
      alias: "utf8bom",
      guessableName: "UTF-8",
    },
    utf8bom: {
      labelLong: "UTF-8 with BOM",
      labelShort: "UTF-8 with BOM",
      encodeOnly: !0,
      order: 2,
      alias: "utf8",
    },
    utf16le: {
      labelLong: "UTF-16 LE",
      labelShort: "UTF-16 LE",
      order: 3,
      guessableName: "UTF-16LE",
    },
    utf16be: {
      labelLong: "UTF-16 BE",
      labelShort: "UTF-16 BE",
      order: 4,
      guessableName: "UTF-16BE",
    },
    windows1252: {
      labelLong: "Western (Windows 1252)",
      labelShort: "Windows 1252",
      order: 5,
      guessableName: "windows-1252",
    },
    iso88591: {
      labelLong: "Western (ISO 8859-1)",
      labelShort: "ISO 8859-1",
      order: 6,
    },
    iso88593: {
      labelLong: "Western (ISO 8859-3)",
      labelShort: "ISO 8859-3",
      order: 7,
    },
    iso885915: {
      labelLong: "Western (ISO 8859-15)",
      labelShort: "ISO 8859-15",
      order: 8,
    },
    macroman: {
      labelLong: "Western (Mac Roman)",
      labelShort: "Mac Roman",
      order: 9,
    },
    cp437: { labelLong: "DOS (CP 437)", labelShort: "CP437", order: 10 },
    windows1256: {
      labelLong: "Arabic (Windows 1256)",
      labelShort: "Windows 1256",
      order: 11,
    },
    iso88596: {
      labelLong: "Arabic (ISO 8859-6)",
      labelShort: "ISO 8859-6",
      order: 12,
    },
    windows1257: {
      labelLong: "Baltic (Windows 1257)",
      labelShort: "Windows 1257",
      order: 13,
    },
    iso88594: {
      labelLong: "Baltic (ISO 8859-4)",
      labelShort: "ISO 8859-4",
      order: 14,
    },
    iso885914: {
      labelLong: "Celtic (ISO 8859-14)",
      labelShort: "ISO 8859-14",
      order: 15,
    },
    windows1250: {
      labelLong: "Central European (Windows 1250)",
      labelShort: "Windows 1250",
      order: 16,
      guessableName: "windows-1250",
    },
    iso88592: {
      labelLong: "Central European (ISO 8859-2)",
      labelShort: "ISO 8859-2",
      order: 17,
      guessableName: "ISO-8859-2",
    },
    cp852: {
      labelLong: "Central European (CP 852)",
      labelShort: "CP 852",
      order: 18,
    },
    windows1251: {
      labelLong: "Cyrillic (Windows 1251)",
      labelShort: "Windows 1251",
      order: 19,
      guessableName: "windows-1251",
    },
    cp866: {
      labelLong: "Cyrillic (CP 866)",
      labelShort: "CP 866",
      order: 20,
      guessableName: "IBM866",
    },
    iso88595: {
      labelLong: "Cyrillic (ISO 8859-5)",
      labelShort: "ISO 8859-5",
      order: 21,
      guessableName: "ISO-8859-5",
    },
    koi8r: {
      labelLong: "Cyrillic (KOI8-R)",
      labelShort: "KOI8-R",
      order: 22,
      guessableName: "KOI8-R",
    },
    koi8u: { labelLong: "Cyrillic (KOI8-U)", labelShort: "KOI8-U", order: 23 },
    iso885913: {
      labelLong: "Estonian (ISO 8859-13)",
      labelShort: "ISO 8859-13",
      order: 24,
    },
    windows1253: {
      labelLong: "Greek (Windows 1253)",
      labelShort: "Windows 1253",
      order: 25,
      guessableName: "windows-1253",
    },
    iso88597: {
      labelLong: "Greek (ISO 8859-7)",
      labelShort: "ISO 8859-7",
      order: 26,
      guessableName: "ISO-8859-7",
    },
    windows1255: {
      labelLong: "Hebrew (Windows 1255)",
      labelShort: "Windows 1255",
      order: 27,
      guessableName: "windows-1255",
    },
    iso88598: {
      labelLong: "Hebrew (ISO 8859-8)",
      labelShort: "ISO 8859-8",
      order: 28,
      guessableName: "ISO-8859-8",
    },
    iso885910: {
      labelLong: "Nordic (ISO 8859-10)",
      labelShort: "ISO 8859-10",
      order: 29,
    },
    iso885916: {
      labelLong: "Romanian (ISO 8859-16)",
      labelShort: "ISO 8859-16",
      order: 30,
    },
    windows1254: {
      labelLong: "Turkish (Windows 1254)",
      labelShort: "Windows 1254",
      order: 31,
    },
    iso88599: {
      labelLong: "Turkish (ISO 8859-9)",
      labelShort: "ISO 8859-9",
      order: 32,
    },
    windows1258: {
      labelLong: "Vietnamese (Windows 1258)",
      labelShort: "Windows 1258",
      order: 33,
    },
    gbk: {
      labelLong: "Simplified Chinese (GBK)",
      labelShort: "GBK",
      order: 34,
    },
    gb18030: {
      labelLong: "Simplified Chinese (GB18030)",
      labelShort: "GB18030",
      order: 35,
    },
    cp950: {
      labelLong: "Traditional Chinese (Big5)",
      labelShort: "Big5",
      order: 36,
      guessableName: "Big5",
    },
    big5hkscs: {
      labelLong: "Traditional Chinese (Big5-HKSCS)",
      labelShort: "Big5-HKSCS",
      order: 37,
    },
    shiftjis: {
      labelLong: "Japanese (Shift JIS)",
      labelShort: "Shift JIS",
      order: 38,
      guessableName: "SHIFT_JIS",
    },
    eucjp: {
      labelLong: "Japanese (EUC-JP)",
      labelShort: "EUC-JP",
      order: 39,
      guessableName: "EUC-JP",
    },
    euckr: {
      labelLong: "Korean (EUC-KR)",
      labelShort: "EUC-KR",
      order: 40,
      guessableName: "EUC-KR",
    },
    windows874: {
      labelLong: "Thai (Windows 874)",
      labelShort: "Windows 874",
      order: 41,
    },
    iso885911: {
      labelLong: "Latin/Thai (ISO 8859-11)",
      labelShort: "ISO 8859-11",
      order: 42,
    },
    koi8ru: {
      labelLong: "Cyrillic (KOI8-RU)",
      labelShort: "KOI8-RU",
      order: 43,
    },
    koi8t: { labelLong: "Tajik (KOI8-T)", labelShort: "KOI8-T", order: 44 },
    gb2312: {
      labelLong: "Simplified Chinese (GB 2312)",
      labelShort: "GB 2312",
      order: 45,
      guessableName: "GB2312",
    },
    cp865: {
      labelLong: "Nordic DOS (CP 865)",
      labelShort: "CP 865",
      order: 46,
    },
    cp850: {
      labelLong: "Western European DOS (CP 850)",
      labelShort: "CP 850",
      order: 47,
    },
  },
  BQt = (() => {
    const i = {}
    for (const t in yW) yW[t].guessableName && (i[t] = yW[t])
    return i
  })(),
  Art = class extends tW {
    constructor(i, t, e = j_, s = "searchProcess") {
      super(
        { query: i, provider: t },
        {
          readdir: (r) => e.Promises.readdir(r.fsPath),
          toCanonicalName: (r) => RNt(r),
        },
        s,
      )
    }
  },
  DNt = class {
    constructor(i, t) {
      ;(this.a = i), (this.b = t)
    }
    search(i, t, e) {
      if (
        (!this.a.folderQueries || !this.a.folderQueries.length) &&
        (!this.a.extraFileResources || !this.a.extraFileResources.length)
      )
        return Promise.resolve({
          type: "success",
          limitHit: !1,
          stats: { type: "searchProcess" },
          messages: [],
        })
      const s = {
          appendLine(a) {
            e({ message: a })
          },
        },
        r = new Art(this.a, new Jrt(s, this.b), j_)
      return new Promise((a, o) =>
        r
          .search((c) => {
            t(c.map(FNt))
          }, i)
          .then(
            (c) =>
              a({
                limitHit: c.limitHit ?? !1,
                type: "success",
                stats: c.stats,
                messages: [],
              }),
            o,
          ),
      )
    }
  }
function FNt(i) {
  return {
    path: i.resource && i.resource.fsPath,
    results: i.results,
    numMatches: (i.results || []).reduce(
      (t, e) => (dM(e) ? t + e.rangeLocations.length : t + 1),
      0,
    ),
  }
}
var ANt = class K3 {
    static {
      this.a = 512
    }
    constructor(t = "searchProcess", e) {
      ;(this.d = t), (this.f = e), (this.b = Object.create(null))
    }
    fileSearch(t) {
      let e
      const s = _rt(t),
        r = new J({
          onDidAddFirstListener: () => {
            ;(e = Zr(async (a) => {
              const o = await this.f?.()
              return this.doFileSearchWithEngine(
                Nrt,
                s,
                (c) => r.fire(c),
                a,
                K3.a,
                o,
              )
            })),
              e.then(
                (a) => r.fire(a),
                (a) =>
                  r.fire({
                    type: "error",
                    error: { message: a.message, stack: a.stack },
                  }),
              )
          },
          onDidRemoveLastListener: () => {
            e.cancel()
          },
        })
      return r.event
    }
    textSearch(t) {
      let e
      const s = _rt(t),
        r = new J({
          onDidAddFirstListener: () => {
            ;(e = Zr((a) => this.g(s, (o) => r.fire(o), a))),
              e.then(
                (a) => r.fire(a),
                (a) =>
                  r.fire({
                    type: "error",
                    error: { message: a.message, stack: a.stack },
                  }),
              )
          },
          onDidRemoveLastListener: () => {
            e.cancel()
          },
        })
      return r.event
    }
    async g(t, e, s) {
      t.maxFileSize = this.h().maxFileSize
      const r = await this.f?.()
      return new DNt(t, r).search(s, e, e)
    }
    h() {
      return { maxFileSize: 16 * dK.GB }
    }
    doFileSearch(t, e, s, r) {
      return this.doFileSearchWithEngine(Nrt, t, s, r, K3.a, e)
    }
    doFileSearchWithEngine(t, e, s, r, a = K3.a, o) {
      let c = 0
      const l = (d) => {
        Array.isArray(d)
          ? ((c += d.length), s(d.map((m) => this.j(m))))
          : d.relativePath
            ? (c++, s(this.j(d)))
            : s(d)
      }
      if (e.sortByScore) {
        let d = this.n(e, l, r)
        if (!d) {
          const m = e.maxResults
              ? Object.assign({}, e, { maxResults: null })
              : e,
            f = new t(m, o)
          d = this.k(f, e, s, l, r)
        }
        return new Promise((m, f) => {
          d.then(([p, v]) => {
            const b = v.map((k) => this.j(k))
            this.q(b, s, a), m(p)
          }, f)
        })
      }
      const u = new t(e, o)
      return this.s(u, l, a, r).then((d) => ({
        limitHit: d.limitHit,
        type: "success",
        stats: {
          detailStats: d.stats,
          type: this.d,
          fromCache: !1,
          resultCount: c,
          sortingTime: void 0,
        },
        messages: [],
      }))
    }
    j(t) {
      return { path: t.base ? se(t.base, t.relativePath) : t.relativePath }
    }
    k(t, e, s, r, a) {
      const o = new J()
      let c = Zr((u) => {
          let d = []
          const m = (f) => {
            Array.isArray(f) ? (d = f) : (r(f), o.fire(f))
          }
          return this.s(t, m, -1, u).then((f) => [f, d])
        }),
        l
      if (e.cacheKey) {
        l = this.l(e.cacheKey)
        const u = { promise: c, event: o.event, resolved: !1 }
        ;(l.resultsToSearchCache[e.filePattern || ""] = u),
          c.then(
            () => {
              u.resolved = !0
            },
            (d) => {
              delete l.resultsToSearchCache[e.filePattern || ""]
            },
          ),
          (c = this.t(c))
      }
      return c.then(([u, d]) => {
        const m = l ? l.scorerCache : Object.create(null),
          f =
            (typeof e.maxResults != "number" || e.maxResults > 0) &&
            ss.create(!1)
        return this.o(e, d, m, a).then((p) => {
          const v = f ? f.elapsed() : -1
          return [
            {
              type: "success",
              stats: {
                detailStats: u.stats,
                sortingTime: v,
                fromCache: !1,
                type: this.d,
                resultCount: p.length,
              },
              messages: u.messages,
              limitHit:
                u.limitHit ||
                (typeof e.maxResults == "number" && d.length > e.maxResults),
            },
            p,
          ]
        })
      })
    }
    l(t) {
      const e = this.b[t]
      return e || (this.b[t] = new _Nt())
    }
    n(t, e, s) {
      const r = t.cacheKey && this.b[t.cacheKey]
      if (!r) return
      const a = this.r(r, t.filePattern || "", e, s)
      if (a)
        return a.then(([o, c, l]) => {
          const u = ss.create(!1)
          return this.o(t, c, r.scorerCache, s).then((d) => {
            const m = u.elapsed(),
              f = {
                fromCache: !0,
                detailStats: l,
                type: this.d,
                resultCount: c.length,
                sortingTime: m,
              }
            return [
              {
                type: "success",
                limitHit:
                  o.limitHit ||
                  (typeof t.maxResults == "number" && c.length > t.maxResults),
                stats: f,
                messages: [],
              },
              d,
            ]
          })
        })
    }
    o(t, e, s, r) {
      const a = vW(t.filePattern || ""),
        o = (l, u) => Zxt(l, u, a, !0, ONt, s),
        c = typeof t.maxResults == "number" ? t.maxResults : E8
      return Rht(e, o, c, 1e4, r)
    }
    q(t, e, s) {
      if (s && s > 0) for (let r = 0; r < t.length; r += s) e(t.slice(r, r + s))
      else e(t)
    }
    r(t, e, s, r) {
      const a = ss.create(!1),
        o = e.indexOf(xe) >= 0
      let c
      for (const m in t.resultsToSearchCache)
        if (e.startsWith(m)) {
          if (o && m.indexOf(xe) < 0 && m !== "") continue
          const f = t.resultsToSearchCache[m]
          c = {
            promise: this.t(f.promise),
            event: f.event,
            resolved: f.resolved,
          }
          break
        }
      if (!c) return null
      const l = a.elapsed(),
        u = ss.create(!1),
        d = c.event(s)
      return (
        r &&
          r.onCancellationRequested(() => {
            d.dispose()
          }),
        c.promise.then(([m, f]) => {
          if (r && r.isCancellationRequested) throw Nu()
          const p = [],
            v = vW(e).normalizedLowercase
          for (const b of f) fM(b, v) && p.push(b)
          return [
            m,
            p,
            {
              cacheWasResolved: c.resolved,
              cacheLookupTime: l,
              cacheFilterTime: u.elapsed(),
              cacheEntryCount: f.length,
            },
          ]
        })
      )
    }
    s(t, e, s, r) {
      return new Promise((a, o) => {
        let c = []
        r?.onCancellationRequested(() => t.cancel()),
          t.search(
            (l) => {
              l &&
                (s
                  ? (c.push(l), s > 0 && c.length >= s && (e(c), (c = [])))
                  : e(l))
            },
            (l) => {
              e(l)
            },
            (l, u) => {
              c.length && e(c),
                l
                  ? (e({ message: "Search finished. Error: " + l.message }),
                    o(l))
                  : (e({
                      message:
                        "Search finished. Stats: " + JSON.stringify(u.stats),
                    }),
                    a(u))
            },
          )
      })
    }
    clearCache(t) {
      return delete this.b[t], Promise.resolve(void 0)
    }
    t(t) {
      return new (class {
        get [Symbol.toStringTag]() {
          return this.toString()
        }
        cancel() {}
        then(e, s) {
          return t.then(e, s)
        }
        catch(e) {
          return this.then(void 0, e)
        }
        finally(e) {
          return t.finally(e)
        }
      })()
    }
  },
  _Nt = class {
    constructor() {
      ;(this.resultsToSearchCache = Object.create(null)),
        (this.scorerCache = Object.create(null))
    }
  },
  ONt = new (class {
    getItemLabel(i) {
      return ke(i.relativePath)
    }
    getItemDescription(i) {
      return Ui(i.relativePath)
    }
    getItemPath(i) {
      return i.relativePath
    }
  })()
function _rt(i) {
  return {
    ...i,
    folderQueries: i.folderQueries && i.folderQueries.map(BNt),
    extraFileResources:
      i.extraFileResources && i.extraFileResources.map((t) => S.revive(t)),
  }
}
function BNt(i) {
  return ki(i)
}
var Ort = class {
  constructor(i, t) {
    ;(this.b = i),
      (this.c = t),
      (this.a = new Set()),
      process.once("exit", () => this.f())
  }
  async provideTextSearchResults(i, t, e, s) {
    const r = await this.c(),
      a = new Jrt(this.b, r)
    return Promise.all(
      t.folderOptions.map((o) => {
        const c = {
          folderOptions: o,
          numThreads: r,
          maxResults: t.maxResults,
          previewOptions: t.previewOptions,
          maxFileSize: t.maxFileSize,
          surroundingContext: t.surroundingContext,
        }
        if (o.folder.scheme === G.vscodeUserData) {
          const l = { ...c, folder: o.folder.with({ scheme: G.file }) },
            u = new dH((d) =>
              e.report({ ...d, uri: d.uri.with({ scheme: o.folder.scheme }) }),
            )
          return this.d(s, (d) =>
            a.provideTextSearchResultsWithRgOptions(i, l, u, d),
          )
        } else
          return this.d(s, (l) =>
            a.provideTextSearchResultsWithRgOptions(i, c, e, l),
          )
      }),
    ).then((o) => ({ limitHit: o.some((l) => !!l && l.limitHit) }))
  }
  async d(i, t) {
    const e = qNt(i)
    this.a.add(e)
    const s = await t(e.token)
    return this.a.delete(e), s
  }
  f() {
    this.a.forEach((i) => i.cancel())
  }
}
function qNt(i) {
  const t = new fe()
  return i.onCancellationRequested(() => t.cancel()), t
}
var bW = class extends xB {
  constructor(t, e, s, r, a) {
    super(t, s, a),
      (this.E = r),
      (this.x = j_),
      (this.y = -1),
      (this.z = null),
      (this.A = !1),
      (this.C = new gt()),
      (this.D = !1),
      (this.getNumThreads = this.getNumThreads.bind(this)),
      (this.getNumThreadsCached = this.getNumThreadsCached.bind(this)),
      (this.F = this.F.bind(this))
    const o = new _B("RipgrepSearchUD", this.s)
    this.C.add(
      this.registerTextSearchProvider(
        G.vscodeUserData,
        new Ort(o, this.getNumThreadsCached),
      ),
    ),
      e.remote.isRemote && e.remote.authority && this.G(),
      r.getConfigProvider().then((c) => {
        this.D || this.C.add(c.onDidChangeConfiguration(this.F))
      })
  }
  F(t) {
    t.affectsConfiguration("search") && (this.B = void 0)
  }
  async getNumThreads() {
    return (await this.E.getConfigProvider())
      .getConfiguration("search")
      .get("ripgrep.maxThreads")
  }
  async getNumThreadsCached() {
    return this.B || (this.B = this.getNumThreads()), this.B
  }
  dispose() {
    ;(this.D = !0), this.C.dispose()
  }
  $enableExtensionHostSearch() {
    this.G()
  }
  G() {
    if (this.A) return
    this.A = !0
    const t = new _B("RipgrepSearchEH", this.s)
    this.C.add(
      this.registerTextSearchProvider(
        G.file,
        new Ort(t, this.getNumThreadsCached),
      ),
    ),
      this.C.add(
        this.H(G.file, new ANt("fileSearchProvider", this.getNumThreadsCached)),
      )
  }
  H(t, e) {
    const s = this.e++
    return (
      (this.z = e),
      (this.y = s),
      this.c.$registerFileSearchProvider(s, this.t(t)),
      et(() => {
        ;(this.z = null), this.c.$unregisterProvider(s)
      })
    )
  }
  $provideFileSearchResults(t, e, s, r) {
    const a = NB(s)
    if (t === this.y) {
      const o = Date.now()
      return this.I(t, e, a, r).then((c) => {
        const l = Date.now() - o
        return this.s.debug(`Ext host file search time: ${l}ms`), c
      })
    }
    return super.$provideFileSearchResults(t, e, s, r)
  }
  async doInternalFileSearchWithCustomCallback(t, e, s) {
    const r = (o) => {
      if ((ATt(o) && (o = [o]), Array.isArray(o))) {
        s(o.map((c) => S.file(c.path)))
        return
      }
      o.message && this.s.debug("ExtHostSearch", o.message)
    }
    if (!this.z) throw new Error("No internal file search handler")
    const a = await this.getNumThreadsCached()
    return this.z.doFileSearch(t, a, r, e)
  }
  async I(t, e, s, r) {
    return this.doInternalFileSearchWithCustomCallback(s, r, (a) => {
      this.c.$handleFileMatch(t, e, a)
    })
  }
  $clearCache(t) {
    return this.z?.clearCache(t), super.$clearCache(t)
  }
  v(t, e) {
    return new Art(t, e, void 0, "textSearchProvider")
  }
}
bW = __decorate(
  [
    __param(0, Ot),
    __param(1, ti),
    __param(2, ah),
    __param(3, Ds),
    __param(4, Rt),
  ],
  bW,
)
function Brt(i, t, e, s, r, a) {
  if (Array.isArray(i)) {
    let o = 0
    for (const c of i) {
      const l = Brt(c, t, e, s, r, a)
      if (l === 10) return l
      l > o && (o = l)
    }
    return o
  } else {
    if (typeof i == "string") return s ? (i === "*" ? 5 : i === e ? 10 : 0) : 0
    if (i) {
      const {
        language: o,
        pattern: c,
        scheme: l,
        hasAccessToAllModels: u,
        notebookType: d,
      } = i
      if (!s && !u) return 0
      d && r && (t = r)
      let m = 0
      if (l)
        if (l === t.scheme) m = 10
        else if (l === "*") m = 5
        else return 0
      if (o)
        if (o === e) m = 10
        else if (o === "*") m = Math.max(m, 5)
        else return 0
      if (d)
        if (d === a) m = 10
        else if (d === "*" && a !== void 0) m = Math.max(m, 5)
        else return 0
      if (c) {
        let f
        if (
          (typeof c == "string" ? (f = c) : (f = { ...c, base: Xr(c.base) }),
          f === t.fsPath || Bc(f, t.fsPath))
        )
          m = 10
        else return 0
      }
      return m
    } else return 0
  }
}
function qrt(i) {
  return typeof i == "string"
    ? !1
    : Array.isArray(i)
      ? i.some(qrt)
      : !!i.notebookType
}
var TW
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Indent = 1)] = "Indent"),
    (i[(i.IndentOutdent = 2)] = "IndentOutdent"),
    (i[(i.Outdent = 3)] = "Outdent")
})(TW || (TW = {}))
var Urt
;(function (i) {
  ;(i.keyword = "keyword"), (i.vector = "vector")
})(Urt || (Urt = {}))
var Mrt
;(function (i) {
  ;(i.OPEN = "open"), (i.CLOSED = "closed"), (i.MERGED = "merged")
})(Mrt || (Mrt = {}))
var Hrt
;(function (i) {
  ;(i.TO_MAIN_FROM_BRANCH = "to_main_from_branch"), (i.TO_HEAD = "to_head")
})(Hrt || (Hrt = {}))
var Wrt
;(function (i) {
  ;(i.Diff = "diff"), (i.Pr = "pr")
})(Wrt || (Wrt = {}))
var kW
;(function (i) {
  ;(i.Upload = "upload"), (i.Syncing = "syncing")
})(kW || (kW = {}))
var jrt
;(function (i) {
  ;(i.Hover = "Hover"),
    (i.Definition = "Definition"),
    (i.TypeDefinition = "TypeDefinition"),
    (i.Reference = "Reference"),
    (i.Implementation = "Implementation")
})(jrt || (jrt = {}))
var Vrt
;(function (i) {
  ;(i.OK = "OK"),
    (i.ERROR = "ERROR"),
    (i.NO_CHANGES_FOUND = "NO_CHANGES_FOUND"),
    (i.NONE = "NONE")
})(Vrt || (Vrt = {}))
var Grt
;(function (i) {
  i.id = "local"
})(Grt || (Grt = {}))
var UNt = "x-client-key",
  MNt = "x-ghost-mode",
  HNt = "x-session-id"
function WNt(i) {
  if (i === !0) return "true"
  if (i === !1) return "false"
  if (i === void 0) return "implicit-false"
  {
    let t = i
    return (t = t), "true"
  }
}
function jNt(i) {
  let t = 165
  for (let e = 0; e < i.length; e++) (i[e] = (i[e] ^ t) + (e % 256)), (t = i[e])
  return i
}
function VNt({
  req: i,
  machineId: t,
  macMachineId: e,
  base64Fn: s,
  cursorVersion: r,
  privacyMode: a,
  backupRequestId: o,
  clientKey: c,
  sessionId: l,
}) {
  try {
    const u = Math.floor(Date.now() / 1e6),
      d = new Uint8Array([
        (u >> 40) & 255,
        (u >> 32) & 255,
        (u >> 24) & 255,
        (u >> 16) & 255,
        (u >> 8) & 255,
        u & 255,
      ]),
      m = jNt(d),
      f = s(m)
    i.header.set(
      "x-cursor-checksum",
      e === void 0 ? `${f}${t}` : `${f}${t}/${e}`,
    )
  } catch {}
  i.header.set("x-cursor-client-version", r),
    l !== void 0 && i.header.set(HNt, l),
    i.header.set(MNt, WNt(a)),
    c !== void 0 && i.header.set(UNt, c)
  try {
    const u = Intl.DateTimeFormat().resolvedOptions().timeZone
    i.header.set("x-cursor-timezone", u)
  } catch {}
  try {
    o &&
      (i.header.has("x-request-id") || i.header.set("x-request-id", o),
      i.header.has("x-amzn-trace-id") ||
        i.header.set("x-amzn-trace-id", `Root=${o}`))
  } catch {}
}
var zrt
;(function (i) {
  i.GetCachedServerConfig = "aiServerConfigService.getCachedServerConfig"
})(zrt || (zrt = {}))
var Yrt
;(function (i) {
  ;(i.Ack = "editHistoryDiffFormatter.ack"),
    (i.GetModelValueInRanges =
      "editHistoryDiffFormatter.getModelValueInRanges"),
    (i.GetModelValue = "editHistoryDiffFormatter.getModelValue"),
    (i.ProcessModelChange = "editHistoryDiffFormatter.processModelChange"),
    (i.FormatDiffHistory = "editHistoryDiffFormatter.formatDiffHistory"),
    (i.CloseCurrentCmdkDiffHistoryPatch =
      "editHistoryDiffFormatter.closeCurrentCmdkDiffHistoryPatch"),
    (i.InitModel = "editHistoryDiffFormatter.initModel"),
    (i.CompileGlobalDiffTrajectories =
      "editHistoryDiffFormatter.compileGlobalDiffTrajectories"),
    (i.CompileGlobalDiffTrajectoriesForCmdk =
      "editHistoryDiffFormatter.compileGlobalDiffTrajectoriesForCmdk"),
    (i.IsRevertingToRecentModel =
      "editHistoryDiffFormatter.isRevertingToRecentModel"),
    (i.IsSuggestingRecentlyRejectedEdit =
      "editHistoryDiffFormatter.isSuggestingRecentlyRejectedEdit"),
    (i.RecordRejectedEdit = "editHistoryDiffFormatter.recordRejectedEdit"),
    (i.ProcessModelChangeLoop =
      "editHistoryDiffFormatter.processModelChangeLoop"),
    (i.SetEnableCppWhitespaceDiffHistoryMode =
      "editHistoryDiffFormatter.setEnableCppWhitespaceDiffHistoryMode"),
    (i.SetEnableCppIncludeUnchangedLines =
      "editHistoryDiffFormatter.setEnableCppIncludeUnchangedLines")
})(Yrt || (Yrt = {}))
var Qrt
;(function (i) {
  i.GetExtHostInfo = "extHostInfo.getExtHostInfo"
})(Qrt || (Qrt = {}))
var Xrt
;(function (i) {
  ;(i.GetFileSyncUpdates = "fileSync.getFileSyncUpdates"),
    (i.ShouldRelyOnFileSyncForFile = "fileSync.shouldRelyOnFileSyncForFile"),
    (i.GetFileSyncEncryptionHeader = "fileSync.getFileSyncEncryptionHeader"),
    (i.ResetSequentialSuccessfulSync = "fileSync.resetSequentialSuccessfulSync")
})(Xrt || (Xrt = {}))
var Krt
;(function (i) {
  ;(i.GetCommitNotes = "commitNotesService.getCommitNotes"),
    (i.SearchCommitNotes = "commitNotesService.searchCommitNotes"),
    (i.InitializeNotes = "commitNotesService.initialiezNotes")
})(Krt || (Krt = {}))
var Zrt
;(function (i) {
  ;(i.GetRelatedFiles = "contextGraph.getRelatedFiles"),
    (i.InitializeWorkspace = "contextGraph.initializeWorkspace"),
    (i.GetWorkspaceSyncStatus = "contextGraph.getWorkspaceSyncStatus"),
    (i.ResetWorkspace = "contextGraph.resetWorkspace"),
    (i.GetRelatedFilesForLine = "contextGraph.getRelatedFilesForLine"),
    (i.GetRelatedFilesForRange = "contextGraph.getRelatedFilesForRange")
})(Zrt || (Zrt = {}))
var tnt
;(function (i) {
  i.GetDirectory = "fileRetrievalActions.readDirectory"
})(tnt || (tnt = {}))
var ent
;(function (i) {
  ;(i.CheckClaudeAPIKey = "misc.checkClaudeAPIKey"),
    (i.CheckGoogleAPIKey = "misc.checkGoogleAPIKey")
})(ent || (ent = {}))
var int
;(function (i) {
  ;(i.GetReferencedSymbols = "treesitter.getReferencedSymbols"),
    (i.GetDefinedSymbols = "treesitter.getDefinedSymbols"),
    (i.GetImportantDefinitionNames = "treesitter.getImportantDefinitionNames")
})(int || (int = {}))
var snt
;(function (i) {
  ;(i.GetRecentCommits = "git.getRecentCommits"),
    (i.GetRecentCommitHashesTouchingFile =
      "git.getRecentCommitHashesTouchingFile"),
    (i.GetCommitByHash = "git.getCommitByHash"),
    (i.GetCommitDetailsByHashes = "git.getCommitDetailsByHashes"),
    (i.GetCurrentIndexAndRecentCommits = "git.getCurrentIndexAndRecentCommits")
})(snt || (snt = {}))
var rnt
;(function (i) {
  i.GetFileImports = "lsp.getFileImports"
})(rnt || (rnt = {}))
var nnt
;(function (i) {
  ;(i.Get = "devOnlyRedis.get"),
    (i.Set = "devOnlyRedis.set"),
    (i.SubscribeToChannelForKey = "devOnlyRedis.subscribeToChannelForKey"),
    (i.UnsubscribeFromChannelForKey =
      "devOnlyRedis.unsubscribeFromChannelForKey")
})(nnt || (nnt = {}))
var ant
;(function (i) {
  i.ValueChanged = "devOnlyRedis.valueChanged"
})(ant || (ant = {}))
var ont
;(function (i) {
  i.TakeScreenshot = "puppeteer.takeScreenshot"
})(ont || (ont = {}))
var cnt
;(function (i) {
  ;(i.ListTools = "mcp.listTools"),
    (i.CallTool = "mcp.callTool"),
    (i.CreateClient = "mcp.createClient"),
    (i.DeleteClient = "mcp.deleteClient")
})(cnt || (cnt = {}))
var lnt
;(function (i) {
  ;(i.Unknown = "unknown"),
    (i.LineChange = "line_change"),
    (i.Typing = "typing"),
    (i.OptionHold = "option_hold"),
    (i.LinterErrors = "lint_errors"),
    (i.ParameterHints = "parameter_hints"),
    (i.CursorPrediction = "cursor_prediction"),
    (i.ManualTrigger = "manual_trigger"),
    (i.EditorChange = "editor_change"),
    (i.LspSuggestions = "lsp_suggestions")
})(lnt || (lnt = {}))
var unt
;(function (i) {
  ;(i.FREE = "free"),
    (i.PRO = "pro"),
    (i.ENTERPRISE = "enterprise"),
    (i.FREE_TRIAL = "free_trial")
})(unt || (unt = {}))
var hnt
;(function (i) {
  ;(i.Ack = "composerEditHistoryDiffFormatter.ack"),
    (i.CompileGlobalDiffTrajectories =
      "composerEditHistoryDiffFormatter.compileGlobalDiffTrajectories"),
    (i.FormatDiffHistory =
      "composerEditHistoryDiffFormatter.formatDiffHistory"),
    (i.InitModel = "composerEditHistoryDiffFormatter.initModel"),
    (i.ResetModel = "composerEditHistoryDiffFormatter.resetModel"),
    (i.ProcessModelChange =
      "composerEditHistoryDiffFormatter.processModelChange"),
    (i.GetModelValue = "composerEditHistoryDiffFormatter.getModelValue")
})(hnt || (hnt = {}))
var UQt = X("editSessionIdentityService"),
  SW
;(function (i) {
  ;(i[(i.Complete = 100)] = "Complete"),
    (i[(i.Partial = 50)] = "Partial"),
    (i[(i.None = 0)] = "None")
})(SW || (SW = {}))
var GNt = class {
    constructor(i) {
      ;(this.a = new Map()),
        (this.b = 0),
        (this.c = i.getProxy(K.MainThreadAiRelatedInformation))
    }
    async $provideAiRelatedInformation(i, t, e) {
      if (this.a.size === 0)
        throw new Error("No related information providers registered")
      const s = this.a.get(i)
      if (!s) throw new Error("related information provider not found")
      return (await s.provideRelatedInformation(t, e)) ?? []
    }
    getRelatedInformation(i, t, e) {
      return this.c.$getAiRelatedInformation(t, e)
    }
    registerRelatedInformationProvider(i, t, e) {
      const s = this.b
      return (
        this.b++,
        this.a.set(s, e),
        this.c.$registerAiRelatedInformationProvider(s, t),
        new Ht(() => {
          this.c.$unregisterAiRelatedInformationProvider(s), this.a.delete(s)
        })
      )
    }
  },
  dnt
;(function (i) {
  ;(i[(i.Full = 1)] = "Full"), (i[(i.Delta = 2)] = "Delta")
})(dnt || (dnt = {}))
function mnt(i) {
  for (let t = 0, e = i.length; t < e; t += 4) {
    const s = i[t + 0],
      r = i[t + 1],
      a = i[t + 2],
      o = i[t + 3]
    ;(i[t + 0] = o), (i[t + 1] = a), (i[t + 2] = r), (i[t + 3] = s)
  }
}
function zNt(i) {
  const t = new Uint8Array(i.buffer, i.byteOffset, i.length * 4)
  return nG() || mnt(t), Q.wrap(t)
}
function YNt(i) {
  const t = i.buffer
  if ((nG() || mnt(t), t.byteOffset % 4 === 0))
    return new Uint32Array(t.buffer, t.byteOffset, t.length / 4)
  {
    const e = new Uint8Array(t.byteLength)
    return e.set(t), new Uint32Array(e.buffer, e.byteOffset, e.length / 4)
  }
}
function EW(i) {
  const t = new Uint32Array(QNt(i))
  let e = 0
  if (((t[e++] = i.id), i.type === "full"))
    (t[e++] = 1),
      (t[e++] = i.data.length),
      t.set(i.data, e),
      (e += i.data.length)
  else {
    ;(t[e++] = 2), (t[e++] = i.deltas.length)
    for (const s of i.deltas)
      (t[e++] = s.start),
        (t[e++] = s.deleteCount),
        s.data
          ? ((t[e++] = s.data.length), t.set(s.data, e), (e += s.data.length))
          : (t[e++] = 0)
  }
  return zNt(t)
}
function QNt(i) {
  let t = 0
  if (((t += 2), i.type === "full")) t += 1 + i.data.length
  else {
    ;(t += 1), (t += 3 * i.deltas.length)
    for (const e of i.deltas) e.data && (t += e.data.length)
  }
  return t
}
function fnt(i) {
  const t = YNt(i)
  let e = 0
  const s = t[e++]
  if (t[e++] === 1) {
    const c = t[e++],
      l = t.subarray(e, e + c)
    return (e += c), { id: s, type: "full", data: l }
  }
  const a = t[e++],
    o = []
  for (let c = 0; c < a; c++) {
    const l = t[e++],
      u = t[e++],
      d = t[e++]
    let m
    d > 0 && ((m = t.subarray(e, e + d)), (e += d)),
      (o[c] = { start: l, deleteCount: u, data: m })
  }
  return { id: s, type: "delta", deltas: o }
}
var XNt = [
    new Tt(
      "vscode.executeDocumentHighlights",
      "_executeDocumentHighlights",
      "Execute document highlight provider.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of DocumentHighlight-instances.",
        pr(pl.to),
      ),
    ),
    new Tt(
      "vscode.executeDocumentSymbolProvider",
      "_executeDocumentSymbolProvider",
      "Execute document symbol provider.",
      [H.Uri],
      new yt(
        "A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.",
        (i, t) => {
          if (d7(i)) return
          class e extends Rh {
            static to(r) {
              const a = new e(
                r.name,
                Ls.to(r.kind),
                r.containerName || "",
                new ys(t[0], U.to(r.range)),
              )
              return (
                (a.detail = r.detail),
                (a.range = a.location.range),
                (a.selectionRange = U.to(r.selectionRange)),
                (a.children = r.children ? r.children.map(e.to) : []),
                a
              )
            }
          }
          return i.map(e.to)
        },
      ),
    ),
    new Tt(
      "vscode.executeFormatDocumentProvider",
      "_executeFormatDocumentProvider",
      "Execute document format provider.",
      [
        H.Uri,
        new H(
          "options",
          "Formatting options",
          (i) => !0,
          (i) => i,
        ),
      ],
      new yt("A promise that resolves to an array of TextEdits.", pr(si.to)),
    ),
    new Tt(
      "vscode.executeFormatRangeProvider",
      "_executeFormatRangeProvider",
      "Execute range format provider.",
      [
        H.Uri,
        H.Range,
        new H(
          "options",
          "Formatting options",
          (i) => !0,
          (i) => i,
        ),
      ],
      new yt("A promise that resolves to an array of TextEdits.", pr(si.to)),
    ),
    new Tt(
      "vscode.executeFormatOnTypeProvider",
      "_executeFormatOnTypeProvider",
      "Execute format on type provider.",
      [
        H.Uri,
        H.Position,
        new H(
          "ch",
          "Trigger character",
          (i) => typeof i == "string",
          (i) => i,
        ),
        new H(
          "options",
          "Formatting options",
          (i) => !0,
          (i) => i,
        ),
      ],
      new yt("A promise that resolves to an array of TextEdits.", pr(si.to)),
    ),
    new Tt(
      "vscode.executeDefinitionProvider",
      "_executeDefinitionProvider",
      "Execute all definition providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location or LocationLink instances.",
        xa,
      ),
    ),
    new Tt(
      "vscode.experimental.executeDefinitionProvider_recursive",
      "_executeDefinitionProvider_recursive",
      "Execute all definition providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location or LocationLink instances.",
        xa,
      ),
    ),
    new Tt(
      "vscode.executeTypeDefinitionProvider",
      "_executeTypeDefinitionProvider",
      "Execute all type definition providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location or LocationLink instances.",
        xa,
      ),
    ),
    new Tt(
      "vscode.experimental.executeTypeDefinitionProvider_recursive",
      "_executeTypeDefinitionProvider_recursive",
      "Execute all type definition providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location or LocationLink instances.",
        xa,
      ),
    ),
    new Tt(
      "vscode.executeDeclarationProvider",
      "_executeDeclarationProvider",
      "Execute all declaration providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location or LocationLink instances.",
        xa,
      ),
    ),
    new Tt(
      "vscode.experimental.executeDeclarationProvider_recursive",
      "_executeDeclarationProvider_recursive",
      "Execute all declaration providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location or LocationLink instances.",
        xa,
      ),
    ),
    new Tt(
      "vscode.executeImplementationProvider",
      "_executeImplementationProvider",
      "Execute all implementation providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location or LocationLink instances.",
        xa,
      ),
    ),
    new Tt(
      "vscode.experimental.executeImplementationProvider_recursive",
      "_executeImplementationProvider_recursive",
      "Execute all implementation providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location or LocationLink instances.",
        xa,
      ),
    ),
    new Tt(
      "vscode.executeReferenceProvider",
      "_executeReferenceProvider",
      "Execute all reference providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location-instances.",
        pr(Qi.to),
      ),
    ),
    new Tt(
      "vscode.experimental.executeReferenceProvider",
      "_executeReferenceProvider_recursive",
      "Execute all reference providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Location-instances.",
        pr(Qi.to),
      ),
    ),
    new Tt(
      "vscode.executeHoverProvider",
      "_executeHoverProvider",
      "Execute all hover providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Hover-instances.",
        pr(hd.to),
      ),
    ),
    new Tt(
      "vscode.experimental.executeHoverProvider_recursive",
      "_executeHoverProvider_recursive",
      "Execute all hover providers.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of Hover-instances.",
        pr(hd.to),
      ),
    ),
    new Tt(
      "vscode.executeSelectionRangeProvider",
      "_executeSelectionRangeProvider",
      "Execute selection range provider.",
      [
        H.Uri,
        new H(
          "position",
          "A position in a text document",
          (i) => Array.isArray(i) && i.every((t) => Ft.isPosition(t)),
          (i) => i.map(Kt.from),
        ),
      ],
      new yt("A promise that resolves to an array of ranges.", (i) =>
        i.map((t) => {
          let e
          for (const s of t.reverse()) e = new Ah(U.to(s), e)
          return e
        }),
      ),
    ),
    new Tt(
      "vscode.executeWorkspaceSymbolProvider",
      "_executeWorkspaceSymbolProvider",
      "Execute all workspace symbol providers.",
      [H.String.with("query", "Search string")],
      new yt(
        "A promise that resolves to an array of SymbolInformation-instances.",
        (i) => i.map(Po.to),
      ),
    ),
    new Tt(
      "vscode.prepareCallHierarchy",
      "_executePrepareCallHierarchy",
      "Prepare call hierarchy at a position inside a document",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of CallHierarchyItem-instances",
        (i) => i.map($o.to),
      ),
    ),
    new Tt(
      "vscode.provideIncomingCalls",
      "_executeProvideIncomingCalls",
      "Compute incoming calls for an item",
      [H.CallHierarchyItem],
      new yt(
        "A promise that resolves to an array of CallHierarchyIncomingCall-instances",
        (i) => i.map(_U.to),
      ),
    ),
    new Tt(
      "vscode.provideOutgoingCalls",
      "_executeProvideOutgoingCalls",
      "Compute outgoing calls for an item",
      [H.CallHierarchyItem],
      new yt(
        "A promise that resolves to an array of CallHierarchyOutgoingCall-instances",
        (i) => i.map(OU.to),
      ),
    ),
    new Tt(
      "vscode.prepareRename",
      "_executePrepareRename",
      "Execute the prepareRename of rename provider.",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to a range and placeholder text.",
        (i) => {
          if (i) return { range: U.to(i.range), placeholder: i.text }
        },
      ),
    ),
    new Tt(
      "vscode.executeDocumentRenameProvider",
      "_executeDocumentRenameProvider",
      "Execute rename provider.",
      [H.Uri, H.Position, H.String.with("newName", "The new symbol name")],
      new yt("A promise that resolves to a WorkspaceEdit.", (i) => {
        if (i) {
          if (i.rejectReason) throw new Error(i.rejectReason)
          return Oi.to(i)
        }
      }),
    ),
    new Tt(
      "vscode.executeLinkProvider",
      "_executeLinkProvider",
      "Execute document link provider.",
      [
        H.Uri,
        H.Number.with(
          "linkResolveCount",
          "Number of links that should be resolved, only when links are unresolved.",
        ).optional(),
      ],
      new yt(
        "A promise that resolves to an array of DocumentLink-instances.",
        (i) => i.map(xo.to),
      ),
    ),
    new Tt(
      "vscode.provideDocumentSemanticTokensLegend",
      "_provideDocumentSemanticTokensLegend",
      "Provide semantic tokens legend for a document",
      [H.Uri],
      new yt("A promise that resolves to SemanticTokensLegend.", (i) => {
        if (i) return new oU(i.tokenTypes, i.tokenModifiers)
      }),
    ),
    new Tt(
      "vscode.provideDocumentSemanticTokens",
      "_provideDocumentSemanticTokens",
      "Provide semantic tokens for a document",
      [H.Uri],
      new yt("A promise that resolves to SemanticTokens.", (i) => {
        if (!i) return
        const t = fnt(i)
        if (t.type === "full") return new al(t.data, void 0)
      }),
    ),
    new Tt(
      "vscode.provideDocumentRangeSemanticTokensLegend",
      "_provideDocumentRangeSemanticTokensLegend",
      "Provide semantic tokens legend for a document range",
      [H.Uri, H.Range.optional()],
      new yt("A promise that resolves to SemanticTokensLegend.", (i) => {
        if (i) return new oU(i.tokenTypes, i.tokenModifiers)
      }),
    ),
    new Tt(
      "vscode.provideDocumentRangeSemanticTokens",
      "_provideDocumentRangeSemanticTokens",
      "Provide semantic tokens for a document range",
      [H.Uri, H.Range],
      new yt("A promise that resolves to SemanticTokens.", (i) => {
        if (!i) return
        const t = fnt(i)
        if (t.type === "full") return new al(t.data, void 0)
      }),
    ),
    new Tt(
      "vscode.executeCompletionItemProvider",
      "_executeCompletionItemProvider",
      "Execute completion item provider.",
      [
        H.Uri,
        H.Position,
        H.String.with(
          "triggerCharacter",
          "Trigger completion when the user types the character, like `,` or `(`",
        ).optional(),
        H.Number.with(
          "itemResolveCount",
          "Number of completions to resolve (too large numbers slow down completions)",
        ).optional(),
      ],
      new yt(
        "A promise that resolves to a CompletionList-instance.",
        (i, t, e) => {
          if (!i) return new Vc([])
          const s = i.suggestions.map((r) => HU.to(r, e))
          return new Vc(s, i.incomplete)
        },
      ),
    ),
    new Tt(
      "vscode.executeSignatureHelpProvider",
      "_executeSignatureHelpProvider",
      "Execute signature help provider.",
      [
        H.Uri,
        H.Position,
        H.String.with(
          "triggerCharacter",
          "Trigger signature help when the user types the character, like `,` or `(`",
        ).optional(),
      ],
      new yt("A promise that resolves to SignatureHelp.", (i) => {
        if (i) return dd.to(i)
      }),
    ),
    new Tt(
      "vscode.executeCodeLensProvider",
      "_executeCodeLensProvider",
      "Execute code lens provider.",
      [
        H.Uri,
        H.Number.with(
          "itemResolveCount",
          "Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)",
        ).optional(),
      ],
      new yt(
        "A promise that resolves to an array of CodeLens-instances.",
        (i, t, e) =>
          pr(
            (s) =>
              new eO(U.to(s.range), s.command && e.fromInternal(s.command)),
          )(i),
      ),
    ),
    new Tt(
      "vscode.executeCodeActionProvider",
      "_executeCodeActionProvider",
      "Execute code action provider.",
      [
        H.Uri,
        new H(
          "rangeOrSelection",
          "Range in a text document. Some refactoring provider requires Selection object.",
          (i) => Nt.isRange(i),
          (i) => (fn.isSelection(i) ? or.from(i) : U.from(i)),
        ),
        H.String.with(
          "kind",
          "Code action kind to return code actions for",
        ).optional(),
        H.Number.with(
          "itemResolveCount",
          "Number of code actions to resolve (too large numbers slow down code actions)",
        ).optional(),
      ],
      new yt(
        "A promise that resolves to an array of Command-instances.",
        (i, t, e) =>
          pr((s) => {
            if (s._isSynthetic) {
              if (!s.command)
                throw new Error("Synthetic code actions must have a command")
              return e.fromInternal(s.command)
            } else {
              const r = new tO(s.title, s.kind ? new Ie(s.kind) : void 0)
              return (
                s.edit && (r.edit = Oi.to(s.edit)),
                s.command && (r.command = e.fromInternal(s.command)),
                (r.isPreferred = s.isPreferred),
                r
              )
            }
          })(i),
      ),
    ),
    new Tt(
      "vscode.executeDocumentColorProvider",
      "_executeDocumentColorProvider",
      "Execute document color provider.",
      [H.Uri],
      new yt(
        "A promise that resolves to an array of ColorInformation objects.",
        (i) => (i ? i.map((t) => new oO(U.to(t.range), gl.to(t.color))) : []),
      ),
    ),
    new Tt(
      "vscode.executeColorPresentationProvider",
      "_executeColorPresentationProvider",
      "Execute color presentation provider.",
      [
        new H(
          "color",
          "The color to show and insert",
          (i) => i instanceof Xc,
          gl.from,
        ),
        new H(
          "context",
          "Context object with uri and range",
          (i) => !0,
          (i) => ({ uri: i.uri, range: U.from(i.range) }),
        ),
      ],
      new yt(
        "A promise that resolves to an array of ColorPresentation objects.",
        (i) => (i ? i.map(t8.to) : []),
      ),
    ),
    new Tt(
      "vscode.executeInlayHintProvider",
      "_executeInlayHintProvider",
      "Execute inlay hints provider",
      [H.Uri, H.Range],
      new yt(
        "A promise that resolves to an array of Inlay objects",
        (i, t, e) => i.map(WU.to.bind(void 0, e)),
      ),
    ),
    new Tt(
      "vscode.executeFoldingRangeProvider",
      "_executeFoldingRangeProvider",
      "Execute folding range provider",
      [H.Uri],
      new yt(
        "A promise that resolves to an array of FoldingRange objects",
        (i, t) => {
          if (i) return i.map(i8.to)
        },
      ),
    ),
    new Tt(
      "vscode.resolveNotebookContentProviders",
      "_resolveNotebookContentProvider",
      "Resolve Notebook Content Providers",
      [],
      new yt(
        "A promise that resolves to an array of NotebookContentProvider static info objects.",
        pr((i) => ({
          viewType: i.viewType,
          displayName: i.displayName,
          options: {
            transientOutputs: i.options.transientOutputs,
            transientCellMetadata: i.options.transientCellMetadata,
            transientDocumentMetadata: i.options.transientDocumentMetadata,
          },
          filenamePattern: i.filenamePattern.map((t) => n8.to(t)),
        })),
      ),
    ),
    new Tt(
      "vscode.executeInlineValueProvider",
      "_executeInlineValueProvider",
      "Execute inline value provider",
      [
        H.Uri,
        H.Range,
        new H(
          "context",
          "An InlineValueContext",
          (i) =>
            i &&
            typeof i.frameId == "number" &&
            i.stoppedLocation instanceof Nt,
          (i) => zO.from(i),
        ),
      ],
      new yt(
        "A promise that resolves to an array of InlineValue objects",
        (i) => i.map(GO.to),
      ),
    ),
    new Tt(
      "vscode.open",
      "_workbench.open",
      "Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.",
      [
        new H(
          "uriOrString",
          "Uri-instance or string (only http/https)",
          (i) =>
            S.isUri(i) || (typeof i == "string" && bmt(i, G.http, G.https)),
          (i) => i,
        ),
        new H(
          "columnOrOptions",
          "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
          (i) => i === void 0 || typeof i == "number" || typeof i == "object",
          (i) =>
            i &&
            (typeof i == "number"
              ? [ii.from(i), void 0]
              : [ii.from(i.viewColumn), md.from(i)]),
        ).optional(),
        H.String.with("label", "").optional(),
      ],
      yt.Void,
    ),
    new Tt(
      "vscode.openWith",
      "_workbench.openWith",
      "Opens the provided resource with a specific editor.",
      [
        H.Uri.with("resource", "Resource to open"),
        H.String.with(
          "viewId",
          "Custom editor view id. This should be the viewType string for custom editors or the notebookType string for notebooks. Use 'default' to use VS Code's default text editor",
        ),
        new H(
          "columnOrOptions",
          "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
          (i) => i === void 0 || typeof i == "number" || typeof i == "object",
          (i) =>
            i &&
            (typeof i == "number"
              ? [ii.from(i), void 0]
              : [ii.from(i.viewColumn), md.from(i)]),
        ).optional(),
      ],
      yt.Void,
    ),
    new Tt(
      "vscode.diff",
      "_workbench.diff",
      "Opens the provided resources in the diff editor to compare their contents.",
      [
        H.Uri.with("left", "Left-hand side resource of the diff editor"),
        H.Uri.with("right", "Right-hand side resource of the diff editor"),
        H.String.with(
          "title",
          "Human readable title for the diff editor",
        ).optional(),
        new H(
          "columnOrOptions",
          "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
          (i) => i === void 0 || typeof i == "object",
          (i) => i && [ii.from(i.viewColumn), md.from(i)],
        ).optional(),
      ],
      yt.Void,
    ),
    new Tt(
      "vscode.changes",
      "_workbench.changes",
      "Opens a list of resources in the changes editor to compare their contents.",
      [
        H.String.with("title", "Human readable title for the changes editor"),
        new H(
          "resourceList",
          "List of resources to compare",
          (i) => {
            for (const t of i) {
              if (t.length !== 3) return !1
              const [e, s, r] = t
              if (
                !S.isUri(e) ||
                (!S.isUri(s) && s !== void 0 && s !== null) ||
                (!S.isUri(r) && r !== void 0 && r !== null)
              )
                return !1
            }
            return !0
          },
          (i) => i,
        ),
      ],
      yt.Void,
    ),
    new Tt(
      "vscode.prepareTypeHierarchy",
      "_executePrepareTypeHierarchy",
      "Prepare type hierarchy at a position inside a document",
      [H.Uri, H.Position],
      new yt(
        "A promise that resolves to an array of TypeHierarchyItem-instances",
        (i) => i.map(No.to),
      ),
    ),
    new Tt(
      "vscode.provideSupertypes",
      "_executeProvideSupertypes",
      "Compute supertypes for an item",
      [H.TypeHierarchyItem],
      new yt(
        "A promise that resolves to an array of TypeHierarchyItem-instances",
        (i) => i.map(No.to),
      ),
    ),
    new Tt(
      "vscode.provideSubtypes",
      "_executeProvideSubtypes",
      "Compute subtypes for an item",
      [H.TypeHierarchyItem],
      new yt(
        "A promise that resolves to an array of TypeHierarchyItem-instances",
        (i) => i.map(No.to),
      ),
    ),
    new Tt(
      "vscode.revealTestInExplorer",
      "_revealTestInExplorer",
      "Reveals a test instance in the explorer",
      [H.TestItem],
      yt.Void,
    ),
    new Tt(
      "vscode.startContinuousTestRun",
      "testing.startContinuousRunFromExtension",
      "Starts running the given tests with continuous run mode.",
      [H.TestProfile, H.Arr(H.TestItem)],
      yt.Void,
    ),
    new Tt(
      "vscode.stopContinuousTestRun",
      "testing.stopContinuousRunFromExtension",
      "Stops running the given tests with continuous run mode.",
      [H.Arr(H.TestItem)],
      yt.Void,
    ),
    new Tt(
      "vscode.experimental.editSession.continue",
      "_workbench.editSessions.actions.continueEditSession",
      "Continue the current edit session in a different workspace",
      [
        H.Uri.with(
          "workspaceUri",
          "The target workspace to continue the current edit session in",
        ),
      ],
      yt.Void,
    ),
    new Tt(
      "setContext",
      "_setContext",
      "Set a custom context key value that can be used in when clauses.",
      [
        H.String.with("name", "The context key name"),
        new H(
          "value",
          "The context key value",
          () => !0,
          (i) => i,
        ),
      ],
      yt.Void,
    ),
    new Tt(
      "vscode.executeMappedEditsProvider",
      "_executeMappedEditsProvider",
      "Execute Mapped Edits Provider",
      [
        H.Uri,
        H.StringArray,
        new H(
          "MappedEditsContext",
          "Mapped Edits Context",
          (i) => r8.is(i),
          (i) => r8.from(i),
        ),
      ],
      new yt("A promise that resolves to a workspace edit or null", (i) =>
        i ? Oi.to(i) : null,
      ),
    ),
    new Tt(
      "vscode.editorChat.start",
      "inlineChat.start",
      "Invoke a new editor chat session",
      [
        new H(
          "Run arguments",
          "",
          (i) => !0,
          (i) => {
            if (i)
              return {
                initialRange: i.initialRange ? U.from(i.initialRange) : void 0,
                initialSelection: fn.isSelection(i.initialSelection)
                  ? or.from(i.initialSelection)
                  : void 0,
                message: i.message,
                autoSend: i.autoSend,
                position: i.position ? Kt.from(i.position) : void 0,
              }
          },
        ),
      ],
      yt.Void,
    ),
  ],
  KNt = class {
    static register(i) {
      XNt.forEach(i.registerApiCommand, i), this.a(i)
    }
    static a(i) {
      i.registerCommand(!1, "_validateWhenClauses", xwt)
    }
  }
function pr(i) {
  return (t) => {
    if (Array.isArray(t)) return t.map(i)
  }
}
function xa(i) {
  if (!Array.isArray(i)) return
  const t = []
  for (const e of i) t0t(e) ? t.push(ud.to(e)) : t.push(Qi.to(e))
  return t
}
var IW = class {
  constructor(t, e) {
    ;(this.a = t.getProxy(K.MainThreadBulkEdits)),
      (this.b = {
        getTextDocumentVersion: (s) => e.getDocument(s)?.version,
        getNotebookDocumentVersion: () => {},
      })
  }
  applyWorkspaceEdit(t, e, s) {
    const r = new gs(Oi.from(t, this.b))
    return this.a.$tryApplyWorkspaceEdit(r, void 0, s?.isRefactoring ?? !1)
  }
}
IW = __decorate([__param(0, Ot)], IW)
var pnt
;(function (i) {
  ;(i[(i.Complete = 1)] = "Complete"),
    (i[(i.Partial = 2)] = "Partial"),
    (i[(i.Omitted = 3)] = "Omitted")
})(pnt || (pnt = {}))
var BB
;(function (i) {
  ;(i[(i.Down = 0)] = "Down"), (i[(i.Up = 1)] = "Up")
})(BB || (BB = {}))
var gnt
;(function (i) {
  ;(i.IncorrectCode = "incorrectCode"),
    (i.DidNotFollowInstructions = "didNotFollowInstructions"),
    (i.IncompleteCode = "incompleteCode"),
    (i.MissingContext = "missingContext"),
    (i.PoorlyWrittenOrFormatted = "poorlyWrittenOrFormatted"),
    (i.RefusedAValidRequest = "refusedAValidRequest"),
    (i.OffensiveOrUnsafe = "offensiveOrUnsafe"),
    (i.Other = "other"),
    (i.WillReportIssue = "willReportIssue")
})(gnt || (gnt = {}))
var vnt
;(function (i) {
  ;(i[(i.Action = 1)] = "Action"), (i[(i.Toolbar = 2)] = "Toolbar")
})(vnt || (vnt = {}))
var HQt = X("IChatService")
function ZNt(i) {
  return !!i && typeof i.sessionId == "string" && i.$mid === 19
}
var t9t = class {
    constructor(i, t, e, s, r) {
      ;(this.j = i),
        (this.k = t),
        (this.l = e),
        (this.m = s),
        (this.n = r),
        (this.b = ss.create(!1)),
        (this.c = !1)
    }
    close() {
      this.c = !0
    }
    get timings() {
      return { firstProgress: this.d, totalElapsed: this.b.elapsed() }
    }
    get apiObject() {
      if (!this.g) {
        let t = function (r) {
          if (e.c) {
            const a = new Error("Response stream has been closed")
            throw (Error.captureStackTrace(a, r), a)
          }
        }
        var i = t
        const e = this
        this.b.reset()
        const s = (r, a) => {
          if (
            (typeof this.d > "u" &&
              (r.kind === "markdownContent" || r.kind === "markdownVuln") &&
              (this.d = this.b.elapsed()),
            a)
          ) {
            const o = this.l.$handleProgressChunk(this.k.requestId, r),
              c = {
                report: (l) => {
                  o?.then((u) => {
                    u &&
                      (ls.isMarkdownString(l.value)
                        ? this.l.$handleProgressChunk(
                            this.k.requestId,
                            bd.from(l),
                            u,
                          )
                        : this.l.$handleProgressChunk(
                            this.k.requestId,
                            bn.from(l),
                            u,
                          ))
                  })
                },
              }
            Promise.all([o, a?.(c)]).then(([l, u]) => {
              l !== void 0 &&
                this.l.$handleProgressChunk(this.k.requestId, sM.from(u), l)
            })
          } else this.l.$handleProgressChunk(this.k.requestId, r)
        }
        this.g = Object.freeze({
          markdown(r) {
            t(this.markdown)
            const a = new DO(r),
              o = wd.from(a)
            return s(o), this
          },
          markdownWithVulnerabilities(r, a) {
            t(this.markdown), a && _(e.j, "chatParticipantAdditions")
            const o = new id(r, a),
              c = h8.from(o)
            return s(c), this
          },
          codeblockUri(r) {
            t(this.codeblockUri), _(e.j, "chatParticipantAdditions")
            const a = new BO(r),
              o = u8.from(a)
            return s(o), this
          },
          filetree(r, a) {
            t(this.filetree)
            const o = new AO(r, a),
              c = yd.from(o)
            return s(c), this
          },
          anchor(r, a) {
            const o = new rd(r, a)
            return this.push(o)
          },
          button(r) {
            t(this.anchor)
            const a = new OO(r),
              o = Td.from(a, e.m, e.n)
            return s(o), this
          },
          progress(r, a) {
            t(this.progress)
            const o = new _O(r, a),
              c = a ? f8.from(o) : Co.from(o)
            return s(c, a), this
          },
          warning(r) {
            t(this.progress), _(e.j, "chatParticipantAdditions")
            const a = new ad(r),
              o = bd.from(a)
            return s(o), this
          },
          reference(r, a) {
            return this.reference2(r, a)
          },
          reference2(r, a, o) {
            if (
              (t(this.reference),
              typeof r == "object" &&
                "variableName" in r &&
                _(e.j, "chatParticipantAdditions"),
              typeof r == "object" && "variableName" in r && !r.value)
            ) {
              const c = e.k.variables.variables.find(
                (l) => l.name === r.variableName,
              )
              if (c) {
                let l
                if (c.references?.length)
                  l = c.references.map((u) => ({
                    kind: "reference",
                    reference: {
                      variableName: r.variableName,
                      value: u.reference,
                    },
                  }))
                else {
                  const u = new vn(r, a, o)
                  l = [bn.from(u)]
                }
                return l.forEach((u) => s(u)), this
              }
            } else {
              const c = new vn(r, a, o),
                l = bn.from(c)
              s(l)
            }
            return this
          },
          codeCitation(r, a, o) {
            t(this.codeCitation), _(e.j, "chatParticipantAdditions")
            const c = new qO(r, a, o),
              l = g8.from(c)
            s(l)
          },
          textEdit(r, a) {
            t(this.textEdit), _(e.j, "chatParticipantAdditions")
            const o = new od(r, Array.isArray(a) ? a : [])
            o.isDone = a === !0 ? !0 : void 0
            const c = p8.from(o)
            return s(c), this
          },
          detectedParticipant(r, a) {
            t(this.detectedParticipant), _(e.j, "chatParticipantAdditions")
            const o = new sd(r, a),
              c = d8.from(o)
            return s(c), this
          },
          confirmation(r, a, o, c) {
            t(this.confirmation), _(e.j, "chatParticipantAdditions")
            const l = new FO(r, a, o, c),
              u = m8.from(l)
            return s(u), this
          },
          push(r) {
            if (
              (t(this.push),
              (r instanceof od ||
                r instanceof id ||
                r instanceof sd ||
                r instanceof ad ||
                r instanceof FO ||
                r instanceof qO ||
                r instanceof UO ||
                r instanceof _O) &&
                _(e.j, "chatParticipantAdditions"),
              r instanceof vn)
            )
              this.reference2(r.value, r.iconPath, r.options)
            else if (r instanceof _O) {
              const a = r.task ? f8.from(r) : Co.from(r)
              s(a, r.task)
            } else if (r instanceof rd) {
              const a = Il.from(r)
              if (r.resolve) {
                _(e.j, "chatParticipantAdditions"), (a.resolveId = Ze())
                const o = new fe()
                r
                  .resolve(o.token)
                  .then(() => {
                    const c = Il.from(r)
                    e.l.$handleAnchorResolve(e.k.requestId, a.resolveId, c)
                  })
                  .then(
                    () => o.dispose(),
                    () => o.dispose(),
                  ),
                  e.n.add(et(() => o.dispose(!0)))
              }
              s(a)
            } else {
              const a = v8.from(r, e.m, e.n)
              s(a)
            }
            return this
          },
        })
      }
      return this.g
    }
  },
  e9t = class ly extends at {
    static {
      this.b = 0
    }
    static {
      this.j = 0
    }
    static {
      this.n = 0
    }
    constructor(t, e, s, r, a) {
      super(),
        (this.u = e),
        (this.w = s),
        (this.y = r),
        (this.z = a),
        (this.c = new Map()),
        (this.m = new Map()),
        (this.q = new Map()),
        (this.s = this.D(new f_())),
        (this.t = this.D(new f_())),
        (this.g = t.getProxy(K.MainThreadChatAgents2)),
        s.registerArgumentProcessor({
          processArgument: (o) => (ZNt(o) ? null : o),
        })
    }
    transferActiveChat(t) {
      this.g.$transferActiveChatSession(t)
    }
    createChatAgent(t, e, s) {
      const r = ly.b++,
        a = new wnt(t, e, this.g, r, s)
      return (
        this.c.set(r, a),
        this.g.$registerAgent(r, t.identifier, e, {}, void 0),
        a.apiAgent
      )
    }
    createDynamicChatAgent(t, e, s, r) {
      const a = ly.b++,
        o = new wnt(t, e, this.g, a, r)
      return (
        this.c.set(a, o),
        this.g.$registerAgent(a, t.identifier, e, { isSticky: !0 }, s),
        o.apiAgent
      )
    }
    registerChatParticipantDetectionProvider(t, e) {
      const s = ly.j++
      return (
        this.m.set(s, new i9t(t, e)),
        this.g.$registerChatParticipantDetectionProvider(s),
        et(() => {
          this.m.delete(s),
            this.g.$unregisterChatParticipantDetectionProvider(s)
        })
      )
    }
    registerRelatedFilesProvider(t, e, s) {
      const r = ly.n++
      return (
        this.q.set(r, new s9t(t, e)),
        this.g.$registerRelatedFilesProvider(r, s),
        et(() => {
          this.q.delete(r), this.g.$unregisterRelatedFilesProvider(r)
        })
      )
    }
    async $provideRelatedFiles(t, e, s) {
      const r = this.q.get(t)
      if (!r) return Promise.resolve([])
      const a = rM.to(e)
      return (await r.provider.provideRelatedFiles(a, s)) ?? void 0
    }
    async $detectChatParticipant(t, e, s, r, a) {
      const { request: o, location: c, history: l } = await this.C(e, s),
        u = this.m.get(t)
      if (!u) return
      const d = await this.F(o, u.extension),
        m = w8.to(o, c, d)
      return u.provider.provideParticipantDetection(
        m,
        { history: l },
        { participants: r.participants, location: kd.to(r.location) },
        a,
      )
    }
    async C(t, e) {
      const s = ki(t),
        r = await this.G(s.agentId, e)
      let a
      if (s.locationData?.type === Ei.Editor) {
        const o = this.y.getDocument(s.locationData.document)
        a = new xtt(
          o,
          or.to(s.locationData.selection),
          U.to(s.locationData.wholeRange),
        )
      } else if (s.locationData?.type === Ei.Notebook) {
        const o = this.y.getDocument(s.locationData.sessionInputUri)
        a = new Ntt(o)
      } else s.locationData?.type, Ei.Terminal
      return { request: s, location: a, history: r }
    }
    async F(t, e) {
      let s
      if (
        (t.userSelectedModelId &&
          (s = await this.z.getLanguageModelByIdentifier(
            e,
            t.userSelectedModelId,
          )),
        !s && ((s = await this.z.getDefaultLanguageModel(e)), !s))
      )
        throw new Error("Language model unavailable")
      return s
    }
    async $invokeAgent(t, e, s, r) {
      const a = this.c.get(t)
      if (!a)
        throw new Error(
          `[CHAT](${t}) CANNOT invoke agent because the agent is not registered`,
        )
      let o
      try {
        const { request: c, location: l, history: u } = await this.C(e, s)
        let d = this.s.get(c.sessionId)
        d || ((d = new gt()), this.s.set(c.sessionId, d)),
          (o = new t9t(a.extension, c, this.g, this.w.converter, d))
        const m = await this.F(c, a.extension),
          f = w8.to(c, l, m),
          p = a.invoke(f, { history: u }, o.apiObject, r)
        return await zG(
          Promise.resolve(p).then((v) => {
            if (v?.metadata)
              try {
                JSON.stringify(v.metadata)
              } catch (k) {
                const E = `result.metadata MUST be JSON.stringify-able. Got error: ${k.message}`
                return (
                  this.u.error(
                    `[${a.extension.identifier.value}] [@${a.id}] ${E}`,
                    a.extension,
                  ),
                  {
                    errorDetails: { message: E },
                    timings: o?.timings,
                    nextQuestion: v.nextQuestion,
                  }
                )
              }
            let b
            return (
              v?.errorDetails &&
                (b = { ...v.errorDetails, responseIsIncomplete: !0 }),
              (b?.responseIsRedacted || b?.isQuotaExceeded) &&
                _(a.extension, "chatParticipantPrivate"),
              {
                errorDetails: b,
                timings: o?.timings,
                metadata: v?.metadata,
                nextQuestion: v?.nextQuestion,
              }
            )
          }),
          r,
        )
      } catch (c) {
        this.u.error(c, a.extension),
          c instanceof wn && c.cause && (c = c.cause)
        const l = c instanceof Error && c.name === "ChatQuotaExceeded"
        return {
          errorDetails: {
            message: Zs(c),
            responseIsIncomplete: !0,
            isQuotaExceeded: l,
          },
        }
      } finally {
        o?.close()
      }
    }
    async G(t, e) {
      const s = []
      for (const r of e.history) {
        const a = ga.to(r.result),
          o = t === r.request.agentId ? a : { ...a, metadata: void 0 },
          c = r.request.variables.variables.filter((m) => !m.isTool).map(y8.to),
          l = r.request.variables.variables.filter((m) => m.isTool).map(b8.to),
          u = new Ptt(
            r.request.message,
            r.request.command,
            c,
            r.request.agentId,
            l,
          )
        s.push(u)
        const d = Ue(r.response.map((m) => v8.toContent(m, this.w.converter)))
        s.push(new $tt(d, o, r.request.agentId, r.request.command))
      }
      return s
    }
    $releaseSession(t) {
      this.s.deleteAndDispose(t)
    }
    async $provideFollowups(t, e, s, r, a) {
      const o = this.c.get(e)
      if (!o) return Promise.resolve([])
      const c = ki(t),
        l = await this.G(o.id, r),
        u = ga.to(s)
      return (await o.provideFollowups(u, { history: l }, a))
        .filter((d) => {
          const m =
            !d.participant ||
            ms.some(
              this.c.values(),
              (f) =>
                f.id === d.participant &&
                ae.equals(f.extension.identifier, o.extension.identifier),
            )
          return (
            m ||
              this.u.warn(
                `[@${o.id}] ChatFollowup refers to an unknown participant: ${d.participant}`,
              ),
            m
          )
        })
        .map((d) => vd.from(d, c))
    }
    $acceptFeedback(t, e, s) {
      const r = this.c.get(t)
      if (!r) return
      const a = ga.to(e)
      let o
      switch (s.direction) {
        case BB.Down:
          o = ed.Unhelpful
          break
        case BB.Up:
          o = ed.Helpful
          break
      }
      const c = {
        result: a,
        kind: o,
        unhelpfulReason: hi(r.extension, "chatParticipantAdditions")
          ? s.reason
          : void 0,
      }
      r.acceptFeedback(Object.freeze(c))
    }
    $acceptAction(t, e, s) {
      const r = this.c.get(t)
      if (!r || s.action.kind === "vote") return
      const a = aM.to(e, s, this.w.converter)
      a && r.acceptAction(Object.freeze(a))
    }
    async $invokeCompletionProvider(t, e, s) {
      const r = this.c.get(t)
      if (!r) return []
      let a = this.t.get(t)
      return (
        a ? a.clear() : ((a = new gt()), this.t.set(t, a)),
        (await r.invokeCompletionProvider(e, s)).map((c) =>
          nM.from(c, this.w.converter, a),
        )
      )
    }
    async $provideWelcomeMessage(t, e) {
      const s = this.c.get(t)
      if (s) return await s.provideWelcomeMessage(e)
    }
    async $provideChatTitle(t, e, s) {
      const r = this.c.get(t)
      if (!r) return
      const a = await this.G(r.id, { history: e })
      return await r.provideTitle({ history: a }, s)
    }
    async $provideSampleQuestions(t, e, s) {
      const r = this.c.get(t)
      if (r)
        return (await r.provideSampleQuestions(kd.to(e), s)).map((a) =>
          vd.from(a, void 0),
        )
    }
  },
  i9t = class {
    constructor(i, t) {
      ;(this.extension = i), (this.provider = t)
    }
  },
  s9t = class {
    constructor(i, t) {
      ;(this.extension = i), (this.provider = t)
    }
  },
  wnt = class {
    constructor(i, t, e, s, r) {
      ;(this.extension = i),
        (this.id = t),
        (this.w = e),
        (this.x = s),
        (this.y = r),
        (this.l = new J()),
        (this.m = new J())
    }
    acceptFeedback(i) {
      this.l.fire(i)
    }
    acceptAction(i) {
      this.m.fire(i)
    }
    async invokeCompletionProvider(i, t) {
      return this.o
        ? ((await this.o.provider.provideCompletionItems(i, t)) ?? [])
        : []
    }
    async provideFollowups(i, t, e) {
      if (!this.b) return []
      const s = await this.b.provideFollowups(i, t, e)
      return s
        ? s
            .filter((r) => !(r && "commandId" in r))
            .filter((r) => !(r && "message" in r))
        : []
    }
    async provideWelcomeMessage(i) {
      if (!this.q?.provideWelcomeMessage) return
      const t = await this.q.provideWelcomeMessage(i),
        e = t?.icon
      if (!(!t || !gi.isThemeIcon(e)))
        return { ...t, icon: e, message: Dt.from(t.message) }
    }
    async provideTitle(i, t) {
      if (this.s) return (await this.s.provideChatTitle(i, t)) ?? void 0
    }
    async provideSampleQuestions(i, t) {
      if (!this.q || !this.q.provideSampleQuestions) return []
      const e = await this.q.provideSampleQuestions(i, t)
      return e || []
    }
    get apiAgent() {
      let i = !1,
        t = !1
      const e = () => {
          i ||
            t ||
            ((t = !0),
            queueMicrotask(() => {
              this.w.$updateAgent(this.x, {
                icon: this.c
                  ? this.c instanceof S
                    ? this.c
                    : "light" in this.c
                      ? this.c.light
                      : void 0
                  : void 0,
                iconDark: this.c && "dark" in this.c ? this.c.dark : void 0,
                themeIcon: this.c instanceof Ji ? this.c : void 0,
                hasFollowups: this.b !== void 0,
                isSecondary: this.k,
                helpTextPrefix:
                  !this.d || typeof this.d == "string"
                    ? this.d
                    : Dt.from(this.d),
                helpTextVariablesPrefix:
                  !this.g || typeof this.g == "string"
                    ? this.g
                    : Dt.from(this.g),
                helpTextPostfix:
                  !this.j || typeof this.j == "string"
                    ? this.j
                    : Dt.from(this.j),
                supportIssueReporting: this.n,
                requester: this.t,
                supportsSlowVariables: this.u,
              }),
                (t = !1)
            }))
        },
        s = this
      return {
        get id() {
          return s.id
        },
        get iconPath() {
          return s.c
        },
        set iconPath(r) {
          ;(s.c = r), e()
        },
        get requestHandler() {
          return s.y
        },
        set requestHandler(r) {
          $G(typeof r == "function", "Invalid request handler"), (s.y = r)
        },
        get followupProvider() {
          return s.b
        },
        set followupProvider(r) {
          ;(s.b = r), e()
        },
        get helpTextPrefix() {
          return _(s.extension, "defaultChatParticipant"), s.d
        },
        set helpTextPrefix(r) {
          _(s.extension, "defaultChatParticipant"), (s.d = r), e()
        },
        get helpTextVariablesPrefix() {
          return _(s.extension, "defaultChatParticipant"), s.g
        },
        set helpTextVariablesPrefix(r) {
          _(s.extension, "defaultChatParticipant"), (s.g = r), e()
        },
        get helpTextPostfix() {
          return _(s.extension, "defaultChatParticipant"), s.j
        },
        set helpTextPostfix(r) {
          _(s.extension, "defaultChatParticipant"), (s.j = r), e()
        },
        get isSecondary() {
          return _(s.extension, "defaultChatParticipant"), s.k
        },
        set isSecondary(r) {
          _(s.extension, "defaultChatParticipant"), (s.k = r), e()
        },
        get supportIssueReporting() {
          return _(s.extension, "chatParticipantPrivate"), s.n
        },
        set supportIssueReporting(r) {
          _(s.extension, "chatParticipantPrivate"), (s.n = r), e()
        },
        get onDidReceiveFeedback() {
          return s.l.event
        },
        set participantVariableProvider(r) {
          if ((_(s.extension, "chatParticipantAdditions"), (s.o = r), r)) {
            if (!r.triggerCharacters.length)
              throw new Error("triggerCharacters are required")
            s.w.$registerAgentCompletionsProvider(
              s.x,
              s.id,
              r.triggerCharacters,
            )
          } else s.w.$unregisterAgentCompletionsProvider(s.x, s.id)
        },
        get participantVariableProvider() {
          return _(s.extension, "chatParticipantAdditions"), s.o
        },
        set welcomeMessageProvider(r) {
          _(s.extension, "defaultChatParticipant"), (s.q = r), e()
        },
        get welcomeMessageProvider() {
          return _(s.extension, "defaultChatParticipant"), s.q
        },
        set titleProvider(r) {
          _(s.extension, "defaultChatParticipant"), (s.s = r), e()
        },
        get titleProvider() {
          return _(s.extension, "defaultChatParticipant"), s.s
        },
        onDidPerformAction: hi(this.extension, "chatParticipantAdditions")
          ? this.m.event
          : void 0,
        set requester(r) {
          ;(s.t = r), e()
        },
        get requester() {
          return s.t
        },
        set supportsSlowReferences(r) {
          _(s.extension, "chatParticipantPrivate"), (s.u = r), e()
        },
        get supportsSlowReferences() {
          return _(s.extension, "chatParticipantPrivate"), s.u
        },
        dispose() {
          ;(i = !0), (s.b = void 0), s.l.dispose(), s.w.$unregisterAgent(s.x)
        },
      }
    }
    invoke(i, t, e, s) {
      return this.y(i, t, e, s)
    }
  },
  r9t = class Tut {
    static {
      this.a = 0
    }
    constructor(t) {
      ;(this.b = new Map()), (this.c = t.getProxy(K.MainThreadChatVariables))
    }
    async $resolveVariable(t, e, s, r) {
      const a = this.b.get(t)
      if (a)
        try {
          if (a.resolver.resolve2) {
            _(a.extension, "chatParticipantAdditions")
            const o = new n9t(e, this.c),
              c = await a.resolver.resolve2(
                a.data.name,
                { prompt: s },
                o.apiObject,
                r,
              )
            if (c && c[0]) return c[0].value
          } else {
            const o = await a.resolver.resolve(a.data.name, { prompt: s }, r)
            if (o && o[0]) return o[0].value
          }
        } catch (o) {
          l7(o)
        }
    }
    registerVariableResolver(t, e, s, r, a, o, c, l, u) {
      const d = Tut.a++,
        m = u ? gi.fromId(u) : void 0
      return (
        this.b.set(d, {
          extension: t,
          data: {
            id: e,
            name: s,
            description: r,
            modelDescription: a,
            icon: m,
          },
          resolver: c,
        }),
        this.c.$registerVariable(d, {
          id: e,
          name: s,
          description: r,
          modelDescription: a,
          isSlow: o,
          fullName: l,
          icon: m,
        }),
        et(() => {
          this.b.delete(d), this.c.$unregisterVariable(d)
        })
      )
    }
  },
  n9t = class {
    constructor(i, t) {
      ;(this.c = i), (this.d = t), (this.a = !1)
    }
    close() {
      this.a = !0
    }
    get apiObject() {
      if (!this.b) {
        let t = function (r) {
          if (e.a) {
            const a = new Error("Response stream has been closed")
            throw (Error.captureStackTrace(a, r), a)
          }
        }
        var i = t
        const e = this,
          s = (r) => {
            this.d.$handleProgressChunk(this.c, r)
          }
        this.b = {
          progress(r) {
            t(this.progress)
            const a = new nd(r),
              o = Co.from(a)
            return s(o), this
          },
          reference(r) {
            t(this.reference)
            const a = new vn(r),
              o = bn.from(a)
            return s(o), this
          },
          push(r) {
            return (
              t(this.push),
              r instanceof vn
                ? s(bn.from(r))
                : r instanceof nd && s(Co.from(r)),
              this
            )
          },
        }
      }
      return this.b
    }
  },
  a9t = class {
    constructor(i) {
      const t = i.getProxy(K.MainThreadClipboard)
      this.value = Object.freeze({
        readText() {
          return t.$readText()
        },
        writeText(e) {
          return t.$writeText(e)
        },
      })
    }
  },
  ynt = "vscode-cdn.net",
  o9t = `vscode-resource.${ynt}`,
  PW = `'self' https://*.${ynt}`
function Tm(i, t) {
  return i.scheme === G.http || i.scheme === G.https
    ? i
    : (t &&
        t.authority &&
        t.isRemote &&
        i.scheme === G.file &&
        (i = S.from({
          scheme: G.vscodeRemote,
          authority: t.authority,
          path: i.path,
        })),
      S.from({
        scheme: G.https,
        authority: `${i.scheme}+${c9t(i.authority)}.${o9t}`,
        path: i.path,
        fragment: i.fragment,
        query: i.query,
      }))
}
function c9t(i) {
  return i.replace(/./g, (t) => {
    const e = t.charCodeAt(0)
    return (e >= 97 && e <= 122) || (e >= 65 && e <= 90) || (e >= 48 && e <= 57)
      ? t
      : "-" + e.toString(16).padStart(4, "0")
  })
}
var l9t = class {
  constructor(i, t, e) {
    ;(this.d = i),
      (this.e = t),
      (this.f = e),
      (this.a = 0),
      (this.b = new gt()),
      (this.c = new Map()),
      this.b.add(
        t.onDidChangeVisibleTextEditors(() => {
          const s = t.getVisibleTextEditors()
          for (const r of this.c.values())
            s.indexOf(r.editor) < 0 && r.inset.dispose()
        }),
      )
  }
  dispose() {
    this.c.forEach((i) => i.inset.dispose()), this.b.dispose()
  }
  createWebviewEditorInset(i, t, e, s, r) {
    let a
    for (const f of this.e.getVisibleTextEditors(!0))
      if (f.value === i) {
        a = f
        break
      }
    if (!a) throw new Error("not a visible editor")
    const o = this,
      c = this.a++,
      l = new J(),
      u = new J(),
      d = new (class {
        constructor() {
          ;(this.a = ""), (this.b = Object.create(null))
        }
        asWebviewUri(f) {
          return Tm(f, o.f)
        }
        get cspSource() {
          return PW
        }
        set options(f) {
          ;(this.b = f), o.d.$setOptions(c, f)
        }
        get options() {
          return this.b
        }
        set html(f) {
          ;(this.a = f), o.d.$setHtml(c, f)
        }
        get html() {
          return this.a
        }
        get onDidReceiveMessage() {
          return l.event
        }
        postMessage(f) {
          return o.d.$postMessage(c, f)
        }
      })(),
      m = new (class {
        constructor() {
          ;(this.editor = i),
            (this.line = t),
            (this.height = e),
            (this.webview = d),
            (this.onDidDispose = u.event)
        }
        dispose() {
          o.c.has(c) &&
            (o.c.delete(c),
            o.d.$disposeEditorInset(c),
            u.fire(),
            u.dispose(),
            l.dispose())
        }
      })()
    return (
      this.d.$createEditorInset(
        c,
        a.id,
        a.value.document.uri,
        t + 1,
        e,
        s || {},
        r.identifier,
        r.extensionLocation,
      ),
      this.c.set(c, { editor: i, inset: m, onDidReceiveMessage: l }),
      m
    )
  }
  $onDidDispose(i) {
    const t = this.c.get(i)
    t && t.inset.dispose()
  }
  $onDidReceiveMessage(i, t) {
    this.c.get(i)?.onDidReceiveMessage.fire(t)
  }
}
function u9t(i, t, e) {
  const s = i.getProxy(K.MainThreadComments)
  class r {
    static {
      this.a = 0
    }
    constructor() {
      ;(this.b = new Map()),
        (this.c = new hn()),
        t.registerArgumentProcessor({
          processArgument: (v) => {
            if (v && v.$mid === 6) {
              const b = this.b.get(v.handle)
              return b ? b.value : v
            } else if (v && v.$mid === 7) {
              const b = v,
                k = this.b.get(b.commentControlHandle)
              if (!k) return b
              const E = k.getCommentThread(b.commentThreadHandle)
              return E ? E.value : b
            } else if (v && (v.$mid === 9 || v.$mid === 8)) {
              const b = this.b.get(v.thread.commentControlHandle)
              if (!b) return v
              const k = b.getCommentThread(v.thread.commentThreadHandle)
              return k
                ? v.$mid === 8
                  ? k.value
                  : { thread: k.value, text: v.text }
                : v
            } else if (v && v.$mid === 10) {
              const b = this.b.get(v.thread.commentControlHandle)
              if (!b) return v
              const k = b.getCommentThread(v.thread.commentThreadHandle)
              if (!k) return v
              const E = v.commentUniqueId,
                P = k.getCommentByUniqueId(E)
              return P || v
            } else if (v && v.$mid === 11) {
              const b = this.b.get(v.thread.commentControlHandle)
              if (!b) return v
              const k = b.getCommentThread(v.thread.commentThreadHandle)
              if (!k) return v
              const E = v.text,
                P = v.commentUniqueId,
                C = k.getCommentByUniqueId(P)
              return C
                ? (typeof C.body == "string"
                    ? (C.body = E)
                    : (C.body = new ls(E)),
                  C)
                : v
            }
            return v
          },
        })
    }
    createCommentController(v, b, k) {
      const E = r.a++,
        P = new o(v, E, b, k)
      this.b.set(P.handle, P)
      const C = this.c.get(v.identifier) || []
      return C.push(P), this.c.set(v.identifier, C), P.value
    }
    async $createCommentThreadTemplate(v, b, k, E) {
      const P = this.b.get(v)
      P && P.$createCommentThreadTemplate(b, k, E)
    }
    async $setActiveComment(v, b) {
      const k = this.b.get(v)
      k && k.$setActiveComment(b ?? void 0)
    }
    async $updateCommentThreadTemplate(v, b, k) {
      const E = this.b.get(v)
      E && E.$updateCommentThreadTemplate(b, k)
    }
    $deleteCommentThread(v, b) {
      this.b.get(v)?.$deleteCommentThread(b)
    }
    async $updateCommentThread(v, b, k) {
      this.b.get(v)?.$updateCommentThread(b, k)
    }
    async $provideCommentingRanges(v, b, k) {
      const E = this.b.get(v)
      if (!E || !E.commentingRangeProvider) return Promise.resolve(void 0)
      const P = await e.ensureDocumentData(S.revive(b))
      return Ci(async () => {
        const C = await E.commentingRangeProvider.provideCommentingRanges(
          P.document,
          k,
        )
        let R
        return (
          Array.isArray(C)
            ? (R = { ranges: C, fileComments: !1 })
            : C
              ? (R = {
                  ranges: C.ranges || [],
                  fileComments: C.enableFileComments || !1,
                })
              : (R = C ?? void 0),
          R
        )
      }).then((C) => {
        let R
        return (
          C &&
            (R = {
              ranges: C.ranges.map((D) => U.from(D)),
              fileComments: C.fileComments,
            }),
          R
        )
      })
    }
    $toggleReaction(v, b, k, E, P) {
      const C = this.b.get(v)
      return !C || !C.reactionHandler
        ? Promise.resolve(void 0)
        : Ci(() => {
            const R = C.getCommentThread(b)
            if (R) {
              const D = R.getCommentByUniqueId(E.uniqueIdInThread)
              if (C !== void 0 && D && C.reactionHandler)
                return C.reactionHandler(D, u(P))
            }
            return Promise.resolve(void 0)
          })
    }
  }
  class a {
    static {
      this.a = 0
    }
    set threadId(v) {
      this.n = v
    }
    get threadId() {
      return this.n
    }
    get id() {
      return this.n
    }
    get resource() {
      return this.o
    }
    get uri() {
      return this.o
    }
    set range(v) {
      ;((v === void 0) != (this.p === void 0) ||
        !v ||
        !this.p ||
        !v.isEqual(this.p)) &&
        ((this.p = v), (this.b.range = v), this.c.fire())
    }
    get range() {
      return this.p
    }
    set canReply(v) {
      this.d !== v && ((this.d = v), (this.b.canReply = v), this.c.fire())
    }
    get canReply() {
      return this.d
    }
    get label() {
      return this.e
    }
    set label(v) {
      ;(this.e = v), (this.b.label = v), this.c.fire()
    }
    get contextValue() {
      return this.f
    }
    set contextValue(v) {
      ;(this.f = v), (this.b.contextValue = v), this.c.fire()
    }
    get comments() {
      return this.q
    }
    set comments(v) {
      ;(this.q = v), (this.b.comments = v), this.c.fire()
    }
    get collapsibleState() {
      return this.g
    }
    set collapsibleState(v) {
      this.g !== v &&
        ((this.g = v), (this.b.collapsibleState = v), this.c.fire())
    }
    get state() {
      return this.h
    }
    set state(v) {
      ;(this.h = v),
        typeof v == "object"
          ? (_(this.extensionDescription, "commentThreadApplicability"),
            (this.b.state = v.resolved),
            (this.b.applicability = v.applicability))
          : (this.b.state = v),
        this.c.fire()
    }
    get isDisposed() {
      return this.j
    }
    constructor(v, b, k, E, P, C, R, D, V) {
      ;(this.m = b),
        (this.n = k),
        (this.o = E),
        (this.p = P),
        (this.q = C),
        (this.extensionDescription = R),
        (this.r = D),
        (this.handle = a.a++),
        (this.commentHandle = 0),
        (this.b = Object.create(null)),
        (this.c = new J()),
        (this.onDidUpdateCommentThread = this.c.event),
        (this.d = !0),
        (this.k = new Map()),
        (this.l = new zr()),
        (this.l.value = new gt()),
        this.n === void 0 && (this.n = `${v}.${this.handle}`),
        s.$createCommentThread(
          b,
          this.handle,
          this.n,
          this.o,
          U.from(this.p),
          this.q.map((Z) => c(this, Z, this.k, this.extensionDescription)),
          R.identifier,
          this.r,
          V,
        ),
        (this.i = []),
        (this.j = !1),
        this.i.push(
          this.onDidUpdateCommentThread(() => {
            this.eventuallyUpdateCommentThread()
          }),
        ),
        this.i.push({
          dispose: () => {
            s.$deleteCommentThread(b, this.handle)
          },
        })
      const tt = this
      this.value = {
        get uri() {
          return tt.uri
        },
        get range() {
          return tt.range
        },
        set range(Z) {
          tt.range = Z
        },
        get comments() {
          return tt.comments
        },
        set comments(Z) {
          tt.comments = Z
        },
        get collapsibleState() {
          return tt.collapsibleState
        },
        set collapsibleState(Z) {
          tt.collapsibleState = Z
        },
        get canReply() {
          return tt.canReply
        },
        set canReply(Z) {
          tt.canReply = Z
        },
        get contextValue() {
          return tt.contextValue
        },
        set contextValue(Z) {
          tt.contextValue = Z
        },
        get label() {
          return tt.label
        },
        set label(Z) {
          tt.label = Z
        },
        get state() {
          return tt.state
        },
        set state(Z) {
          tt.state = Z
        },
        reveal: (Z, M) => tt.reveal(Z, M),
        hide: () => tt.hide(),
        dispose: () => {
          tt.dispose()
        },
      }
    }
    s() {
      this.r && ((this.r = !1), (this.b.isTemplate = !1))
    }
    eventuallyUpdateCommentThread() {
      if (this.j) return
      this.s(), this.l.value || (this.l.value = new gt())
      const v = (k) => Object.prototype.hasOwnProperty.call(this.b, k),
        b = {}
      v("range") && (b.range = U.from(this.p)),
        v("label") && (b.label = this.label),
        v("contextValue") && (b.contextValue = this.contextValue ?? null),
        v("comments") &&
          (b.comments = this.q.map((k) =>
            c(this, k, this.k, this.extensionDescription),
          )),
        v("collapsibleState") && (b.collapseState = d(this.g)),
        v("canReply") && (b.canReply = this.canReply),
        v("state") && (b.state = m(this.h)),
        v("applicability") && (b.applicability = f(this.h)),
        v("isTemplate") && (b.isTemplate = this.r),
        (this.b = {}),
        s.$updateCommentThread(this.m, this.handle, this.n, this.o, b)
    }
    getCommentByUniqueId(v) {
      for (const b of this.k) {
        const k = b[0],
          E = b[1]
        if (v === E) return k
      }
    }
    async reveal(v, b) {
      _(this.extensionDescription, "commentReveal")
      let k
      v && v.body !== void 0 ? (k = v) : (b = b ?? v)
      let E = k ? this.k.get(k) : void 0
      E ??= this.k.get(this.q[0])
      let P = !0,
        C = !1
      return (
        b?.focus === Qh.Reply
          ? ((C = !0), (P = !1))
          : b?.focus === Qh.Comment && (P = !1),
        s.$revealCommentThread(this.m, this.handle, E, {
          preserveFocus: P,
          focusReply: C,
        })
      )
    }
    async hide() {
      return s.$hideCommentThread(this.m, this.handle)
    }
    dispose() {
      ;(this.j = !0), this.l.dispose(), this.i.forEach((v) => v.dispose())
    }
  }
  __decorate([z_(100)], a.prototype, "eventuallyUpdateCommentThread", null)
  class o {
    get id() {
      return this.j
    }
    get label() {
      return this.k
    }
    get handle() {
      return this.i
    }
    get commentingRangeProvider() {
      return this.b
    }
    set commentingRangeProvider(v) {
      ;(this.b = v),
        v?.resourceHints && _(this.h, "commentingRangeHint"),
        s.$updateCommentingRanges(this.handle, v?.resourceHints)
    }
    get reactionHandler() {
      return this.c
    }
    set reactionHandler(v) {
      ;(this.c = v),
        s.$updateCommentControllerFeatures(this.handle, {
          reactionHandler: !!v,
        })
    }
    get options() {
      return this.d
    }
    set options(v) {
      ;(this.d = v),
        s.$updateCommentControllerFeatures(this.handle, { options: this.d })
    }
    get activeComment() {
      return _(this.h, "activeComment"), this.e
    }
    get activeCommentThread() {
      return _(this.h, "activeComment"), this.f?.value
    }
    constructor(v, b, k, E) {
      ;(this.h = v),
        (this.i = b),
        (this.j = k),
        (this.k = E),
        (this.a = new Map()),
        s.$registerCommentController(this.handle, k, E, this.h.identifier.value)
      const P = this
      ;(this.value = Object.freeze({
        id: P.id,
        label: P.label,
        get options() {
          return P.options
        },
        set options(C) {
          P.options = C
        },
        get commentingRangeProvider() {
          return P.commentingRangeProvider
        },
        set commentingRangeProvider(C) {
          P.commentingRangeProvider = C
        },
        get reactionHandler() {
          return P.reactionHandler
        },
        set reactionHandler(C) {
          P.reactionHandler = C
        },
        get activeCommentThread() {
          return P.activeCommentThread
        },
        createCommentThread(C, R, D) {
          return P.createCommentThread(C, R, D).value
        },
        dispose: () => {
          P.dispose()
        },
      })),
        (this.g = []),
        this.g.push({
          dispose: () => {
            s.$unregisterCommentController(this.handle)
          },
        })
    }
    createCommentThread(v, b, k) {
      b === void 0 && _(this.h, "fileComments")
      const E = new a(this.id, this.handle, void 0, v, b, k, this.h, !1)
      return this.a.set(E.handle, E), E
    }
    $setActiveComment(v) {
      if (!v) {
        ;(this.e = void 0), (this.f = void 0)
        return
      }
      const b = this.a.get(v.commentThreadHandle)
      b &&
        ((this.e = v.uniqueIdInThread
          ? b.getCommentByUniqueId(v.uniqueIdInThread)
          : void 0),
        (this.f = b))
    }
    $createCommentThreadTemplate(v, b, k) {
      const E = new a(
        this.id,
        this.handle,
        void 0,
        S.revive(v),
        U.to(b),
        [],
        this.h,
        !0,
        k,
      )
      return (E.collapsibleState = Lc.Expanded), this.a.set(E.handle, E), E
    }
    $updateCommentThreadTemplate(v, b) {
      const k = this.a.get(v)
      k && (k.range = U.to(b))
    }
    $updateCommentThread(v, b) {
      const k = this.a.get(v)
      if (!k) return
      ;((P) => Object.prototype.hasOwnProperty.call(b, P))("collapseState") &&
        (k.collapsibleState = d(b.collapseState))
    }
    $deleteCommentThread(v) {
      this.a.get(v)?.dispose(), this.a.delete(v)
    }
    getCommentThread(v) {
      return this.a.get(v)
    }
    dispose() {
      this.a.forEach((v) => {
        v.dispose()
      }),
        this.g.forEach((v) => v.dispose())
    }
  }
  function c(p, v, b, k) {
    let E = b.get(v)
    return (
      E || ((E = ++p.commentHandle), b.set(v, E)),
      v.state !== void 0 && _(k, "commentsDraftState"),
      v.reactions?.some((P) => P.reactors !== void 0) && _(k, "commentReactor"),
      {
        mode: v.mode,
        contextValue: v.contextValue,
        uniqueIdInThread: E,
        body: typeof v.body == "string" ? v.body : Dt.from(v.body),
        userName: v.author.name,
        userIconPath: v.author.iconPath,
        label: v.label,
        commentReactions: v.reactions ? v.reactions.map((P) => l(P)) : void 0,
        state: v.state,
        timestamp: v.timestamp?.toJSON(),
      }
    )
  }
  function l(p) {
    return {
      label: p.label,
      iconPath: p.iconPath ? jO(p.iconPath) : void 0,
      count: p.count,
      hasReacted: p.authorHasReacted,
      reactors:
        p.reactors && p.reactors.length > 0 && typeof p.reactors[0] != "string"
          ? p.reactors.map((v) => v.name)
          : p.reactors,
    }
  }
  function u(p) {
    return {
      label: p.label || "",
      count: p.count || 0,
      iconPath: p.iconPath ? S.revive(p.iconPath) : "",
      authorHasReacted: p.hasReacted || !1,
      reactors: p.reactors?.map((v) => ({ name: v })),
    }
  }
  function d(p) {
    if (p !== void 0)
      switch (p) {
        case Gh.Expanded:
          return Lc.Expanded
        case Gh.Collapsed:
          return Lc.Collapsed
      }
    return Lc.Collapsed
  }
  function m(p) {
    let v
    if ((typeof p == "object" ? (v = p.resolved) : (v = p), v !== void 0))
      switch (v) {
        case zh.Unresolved:
          return fh.Unresolved
        case zh.Resolved:
          return fh.Resolved
      }
    return fh.Unresolved
  }
  function f(p) {
    let v
    if ((typeof p == "object" && (v = p.applicability), v !== void 0))
      switch (v) {
        case Yh.Current:
          return ph.Current
        case Yh.Outdated:
          return ph.Outdated
      }
    return ph.Current
  }
  return new r()
}
var h9t = class uy extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShadowHealthCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new uy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uy, t, e)
    }
  },
  d9t = class hy extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShadowHealthCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new hy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hy, t, e)
    }
  },
  m9t = class dy extends h {
    constructor(t) {
      super(),
        (this.files = []),
        (this.includeQuickFixes = !1),
        (this.doNotUseInProdNewFilesShouldBeTemporarilyCreatedForIncreasedAccuracy =
          !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: f9t, repeated: !0 },
        { no: 2, name: "include_quick_fixes", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "do_not_use_in_prod_new_files_should_be_temporarily_created_for_increased_accuracy",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new dy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dy, t, e)
    }
  },
  f9t = class my extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.initialContent = ""),
        (this.finalContent = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeRequest.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "initial_content", kind: "scalar", T: 9 },
        { no: 3, name: "final_content", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "get_all_lints_not_just_delta_lints_for_ranges_in_final_model",
          kind: "message",
          T: p9t,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new my().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new my().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new my().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(my, t, e)
    }
  },
  p9t = class fy extends h {
    constructor(t) {
      super(), (this.ranges = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.GetLintsForChangeRequest.File.RangeCollection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranges", kind: "message", T: g9t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fy, t, e)
    }
  },
  g9t = class py extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeRequest.File.IRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new py().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new py().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new py().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(py, t, e)
    }
  },
  qB = class gy extends h {
    constructor(t) {
      super(), (this.lints = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lints", kind: "message", T: v9t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gy, t, e)
    }
  },
  v9t = class vy extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        (this.quickFixes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeResponse.Lint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 5, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 6,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 7, name: "end_column_one_indexed", kind: "scalar", T: 5 },
        { no: 9, name: "quick_fixes", kind: "message", T: w9t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new vy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vy, t, e)
    }
  },
  w9t = class wy extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.kind = ""),
        (this.isPreferred = !1),
        (this.edits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeResponse.Lint.QuickFix"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8 },
        { no: 4, name: "edits", kind: "message", T: y9t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wy, t, e)
    }
  },
  y9t = class yy extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeResponse.Lint.QuickFix.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 4, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 6, name: "end_column_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new yy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yy, t, e)
    }
  },
  km = {
    typeName: "aiserver.v1.ShadowWorkspaceService",
    methods: {
      getLintsForChange: {
        name: "GetLintsForChange",
        I: m9t,
        O: qB,
        kind: I.Unary,
      },
      shadowHealthCheck: {
        name: "ShadowHealthCheck",
        I: h9t,
        O: d9t,
        kind: I.Unary,
      },
    },
  },
  b9t = class by extends h {
    constructor(t) {
      super(),
        (this.files = []),
        (this.targetDir = ""),
        (this.repo = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateExperimentalIndexRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "target_dir", kind: "scalar", T: 9 },
        { no: 3, name: "repo", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new by().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new by().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new by().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(by, t, e)
    }
  },
  T9t = class Ty extends h {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateExperimentalIndexResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ty().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ty().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ty().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ty, t, e)
    }
  },
  k9t = class ky extends h {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListExperimentalIndexFilesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ky().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ky().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ky().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ky, t, e)
    }
  },
  S9t = class Sy extends h {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.files = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListExperimentalIndexFilesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "files", kind: "message", T: knt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Sy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sy, t, e)
    }
  },
  bnt = class Ey extends h {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ey().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ey().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ey().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ey, t, e)
    }
  },
  E9t = class Iy extends h {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.item = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "ready", kind: "message", T: I9t, oneof: "item" },
        { no: 3, name: "register", kind: "message", T: P9t, oneof: "item" },
        { no: 4, name: "choose", kind: "message", T: $9t, oneof: "item" },
        { no: 5, name: "summarize", kind: "message", T: x9t, oneof: "item" },
        { no: 6, name: "error", kind: "message", T: N9t, oneof: "item" },
      ])
    }
    static fromBinary(t, e) {
      return new Iy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Iy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Iy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Iy, t, e)
    }
  },
  I9t = class Py extends h {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse.ReadyItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "request", kind: "message", T: bnt },
      ])
    }
    static fromBinary(t, e) {
      return new Py().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Py().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Py().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Py, t, e)
    }
  },
  P9t = class $y extends h {
    constructor(t) {
      super(), (this.reqUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse.RegisterItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "response", kind: "message", T: C9t },
        { no: 2, name: "request", kind: "message", T: $W },
        { no: 3, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $y().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $y().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $y().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($y, t, e)
    }
  },
  $9t = class xy extends h {
    constructor(t) {
      super(), (this.reqUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse.ChooseItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "response", kind: "message", T: _9t },
        { no: 2, name: "request", kind: "message", T: xW },
        { no: 3, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xy, t, e)
    }
  },
  x9t = class Ny extends h {
    constructor(t) {
      super(), (this.reqUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ListenExperimentalIndexResponse.SummarizeItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "response", kind: "message", T: U9t },
        { no: 2, name: "request", kind: "message", T: NW },
        { no: 3, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ny().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ny().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ny().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ny, t, e)
    }
  },
  N9t = class Cy extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.statusCode = 0),
        (this.request = { case: void 0 }),
        (this.reqUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse.ErrorItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "status_code", kind: "scalar", T: 5 },
        { no: 3, name: "register", kind: "message", T: $W, oneof: "request" },
        { no: 4, name: "choose", kind: "message", T: xW, oneof: "request" },
        { no: 5, name: "summarize", kind: "message", T: NW, oneof: "request" },
        { no: 6, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Cy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cy, t, e)
    }
  },
  $W = class Jy extends h {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.workspaceRelativePath = ""),
        (this.content = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RegisterFileToIndexRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 3, name: "root_context_node", kind: "message", T: j9t },
        { no: 4, name: "content", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Jy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jy, t, e)
    }
  },
  C9t = class Ly extends h {
    constructor(t) {
      super(),
        (this.fileId = ""),
        (this.rootContextNodeId = ""),
        (this.dependencyResolutionAttempts = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RegisterFileToIndexResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_id", kind: "scalar", T: 9 },
        { no: 2, name: "root_context_node_id", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "dependency_resolution_attempts",
          kind: "message",
          T: Ent,
          repeated: !0,
        },
        { no: 4, name: "file_data", kind: "message", T: knt },
      ])
    }
    static fromBinary(t, e) {
      return new Ly().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ly().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ly().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ly, t, e)
    }
  },
  J9t = class Ry extends h {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.fileId = ""),
        (this.dependencyResolutionResults = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetupIndexDependenciesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 3, name: "file_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "dependency_resolution_results",
          kind: "message",
          T: V9t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Ry().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ry().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ry().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ry, t, e)
    }
  },
  L9t = class Dy extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetupIndexDependenciesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Dy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dy, t, e)
    }
  },
  R9t = class Fy extends h {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComputeIndexTopoSortRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Fy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fy, t, e)
    }
  },
  D9t = class Ay extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComputeIndexTopoSortResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Ay().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ay().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ay().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ay, t, e)
    }
  },
  xW = class _y extends h {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.request = { case: void 0 }),
        (this.recompute = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "file", kind: "message", T: F9t, oneof: "request" },
        { no: 3, name: "node", kind: "message", T: A9t, oneof: "request" },
        { no: 4, name: "recompute", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new _y().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _y().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _y().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_y, t, e)
    }
  },
  F9t = class Oy extends h {
    constructor(t) {
      super(), (this.fileId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesRequest.FileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Oy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Oy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Oy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Oy, t, e)
    }
  },
  A9t = class By extends h {
    constructor(t) {
      super(), (this.nodeId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesRequest.NodeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new By().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new By().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new By().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(By, t, e)
    }
  },
  _9t = class qy extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: O9t, oneof: "response" },
        { no: 2, name: "node", kind: "message", T: Tnt, oneof: "response" },
      ])
    }
    static fromBinary(t, e) {
      return new qy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qy, t, e)
    }
  },
  Tnt = class Uy extends h {
    constructor(t) {
      super(),
        (this.nodeId = ""),
        (this.actions = []),
        (this.skipped = !1),
        (this.dependencies = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesResponse.NodeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node_id", kind: "scalar", T: 9 },
        { no: 2, name: "actions", kind: "message", T: UB, repeated: !0 },
        { no: 3, name: "skipped", kind: "scalar", T: 8 },
        { no: 4, name: "dependencies", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Uy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Uy, t, e)
    }
  },
  O9t = class My extends h {
    constructor(t) {
      super(),
        (this.fileId = ""),
        (this.nodeResponses = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesResponse.FileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "node_responses",
          kind: "message",
          T: Tnt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new My().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new My().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new My().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(My, t, e)
    }
  },
  B9t = class Hy extends h {
    constructor(t) {
      super(),
        (this.nodeId = ""),
        (this.references = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RegisterCodeReferencesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node_id", kind: "scalar", T: 9 },
        { no: 2, name: "references", kind: "message", T: Y9t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Hy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hy, t, e)
    }
  },
  q9t = class Wy extends h {
    constructor(t) {
      super(), (this.dependencies = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RegisterCodeReferencesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "dependencies", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Wy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wy, t, e)
    }
  },
  NW = class jy extends h {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.nodeId = ""),
        (this.recompute = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeWithReferencesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "node_id", kind: "scalar", T: 9 },
        { no: 3, name: "recompute", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new jy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jy, t, e)
    }
  },
  U9t = class Vy extends h {
    constructor(t) {
      super(),
        (this.response = { case: void 0 }),
        (this.nodeId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeWithReferencesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "message", T: M9t, oneof: "response" },
        {
          no: 2,
          name: "dependency",
          kind: "message",
          T: H9t,
          oneof: "response",
        },
        { no: 3, name: "node_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Vy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vy, t, e)
    }
  },
  M9t = class Gy extends h {
    constructor(t) {
      super(), (this.summary = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeWithReferencesResponse.Success"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "summary", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Gy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gy, t, e)
    }
  },
  H9t = class zy extends h {
    constructor(t) {
      super(), (this.nodes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeWithReferencesResponse.Dependency"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "nodes", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zy, t, e)
    }
  },
  CW = class Yy extends h {
    constructor(t) {
      super(), (this.reqUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RequestReceivedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Yy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yy, t, e)
    }
  },
  W9t = class Qy extends h {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.id = ""),
        (this.summary = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReflectionData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "summary", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Qy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qy, t, e)
    }
  },
  knt = class Xy extends h {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.workspaceRelativePath = ""),
        (this.stage = ""),
        (this.order = 0),
        (this.nodes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IndexFileData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 3, name: "stage", kind: "scalar", T: 9 },
        { no: 4, name: "order", kind: "scalar", T: 5 },
        { no: 5, name: "nodes", kind: "message", T: Snt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Xy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xy, t, e)
    }
  },
  Snt = class Ky extends h {
    constructor(t) {
      super(),
        (this.nodeId = ""),
        (this.stage = ""),
        (this.content = ""),
        (this.summary = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IndexFileData.NodeData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node_id", kind: "scalar", T: 9 },
        { no: 2, name: "stage", kind: "scalar", T: 9 },
        { no: 3, name: "content", kind: "scalar", T: 9 },
        { no: 4, name: "summary", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ky().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ky().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ky().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ky, t, e)
    }
  },
  j9t = class wu extends h {
    constructor(t) {
      super(),
        (this.workspaceRelativePath = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.children = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SerializedContextNode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "children", kind: "message", T: wu, repeated: !0 },
        { no: 5, name: "node_snippets", kind: "message", T: JW },
      ])
    }
    static fromBinary(t, e) {
      return new wu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wu, t, e)
    }
  },
  Ent = class Zy extends h {
    constructor(t) {
      super(),
        (this.workspaceRelativePath = ""),
        (this.nodeId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.URIResolutionAttempt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "node_id", kind: "scalar", T: 9 },
        { no: 3, name: "symbol", kind: "message", T: UB },
      ])
    }
    static fromBinary(t, e) {
      return new Zy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zy, t, e)
    }
  },
  V9t = class t0 extends h {
    constructor(t) {
      super(), (this.resolvedPaths = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.URIResolutionResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: Ent },
        { no: 2, name: "resolved_paths", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new t0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t0, t, e)
    }
  },
  G9t = class e0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ExtractPathsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_code_snippets", kind: "message", T: JW },
      ])
    }
    static fromBinary(t, e) {
      return new e0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e0, t, e)
    }
  },
  z9t = class i0 extends h {
    constructor(t) {
      super(), (this.paths = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ExtractPathsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "paths", kind: "message", T: UB, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new i0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i0, t, e)
    }
  },
  Y9t = class s0 extends h {
    constructor(t) {
      super(), (this.references = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SymbolActionResults"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "action", kind: "message", T: UB },
        { no: 2, name: "references", kind: "message", T: Q9t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new s0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s0, t, e)
    }
  },
  Q9t = class r0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SymbolActionResultReference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "range", kind: "message", T: Pi },
        { no: 2, name: "reference", kind: "message", T: JW },
      ])
    }
    static fromBinary(t, e) {
      return new r0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r0, t, e)
    }
  },
  JW = class n0 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.totalLines = 0),
        (this.snippets = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileCodeSnippets"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "total_lines", kind: "scalar", T: 5 },
        { no: 3, name: "snippets", kind: "message", T: X9t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new n0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n0, t, e)
    }
  },
  X9t = class a0 extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeSnippet"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new a0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a0, t, e)
    }
  },
  UB = class o0 extends h {
    constructor(t) {
      super(),
        (this.workspaceRelativePath = ""),
        (this.lineNumber = 0),
        (this.symbolStartColumn = 0),
        (this.symbolEndColumn = 0),
        (this.action = Sm.UNSPECIFIED),
        (this.symbol = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeSymbolWithAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "symbol_start_column", kind: "scalar", T: 5 },
        { no: 4, name: "symbol_end_column", kind: "scalar", T: 5 },
        { no: 5, name: "action", kind: "enum", T: n.getEnumType(Sm) },
        { no: 6, name: "symbol", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new o0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o0, t, e)
    }
  },
  Sm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GO_TO_DEFINITION = 1)] = "GO_TO_DEFINITION"),
    (i[(i.GO_TO_IMPLEMENTATION = 2)] = "GO_TO_IMPLEMENTATION"),
    (i[(i.REFERENCES = 3)] = "REFERENCES")
})(Sm || (Sm = {})),
  n.util.setEnumType(Sm, "aiserver.v1.CodeSymbolWithAction.CodeSymbolAction", [
    { no: 0, name: "CODE_SYMBOL_ACTION_UNSPECIFIED" },
    { no: 1, name: "CODE_SYMBOL_ACTION_GO_TO_DEFINITION" },
    { no: 2, name: "CODE_SYMBOL_ACTION_GO_TO_IMPLEMENTATION" },
    { no: 3, name: "CODE_SYMBOL_ACTION_REFERENCES" },
  ])
var MB
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"), (i[(i.DEFAULT = 1)] = "DEFAULT")
})(MB || (MB = {})),
  n.util.setEnumType(MB, "aiserver.v1.ChunkingStrategy", [
    { no: 0, name: "CHUNKING_STRATEGY_UNSPECIFIED" },
    { no: 1, name: "CHUNKING_STRATEGY_DEFAULT" },
  ])
var Em
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LULEA = 1)] = "LULEA"),
    (i[(i.UMEA = 2)] = "UMEA"),
    (i[(i.NONE = 3)] = "NONE"),
    (i[(i.LLAMA = 4)] = "LLAMA"),
    (i[(i.STARCODER_V1 = 5)] = "STARCODER_V1"),
    (i[(i.GPT_3_5_LOGPROBS = 6)] = "GPT_3_5_LOGPROBS"),
    (i[(i.LULEA_HAIKU = 7)] = "LULEA_HAIKU"),
    (i[(i.COHERE = 8)] = "COHERE"),
    (i[(i.VOYAGE = 9)] = "VOYAGE"),
    (i[(i.VOYAGE_EMBEDS = 10)] = "VOYAGE_EMBEDS"),
    (i[(i.IDENTITY = 11)] = "IDENTITY"),
    (i[(i.ADA_EMBEDS = 12)] = "ADA_EMBEDS")
})(Em || (Em = {})),
  n.util.setEnumType(Em, "aiserver.v1.RerankerAlgorithm", [
    { no: 0, name: "RERANKER_ALGORITHM_UNSPECIFIED" },
    { no: 1, name: "RERANKER_ALGORITHM_LULEA" },
    { no: 2, name: "RERANKER_ALGORITHM_UMEA" },
    { no: 3, name: "RERANKER_ALGORITHM_NONE" },
    { no: 4, name: "RERANKER_ALGORITHM_LLAMA" },
    { no: 5, name: "RERANKER_ALGORITHM_STARCODER_V1" },
    { no: 6, name: "RERANKER_ALGORITHM_GPT_3_5_LOGPROBS" },
    { no: 7, name: "RERANKER_ALGORITHM_LULEA_HAIKU" },
    { no: 8, name: "RERANKER_ALGORITHM_COHERE" },
    { no: 9, name: "RERANKER_ALGORITHM_VOYAGE" },
    { no: 10, name: "RERANKER_ALGORITHM_VOYAGE_EMBEDS" },
    { no: 11, name: "RERANKER_ALGORITHM_IDENTITY" },
    { no: 12, name: "RERANKER_ALGORITHM_ADA_EMBEDS" },
  ])
var HB
;(function (i) {
  ;(i[(i.RECHUNKER_CHOICE_UNSPECIFIED = 0)] = "RECHUNKER_CHOICE_UNSPECIFIED"),
    (i[(i.RECHUNKER_CHOICE_IDENTITY = 1)] = "RECHUNKER_CHOICE_IDENTITY"),
    (i[(i.RECHUNKER_CHOICE_600_TOKS = 2)] = "RECHUNKER_CHOICE_600_TOKS"),
    (i[(i.RECHUNKER_CHOICE_2400_TOKS = 3)] = "RECHUNKER_CHOICE_2400_TOKS"),
    (i[(i.RECHUNKER_CHOICE_4000_TOKS = 4)] = "RECHUNKER_CHOICE_4000_TOKS")
})(HB || (HB = {})),
  n.util.setEnumType(HB, "aiserver.v1.RechunkerChoice", [
    { no: 0, name: "RECHUNKER_CHOICE_UNSPECIFIED" },
    { no: 1, name: "RECHUNKER_CHOICE_IDENTITY" },
    { no: 2, name: "RECHUNKER_CHOICE_600_TOKS" },
    { no: 3, name: "RECHUNKER_CHOICE_2400_TOKS" },
    { no: 4, name: "RECHUNKER_CHOICE_4000_TOKS" },
  ])
var K9t = class c0 extends h {
    constructor(t) {
      super(),
        (this.readmes = []),
        (this.topLevelRelativeWorkspacePaths = []),
        (this.workspaceRootPath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHighLevelFolderDescriptionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "readmes", kind: "message", T: Z9t, repeated: !0 },
        {
          no: 2,
          name: "top_level_relative_workspace_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 4, name: "workspace_root_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new c0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c0, t, e)
    }
  },
  Z9t = class l0 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHighLevelFolderDescriptionRequest.Readme"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new l0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l0, t, e)
    }
  },
  tCt = class u0 extends h {
    constructor(t) {
      super(), (this.description = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHighLevelFolderDescriptionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new u0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u0, t, e)
    }
  },
  eCt = class h0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EnsureIndexCreatedRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new h0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h0, t, e)
    }
  },
  iCt = class d0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EnsureIndexCreatedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new d0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d0, t, e)
    }
  },
  Na = class m0 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.hashOfNode = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PartialPathItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "hash_of_node", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new m0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m0, t, e)
    }
  },
  sCt = class f0 extends h {
    constructor(t) {
      super(),
        (this.rootHash = ""),
        (this.potentialLegacyRepoName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoInitHandshakeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
        { no: 2, name: "root_hash", kind: "scalar", T: 9 },
        { no: 3, name: "potential_legacy_repo_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new f0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f0, t, e)
    }
  },
  rCt = class p0 extends h {
    constructor(t) {
      super(),
        (this.status = Im.UNSPECIFIED),
        (this.repoName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoInitHandshakeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Im) },
        { no: 2, name: "repo_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new p0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p0, t, e)
    }
  },
  Im
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.UP_TO_DATE = 1)] = "UP_TO_DATE"),
    (i[(i.OUT_OF_SYNC = 2)] = "OUT_OF_SYNC"),
    (i[(i.FAILURE = 3)] = "FAILURE"),
    (i[(i.EMPTY = 4)] = "EMPTY")
})(Im || (Im = {})),
  n.util.setEnumType(Im, "aiserver.v1.FastRepoInitHandshakeResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_UP_TO_DATE" },
    { no: 2, name: "STATUS_OUT_OF_SYNC" },
    { no: 3, name: "STATUS_FAILURE" },
    { no: 4, name: "STATUS_EMPTY" },
  ])
var nCt = class g0 extends h {
    constructor(t) {
      super(), (this.rootHash = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoInitHandshakeV2Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
        { no: 2, name: "root_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new g0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g0, t, e)
    }
  },
  aCt = class v0 extends h {
    constructor(t) {
      super(),
        (this.codebaseId = ""),
        (this.status = Pm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryCodebaseInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebase_id", kind: "scalar", T: 9 },
        { no: 2, name: "status", kind: "enum", T: n.getEnumType(Pm) },
      ])
    }
    static fromBinary(t, e) {
      return new v0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v0, t, e)
    }
  },
  Pm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.UP_TO_DATE = 1)] = "UP_TO_DATE"),
    (i[(i.OUT_OF_SYNC = 2)] = "OUT_OF_SYNC"),
    (i[(i.EMPTY = 3)] = "EMPTY")
})(Pm || (Pm = {})),
  n.util.setEnumType(Pm, "aiserver.v1.RepositoryCodebaseInfo.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_UP_TO_DATE" },
    { no: 2, name: "STATUS_OUT_OF_SYNC" },
    { no: 3, name: "STATUS_EMPTY" },
  ])
var oCt = class w0 extends h {
    constructor(t) {
      super(),
        (this.status = $m.UNSPECIFIED),
        (this.codebases = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoInitHandshakeV2Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType($m) },
        { no: 2, name: "codebases", kind: "message", T: aCt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new w0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w0, t, e)
    }
  },
  $m
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FAILURE = 1)] = "FAILURE"),
    (i[(i.SUCCESS = 2)] = "SUCCESS")
})($m || ($m = {})),
  n.util.setEnumType($m, "aiserver.v1.FastRepoInitHandshakeV2Response.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_FAILURE" },
    { no: 2, name: "STATUS_SUCCESS" },
  ])
var cCt = class y0 extends h {
    constructor(t) {
      super(),
        (this.codebaseId = ""),
        (this.status = xm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryCodebaseSyncStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebase_id", kind: "scalar", T: 9 },
        { no: 2, name: "status", kind: "enum", T: n.getEnumType(xm) },
      ])
    }
    static fromBinary(t, e) {
      return new y0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y0, t, e)
    }
  },
  xm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE")
})(xm || (xm = {})),
  n.util.setEnumType(xm, "aiserver.v1.RepositoryCodebaseSyncStatus.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
  ])
var lCt = class b0 extends h {
    constructor(t) {
      super(), (this.codebases = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoSyncCompleteRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebases", kind: "message", T: cCt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new b0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b0, t, e)
    }
  },
  uCt = class T0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoSyncCompleteResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new T0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T0, t, e)
    }
  },
  hCt = class k0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
        { no: 2, name: "local_partial_path", kind: "message", T: Na },
      ])
    }
    static fromBinary(t, e) {
      return new k0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k0, t, e)
    }
  },
  dCt = class S0 extends h {
    constructor(t) {
      super(), (this.result = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "match", kind: "scalar", T: 8, oneof: "result" },
        { no: 2, name: "mismatch", kind: "message", T: mCt, oneof: "result" },
      ])
    }
    static fromBinary(t, e) {
      return new S0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S0, t, e)
    }
  },
  mCt = class E0 extends h {
    constructor(t) {
      super(), (this.children = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeResponse.Mismatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "children", kind: "message", T: Na, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new E0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E0, t, e)
    }
  },
  Int = class I0 extends h {
    constructor(t) {
      super(), (this.orthogonalTransformSeed = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClientRepositoryInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "orthogonal_transform_seed", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new I0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I0, t, e)
    }
  },
  fCt = class P0 extends h {
    constructor(t) {
      super(), (this.codebaseId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeV2Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "client_repository_info", kind: "message", T: Int },
        { no: 2, name: "codebase_id", kind: "scalar", T: 9 },
        { no: 3, name: "local_partial_path", kind: "message", T: Na },
      ])
    }
    static fromBinary(t, e) {
      return new P0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P0, t, e)
    }
  },
  pCt = class $0 extends h {
    constructor(t) {
      super(), (this.result = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeV2Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "match", kind: "scalar", T: 8, oneof: "result" },
        { no: 2, name: "mismatch", kind: "message", T: gCt, oneof: "result" },
      ])
    }
    static fromBinary(t, e) {
      return new $0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($0, t, e)
    }
  },
  gCt = class x0 extends h {
    constructor(t) {
      super(), (this.children = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeV2Response.Mismatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "children", kind: "message", T: Na, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new x0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x0, t, e)
    }
  },
  vCt = class N0 extends h {
    constructor(t) {
      super(),
        (this.partialPath = { case: void 0 }),
        (this.ancestorSpline = []),
        (this.updateType = Nm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
        {
          no: 2,
          name: "directory",
          kind: "message",
          T: Na,
          oneof: "partial_path",
        },
        {
          no: 3,
          name: "local_file",
          kind: "message",
          T: wCt,
          oneof: "partial_path",
        },
        {
          no: 4,
          name: "ancestor_spline",
          kind: "message",
          T: Na,
          repeated: !0,
        },
        { no: 5, name: "update_type", kind: "enum", T: n.getEnumType(Nm) },
      ])
    }
    static fromBinary(t, e) {
      return new N0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N0, t, e)
    }
  },
  Nm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ADD = 1)] = "ADD"),
    (i[(i.DELETE = 2)] = "DELETE"),
    (i[(i.MODIFY = 3)] = "MODIFY")
})(Nm || (Nm = {})),
  n.util.setEnumType(Nm, "aiserver.v1.FastUpdateFileRequest.UpdateType", [
    { no: 0, name: "UPDATE_TYPE_UNSPECIFIED" },
    { no: 1, name: "UPDATE_TYPE_ADD" },
    { no: 2, name: "UPDATE_TYPE_DELETE" },
    { no: 3, name: "UPDATE_TYPE_MODIFY" },
  ])
var wCt = class C0 extends h {
    constructor(t) {
      super(),
        (this.hash = ""),
        (this.unencryptedRelativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileRequest.LocalFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: ks },
        { no: 2, name: "hash", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "unencrypted_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
      ])
    }
    static fromBinary(t, e) {
      return new C0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C0, t, e)
    }
  },
  yCt = class J0 extends h {
    constructor(t) {
      super(), (this.status = Cm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Cm) },
      ])
    }
    static fromBinary(t, e) {
      return new J0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J0, t, e)
    }
  },
  Cm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.EXPECTED_FAILURE = 3)] = "EXPECTED_FAILURE")
})(Cm || (Cm = {})),
  n.util.setEnumType(Cm, "aiserver.v1.FastUpdateFileResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_EXPECTED_FAILURE" },
  ])
var bCt = class L0 extends h {
    constructor(t) {
      super(),
        (this.codebaseId = ""),
        (this.partialPath = { case: void 0 }),
        (this.ancestorSpline = []),
        (this.updateType = Jm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileV2Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "client_repository_info", kind: "message", T: Int },
        { no: 2, name: "codebase_id", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "directory",
          kind: "message",
          T: Na,
          oneof: "partial_path",
        },
        {
          no: 4,
          name: "local_file",
          kind: "message",
          T: TCt,
          oneof: "partial_path",
        },
        {
          no: 5,
          name: "ancestor_spline",
          kind: "message",
          T: Na,
          repeated: !0,
        },
        { no: 6, name: "update_type", kind: "enum", T: n.getEnumType(Jm) },
      ])
    }
    static fromBinary(t, e) {
      return new L0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L0, t, e)
    }
  },
  Jm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ADD = 1)] = "ADD"),
    (i[(i.DELETE = 2)] = "DELETE"),
    (i[(i.MODIFY = 3)] = "MODIFY")
})(Jm || (Jm = {})),
  n.util.setEnumType(Jm, "aiserver.v1.FastUpdateFileV2Request.UpdateType", [
    { no: 0, name: "UPDATE_TYPE_UNSPECIFIED" },
    { no: 1, name: "UPDATE_TYPE_ADD" },
    { no: 2, name: "UPDATE_TYPE_DELETE" },
    { no: 3, name: "UPDATE_TYPE_MODIFY" },
  ])
var TCt = class R0 extends h {
    constructor(t) {
      super(),
        (this.hash = ""),
        (this.unencryptedRelativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileV2Request.LocalFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: ks },
        { no: 2, name: "hash", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "unencrypted_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
      ])
    }
    static fromBinary(t, e) {
      return new R0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R0, t, e)
    }
  },
  kCt = class D0 extends h {
    constructor(t) {
      super(), (this.status = Lm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileV2Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Lm) },
      ])
    }
    static fromBinary(t, e) {
      return new D0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D0, t, e)
    }
  },
  Lm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.EXPECTED_FAILURE = 3)] = "EXPECTED_FAILURE")
})(Lm || (Lm = {})),
  n.util.setEnumType(Lm, "aiserver.v1.FastUpdateFileV2Response.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_EXPECTED_FAILURE" },
  ])
var SCt = class F0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUploadLimitsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new F0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F0, t, e)
    }
  },
  ECt = class A0 extends h {
    constructor(t) {
      super(),
        (this.softLimit = 0),
        (this.hardLimit = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUploadLimitsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "soft_limit", kind: "scalar", T: 5 },
        { no: 2, name: "hard_limit", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new A0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A0, t, e)
    }
  },
  ICt = class _0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetNumFilesToSendRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new _0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_0, t, e)
    }
  },
  PCt = class O0 extends h {
    constructor(t) {
      super(), (this.numFiles = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetNumFilesToSendResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_files", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new O0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O0, t, e)
    }
  },
  $Ct = class B0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetAvailableChunkingStrategiesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new B0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B0, t, e)
    }
  },
  xCt = class q0 extends h {
    constructor(t) {
      super(), (this.chunkingStrategies = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetAvailableChunkingStrategiesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "chunking_strategies",
          kind: "enum",
          T: n.getEnumType(MB),
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new q0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q0, t, e)
    }
  },
  NCt = class U0 extends h {
    constructor(t) {
      super(), (this.texts = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmbeddingsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "texts", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new U0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U0, t, e)
    }
  },
  CCt = class M0 extends h {
    constructor(t) {
      super(), (this.embeddings = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmbeddingsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "embeddings", kind: "message", T: JCt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new M0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M0, t, e)
    }
  },
  JCt = class H0 extends h {
    constructor(t) {
      super(), (this.embedding = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmbeddingsResponse.Embedding"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "embedding", kind: "scalar", T: 2, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new H0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H0, t, e)
    }
  },
  WQt = class W0 extends h {
    constructor(t) {
      super(), (this.codebaseId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AdminRemoveRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebase_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new W0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W0, t, e)
    }
  },
  jQt = class j0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AdminRemoveRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new j0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j0, t, e)
    }
  },
  VQt = class V0 extends h {
    constructor(t) {
      super(), (this.codebaseId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebase_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new V0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V0, t, e)
    }
  },
  GQt = class G0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new G0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G0, t, e)
    }
  },
  zQt = class z0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartUploadRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new z0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z0, t, e)
    }
  },
  YQt = class Y0 extends h {
    constructor(t) {
      super(),
        (this.status = Rm.UNSPECIFIED),
        (this.seenFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartUploadRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Rm) },
        { no: 2, name: "seen_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Y0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y0, t, e)
    }
  },
  Rm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.ALREADY_EXISTS = 3)] = "ALREADY_EXISTS")
})(Rm || (Rm = {})),
  n.util.setEnumType(Rm, "aiserver.v1.StartUploadRepoResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_ALREADY_EXISTS" },
  ])
var QQt = class Q0 extends h {
    constructor(t) {
      super(),
        (this.commitSha = ""),
        (this.queueId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
        { no: 2, name: "file", kind: "message", T: ks },
        { no: 3, name: "commit_sha", kind: "scalar", T: 9 },
        { no: 4, name: "queue_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Q0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q0, t, e)
    }
  },
  XQt = class X0 extends h {
    constructor(t) {
      super(), (this.status = Dm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Dm) },
      ])
    }
    static fromBinary(t, e) {
      return new X0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X0, t, e)
    }
  },
  Dm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.EXPECTED_FAILURE = 3)] = "EXPECTED_FAILURE"),
    (i[(i.QUEUE_BACKED_UP = 4)] = "QUEUE_BACKED_UP")
})(Dm || (Dm = {})),
  n.util.setEnumType(Dm, "aiserver.v1.UploadFileResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_EXPECTED_FAILURE" },
    { no: 4, name: "STATUS_QUEUE_BACKED_UP" },
  ])
var KQt = class K0 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishUploadRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new K0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K0, t, e)
    }
  },
  ZQt = class Z0 extends h {
    constructor(t) {
      super(), (this.status = Fm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishUploadRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Fm) },
      ])
    }
    static fromBinary(t, e) {
      return new Z0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z0, t, e)
    }
  },
  Fm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE")
})(Fm || (Fm = {})),
  n.util.setEnumType(Fm, "aiserver.v1.FinishUploadRepoResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
  ])
var tXt = class tb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartUpdateRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new tb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tb, t, e)
    }
  },
  eXt = class eb extends h {
    constructor(t) {
      super(), (this.status = Am.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartUpdateRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Am) },
      ])
    }
    static fromBinary(t, e) {
      return new eb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eb, t, e)
    }
  },
  Am
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.NOT_FOUND = 3)] = "NOT_FOUND"),
    (i[(i.ALREADY_SYNCING = 4)] = "ALREADY_SYNCING")
})(Am || (Am = {})),
  n.util.setEnumType(Am, "aiserver.v1.StartUpdateRepoResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_NOT_FOUND" },
    { no: 4, name: "STATUS_ALREADY_SYNCING" },
  ])
var iXt = class ib extends h {
    constructor(t) {
      super(),
        (this.commitSha = ""),
        (this.queueId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
        { no: 2, name: "added_file", kind: "message", T: ks },
        { no: 3, name: "deleted_file_path", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "commit_sha", kind: "scalar", T: 9 },
        { no: 5, name: "queue_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ib().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ib().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ib().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ib, t, e)
    }
  },
  sXt = class sb extends h {
    constructor(t) {
      super(), (this.status = _m.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(_m) },
      ])
    }
    static fromBinary(t, e) {
      return new sb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sb, t, e)
    }
  },
  _m
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.EXPECTED_FAILURE = 3)] = "EXPECTED_FAILURE"),
    (i[(i.QUEUE_BACKED_UP = 4)] = "QUEUE_BACKED_UP")
})(_m || (_m = {})),
  n.util.setEnumType(_m, "aiserver.v1.UpdateFileResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_EXPECTED_FAILURE" },
    { no: 4, name: "STATUS_QUEUE_BACKED_UP" },
  ])
var rXt = class rb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishUpdateRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new rb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rb, t, e)
    }
  },
  nXt = class nb extends h {
    constructor(t) {
      super(), (this.status = Om.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishUpdateRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Om) },
      ])
    }
    static fromBinary(t, e) {
      return new nb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nb, t, e)
    }
  },
  Om
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE")
})(Om || (Om = {})),
  n.util.setEnumType(Om, "aiserver.v1.FinishUpdateRepoResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
  ])
var aXt = class ab extends h {
    constructor(t) {
      super(), (this.requests = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BatchRepositoryStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "requests", kind: "message", T: _Ct, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ab().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ab().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ab().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ab, t, e)
    }
  },
  oXt = class ob extends h {
    constructor(t) {
      super(), (this.responses = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BatchRepositoryStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "responses", kind: "message", T: OCt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ob().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ob().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ob().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ob, t, e)
    }
  },
  cXt = class cb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UnsubscribeRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new cb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cb, t, e)
    }
  },
  lXt = class lb extends h {
    constructor(t) {
      super(), (this.status = Bm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UnsubscribeRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Bm) },
      ])
    }
    static fromBinary(t, e) {
      return new lb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lb, t, e)
    }
  },
  Bm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NOT_FOUND = 1)] = "NOT_FOUND"),
    (i[(i.NOT_SUBSCRIBED = 2)] = "NOT_SUBSCRIBED"),
    (i[(i.SUCCESS = 3)] = "SUCCESS")
})(Bm || (Bm = {})),
  n.util.setEnumType(Bm, "aiserver.v1.UnsubscribeRepositoryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_NOT_FOUND" },
    { no: 2, name: "STATUS_NOT_SUBSCRIBED" },
    { no: 3, name: "STATUS_SUCCESS" },
  ])
var uXt = class ub extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogoutRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new ub().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ub().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ub().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ub, t, e)
    }
  },
  hXt = class hb extends h {
    constructor(t) {
      super(), (this.status = qm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogoutResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(qm) },
      ])
    }
    static fromBinary(t, e) {
      return new hb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hb, t, e)
    }
  },
  qm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.NOT_LOGGED_IN = 3)] = "NOT_LOGGED_IN")
})(qm || (qm = {})),
  n.util.setEnumType(qm, "aiserver.v1.LogoutResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_NOT_LOGGED_IN" },
  ])
var LCt = class db extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new db().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new db().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new db().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(db, t, e)
    }
  },
  RCt = class mb extends h {
    constructor(t) {
      super(), (this.status = Um.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Um) },
      ])
    }
    static fromBinary(t, e) {
      return new mb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mb, t, e)
    }
  },
  Um
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NOT_FOUND = 1)] = "NOT_FOUND"),
    (i[(i.NOT_AUTHORIZED = 2)] = "NOT_AUTHORIZED"),
    (i[(i.STARTED = 3)] = "STARTED"),
    (i[(i.SUCCESS = 4)] = "SUCCESS")
})(Um || (Um = {})),
  n.util.setEnumType(Um, "aiserver.v1.RemoveRepositoryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_NOT_FOUND" },
    { no: 2, name: "STATUS_NOT_AUTHORIZED" },
    { no: 3, name: "STATUS_STARTED" },
    { no: 4, name: "STATUS_SUCCESS" },
  ])
var dXt = class fb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SubscribeRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new fb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fb, t, e)
    }
  },
  mXt = class pb extends h {
    constructor(t) {
      super(), (this.status = Mm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SubscribeRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Mm) },
      ])
    }
    static fromBinary(t, e) {
      return new pb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pb, t, e)
    }
  },
  Mm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NOT_FOUND = 1)] = "NOT_FOUND"),
    (i[(i.NOT_AUTHORIZED = 2)] = "NOT_AUTHORIZED"),
    (i[(i.ALREADY_SUBSCRIBED = 3)] = "ALREADY_SUBSCRIBED"),
    (i[(i.SUCCESS = 4)] = "SUCCESS")
})(Mm || (Mm = {})),
  n.util.setEnumType(Mm, "aiserver.v1.SubscribeRepositoryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_NOT_FOUND" },
    { no: 2, name: "STATUS_NOT_AUTHORIZED" },
    { no: 3, name: "STATUS_ALREADY_SUBSCRIBED" },
    { no: 4, name: "STATUS_SUCCESS" },
  ])
var Pnt = class gb extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.topK = 0),
        (this.rerank = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "repository", kind: "message", T: Mt },
        { no: 3, name: "top_k", kind: "scalar", T: 5 },
        { no: 4, name: "model_details", kind: "message", T: St },
        { no: 5, name: "rerank", kind: "scalar", T: 8 },
        { no: 6, name: "context_cache_request", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "glob_filter", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "not_glob_filter", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "race_n_requests", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gb, t, e)
    }
  },
  xi = class vb extends h {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_block", kind: "message", T: Ne },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new vb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vb, t, e)
    }
  },
  DCt = class wb extends h {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: ks },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new wb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wb, t, e)
    }
  },
  $nt = class yb extends h {
    constructor(t) {
      super(), (this.codeResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: xi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yb, t, e)
    }
  },
  xnt = class bb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemSearchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: Pnt },
      ])
    }
    static fromBinary(t, e) {
      return new bb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bb, t, e)
    }
  },
  Nnt = class Tb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeResultWithClassificationInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_result", kind: "message", T: xi },
        {
          no: 2,
          name: "line_number_classification",
          kind: "message",
          T: FCt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Tb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tb, t, e)
    }
  },
  FCt = class kb extends h {
    constructor(t) {
      super(),
        (this.queryComputedFor = ""),
        (this.matchedStrings = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.CodeResultWithClassificationInfo.LineNumberClassification"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "detailed_line", kind: "message", T: PM },
        { no: 2, name: "query_computed_for", kind: "scalar", T: 9 },
        { no: 3, name: "matched_strings", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "highlight_range", kind: "message", T: Pi },
      ])
    }
    static fromBinary(t, e) {
      return new kb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kb, t, e)
    }
  },
  Cnt = class Sb extends h {
    constructor(t) {
      super(), (this.codeResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemSearchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "response", kind: "message", T: $nt },
        { no: 2, name: "metadata", kind: "message", T: ACt, opt: !0 },
        { no: 3, name: "code_results", kind: "message", T: Nnt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Sb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sb, t, e)
    }
  },
  ACt = class Eb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemSearchResponse.SemSearchMetadata"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query_embedding_model", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "server_side_latency_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 3, name: "embed_latency_ms", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "knn_latency_ms", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Eb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Eb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Eb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Eb, t, e)
    }
  },
  fXt = class Ib extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LoginRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Ib().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ib().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ib().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ib, t, e)
    }
  },
  pXt = class Pb extends h {
    constructor(t) {
      super(), (this.loginUrl = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LoginResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "login_url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Pb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pb, t, e)
    }
  },
  gXt = class $b extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsLoggedInRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new $b().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $b().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $b().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($b, t, e)
    }
  },
  vXt = class xb extends h {
    constructor(t) {
      super(), (this.loggedIn = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsLoggedInResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "logged_in", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new xb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xb, t, e)
    }
  },
  wXt = class Nb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PollLoginRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Nb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nb, t, e)
    }
  },
  yXt = class Cb extends h {
    constructor(t) {
      super(), (this.status = Hm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PollLoginResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Hm) },
      ])
    }
    static fromBinary(t, e) {
      return new Cb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cb, t, e)
    }
  },
  Hm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOGGED_IN = 1)] = "LOGGED_IN"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.CHECKING = 3)] = "CHECKING")
})(Hm || (Hm = {})),
  n.util.setEnumType(Hm, "aiserver.v1.PollLoginResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_LOGGED_IN" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_CHECKING" },
  ])
var bXt = class Jb extends h {
    constructor(t) {
      super(), (this.scopes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpgradeScopeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "scopes", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Jb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jb, t, e)
    }
  },
  TXt = class Lb extends h {
    constructor(t) {
      super(), (this.status = Wm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpgradeScopeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Wm) },
      ])
    }
    static fromBinary(t, e) {
      return new Lb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lb, t, e)
    }
  },
  Wm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE")
})(Wm || (Wm = {})),
  n.util.setEnumType(Wm, "aiserver.v1.UpgradeScopeResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
  ])
var kXt = class Rb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoriesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Rb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rb, t, e)
    }
  },
  SXt = class Db extends h {
    constructor(t) {
      super(), (this.repositories = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoriesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repositories", kind: "message", T: Mt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Db().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Db().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Db().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Db, t, e)
    }
  },
  EXt = class Fb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new Fb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fb, t, e)
    }
  },
  IXt = class Ab extends h {
    constructor(t) {
      super(), (this.status = jm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(jm) },
      ])
    }
    static fromBinary(t, e) {
      return new Ab().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ab().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ab().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ab, t, e)
    }
  },
  jm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.AUTH_TOKEN_BAD_PERMISSIONS = 3)] = "AUTH_TOKEN_BAD_PERMISSIONS"),
    (i[(i.ALREADY_EXISTS = 4)] = "ALREADY_EXISTS")
})(jm || (jm = {})),
  n.util.setEnumType(jm, "aiserver.v1.UploadRepositoryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_AUTH_TOKEN_BAD_PERMISSIONS" },
    { no: 4, name: "STATUS_ALREADY_EXISTS" },
  ])
var _Ct = class _b extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: Mt },
      ])
    }
    static fromBinary(t, e) {
      return new _b().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _b().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _b().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_b, t, e)
    }
  },
  OCt = class Ob extends h {
    constructor(t) {
      super(), (this.status = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "not_found", kind: "message", T: BCt, oneof: "status" },
        { no: 2, name: "uploading", kind: "message", T: UCt, oneof: "status" },
        { no: 3, name: "syncing", kind: "message", T: MCt, oneof: "status" },
        { no: 4, name: "synced", kind: "message", T: HCt, oneof: "status" },
        {
          no: 5,
          name: "not_subscribed",
          kind: "message",
          T: qCt,
          oneof: "status",
        },
        { no: 6, name: "too_big", kind: "message", T: WCt, oneof: "status" },
        {
          no: 7,
          name: "auth_token_not_found",
          kind: "message",
          T: jCt,
          oneof: "status",
        },
        {
          no: 8,
          name: "auth_token_not_authorized",
          kind: "message",
          T: VCt,
          oneof: "status",
        },
        {
          no: 10,
          name: "error_uploading",
          kind: "message",
          T: Jnt,
          oneof: "status",
        },
        {
          no: 11,
          name: "error_syncing",
          kind: "message",
          T: Jnt,
          oneof: "status",
        },
        { no: 9, name: "is_owner", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ob().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ob().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ob().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ob, t, e)
    }
  },
  BCt = class Bb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.NotFound"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Bb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bb, t, e)
    }
  },
  qCt = class qb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.NotSubscribed"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new qb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qb, t, e)
    }
  },
  UCt = class Ub extends h {
    constructor(t) {
      super(), (this.progress = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.Uploading"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "progress", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new Ub().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ub().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ub().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ub, t, e)
    }
  },
  MCt = class Mb extends h {
    constructor(t) {
      super(),
        (this.branch = ""),
        (this.oldCommit = ""),
        (this.newCommit = ""),
        (this.progress = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.Syncing"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "branch", kind: "scalar", T: 9 },
        { no: 2, name: "old_commit", kind: "scalar", T: 9 },
        { no: 3, name: "new_commit", kind: "scalar", T: 9 },
        { no: 4, name: "progress", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new Mb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mb, t, e)
    }
  },
  HCt = class Hb extends h {
    constructor(t) {
      super(),
        (this.branch = ""),
        (this.commit = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.Synced"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "branch", kind: "scalar", T: 9 },
        { no: 2, name: "commit", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Hb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hb, t, e)
    }
  },
  WCt = class Wb extends h {
    constructor(t) {
      super(), (this.maxSize = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.TooBig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "max_size", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Wb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wb, t, e)
    }
  },
  jCt = class jb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.AuthTokenNotFound"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new jb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jb, t, e)
    }
  },
  VCt = class Vb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RepositoryStatusResponse.AuthTokenNotAuthorized"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Vb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vb, t, e)
    }
  },
  Jnt = class Gb extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.EmptyMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Gb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gb, t, e)
    }
  },
  Mt = class zb extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.remoteUrls = []),
        (this.remoteNames = []),
        (this.repoName = ""),
        (this.repoOwner = ""),
        (this.isTracked = !1),
        (this.isLocal = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "remote_urls", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "remote_names", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "repo_name", kind: "scalar", T: 9 },
        { no: 5, name: "repo_owner", kind: "scalar", T: 9 },
        { no: 6, name: "is_tracked", kind: "scalar", T: 8 },
        { no: 7, name: "is_local", kind: "scalar", T: 8 },
        { no: 8, name: "num_files", kind: "scalar", T: 5, opt: !0 },
        {
          no: 9,
          name: "orthogonal_transform_seed",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        {
          no: 10,
          name: "preferred_embedding_model",
          kind: "enum",
          T: n.getEnumType(j8),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new zb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zb, t, e)
    }
  },
  PXt = class Yb extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.topK = 0),
        (this.topReflectionsK = 0),
        (this.indexIds = []),
        (this.useModelOnFiles = !1),
        (this.useReflections = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchRepositoryDeepContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "top_k", kind: "scalar", T: 5 },
        { no: 3, name: "top_reflections_k", kind: "scalar", T: 5 },
        { no: 4, name: "index_ids", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "use_model_on_files", kind: "scalar", T: 8 },
        { no: 6, name: "use_reflections", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Yb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yb, t, e)
    }
  },
  GCt = class Qb extends h {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NodeResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node", kind: "message", T: Snt },
        { no: 2, name: "file", kind: "message", T: ks },
        { no: 3, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new Qb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qb, t, e)
    }
  },
  zCt = class Xb extends h {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReflectionResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "reflection", kind: "message", T: W9t },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new Xb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xb, t, e)
    }
  },
  YCt = class Kb extends h {
    constructor(t) {
      super(),
        (this.topNodes = []),
        (this.reflections = []),
        (this.indexId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchRepositoryDeepContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "top_nodes", kind: "message", T: GCt, repeated: !0 },
        { no: 2, name: "reflections", kind: "message", T: zCt, repeated: !0 },
        { no: 3, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Kb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kb, t, e)
    }
  },
  QCt = class Zb extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.codeResults = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLineNumberClassificationsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "code_results", kind: "message", T: xi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Zb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zb, t, e)
    }
  },
  XCt = class tT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLineNumberClassificationsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "classified_result", kind: "message", T: Nnt },
      ])
    }
    static fromBinary(t, e) {
      return new tT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tT, t, e)
    }
  },
  As
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.READ_SEMSEARCH_FILES = 1)] = "READ_SEMSEARCH_FILES"),
    (i[(i.READ_FILE_FOR_IMPORTS = 2)] = "READ_FILE_FOR_IMPORTS"),
    (i[(i.RIPGREP_SEARCH = 3)] = "RIPGREP_SEARCH"),
    (i[(i.RUN_TERMINAL_COMMAND = 4)] = "RUN_TERMINAL_COMMAND"),
    (i[(i.READ_FILE = 5)] = "READ_FILE"),
    (i[(i.LIST_DIR = 6)] = "LIST_DIR"),
    (i[(i.EDIT_FILE = 7)] = "EDIT_FILE"),
    (i[(i.FILE_SEARCH = 8)] = "FILE_SEARCH"),
    (i[(i.SEMANTIC_SEARCH_FULL = 9)] = "SEMANTIC_SEARCH_FULL"),
    (i[(i.CREATE_FILE = 10)] = "CREATE_FILE"),
    (i[(i.DELETE_FILE = 11)] = "DELETE_FILE"),
    (i[(i.REAPPLY = 12)] = "REAPPLY"),
    (i[(i.GET_RELATED_FILES = 13)] = "GET_RELATED_FILES"),
    (i[(i.PARALLEL_APPLY = 14)] = "PARALLEL_APPLY"),
    (i[(i.RUN_TERMINAL_COMMAND_V2 = 15)] = "RUN_TERMINAL_COMMAND_V2"),
    (i[(i.FETCH_RULES = 16)] = "FETCH_RULES"),
    (i[(i.PLANNER = 17)] = "PLANNER"),
    (i[(i.WEB_SEARCH = 18)] = "WEB_SEARCH"),
    (i[(i.MCP = 19)] = "MCP"),
    (i[(i.WEB_VIEWER = 20)] = "WEB_VIEWER"),
    (i[(i.DIFF_HISTORY = 21)] = "DIFF_HISTORY")
})(As || (As = {})),
  n.util.setEnumType(As, "aiserver.v1.ClientSideToolV2", [
    { no: 0, name: "CLIENT_SIDE_TOOL_V2_UNSPECIFIED" },
    { no: 1, name: "CLIENT_SIDE_TOOL_V2_READ_SEMSEARCH_FILES" },
    { no: 2, name: "CLIENT_SIDE_TOOL_V2_READ_FILE_FOR_IMPORTS" },
    { no: 3, name: "CLIENT_SIDE_TOOL_V2_RIPGREP_SEARCH" },
    { no: 4, name: "CLIENT_SIDE_TOOL_V2_RUN_TERMINAL_COMMAND" },
    { no: 5, name: "CLIENT_SIDE_TOOL_V2_READ_FILE" },
    { no: 6, name: "CLIENT_SIDE_TOOL_V2_LIST_DIR" },
    { no: 7, name: "CLIENT_SIDE_TOOL_V2_EDIT_FILE" },
    { no: 8, name: "CLIENT_SIDE_TOOL_V2_FILE_SEARCH" },
    { no: 9, name: "CLIENT_SIDE_TOOL_V2_SEMANTIC_SEARCH_FULL" },
    { no: 10, name: "CLIENT_SIDE_TOOL_V2_CREATE_FILE" },
    { no: 11, name: "CLIENT_SIDE_TOOL_V2_DELETE_FILE" },
    { no: 12, name: "CLIENT_SIDE_TOOL_V2_REAPPLY" },
    { no: 13, name: "CLIENT_SIDE_TOOL_V2_GET_RELATED_FILES" },
    { no: 14, name: "CLIENT_SIDE_TOOL_V2_PARALLEL_APPLY" },
    { no: 15, name: "CLIENT_SIDE_TOOL_V2_RUN_TERMINAL_COMMAND_V2" },
    { no: 16, name: "CLIENT_SIDE_TOOL_V2_FETCH_RULES" },
    { no: 17, name: "CLIENT_SIDE_TOOL_V2_PLANNER" },
    { no: 18, name: "CLIENT_SIDE_TOOL_V2_WEB_SEARCH" },
    { no: 19, name: "CLIENT_SIDE_TOOL_V2_MCP" },
    { no: 20, name: "CLIENT_SIDE_TOOL_V2_WEB_VIEWER" },
    { no: 21, name: "CLIENT_SIDE_TOOL_V2_DIFF_HISTORY" },
  ])
var _o
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.BASH = 1)] = "BASH"),
    (i[(i.POWERSHELL = 2)] = "POWERSHELL")
})(_o || (_o = {})),
  n.util.setEnumType(_o, "aiserver.v1.ShellType", [
    { no: 0, name: "SHELL_TYPE_UNSPECIFIED" },
    { no: 1, name: "SHELL_TYPE_BASH" },
    { no: 2, name: "SHELL_TYPE_POWERSHELL" },
  ])
var Oo
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SEARCH = 1)] = "SEARCH"),
    (i[(i.READ_CHUNK = 2)] = "READ_CHUNK"),
    (i[(i.GOTODEF = 3)] = "GOTODEF"),
    (i[(i.EDIT = 4)] = "EDIT"),
    (i[(i.UNDO_EDIT = 5)] = "UNDO_EDIT"),
    (i[(i.END = 6)] = "END"),
    (i[(i.NEW_FILE = 7)] = "NEW_FILE"),
    (i[(i.ADD_TEST = 8)] = "ADD_TEST"),
    (i[(i.RUN_TEST = 9)] = "RUN_TEST"),
    (i[(i.DELETE_TEST = 10)] = "DELETE_TEST"),
    (i[(i.SAVE_FILE = 11)] = "SAVE_FILE"),
    (i[(i.GET_TESTS = 12)] = "GET_TESTS"),
    (i[(i.GET_SYMBOLS = 13)] = "GET_SYMBOLS"),
    (i[(i.SEMANTIC_SEARCH = 14)] = "SEMANTIC_SEARCH"),
    (i[(i.GET_PROJECT_STRUCTURE = 15)] = "GET_PROJECT_STRUCTURE"),
    (i[(i.CREATE_RM_FILES = 16)] = "CREATE_RM_FILES"),
    (i[(i.RUN_TERMINAL_COMMANDS = 17)] = "RUN_TERMINAL_COMMANDS"),
    (i[(i.NEW_EDIT = 18)] = "NEW_EDIT"),
    (i[(i.READ_WITH_LINTER = 19)] = "READ_WITH_LINTER")
})(Oo || (Oo = {})),
  n.util.setEnumType(Oo, "aiserver.v1.BuiltinTool", [
    { no: 0, name: "BUILTIN_TOOL_UNSPECIFIED" },
    { no: 1, name: "BUILTIN_TOOL_SEARCH" },
    { no: 2, name: "BUILTIN_TOOL_READ_CHUNK" },
    { no: 3, name: "BUILTIN_TOOL_GOTODEF" },
    { no: 4, name: "BUILTIN_TOOL_EDIT" },
    { no: 5, name: "BUILTIN_TOOL_UNDO_EDIT" },
    { no: 6, name: "BUILTIN_TOOL_END" },
    { no: 7, name: "BUILTIN_TOOL_NEW_FILE" },
    { no: 8, name: "BUILTIN_TOOL_ADD_TEST" },
    { no: 9, name: "BUILTIN_TOOL_RUN_TEST" },
    { no: 10, name: "BUILTIN_TOOL_DELETE_TEST" },
    { no: 11, name: "BUILTIN_TOOL_SAVE_FILE" },
    { no: 12, name: "BUILTIN_TOOL_GET_TESTS" },
    { no: 13, name: "BUILTIN_TOOL_GET_SYMBOLS" },
    { no: 14, name: "BUILTIN_TOOL_SEMANTIC_SEARCH" },
    { no: 15, name: "BUILTIN_TOOL_GET_PROJECT_STRUCTURE" },
    { no: 16, name: "BUILTIN_TOOL_CREATE_RM_FILES" },
    { no: 17, name: "BUILTIN_TOOL_RUN_TERMINAL_COMMANDS" },
    { no: 18, name: "BUILTIN_TOOL_NEW_EDIT" },
    { no: 19, name: "BUILTIN_TOOL_READ_WITH_LINTER" },
  ])
var Hl
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.EXECUTION_COMPLETED = 1)] = "EXECUTION_COMPLETED"),
    (i[(i.EXECUTION_ABORTED = 2)] = "EXECUTION_ABORTED"),
    (i[(i.EXECUTION_FAILED = 3)] = "EXECUTION_FAILED"),
    (i[(i.ERROR_OCCURRED_CHECKING_REASON = 4)] =
      "ERROR_OCCURRED_CHECKING_REASON")
})(Hl || (Hl = {})),
  n.util.setEnumType(Hl, "aiserver.v1.RunTerminalCommandEndedReason", [
    { no: 0, name: "RUN_TERMINAL_COMMAND_ENDED_REASON_UNSPECIFIED" },
    { no: 1, name: "RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED" },
    { no: 2, name: "RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_ABORTED" },
    { no: 3, name: "RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_FAILED" },
    {
      no: 4,
      name: "RUN_TERMINAL_COMMAND_ENDED_REASON_ERROR_OCCURRED_CHECKING_REASON",
    },
  ])
var KCt = class eT extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReapplyParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new eT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eT, t, e)
    }
  },
  ZCt = class iT extends h {
    constructor(t) {
      super(),
        (this.isApplied = !1),
        (this.applyFailed = !1),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReapplyResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff", kind: "message", T: RW },
        { no: 2, name: "is_applied", kind: "scalar", T: 8 },
        { no: 3, name: "apply_failed", kind: "scalar", T: 8 },
        { no: 4, name: "linter_errors", kind: "message", T: ka, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new iT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iT, t, e)
    }
  },
  tJt = class sT extends h {
    constructor(t) {
      super(), (this.ruleNames = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FetchRulesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "rule_names", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sT, t, e)
    }
  },
  eJt = class rT extends h {
    constructor(t) {
      super(), (this.rules = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FetchRulesResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "rules", kind: "message", T: $M, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new rT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rT, t, e)
    }
  },
  iJt = class nT extends h {
    constructor(t) {
      super(), (this.instruction = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PlannerParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "scalar", T: 9 },
        { no: 2, name: "plan", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new nT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nT, t, e)
    }
  },
  sJt = class aT extends h {
    constructor(t) {
      super(), (this.plan = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PlannerResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "plan", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new aT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aT, t, e)
    }
  },
  rJt = class oT extends h {
    constructor(t) {
      super(), (this.targetFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelatedFilesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "target_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new oT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oT, t, e)
    }
  },
  nJt = class cT extends h {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelatedFilesResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: aJt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new cT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cT, t, e)
    }
  },
  aJt = class lT extends h {
    constructor(t) {
      super(), (this.uri = ""), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelatedFilesResult.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new lT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lT, t, e)
    }
  },
  oJt = class uT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReapplyStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new uT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uT, t, e)
    }
  },
  $Xt = class hT extends h {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.explanation = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandArguments"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "explanation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new hT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hT, t, e)
    }
  },
  xXt = class dT extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.targetDirectories = []),
        (this.explanation = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchArguments"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "target_directories",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 3, name: "explanation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new dT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dT, t, e)
    }
  },
  LW = class mT extends h {
    constructor(t) {
      super(),
        (this.clientVisibleErrorMessage = ""),
        (this.modelVisibleErrorMessage = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolResultError"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "client_visible_error_message", kind: "scalar", T: 9 },
        { no: 2, name: "model_visible_error_message", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "actual_error_message_only_send_from_client_to_server_never_the_other_way_around_because_that_may_be_a_security_risk",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new mT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mT, t, e)
    }
  },
  Lnt = class fT extends h {
    constructor(t) {
      super(),
        (this.tool = As.UNSPECIFIED),
        (this.params = { case: void 0 }),
        (this.toolCallId = ""),
        (this.name = ""),
        (this.rawArgs = ""),
        (this.isStreaming = !1),
        (this.isLastMessage = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClientSideToolV2Call"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(As) },
        {
          no: 2,
          name: "read_semsearch_files_params",
          kind: "message",
          T: Ant,
          oneof: "params",
        },
        {
          no: 4,
          name: "read_file_for_imports_params",
          kind: "message",
          T: Bnt,
          oneof: "params",
        },
        {
          no: 5,
          name: "ripgrep_search_params",
          kind: "message",
          T: EJt,
          oneof: "params",
        },
        {
          no: 7,
          name: "run_terminal_command_params",
          kind: "message",
          T: iLt,
          oneof: "params",
        },
        {
          no: 8,
          name: "read_file_params",
          kind: "message",
          T: TJt,
          oneof: "params",
        },
        {
          no: 12,
          name: "list_dir_params",
          kind: "message",
          T: wJt,
          oneof: "params",
        },
        {
          no: 13,
          name: "edit_file_params",
          kind: "message",
          T: uJt,
          oneof: "params",
        },
        {
          no: 16,
          name: "file_search_params",
          kind: "message",
          T: fJt,
          oneof: "params",
        },
        {
          no: 17,
          name: "semantic_search_full_params",
          kind: "message",
          T: YJt,
          oneof: "params",
        },
        {
          no: 18,
          name: "create_file_params",
          kind: "message",
          T: qnt,
          oneof: "params",
        },
        {
          no: 19,
          name: "delete_file_params",
          kind: "message",
          T: Mnt,
          oneof: "params",
        },
        {
          no: 20,
          name: "reapply_params",
          kind: "message",
          T: KCt,
          oneof: "params",
        },
        {
          no: 21,
          name: "get_related_files_params",
          kind: "message",
          T: rJt,
          oneof: "params",
        },
        {
          no: 22,
          name: "parallel_apply_params",
          kind: "message",
          T: h5t,
          oneof: "params",
        },
        {
          no: 23,
          name: "run_terminal_command_v2_params",
          kind: "message",
          T: g5t,
          oneof: "params",
        },
        {
          no: 24,
          name: "fetch_rules_params",
          kind: "message",
          T: tJt,
          oneof: "params",
        },
        {
          no: 25,
          name: "planner_params",
          kind: "message",
          T: iJt,
          oneof: "params",
        },
        {
          no: 26,
          name: "web_search_params",
          kind: "message",
          T: k5t,
          oneof: "params",
        },
        {
          no: 27,
          name: "mcp_params",
          kind: "message",
          T: N5t,
          oneof: "params",
        },
        {
          no: 28,
          name: "web_viewer_params",
          kind: "message",
          T: P5t,
          oneof: "params",
        },
        {
          no: 29,
          name: "diff_history_params",
          kind: "message",
          T: L5t,
          oneof: "params",
        },
        { no: 3, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 6, name: "timeout_ms", kind: "scalar", T: 1, opt: !0 },
        { no: 9, name: "name", kind: "scalar", T: 9 },
        { no: 10, name: "raw_args", kind: "scalar", T: 9 },
        { no: 14, name: "is_streaming", kind: "scalar", T: 8 },
        { no: 15, name: "is_last_message", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new fT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fT, t, e)
    }
  },
  WB = class pT extends h {
    constructor(t) {
      super(),
        (this.tool = As.UNSPECIFIED),
        (this.result = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClientSideToolV2Result"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(As) },
        {
          no: 2,
          name: "read_semsearch_files_result",
          kind: "message",
          T: Ont,
          oneof: "result",
        },
        {
          no: 3,
          name: "read_file_for_imports_result",
          kind: "message",
          T: ZJt,
          oneof: "result",
        },
        {
          no: 4,
          name: "ripgrep_search_result",
          kind: "message",
          T: RJt,
          oneof: "result",
        },
        {
          no: 5,
          name: "run_terminal_command_result",
          kind: "message",
          T: rLt,
          oneof: "result",
        },
        {
          no: 6,
          name: "read_file_result",
          kind: "message",
          T: kJt,
          oneof: "result",
        },
        {
          no: 9,
          name: "list_dir_result",
          kind: "message",
          T: Rnt,
          oneof: "result",
        },
        {
          no: 10,
          name: "edit_file_result",
          kind: "message",
          T: hJt,
          oneof: "result",
        },
        {
          no: 11,
          name: "file_search_result",
          kind: "message",
          T: gJt,
          oneof: "result",
        },
        {
          no: 18,
          name: "semantic_search_full_result",
          kind: "message",
          T: QJt,
          oneof: "result",
        },
        {
          no: 19,
          name: "create_file_result",
          kind: "message",
          T: Unt,
          oneof: "result",
        },
        {
          no: 20,
          name: "delete_file_result",
          kind: "message",
          T: Hnt,
          oneof: "result",
        },
        {
          no: 21,
          name: "reapply_result",
          kind: "message",
          T: ZCt,
          oneof: "result",
        },
        {
          no: 22,
          name: "get_related_files_result",
          kind: "message",
          T: nJt,
          oneof: "result",
        },
        {
          no: 23,
          name: "parallel_apply_result",
          kind: "message",
          T: m5t,
          oneof: "result",
        },
        {
          no: 24,
          name: "run_terminal_command_v2_result",
          kind: "message",
          T: w5t,
          oneof: "result",
        },
        {
          no: 25,
          name: "fetch_rules_result",
          kind: "message",
          T: eJt,
          oneof: "result",
        },
        {
          no: 26,
          name: "planner_result",
          kind: "message",
          T: sJt,
          oneof: "result",
        },
        {
          no: 27,
          name: "web_search_result",
          kind: "message",
          T: S5t,
          oneof: "result",
        },
        {
          no: 28,
          name: "mcp_result",
          kind: "message",
          T: C5t,
          oneof: "result",
        },
        {
          no: 29,
          name: "web_viewer_result",
          kind: "message",
          T: $5t,
          oneof: "result",
        },
        {
          no: 30,
          name: "diff_history_result",
          kind: "message",
          T: R5t,
          oneof: "result",
        },
        { no: 8, name: "error", kind: "message", T: LW, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new pT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pT, t, e)
    }
  },
  cJt = class gT extends h {
    constructor(t) {
      super(),
        (this.tool = As.UNSPECIFIED),
        (this.toolCallId = ""),
        (this.name = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamedBackPartialToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(As) },
        { no: 2, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new gT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gT, t, e)
    }
  },
  lJt = class vT extends h {
    constructor(t) {
      super(),
        (this.tool = As.UNSPECIFIED),
        (this.toolCallId = ""),
        (this.params = { case: void 0 }),
        (this.name = ""),
        (this.rawArgs = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamedBackToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(As) },
        { no: 2, name: "tool_call_id", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "read_semsearch_files_stream",
          kind: "message",
          T: GJt,
          oneof: "params",
        },
        {
          no: 4,
          name: "read_file_for_imports_stream",
          kind: "message",
          T: KJt,
          oneof: "params",
        },
        {
          no: 5,
          name: "ripgrep_search_stream",
          kind: "message",
          T: VJt,
          oneof: "params",
        },
        {
          no: 6,
          name: "run_terminal_command_stream",
          kind: "message",
          T: nLt,
          oneof: "params",
        },
        {
          no: 7,
          name: "read_file_stream",
          kind: "message",
          T: SJt,
          oneof: "params",
        },
        {
          no: 12,
          name: "list_dir_stream",
          kind: "message",
          T: bJt,
          oneof: "params",
        },
        {
          no: 13,
          name: "edit_file_stream",
          kind: "message",
          T: mJt,
          oneof: "params",
        },
        {
          no: 14,
          name: "file_search_stream",
          kind: "message",
          T: pJt,
          oneof: "params",
        },
        {
          no: 19,
          name: "semantic_search_full_stream",
          kind: "message",
          T: XJt,
          oneof: "params",
        },
        {
          no: 20,
          name: "create_file_stream",
          kind: "message",
          T: tLt,
          oneof: "params",
        },
        {
          no: 21,
          name: "delete_file_stream",
          kind: "message",
          T: eLt,
          oneof: "params",
        },
        {
          no: 22,
          name: "reapply_stream",
          kind: "message",
          T: oJt,
          oneof: "params",
        },
        {
          no: 23,
          name: "get_related_files_stream",
          kind: "message",
          T: zJt,
          oneof: "params",
        },
        {
          no: 24,
          name: "parallel_apply_stream",
          kind: "message",
          T: p5t,
          oneof: "params",
        },
        {
          no: 25,
          name: "run_terminal_command_v2_stream",
          kind: "message",
          T: y5t,
          oneof: "params",
        },
        {
          no: 26,
          name: "fetch_rules_stream",
          kind: "message",
          T: b5t,
          oneof: "params",
        },
        {
          no: 27,
          name: "planner_stream",
          kind: "message",
          T: T5t,
          oneof: "params",
        },
        {
          no: 28,
          name: "web_search_stream",
          kind: "message",
          T: I5t,
          oneof: "params",
        },
        {
          no: 29,
          name: "mcp_stream",
          kind: "message",
          T: J5t,
          oneof: "params",
        },
        {
          no: 30,
          name: "web_viewer_stream",
          kind: "message",
          T: x5t,
          oneof: "params",
        },
        {
          no: 31,
          name: "diff_history_stream",
          kind: "message",
          T: A5t,
          oneof: "params",
        },
        { no: 8, name: "name", kind: "scalar", T: 9 },
        { no: 9, name: "raw_args", kind: "scalar", T: 9 },
        { no: 10, name: "error", kind: "message", T: LW, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new vT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vT, t, e)
    }
  },
  uJt = class wT extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.language = ""),
        (this.contents = ""),
        (this.blocking = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "language", kind: "scalar", T: 9 },
        { no: 3, name: "contents", kind: "scalar", T: 9 },
        { no: 4, name: "blocking", kind: "scalar", T: 8 },
        { no: 5, name: "instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wT, t, e)
    }
  },
  hJt = class yT extends h {
    constructor(t) {
      super(),
        (this.isApplied = !1),
        (this.applyFailed = !1),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff", kind: "message", T: RW },
        { no: 2, name: "is_applied", kind: "scalar", T: 8 },
        { no: 3, name: "apply_failed", kind: "scalar", T: 8 },
        { no: 4, name: "linter_errors", kind: "message", T: ka, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yT, t, e)
    }
  },
  RW = class bT extends h {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.editor = Vm.UNSPECIFIED),
        (this.hitTimeout = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileResult.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: dJt, repeated: !0 },
        { no: 2, name: "editor", kind: "enum", T: n.getEnumType(Vm) },
        { no: 3, name: "hit_timeout", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new bT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bT, t, e)
    }
  },
  Vm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.AI = 1)] = "AI"),
    (i[(i.HUMAN = 2)] = "HUMAN")
})(Vm || (Vm = {})),
  n.util.setEnumType(Vm, "aiserver.v1.EditFileResult.FileDiff.Editor", [
    { no: 0, name: "EDITOR_UNSPECIFIED" },
    { no: 1, name: "EDITOR_AI" },
    { no: 2, name: "EDITOR_HUMAN" },
  ])
var dJt = class TT extends h {
    constructor(t) {
      super(),
        (this.diffString = ""),
        (this.oldStart = 0),
        (this.newStart = 0),
        (this.oldLines = 0),
        (this.newLines = 0),
        (this.linesRemoved = 0),
        (this.linesAdded = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileResult.FileDiff.ChunkDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_string", kind: "scalar", T: 9 },
        { no: 2, name: "old_start", kind: "scalar", T: 5 },
        { no: 3, name: "new_start", kind: "scalar", T: 5 },
        { no: 4, name: "old_lines", kind: "scalar", T: 5 },
        { no: 5, name: "new_lines", kind: "scalar", T: 5 },
        { no: 6, name: "lines_removed", kind: "scalar", T: 5 },
        { no: 7, name: "lines_added", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new TT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TT, t, e)
    }
  },
  mJt = class kT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new kT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kT, t, e)
    }
  },
  fJt = class ST extends h {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallFileSearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ST().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ST().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ST().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ST, t, e)
    }
  },
  NXt = class ET extends h {
    constructor(t) {
      super(), (this.targetFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallGetRelatedFilesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "target_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ET().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ET().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ET().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ET, t, e)
    }
  },
  pJt = class IT extends h {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallFileSearchStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new IT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IT, t, e)
    }
  },
  gJt = class PT extends h {
    constructor(t) {
      super(),
        (this.files = []),
        (this.numResults = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallFileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: vJt, repeated: !0 },
        { no: 2, name: "limit_hit", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "num_results", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new PT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PT, t, e)
    }
  },
  vJt = class $T extends h {
    constructor(t) {
      super(), (this.uri = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallFileSearchResult.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $T().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $T().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $T().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($T, t, e)
    }
  },
  wJt = class xT extends h {
    constructor(t) {
      super(), (this.directoryPath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListDirParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "directory_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xT, t, e)
    }
  },
  Rnt = class NT extends h {
    constructor(t) {
      super(),
        (this.files = []),
        (this.directoryRelativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListDirResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: yJt, repeated: !0 },
        {
          no: 2,
          name: "directory_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
      ])
    }
    static fromBinary(t, e) {
      return new NT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NT, t, e)
    }
  },
  yJt = class CT extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.isDirectory = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListDirResult.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "is_directory", kind: "scalar", T: 8 },
        { no: 3, name: "size", kind: "scalar", T: 3, opt: !0 },
        { no: 4, name: "last_modified", kind: "message", T: Fet, opt: !0 },
        { no: 5, name: "num_children", kind: "scalar", T: 5, opt: !0 },
        { no: 6, name: "num_lines", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new CT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CT, t, e)
    }
  },
  bJt = class JT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListDirStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new JT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JT, t, e)
    }
  },
  TJt = class LT extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.readEntireFile = !1),
        (this.fileIsAllowedToBeReadEntirely = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "read_entire_file", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "start_line_one_indexed",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "end_line_one_indexed_inclusive",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "file_is_allowed_to_be_read_entirely",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new LT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LT, t, e)
    }
  },
  kJt = class RT extends h {
    constructor(t) {
      super(),
        (this.contents = ""),
        (this.didDowngradeToLineRange = !1),
        (this.didShortenLineRange = !1),
        (this.didSetDefaultLineRange = !1),
        (this.relativeWorkspacePath = ""),
        (this.didShortenCharRange = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
        { no: 2, name: "did_downgrade_to_line_range", kind: "scalar", T: 8 },
        { no: 3, name: "did_shorten_line_range", kind: "scalar", T: 8 },
        { no: 4, name: "did_set_default_line_range", kind: "scalar", T: 8 },
        { no: 5, name: "full_file_contents", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "outline", kind: "scalar", T: 9, opt: !0 },
        {
          no: 7,
          name: "start_line_one_indexed",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 8,
          name: "end_line_one_indexed_inclusive",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 9, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 10, name: "did_shorten_char_range", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new RT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RT, t, e)
    }
  },
  SJt = class DT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new DT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DT, t, e)
    }
  },
  EJt = class FT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "options", kind: "message", T: $Jt },
        { no: 2, name: "pattern_info", kind: "message", T: IJt },
      ])
    }
    static fromBinary(t, e) {
      return new FT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FT, t, e)
    }
  },
  IJt = class AT extends h {
    constructor(t) {
      super(), (this.pattern = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchParams.IPatternInfoProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "pattern", kind: "scalar", T: 9 },
        { no: 2, name: "is_reg_exp", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "is_word_match", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "word_separators", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "is_multiline", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "is_unicode", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "is_case_sensitive", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "notebook_info", kind: "message", T: PJt },
      ])
    }
    static fromBinary(t, e) {
      return new AT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AT, t, e)
    }
  },
  PJt = class _T extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.IPatternInfoProto.INotebookPatternInfoProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "is_in_notebook_markdown_input",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 2,
          name: "is_in_notebook_markdown_preview",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 3,
          name: "is_in_notebook_cell_input",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 4,
          name: "is_in_notebook_cell_output",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new _T().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _T().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _T().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_T, t, e)
    }
  },
  $Jt = class OT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "preview_options", kind: "message", T: JJt },
        { no: 2, name: "file_encoding", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "surrounding_context", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "is_smart_case", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "notebook_search_config", kind: "message", T: LJt },
        { no: 6, name: "exclude_pattern", kind: "message", T: NJt },
        { no: 7, name: "include_pattern", kind: "message", T: Dnt },
        { no: 8, name: "expand_patterns", kind: "scalar", T: 8, opt: !0 },
        { no: 9, name: "max_results", kind: "scalar", T: 5, opt: !0 },
        { no: 10, name: "max_file_size", kind: "scalar", T: 5, opt: !0 },
        {
          no: 11,
          name: "disregard_ignore_files",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 12,
          name: "disregard_global_ignore_files",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 13,
          name: "disregard_parent_ignore_files",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 14,
          name: "disregard_exclude_settings",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 15,
          name: "disregard_search_exclude_settings",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 16, name: "ignore_symlinks", kind: "scalar", T: 8, opt: !0 },
        { no: 17, name: "only_open_editors", kind: "scalar", T: 8, opt: !0 },
        { no: 18, name: "only_file_scheme", kind: "scalar", T: 8, opt: !0 },
        { no: 19, name: "reason", kind: "scalar", T: 9, opt: !0 },
        { no: 20, name: "extra_file_resources", kind: "message", T: xJt },
      ])
    }
    static fromBinary(t, e) {
      return new OT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OT, t, e)
    }
  },
  xJt = class BT extends h {
    constructor(t) {
      super(), (this.extraFileResources = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ExtraFileResourcesProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "extra_file_resources",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new BT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BT, t, e)
    }
  },
  NJt = class qT extends h {
    constructor(t) {
      super(), (this.excludePattern = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ExcludePatternProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "exclude_pattern",
          kind: "message",
          T: CJt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new qT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qT, t, e)
    }
  },
  CJt = class UT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ISearchPatternBuilderProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "pattern", kind: "message", T: Dnt },
      ])
    }
    static fromBinary(t, e) {
      return new UT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UT, t, e)
    }
  },
  Dnt = class MT extends h {
    constructor(t) {
      super(), (this.patterns = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ISearchPathPatternBuilderProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "patterns", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new MT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MT, t, e)
    }
  },
  JJt = class HT extends h {
    constructor(t) {
      super(),
        (this.matchLines = 0),
        (this.charsPerLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ITextSearchPreviewOptionsProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "match_lines", kind: "scalar", T: 5 },
        { no: 2, name: "chars_per_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new HT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HT, t, e)
    }
  },
  LJt = class WT extends h {
    constructor(t) {
      super(),
        (this.includeMarkupInput = !1),
        (this.includeMarkupPreview = !1),
        (this.includeCodeInput = !1),
        (this.includeOutput = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.INotebookSearchConfigProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "include_markup_input", kind: "scalar", T: 8 },
        { no: 2, name: "include_markup_preview", kind: "scalar", T: 8 },
        { no: 3, name: "include_code_input", kind: "scalar", T: 8 },
        { no: 4, name: "include_output", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new WT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WT, t, e)
    }
  },
  RJt = class jT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "internal", kind: "message", T: DJt },
      ])
    }
    static fromBinary(t, e) {
      return new jT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jT, t, e)
    }
  },
  DJt = class VT extends h {
    constructor(t) {
      super(),
        (this.results = []),
        (this.messages = []),
        (this.stats = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: FJt, repeated: !0 },
        { no: 2, name: "exit", kind: "enum", T: n.getEnumType(jB), opt: !0 },
        { no: 3, name: "limit_hit", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "messages", kind: "message", T: qJt, repeated: !0 },
        {
          no: 5,
          name: "file_search_stats",
          kind: "message",
          T: UJt,
          oneof: "stats",
        },
        {
          no: 6,
          name: "text_search_stats",
          kind: "message",
          T: MJt,
          oneof: "stats",
        },
      ])
    }
    static fromBinary(t, e) {
      return new VT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VT, t, e)
    }
  },
  Gm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.INFORMATION = 1)] = "INFORMATION"),
    (i[(i.WARNING = 2)] = "WARNING")
})(Gm || (Gm = {})),
  n.util.setEnumType(
    Gm,
    "aiserver.v1.RipgrepSearchResultInternal.TextSearchCompleteMessageType",
    [
      { no: 0, name: "TEXT_SEARCH_COMPLETE_MESSAGE_TYPE_UNSPECIFIED" },
      { no: 1, name: "TEXT_SEARCH_COMPLETE_MESSAGE_TYPE_INFORMATION" },
      { no: 2, name: "TEXT_SEARCH_COMPLETE_MESSAGE_TYPE_WARNING" },
    ],
  )
var jB
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NORMAL = 1)] = "NORMAL"),
    (i[(i.NEW_SEARCH_STARTED = 2)] = "NEW_SEARCH_STARTED")
})(jB || (jB = {})),
  n.util.setEnumType(
    jB,
    "aiserver.v1.RipgrepSearchResultInternal.SearchCompletionExitCode",
    [
      { no: 0, name: "SEARCH_COMPLETION_EXIT_CODE_UNSPECIFIED" },
      { no: 1, name: "SEARCH_COMPLETION_EXIT_CODE_NORMAL" },
      { no: 2, name: "SEARCH_COMPLETION_EXIT_CODE_NEW_SEARCH_STARTED" },
    ],
  )
var FJt = class GT extends h {
    constructor(t) {
      super(),
        (this.resource = ""),
        (this.results = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.IFileMatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "resource", kind: "scalar", T: 9 },
        { no: 2, name: "results", kind: "message", T: AJt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new GT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GT, t, e)
    }
  },
  AJt = class zT extends h {
    constructor(t) {
      super(), (this.result = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ITextSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "match", kind: "message", T: _Jt, oneof: "result" },
        { no: 2, name: "context", kind: "message", T: OJt, oneof: "result" },
      ])
    }
    static fromBinary(t, e) {
      return new zT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zT, t, e)
    }
  },
  _Jt = class YT extends h {
    constructor(t) {
      super(),
        (this.rangeLocations = []),
        (this.previewText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.ITextSearchMatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "range_locations",
          kind: "message",
          T: BJt,
          repeated: !0,
        },
        { no: 3, name: "preview_text", kind: "scalar", T: 9 },
        { no: 4, name: "webview_index", kind: "scalar", T: 5, opt: !0 },
        { no: 5, name: "cell_fragment", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new YT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YT, t, e)
    }
  },
  OJt = class QT extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ITextSearchContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new QT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QT, t, e)
    }
  },
  BJt = class XT extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ISearchRangeSetPairing"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "source", kind: "message", T: Fnt },
        { no: 2, name: "preview", kind: "message", T: Fnt },
      ])
    }
    static fromBinary(t, e) {
      return new XT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XT, t, e)
    }
  },
  Fnt = class KT extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.ISearchRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new KT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KT, t, e)
    }
  },
  qJt = class ZT extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.type = Gm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ITextSearchCompleteMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "type", kind: "enum", T: n.getEnumType(Gm) },
        { no: 3, name: "trusted", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ZT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZT, t, e)
    }
  },
  UJt = class tk extends h {
    constructor(t) {
      super(),
        (this.fromCache = !1),
        (this.detailStats = { case: void 0 }),
        (this.resultCount = 0),
        (this.type = zm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.IFileSearchStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "from_cache", kind: "scalar", T: 8 },
        {
          no: 2,
          name: "search_engine_stats",
          kind: "message",
          T: HJt,
          oneof: "detail_stats",
        },
        {
          no: 3,
          name: "cached_search_stats",
          kind: "message",
          T: WJt,
          oneof: "detail_stats",
        },
        {
          no: 4,
          name: "file_search_provider_stats",
          kind: "message",
          T: jJt,
          oneof: "detail_stats",
        },
        { no: 5, name: "result_count", kind: "scalar", T: 5 },
        { no: 6, name: "type", kind: "enum", T: n.getEnumType(zm) },
        { no: 7, name: "sorting_time", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tk, t, e)
    }
  },
  zm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FILE_SEARCH_PROVIDER = 1)] = "FILE_SEARCH_PROVIDER"),
    (i[(i.SEARCH_PROCESS = 2)] = "SEARCH_PROCESS")
})(zm || (zm = {})),
  n.util.setEnumType(
    zm,
    "aiserver.v1.RipgrepSearchResultInternal.IFileSearchStats.FileSearchProviderType",
    [
      { no: 0, name: "FILE_SEARCH_PROVIDER_TYPE_UNSPECIFIED" },
      { no: 1, name: "FILE_SEARCH_PROVIDER_TYPE_FILE_SEARCH_PROVIDER" },
      { no: 2, name: "FILE_SEARCH_PROVIDER_TYPE_SEARCH_PROCESS" },
    ],
  )
var MJt = class ek extends h {
    constructor(t) {
      super(), (this.type = Ym.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.ITextSearchStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(Ym) },
      ])
    }
    static fromBinary(t, e) {
      return new ek().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ek().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ek().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ek, t, e)
    }
  },
  Ym
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.TEXT_SEARCH_PROVIDER = 1)] = "TEXT_SEARCH_PROVIDER"),
    (i[(i.SEARCH_PROCESS = 2)] = "SEARCH_PROCESS"),
    (i[(i.AI_TEXT_SEARCH_PROVIDER = 3)] = "AI_TEXT_SEARCH_PROVIDER")
})(Ym || (Ym = {})),
  n.util.setEnumType(
    Ym,
    "aiserver.v1.RipgrepSearchResultInternal.ITextSearchStats.TextSearchProviderType",
    [
      { no: 0, name: "TEXT_SEARCH_PROVIDER_TYPE_UNSPECIFIED" },
      { no: 1, name: "TEXT_SEARCH_PROVIDER_TYPE_TEXT_SEARCH_PROVIDER" },
      { no: 2, name: "TEXT_SEARCH_PROVIDER_TYPE_SEARCH_PROCESS" },
      { no: 3, name: "TEXT_SEARCH_PROVIDER_TYPE_AI_TEXT_SEARCH_PROVIDER" },
    ],
  )
var HJt = class ik extends h {
    constructor(t) {
      super(),
        (this.fileWalkTime = 0),
        (this.directoriesWalked = 0),
        (this.filesWalked = 0),
        (this.cmdTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ISearchEngineStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_walk_time", kind: "scalar", T: 5 },
        { no: 2, name: "directories_walked", kind: "scalar", T: 5 },
        { no: 3, name: "files_walked", kind: "scalar", T: 5 },
        { no: 4, name: "cmd_time", kind: "scalar", T: 5 },
        { no: 5, name: "cmd_result_count", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ik().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ik().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ik().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ik, t, e)
    }
  },
  WJt = class sk extends h {
    constructor(t) {
      super(),
        (this.cacheWasResolved = !1),
        (this.cacheLookupTime = 0),
        (this.cacheFilterTime = 0),
        (this.cacheEntryCount = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ICachedSearchStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cache_was_resolved", kind: "scalar", T: 8 },
        { no: 2, name: "cache_lookup_time", kind: "scalar", T: 5 },
        { no: 3, name: "cache_filter_time", kind: "scalar", T: 5 },
        { no: 4, name: "cache_entry_count", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new sk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sk, t, e)
    }
  },
  jJt = class rk extends h {
    constructor(t) {
      super(),
        (this.providerTime = 0),
        (this.postProcessTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.IFileSearchProviderStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "provider_time", kind: "scalar", T: 5 },
        { no: 2, name: "post_process_time", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new rk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rk, t, e)
    }
  },
  VJt = class nk extends h {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nk, t, e)
    }
  },
  Ant = class ak extends h {
    constructor(t) {
      super(),
        (this.codeResults = []),
        (this.query = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadSemsearchFilesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository_info", kind: "message", T: Mt },
        { no: 2, name: "code_results", kind: "message", T: xi, repeated: !0 },
        { no: 3, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ak().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ak().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ak().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ak, t, e)
    }
  },
  _nt = class ok extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.missingReason = Qm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MissingFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "missing_reason", kind: "enum", T: n.getEnumType(Qm) },
        { no: 3, name: "num_lines", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ok().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ok().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ok().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ok, t, e)
    }
  },
  Qm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.TOO_LARGE = 1)] = "TOO_LARGE"),
    (i[(i.NOT_FOUND = 2)] = "NOT_FOUND")
})(Qm || (Qm = {})),
  n.util.setEnumType(Qm, "aiserver.v1.MissingFile.MissingReason", [
    { no: 0, name: "MISSING_REASON_UNSPECIFIED" },
    { no: 1, name: "MISSING_REASON_TOO_LARGE" },
    { no: 2, name: "MISSING_REASON_NOT_FOUND" },
  ])
var Ont = class ck extends h {
    constructor(t) {
      super(),
        (this.codeResults = []),
        (this.allFiles = []),
        (this.missingFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadSemsearchFilesResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: xi, repeated: !0 },
        { no: 2, name: "all_files", kind: "message", T: ks, repeated: !0 },
        { no: 3, name: "missing_files", kind: "message", T: _nt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ck().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ck().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ck().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ck, t, e)
    }
  },
  GJt = class lk extends h {
    constructor(t) {
      super(), (this.numFiles = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadSemsearchFilesStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_files", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new lk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lk, t, e)
    }
  },
  zJt = class uk extends h {
    constructor(t) {
      super(), (this.targetFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelatedFilesStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "target_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uk, t, e)
    }
  },
  YJt = class hk extends h {
    constructor(t) {
      super(), (this.query = ""), (this.topK = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchFullParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository_info", kind: "message", T: Mt },
        { no: 2, name: "query", kind: "scalar", T: 9 },
        { no: 3, name: "include_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "exclude_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "top_k", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new hk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hk, t, e)
    }
  },
  QJt = class dk extends h {
    constructor(t) {
      super(),
        (this.codeResults = []),
        (this.allFiles = []),
        (this.missingFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchFullResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: xi, repeated: !0 },
        { no: 2, name: "all_files", kind: "message", T: ks, repeated: !0 },
        { no: 3, name: "missing_files", kind: "message", T: _nt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new dk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dk, t, e)
    }
  },
  XJt = class mk extends h {
    constructor(t) {
      super(), (this.numFiles = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchFullStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_files", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new mk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mk, t, e)
    }
  },
  KJt = class fk extends h {
    constructor(t) {
      super(), (this.relativeFilePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileForImportsStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new fk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fk, t, e)
    }
  },
  Bnt = class pk extends h {
    constructor(t) {
      super(), (this.relativeFilePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileForImportsParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new pk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pk, t, e)
    }
  },
  ZJt = class gk extends h {
    constructor(t) {
      super(), (this.contents = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileForImportsResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new gk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gk, t, e)
    }
  },
  tLt = class vk extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateFileStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new vk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vk, t, e)
    }
  },
  qnt = class wk extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new wk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wk, t, e)
    }
  },
  Unt = class yk extends h {
    constructor(t) {
      super(),
        (this.fileCreatedSuccessfully = !1),
        (this.fileAlreadyExists = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_created_successfully", kind: "scalar", T: 8 },
        { no: 2, name: "file_already_exists", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new yk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yk, t, e)
    }
  },
  Mnt = class bk extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bk, t, e)
    }
  },
  Hnt = class Tk extends h {
    constructor(t) {
      super(),
        (this.rejected = !1),
        (this.fileNonExistent = !1),
        (this.fileDeletedSuccessfully = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "rejected", kind: "scalar", T: 8 },
        { no: 2, name: "file_non_existent", kind: "scalar", T: 8 },
        { no: 3, name: "file_deleted_successfully", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Tk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tk, t, e)
    }
  },
  eLt = class kk extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteFileStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kk, t, e)
    }
  },
  iLt = class Sk extends h {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.requireUserApproval = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "cwd", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "new_session", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "require_user_approval", kind: "scalar", T: 8 },
        { no: 4, name: "options", kind: "message", T: sLt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Sk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sk, t, e)
    }
  },
  sLt = class Ek extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandParams.ExecutionOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "timeout", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "skip_ai_check", kind: "scalar", T: 8, opt: !0 },
        {
          no: 3,
          name: "command_run_timeout_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "command_change_check_interval_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "ai_finish_check_max_attempts",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 6,
          name: "ai_finish_check_interval_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 7, name: "delayer_interval_ms", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ek().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ek().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ek().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ek, t, e)
    }
  },
  rLt = class Ik extends h {
    constructor(t) {
      super(),
        (this.output = ""),
        (this.exitCode = 0),
        (this.poppedOutIntoBackground = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "scalar", T: 9 },
        { no: 2, name: "exit_code", kind: "scalar", T: 5 },
        { no: 3, name: "rejected", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "popped_out_into_background", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Ik().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ik().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ik().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ik, t, e)
    }
  },
  nLt = class Pk extends h {
    constructor(t) {
      super(), (this.command = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Pk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pk, t, e)
    }
  },
  aLt = class $k extends h {
    constructor(t) {
      super(),
        (this.tool = Oo.UNSPECIFIED),
        (this.params = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BuiltinToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(Oo) },
        {
          no: 2,
          name: "search_params",
          kind: "message",
          T: ILt,
          oneof: "params",
        },
        {
          no: 3,
          name: "read_chunk_params",
          kind: "message",
          T: NLt,
          oneof: "params",
        },
        {
          no: 4,
          name: "gotodef_params",
          kind: "message",
          T: OLt,
          oneof: "params",
        },
        {
          no: 5,
          name: "edit_params",
          kind: "message",
          T: jLt,
          oneof: "params",
        },
        {
          no: 6,
          name: "undo_edit_params",
          kind: "message",
          T: JLt,
          oneof: "params",
        },
        { no: 7, name: "end_params", kind: "message", T: LLt, oneof: "params" },
        {
          no: 8,
          name: "new_file_params",
          kind: "message",
          T: TLt,
          oneof: "params",
        },
        {
          no: 9,
          name: "add_test_params",
          kind: "message",
          T: YLt,
          oneof: "params",
        },
        {
          no: 10,
          name: "run_test_params",
          kind: "message",
          T: ZLt,
          oneof: "params",
        },
        {
          no: 11,
          name: "delete_test_params",
          kind: "message",
          T: r5t,
          oneof: "params",
        },
        {
          no: 12,
          name: "save_file_params",
          kind: "message",
          T: a5t,
          oneof: "params",
        },
        {
          no: 13,
          name: "get_tests_params",
          kind: "message",
          T: e5t,
          oneof: "params",
        },
        {
          no: 14,
          name: "get_symbols_params",
          kind: "message",
          T: c5t,
          oneof: "params",
        },
        {
          no: 15,
          name: "semantic_search_params",
          kind: "message",
          T: kLt,
          oneof: "params",
        },
        {
          no: 16,
          name: "get_project_structure_params",
          kind: "message",
          T: wLt,
          oneof: "params",
        },
        {
          no: 17,
          name: "create_rm_files_params",
          kind: "message",
          T: gLt,
          oneof: "params",
        },
        {
          no: 18,
          name: "run_terminal_commands_params",
          kind: "message",
          T: fLt,
          oneof: "params",
        },
        {
          no: 19,
          name: "new_edit_params",
          kind: "message",
          T: HLt,
          oneof: "params",
        },
        {
          no: 20,
          name: "read_with_linter_params",
          kind: "message",
          T: dLt,
          oneof: "params",
        },
        {
          no: 21,
          name: "add_ui_step_params",
          kind: "message",
          T: cLt,
          oneof: "params",
        },
        {
          no: 23,
          name: "read_semsearch_files_params",
          kind: "message",
          T: Ant,
          oneof: "params",
        },
        {
          no: 24,
          name: "read_file_for_imports_params",
          kind: "message",
          T: Bnt,
          oneof: "params",
        },
        {
          no: 25,
          name: "create_file_params",
          kind: "message",
          T: qnt,
          oneof: "params",
        },
        {
          no: 26,
          name: "delete_file_params",
          kind: "message",
          T: Mnt,
          oneof: "params",
        },
        { no: 22, name: "tool_call_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new $k().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $k().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $k().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($k, t, e)
    }
  },
  oLt = class xk extends h {
    constructor(t) {
      super(),
        (this.tool = Oo.UNSPECIFIED),
        (this.result = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BuiltinToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(Oo) },
        {
          no: 2,
          name: "search_result",
          kind: "message",
          T: xLt,
          oneof: "result",
        },
        {
          no: 3,
          name: "read_chunk_result",
          kind: "message",
          T: CLt,
          oneof: "result",
        },
        {
          no: 4,
          name: "gotodef_result",
          kind: "message",
          T: ULt,
          oneof: "result",
        },
        {
          no: 5,
          name: "edit_result",
          kind: "message",
          T: VLt,
          oneof: "result",
        },
        {
          no: 6,
          name: "undo_edit_result",
          kind: "message",
          T: DLt,
          oneof: "result",
        },
        { no: 7, name: "end_result", kind: "message", T: FLt, oneof: "result" },
        {
          no: 8,
          name: "new_file_result",
          kind: "message",
          T: RLt,
          oneof: "result",
        },
        {
          no: 9,
          name: "add_test_result",
          kind: "message",
          T: QLt,
          oneof: "result",
        },
        {
          no: 10,
          name: "run_test_result",
          kind: "message",
          T: t5t,
          oneof: "result",
        },
        {
          no: 11,
          name: "delete_test_result",
          kind: "message",
          T: n5t,
          oneof: "result",
        },
        {
          no: 12,
          name: "save_file_result",
          kind: "message",
          T: o5t,
          oneof: "result",
        },
        {
          no: 13,
          name: "get_tests_result",
          kind: "message",
          T: i5t,
          oneof: "result",
        },
        {
          no: 14,
          name: "get_symbols_result",
          kind: "message",
          T: u5t,
          oneof: "result",
        },
        {
          no: 15,
          name: "semantic_search_result",
          kind: "message",
          T: SLt,
          oneof: "result",
        },
        {
          no: 16,
          name: "get_project_structure_result",
          kind: "message",
          T: yLt,
          oneof: "result",
        },
        {
          no: 17,
          name: "create_rm_files_result",
          kind: "message",
          T: vLt,
          oneof: "result",
        },
        {
          no: 18,
          name: "run_terminal_commands_result",
          kind: "message",
          T: pLt,
          oneof: "result",
        },
        {
          no: 19,
          name: "new_edit_result",
          kind: "message",
          T: WLt,
          oneof: "result",
        },
        {
          no: 20,
          name: "read_with_linter_result",
          kind: "message",
          T: mLt,
          oneof: "result",
        },
        {
          no: 21,
          name: "add_ui_step_result",
          kind: "message",
          T: hLt,
          oneof: "result",
        },
        {
          no: 22,
          name: "read_semsearch_files_result",
          kind: "message",
          T: Ont,
          oneof: "result",
        },
        {
          no: 23,
          name: "create_file_result",
          kind: "message",
          T: Unt,
          oneof: "result",
        },
        {
          no: 24,
          name: "delete_file_result",
          kind: "message",
          T: Hnt,
          oneof: "result",
        },
      ])
    }
    static fromBinary(t, e) {
      return new xk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xk, t, e)
    }
  },
  cLt = class Nk extends h {
    constructor(t) {
      super(),
        (this.conversationId = ""),
        (this.step = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddUiStepParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "search_results",
          kind: "message",
          T: uLt,
          oneof: "step",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Nk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nk, t, e)
    }
  },
  lLt = class Ck extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddUiStepParams.SearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ck().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ck().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ck().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ck, t, e)
    }
  },
  uLt = class Jk extends h {
    constructor(t) {
      super(), (this.searchResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddUiStepParams.SearchResults"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "search_results",
          kind: "message",
          T: lLt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Jk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jk, t, e)
    }
  },
  hLt = class Lk extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddUiStepResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Lk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lk, t, e)
    }
  },
  CXt = class Rk extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ServerSideToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Rk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rk, t, e)
    }
  },
  Wnt = class Dk extends h {
    constructor(t) {
      super(), (this.toolCall = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "builtin_tool_call",
          kind: "message",
          T: aLt,
          oneof: "tool_call",
        },
        {
          no: 2,
          name: "custom_tool_call",
          kind: "message",
          T: ALt,
          oneof: "tool_call",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Dk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dk, t, e)
    }
  },
  DW = class Fk extends h {
    constructor(t) {
      super(), (this.toolResult = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "builtin_tool_result",
          kind: "message",
          T: oLt,
          oneof: "tool_result",
        },
        {
          no: 2,
          name: "custom_tool_result",
          kind: "message",
          T: _Lt,
          oneof: "tool_result",
        },
        {
          no: 3,
          name: "error_tool_result",
          kind: "message",
          T: MLt,
          oneof: "tool_result",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Fk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fk, t, e)
    }
  },
  dLt = class Ak extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadWithLinterParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ak().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ak().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ak().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ak, t, e)
    }
  },
  mLt = class _k extends h {
    constructor(t) {
      super(),
        (this.contents = ""),
        (this.diagnostics = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadWithLinterResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
        { no: 2, name: "diagnostics", kind: "message", T: Oet, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _k().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _k().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _k().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_k, t, e)
    }
  },
  fLt = class Ok extends h {
    constructor(t) {
      super(),
        (this.commands = []),
        (this.commandsUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandsParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commands", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "commands_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ok().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ok().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ok().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ok, t, e)
    }
  },
  pLt = class Bk extends h {
    constructor(t) {
      super(), (this.outputs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandsResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "outputs", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Bk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bk, t, e)
    }
  },
  gLt = class qk extends h {
    constructor(t) {
      super(),
        (this.removedFilePaths = []),
        (this.createdFilePaths = []),
        (this.createdDirectoryPaths = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateRmFilesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "removed_file_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 2,
          name: "created_file_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 3,
          name: "created_directory_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new qk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qk, t, e)
    }
  },
  vLt = class Uk extends h {
    constructor(t) {
      super(),
        (this.createdFilePaths = []),
        (this.removedFilePaths = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateRmFilesResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "created_file_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 2,
          name: "removed_file_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Uk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Uk, t, e)
    }
  },
  wLt = class Mk extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetProjectStructureParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Mk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mk, t, e)
    }
  },
  yLt = class Hk extends h {
    constructor(t) {
      super(),
        (this.files = []),
        (this.rootWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetProjectStructureResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: bLt, repeated: !0 },
        { no: 2, name: "root_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Hk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hk, t, e)
    }
  },
  bLt = class Wk extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.outline = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetProjectStructureResult.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "outline", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Wk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wk, t, e)
    }
  },
  TLt = class jk extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jk, t, e)
    }
  },
  kLt = class Vk extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.topK = 0),
        (this.grabWholeFile = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "include_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "exclude_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "top_k", kind: "scalar", T: 5 },
        { no: 5, name: "index_id", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "grab_whole_file", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Vk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vk, t, e)
    }
  },
  SLt = class Gk extends h {
    constructor(t) {
      super(),
        (this.results = []),
        (this.files = {}),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: ELt, repeated: !0 },
        {
          no: 2,
          name: "files",
          kind: "map",
          K: 9,
          V: { kind: "scalar", T: 9 },
        },
      ])
    }
    static fromBinary(t, e) {
      return new Gk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gk, t, e)
    }
  },
  ELt = class zk extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.score = 0),
        (this.content = ""),
        (this.detailedLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchResult.Item"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "score", kind: "scalar", T: 2 },
        { no: 3, name: "content", kind: "scalar", T: 9 },
        { no: 4, name: "range", kind: "message", T: Pi },
        { no: 5, name: "original_content", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "detailed_lines", kind: "message", T: PM, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zk, t, e)
    }
  },
  ILt = class Yk extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.regex = !1),
        (this.includePattern = ""),
        (this.excludePattern = ""),
        (this.filenameSearch = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "regex", kind: "scalar", T: 8 },
        { no: 3, name: "include_pattern", kind: "scalar", T: 9 },
        { no: 4, name: "exclude_pattern", kind: "scalar", T: 9 },
        { no: 5, name: "filename_search", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Yk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yk, t, e)
    }
  },
  PLt = class Qk extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.numMatches = 0),
        (this.potentiallyRelevantLines = []),
        (this.cropped = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchToolFileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "num_matches", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "potentially_relevant_lines",
          kind: "message",
          T: $Lt,
          repeated: !0,
        },
        { no: 4, name: "cropped", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Qk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qk, t, e)
    }
  },
  $Lt = class Xk extends h {
    constructor(t) {
      super(),
        (this.lineNumber = 0),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchToolFileSearchResult.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line_number", kind: "scalar", T: 5 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Xk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xk, t, e)
    }
  },
  xLt = class Kk extends h {
    constructor(t) {
      super(),
        (this.fileResults = []),
        (this.numTotalMatches = 0),
        (this.numTotalMatchedFiles = 0),
        (this.numTotalMayBeIncomplete = !1),
        (this.filesOnly = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_results", kind: "message", T: PLt, repeated: !0 },
        { no: 2, name: "num_total_matches", kind: "scalar", T: 5 },
        { no: 3, name: "num_total_matched_files", kind: "scalar", T: 5 },
        { no: 4, name: "num_total_may_be_incomplete", kind: "scalar", T: 8 },
        { no: 5, name: "files_only", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Kk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kk, t, e)
    }
  },
  NLt = class Zk extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadChunkParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "num_lines", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Zk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zk, t, e)
    }
  },
  CLt = class tS extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        (this.totalNumLines = 0),
        (this.cropped = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadChunkResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "total_num_lines", kind: "scalar", T: 5 },
        { no: 5, name: "cropped", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new tS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tS, t, e)
    }
  },
  JLt = class eS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UndoEditParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new eS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eS, t, e)
    }
  },
  LLt = class iS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EndParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new iS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iS, t, e)
    }
  },
  RLt = class sS extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileTotalLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_total_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new sS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sS, t, e)
    }
  },
  DLt = class rS extends h {
    constructor(t) {
      super(),
        (this.feedback = []),
        (this.relativeWorkspacePath = ""),
        (this.contextStartLineNumber = 0),
        (this.contextLines = []),
        (this.contextTotalNumLines = 0),
        (this.fileTotalLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UndoEditResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "context_start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "context_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "context_total_num_lines", kind: "scalar", T: 5 },
        { no: 6, name: "file_total_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new rS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rS, t, e)
    }
  },
  FLt = class nS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EndResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new nS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nS, t, e)
    }
  },
  ALt = class aS extends h {
    constructor(t) {
      super(),
        (this.toolId = ""),
        (this.params = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_id", kind: "scalar", T: 9 },
        { no: 2, name: "params", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new aS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aS, t, e)
    }
  },
  JXt = class oS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ScratchpadResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new oS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oS, t, e)
    }
  },
  _Lt = class cS extends h {
    constructor(t) {
      super(),
        (this.toolId = ""),
        (this.result = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_id", kind: "scalar", T: 9 },
        { no: 2, name: "result", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cS, t, e)
    }
  },
  OLt = class lS extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lineNumber = 0),
        (this.symbol = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GotodefParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "symbol", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lS, t, e)
    }
  },
  BLt = class uS extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.potentiallyRelevantLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GotodefToolFileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "potentially_relevant_lines",
          kind: "message",
          T: qLt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new uS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uS, t, e)
    }
  },
  qLt = class hS extends h {
    constructor(t) {
      super(),
        (this.lineNumber = 0),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GotodefToolFileSearchResult.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line_number", kind: "scalar", T: 5 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new hS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hS, t, e)
    }
  },
  ULt = class dS extends h {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GotodefResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: BLt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new dS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dS, t, e)
    }
  },
  MLt = class mS extends h {
    constructor(t) {
      super(), (this.errorMessage = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ErrorToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new mS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mS, t, e)
    }
  },
  HLt = class fS extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.editId = ""),
        (this.firstEdit = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewEditParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
        { no: 5, name: "edit_id", kind: "scalar", T: 9 },
        { no: 6, name: "first_edit", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new fS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fS, t, e)
    }
  },
  WLt = class pS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewEditResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new pS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pS, t, e)
    }
  },
  jLt = class gS extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.replaceNumLines = 0),
        (this.newLines = []),
        (this.editId = ""),
        (this.frontendEditType = Xm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "replace_num_lines", kind: "scalar", T: 5 },
        { no: 4, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 7, name: "replace_whole_file", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "edit_id", kind: "scalar", T: 9 },
        {
          no: 6,
          name: "frontend_edit_type",
          kind: "enum",
          T: n.getEnumType(Xm),
        },
        {
          no: 8,
          name: "auto_fix_all_linter_errors_in_file",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new gS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gS, t, e)
    }
  },
  Xm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.INLINE_DIFFS = 1)] = "INLINE_DIFFS"),
    (i[(i.SIMPLE = 2)] = "SIMPLE")
})(Xm || (Xm = {})),
  n.util.setEnumType(Xm, "aiserver.v1.EditParams.FrontendEditType", [
    { no: 0, name: "FRONTEND_EDIT_TYPE_UNSPECIFIED" },
    { no: 1, name: "FRONTEND_EDIT_TYPE_INLINE_DIFFS" },
    { no: 2, name: "FRONTEND_EDIT_TYPE_SIMPLE" },
  ])
var VLt = class vS extends h {
    constructor(t) {
      super(),
        (this.feedback = []),
        (this.contextStartLineNumber = 0),
        (this.contextLines = []),
        (this.file = ""),
        (this.fileTotalLines = 0),
        (this.structuredFeedback = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "context_start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "context_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "file", kind: "scalar", T: 9 },
        { no: 5, name: "file_total_lines", kind: "scalar", T: 5 },
        {
          no: 6,
          name: "structured_feedback",
          kind: "message",
          T: zLt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vS, t, e)
    }
  },
  GLt = class wS extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditResult.RelatedInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new wS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wS, t, e)
    }
  },
  zLt = class yS extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.relatedInformation = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditResult.Feedback"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_line_number", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "related_information",
          kind: "message",
          T: GLt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new yS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yS, t, e)
    }
  },
  YLt = class bS extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.testName = ""),
        (this.testCode = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddTestParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "test_name", kind: "scalar", T: 9 },
        { no: 3, name: "test_code", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bS, t, e)
    }
  },
  QLt = class TS extends h {
    constructor(t) {
      super(), (this.feedback = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddTestResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback", kind: "message", T: KLt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new TS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TS, t, e)
    }
  },
  XLt = class kS extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddTestResult.RelatedInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kS, t, e)
    }
  },
  KLt = class SS extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.relatedInformation = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddTestResult.Feedback"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_line_number", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "related_information",
          kind: "message",
          T: XLt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new SS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SS, t, e)
    }
  },
  ZLt = class ES extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTestParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "test_name", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ES().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ES().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ES().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ES, t, e)
    }
  },
  t5t = class IS extends h {
    constructor(t) {
      super(), (this.result = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTestResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "result", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new IS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IS, t, e)
    }
  },
  e5t = class PS extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTestsParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PS, t, e)
    }
  },
  i5t = class $S extends h {
    constructor(t) {
      super(), (this.tests = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTestsResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tests", kind: "message", T: s5t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new $S().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $S().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $S().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($S, t, e)
    }
  },
  s5t = class xS extends h {
    constructor(t) {
      super(), (this.name = ""), (this.lines = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTestsResult.Test"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new xS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xS, t, e)
    }
  },
  r5t = class NS extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteTestParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "test_name", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new NS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NS, t, e)
    }
  },
  n5t = class CS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteTestResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new CS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CS, t, e)
    }
  },
  a5t = class JS extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SaveFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JS, t, e)
    }
  },
  o5t = class LS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SaveFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new LS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LS, t, e)
    }
  },
  c5t = class RS extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.includeChildren = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSymbolsParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_range", kind: "message", T: l5t, opt: !0 },
        { no: 3, name: "include_children", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new RS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RS, t, e)
    }
  },
  l5t = class DS extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumberInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSymbolsParams.LineRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new DS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DS, t, e)
    }
  },
  u5t = class FS extends h {
    constructor(t) {
      super(), (this.symbols = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSymbolsResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbols", kind: "message", T: xM, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new FS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FS, t, e)
    }
  },
  h5t = class AS extends h {
    constructor(t) {
      super(),
        (this.editPlan = ""),
        (this.fileRegions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "edit_plan", kind: "scalar", T: 9 },
        { no: 2, name: "file_regions", kind: "message", T: d5t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new AS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AS, t, e)
    }
  },
  d5t = class _S extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyParams.FileRegion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Pi },
      ])
    }
    static fromBinary(t, e) {
      return new _S().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _S().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _S().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_S, t, e)
    }
  },
  m5t = class OS extends h {
    constructor(t) {
      super(), (this.fileResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_results", kind: "message", T: f5t, repeated: !0 },
        { no: 2, name: "error", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new OS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OS, t, e)
    }
  },
  f5t = class BS extends h {
    constructor(t) {
      super(),
        (this.filePath = ""),
        (this.isApplied = !1),
        (this.applyFailed = !1),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyResult.FileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_path", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "message", T: RW },
        { no: 3, name: "is_applied", kind: "scalar", T: 8 },
        { no: 4, name: "apply_failed", kind: "scalar", T: 8 },
        { no: 5, name: "error", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "linter_errors", kind: "message", T: ka, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new BS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BS, t, e)
    }
  },
  p5t = class qS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new qS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qS, t, e)
    }
  },
  g5t = class US extends h {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.isBackground = !1),
        (this.requireUserApproval = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandV2Params"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "cwd", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "new_session", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "options", kind: "message", T: v5t, opt: !0 },
        { no: 5, name: "is_background", kind: "scalar", T: 8 },
        { no: 6, name: "require_user_approval", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new US().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new US().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new US().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(US, t, e)
    }
  },
  v5t = class MS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandV2Params.ExecutionOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "timeout", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "skip_ai_check", kind: "scalar", T: 8, opt: !0 },
        {
          no: 3,
          name: "command_run_timeout_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "command_change_check_interval_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "ai_finish_check_max_attempts",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 6,
          name: "ai_finish_check_interval_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 7, name: "delayer_interval_ms", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new MS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MS, t, e)
    }
  },
  w5t = class HS extends h {
    constructor(t) {
      super(),
        (this.output = ""),
        (this.exitCode = 0),
        (this.poppedOutIntoBackground = !1),
        (this.isRunningInBackground = !1),
        (this.notInterrupted = !1),
        (this.resultingWorkingDirectory = ""),
        (this.didUserChange = !1),
        (this.endedReason = Hl.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandV2Result"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "scalar", T: 9 },
        { no: 2, name: "exit_code", kind: "scalar", T: 5 },
        { no: 3, name: "rejected", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "popped_out_into_background", kind: "scalar", T: 8 },
        { no: 5, name: "is_running_in_background", kind: "scalar", T: 8 },
        { no: 6, name: "not_interrupted", kind: "scalar", T: 8 },
        { no: 7, name: "resulting_working_directory", kind: "scalar", T: 9 },
        { no: 8, name: "did_user_change", kind: "scalar", T: 8 },
        { no: 9, name: "ended_reason", kind: "enum", T: n.getEnumType(Hl) },
        { no: 10, name: "exit_code_v2", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new HS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HS, t, e)
    }
  },
  y5t = class WS extends h {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.isBackground = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandV2Stream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "is_background", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new WS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WS, t, e)
    }
  },
  b5t = class jS extends h {
    constructor(t) {
      super(), (this.ruleNames = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FetchRulesStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "rule_names", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new jS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jS, t, e)
    }
  },
  T5t = class VS extends h {
    constructor(t) {
      super(), (this.instruction = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PlannerStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "scalar", T: 9 },
        { no: 2, name: "plan", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new VS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VS, t, e)
    }
  },
  k5t = class GS extends h {
    constructor(t) {
      super(), (this.searchTerm = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebSearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "search_term", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new GS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GS, t, e)
    }
  },
  S5t = class zS extends h {
    constructor(t) {
      super(), (this.references = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "references", kind: "message", T: E5t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zS, t, e)
    }
  },
  E5t = class YS extends h {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.url = ""),
        (this.chunk = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebSearchResult.WebReference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "chunk", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new YS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YS, t, e)
    }
  },
  I5t = class QS extends h {
    constructor(t) {
      super(), (this.searchTerm = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebSearchStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "search_term", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new QS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QS, t, e)
    }
  },
  P5t = class XS extends h {
    constructor(t) {
      super(), (this.url = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebViewerParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XS, t, e)
    }
  },
  $5t = class KS extends h {
    constructor(t) {
      super(), (this.url = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebViewerResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "screenshot", kind: "message", T: Ea },
      ])
    }
    static fromBinary(t, e) {
      return new KS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KS, t, e)
    }
  },
  x5t = class ZS extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebViewerStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new ZS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZS, t, e)
    }
  },
  N5t = class tE extends h {
    constructor(t) {
      super(), (this.tools = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MCPParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tools", kind: "message", T: FW, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tE, t, e)
    }
  },
  FW = class eE extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.description = ""),
        (this.parameters = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MCPParams.Tool"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "description", kind: "scalar", T: 9 },
        { no: 3, name: "parameters", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new eE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eE, t, e)
    }
  },
  C5t = class iE extends h {
    constructor(t) {
      super(),
        (this.selectedTool = ""),
        (this.result = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MCPResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "selected_tool", kind: "scalar", T: 9 },
        { no: 2, name: "result", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iE, t, e)
    }
  },
  J5t = class sE extends h {
    constructor(t) {
      super(), (this.tools = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MCPStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tools", kind: "message", T: FW, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sE, t, e)
    }
  },
  L5t = class rE extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new rE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rE, t, e)
    }
  },
  R5t = class nE extends h {
    constructor(t) {
      super(), (this.humanChanges = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 40,
          name: "human_changes",
          kind: "message",
          T: F5t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new nE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nE, t, e)
    }
  },
  D5t = class aE extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumberExclusive = 0),
        (this.beforeContextLines = []),
        (this.removedLines = []),
        (this.addedLines = []),
        (this.afterContextLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryResult.RenderedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "before_context_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 4, name: "removed_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "added_lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 6,
          name: "after_context_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new aE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aE, t, e)
    }
  },
  F5t = class oE extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.renderedDiffs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryResult.HumanChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "rendered_diffs",
          kind: "message",
          T: D5t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new oE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oE, t, e)
    }
  },
  A5t = class cE extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new cE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cE, t, e)
    }
  },
  gr
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.READ_WRITE_FILE = 1)] = "READ_WRITE_FILE"),
    (i[(i.RUN_TERM = 2)] = "RUN_TERM"),
    (i[(i.CREATE_RM_FILES = 3)] = "CREATE_RM_FILES")
})(gr || (gr = {})),
  n.util.setEnumType(gr, "aiserver.v1.AiProjectStepType", [
    { no: 0, name: "AI_PROJECT_STEP_TYPE_UNSPECIFIED" },
    { no: 1, name: "AI_PROJECT_STEP_TYPE_READ_WRITE_FILE" },
    { no: 2, name: "AI_PROJECT_STEP_TYPE_RUN_TERM" },
    { no: 3, name: "AI_PROJECT_STEP_TYPE_CREATE_RM_FILES" },
  ])
var _5t = class lE extends h {
    constructor(t) {
      super(), (this.prompt = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectAgentInitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
        { no: 2, name: "prompt", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lE, t, e)
    }
  },
  Km = class uE extends h {
    constructor(t) {
      super(),
        (this.fullUserMessage = ""),
        (this.fullBotMessage = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MessagePayload"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "full_user_message", kind: "scalar", T: 9 },
        { no: 2, name: "full_bot_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new uE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uE, t, e)
    }
  },
  O5t = class hE extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectClarification"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "thought", kind: "scalar", T: 9, oneof: "response" },
        {
          no: 3,
          name: "message_payload",
          kind: "message",
          T: Km,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new hE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hE, t, e)
    }
  },
  B5t = class dE extends h {
    constructor(t) {
      super(),
        (this.clarificationResponse = ""),
        (this.previousMessages = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectClarificationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
        { no: 2, name: "clarification_response", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "previous_messages",
          kind: "message",
          T: Fd,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new dE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dE, t, e)
    }
  },
  jnt = class mE extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectClarificationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "clarification",
          kind: "message",
          T: O5t,
          oneof: "response",
        },
        {
          no: 2,
          name: "repeat_clarification",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new mE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mE, t, e)
    }
  },
  q5t = class fE extends h {
    constructor(t) {
      super(), (this.previousMessages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectAgentPlanRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
        {
          no: 3,
          name: "previous_messages",
          kind: "message",
          T: Fd,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new fE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fE, t, e)
    }
  },
  Vnt = class pE extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectAgentPlanResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "output", kind: "scalar", T: 9, oneof: "response" },
        {
          no: 3,
          name: "message_payload",
          kind: "message",
          T: Km,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new pE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pE, t, e)
    }
  },
  U5t = class gE extends h {
    constructor(t) {
      super(),
        (this.previousMessages = []),
        (this.feedbackOrProgress = ""),
        (this.forceMoveToNextStep = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectPlanFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
        {
          no: 2,
          name: "previous_messages",
          kind: "message",
          T: Fd,
          repeated: !0,
        },
        { no: 3, name: "feedback_or_progress", kind: "scalar", T: 9 },
        { no: 4, name: "force_move_to_next_step", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new gE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gE, t, e)
    }
  },
  M5t = class vE extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectPlanFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "revised_plan",
          kind: "message",
          T: Vnt,
          oneof: "response",
        },
        {
          no: 2,
          name: "repeat_feedback",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new vE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vE, t, e)
    }
  },
  H5t = class wE extends h {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.spec = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
        { no: 2, name: "description", kind: "scalar", T: 9 },
        { no: 3, name: "spec", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new wE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wE, t, e)
    }
  },
  Gnt = class yE extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "step", kind: "message", T: W5t, oneof: "response" },
        {
          no: 3,
          name: "message_payload",
          kind: "message",
          T: Km,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new yE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yE, t, e)
    }
  },
  W5t = class bE extends h {
    constructor(t) {
      super(),
        (this.stepNumber = 0),
        (this.stepDescription = ""),
        (this.stepType = gr.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownResponse.Step"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "step_number", kind: "scalar", T: 5 },
        { no: 2, name: "step_description", kind: "scalar", T: 9 },
        { no: 3, name: "step_type", kind: "enum", T: n.getEnumType(gr) },
      ])
    }
    static fromBinary(t, e) {
      return new bE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bE, t, e)
    }
  },
  j5t = class TE extends h {
    constructor(t) {
      super(),
        (this.previousMessages = []),
        (this.feedbackOrProgress = ""),
        (this.forceMoveToNextStep = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
        {
          no: 2,
          name: "previous_messages",
          kind: "message",
          T: Fd,
          repeated: !0,
        },
        { no: 3, name: "feedback_or_progress", kind: "scalar", T: 9 },
        { no: 4, name: "force_move_to_next_step", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new TE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TE, t, e)
    }
  },
  V5t = class kE extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "revised_breakdown",
          kind: "message",
          T: Gnt,
          oneof: "response",
        },
        {
          no: 2,
          name: "repeat_feedback",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new kE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kE, t, e)
    }
  },
  G5t = class SE extends h {
    constructor(t) {
      super(),
        (this.stepDescription = ""),
        (this.projectPlan = ""),
        (this.projectBreakdown = []),
        (this.stepType = gr.UNSPECIFIED),
        (this.shellType = _o.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
        { no: 2, name: "step_description", kind: "scalar", T: 9 },
        { no: 3, name: "project_plan", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "project_breakdown",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 5, name: "step_type", kind: "enum", T: n.getEnumType(gr) },
        { no: 6, name: "shell_type", kind: "enum", T: n.getEnumType(_o) },
      ])
    }
    static fromBinary(t, e) {
      return new SE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SE, t, e)
    }
  },
  znt = class EE extends h {
    constructor(t) {
      super(),
        (this.response = { case: void 0 }),
        (this.stepType = gr.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "output", kind: "scalar", T: 9, oneof: "response" },
        {
          no: 3,
          name: "message_payload",
          kind: "message",
          T: Km,
          oneof: "response",
        },
        {
          no: 5,
          name: "step_payload",
          kind: "message",
          T: K5t,
          oneof: "response",
        },
        { no: 4, name: "step_type", kind: "enum", T: n.getEnumType(gr) },
      ])
    }
    static fromBinary(t, e) {
      return new EE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EE, t, e)
    }
  },
  z5t = class IE extends h {
    constructor(t) {
      super(), (this.filename = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.WriteCode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "filename", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new IE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IE, t, e)
    }
  },
  Y5t = class PE extends h {
    constructor(t) {
      super(), (this.thought = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.ReviseCode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PE, t, e)
    }
  },
  Q5t = class $E extends h {
    constructor(t) {
      super(),
        (this.commandBatchUuid = ""),
        (this.command = ""),
        (this.response = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.RunTerm"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command_batch_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "command", kind: "scalar", T: 9 },
        { no: 3, name: "response", kind: "scalar", T: 9 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $E().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $E().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $E().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($E, t, e)
    }
  },
  X5t = class xE extends h {
    constructor(t) {
      super(), (this.payload = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.CreatingFiles"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "filename", kind: "scalar", T: 9, oneof: "payload" },
        { no: 2, name: "directory", kind: "scalar", T: 9, oneof: "payload" },
      ])
    }
    static fromBinary(t, e) {
      return new xE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xE, t, e)
    }
  },
  LXt = class NE extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.Nothing"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new NE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NE, t, e)
    }
  },
  K5t = class CE extends h {
    constructor(t) {
      super(), (this.payload = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.StepPayload"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 5,
          name: "write_code",
          kind: "message",
          T: z5t,
          oneof: "payload",
        },
        { no: 6, name: "run_term", kind: "message", T: Q5t, oneof: "payload" },
        {
          no: 7,
          name: "creating_files",
          kind: "message",
          T: X5t,
          oneof: "payload",
        },
        {
          no: 8,
          name: "revise_code",
          kind: "message",
          T: Y5t,
          oneof: "payload",
        },
      ])
    }
    static fromBinary(t, e) {
      return new CE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CE, t, e)
    }
  },
  Z5t = class JE extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: znt,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new JE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JE, t, e)
    }
  },
  tRt = class LE extends h {
    constructor(t) {
      super(),
        (this.stepDescription = ""),
        (this.projectPlan = ""),
        (this.projectBreakdown = []),
        (this.stepType = gr.UNSPECIFIED),
        (this.shellType = _o.UNSPECIFIED),
        (this.previousFeedbackMessages = []),
        (this.forceMoveToNextStep = !1),
        (this.feedbackPayload = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
        { no: 2, name: "step_description", kind: "scalar", T: 9 },
        { no: 3, name: "project_plan", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "project_breakdown",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 5, name: "step_type", kind: "enum", T: n.getEnumType(gr) },
        { no: 6, name: "shell_type", kind: "enum", T: n.getEnumType(_o) },
        {
          no: 7,
          name: "previous_feedback_messages",
          kind: "message",
          T: Fd,
          repeated: !0,
        },
        { no: 8, name: "force_move_to_next_step", kind: "scalar", T: 8 },
        {
          no: 9,
          name: "modify_code_payload",
          kind: "message",
          T: eRt,
          oneof: "feedback_payload",
        },
      ])
    }
    static fromBinary(t, e) {
      return new LE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LE, t, e)
    }
  },
  eRt = class RE extends h {
    constructor(t) {
      super(),
        (this.filesToModify = []),
        (this.feedbackText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.AiProjectStepFeedbackRequest.ModifyCodePayload"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files_to_modify", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "feedback_text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RE, t, e)
    }
  },
  iRt = class DE extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "response_from_feedback",
          kind: "message",
          T: znt,
          oneof: "response",
        },
        {
          no: 2,
          name: "repeat_feedback",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new DE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DE, t, e)
    }
  },
  sRt = class FE extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepFeedbackResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: iRt,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new FE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FE, t, e)
    }
  },
  RXt = class AE extends h {
    constructor(t) {
      super(), (this.code = ""), (this.path = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectAgentWriteCode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "code", kind: "scalar", T: 9 },
        { no: 3, name: "path", kind: "scalar", T: 9 },
        { no: 4, name: "message_payload", kind: "message", T: Km },
      ])
    }
    static fromBinary(t, e) {
      return new AE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AE, t, e)
    }
  },
  Ynt = {
    typeName: "aiserver.v1.AiProjectService",
    methods: {
      aiProjectAgentInit: {
        name: "AiProjectAgentInit",
        I: _5t,
        O: jnt,
        kind: I.ServerStreaming,
      },
      aiProjectClarification: {
        name: "AiProjectClarification",
        I: B5t,
        O: jnt,
        kind: I.ServerStreaming,
      },
      aiProjectPlan: {
        name: "AiProjectPlan",
        I: q5t,
        O: Vnt,
        kind: I.ServerStreaming,
      },
      aiProjectPlanFeedback: {
        name: "AiProjectPlanFeedback",
        I: U5t,
        O: M5t,
        kind: I.ServerStreaming,
      },
      aiProjectBreakdown: {
        name: "AiProjectBreakdown",
        I: H5t,
        O: Gnt,
        kind: I.ServerStreaming,
      },
      aiProjectBreakdownFeedback: {
        name: "AiProjectBreakdownFeedback",
        I: j5t,
        O: V5t,
        kind: I.ServerStreaming,
      },
      aiProjectStep: {
        name: "AiProjectStep",
        I: G5t,
        O: Z5t,
        kind: I.ServerStreaming,
      },
      aiProjectStepFeedback: {
        name: "AiProjectStepFeedback",
        I: tRt,
        O: sRt,
        kind: I.ServerStreaming,
      },
    },
  },
  rRt = class _E extends h {
    constructor(t) {
      super(), (this.mode = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportModeSelectionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "mode", kind: "scalar", T: 9 },
        { no: 2, name: "debug_info", kind: "message", T: Rs },
      ])
    }
    static fromBinary(t, e) {
      return new _E().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _E().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _E().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_E, t, e)
    }
  },
  nRt = class OE extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportModeSelectionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new OE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OE, t, e)
    }
  },
  aRt = class BE extends h {
    constructor(t) {
      super(),
        (this.patchUuid = ""),
        (this.patchString = ""),
        (this.source = ""),
        (this.reflection = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecordAcceptedPatchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "patch_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "patch_string", kind: "scalar", T: 9 },
        { no: 3, name: "source", kind: "scalar", T: 9 },
        { no: 4, name: "reflection", kind: "scalar", T: 9 },
        { no: 5, name: "debug_info", kind: "message", T: Rs },
      ])
    }
    static fromBinary(t, e) {
      return new BE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BE, t, e)
    }
  },
  oRt = class qE extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecordAcceptedPatchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new qE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qE, t, e)
    }
  },
  cRt = class UE extends h {
    constructor(t) {
      super(), (this.ans = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFilePathsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ans", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new UE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UE, t, e)
    }
  },
  lRt = class ME extends h {
    constructor(t) {
      super(), (this.paths = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFilePathsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "paths", kind: "message", T: uRt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ME().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ME().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ME().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ME, t, e)
    }
  },
  uRt = class HE extends h {
    constructor(t) {
      super(),
        (this.rawPath = ""),
        (this.interestingLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFilePathsResponse.Path"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "raw_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "interesting_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new HE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HE, t, e)
    }
  },
  hRt = class WE extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.oldFileContents = ""),
        (this.newFileContents = ""),
        (this.patchString = ""),
        (this.branchNotes = ""),
        (this.branchName = ""),
        (this.highLevelAiAnswer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainReflectRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "old_file_contents", kind: "scalar", T: 9 },
        { no: 3, name: "new_file_contents", kind: "scalar", T: 9 },
        { no: 9, name: "patch_string", kind: "scalar", T: 9 },
        { no: 4, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 5, name: "branch_name", kind: "scalar", T: 9 },
        { no: 6, name: "high_level_ai_answer", kind: "scalar", T: 9 },
        { no: 7, name: "override_model", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "override_token_limit", kind: "scalar", T: 5, opt: !0 },
        { no: 10, name: "lints", kind: "message", T: qB },
      ])
    }
    static fromBinary(t, e) {
      return new WE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WE, t, e)
    }
  },
  dRt = class jE extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainReflectResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "decision", kind: "message", T: gRt },
      ])
    }
    static fromBinary(t, e) {
      return new jE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jE, t, e)
    }
  },
  mRt = class VE extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainReflectResponse.AcceptDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new VE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VE, t, e)
    }
  },
  fRt = class GE extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.OpusChainReflectResponse.RetryWithoutMoreInformationDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new GE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GE, t, e)
    }
  },
  pRt = class zE extends h {
    constructor(t) {
      super(), (this.codebaseQuestions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.OpusChainReflectResponse.RetryWithCodebaseQuestionDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "codebase_questions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new zE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zE, t, e)
    }
  },
  gRt = class YE extends h {
    constructor(t) {
      super(), (this.decision = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainReflectResponse.Decision"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "accept", kind: "message", T: mRt, oneof: "decision" },
        {
          no: 2,
          name: "retry_without_more_information",
          kind: "message",
          T: fRt,
          oneof: "decision",
        },
        {
          no: 3,
          name: "retry_with_codebase_question",
          kind: "message",
          T: pRt,
          oneof: "decision",
        },
      ])
    }
    static fromBinary(t, e) {
      return new YE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YE, t, e)
    }
  },
  vRt = class QE extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.highLevelAiAnswer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFileInstructionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "high_level_ai_answer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new QE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QE, t, e)
    }
  },
  wRt = class XE extends h {
    constructor(t) {
      super(), (this.fileInstruction = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFileInstructionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_instruction", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XE, t, e)
    }
  },
  yRt = class KE extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.branchNotes = ""),
        (this.branchName = ""),
        (this.highLevelAiAnswer = ""),
        (this.originatingReflection = ""),
        (this.scoredCodebaseContext = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetPlanRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        { no: 3, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 4, name: "branch_name", kind: "scalar", T: 9 },
        { no: 5, name: "high_level_ai_answer", kind: "scalar", T: 9 },
        { no: 9, name: "originating_reflection", kind: "scalar", T: 9 },
        { no: 6, name: "override_model", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "override_token_limit", kind: "scalar", T: 5, opt: !0 },
        {
          no: 15,
          name: "scored_codebase_context",
          kind: "message",
          T: xi,
          repeated: !0,
        },
        {
          no: 8,
          name: "codebase_information",
          kind: "message",
          T: bRt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new KE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KE, t, e)
    }
  },
  bRt = class ZE extends h {
    constructor(t) {
      super(), (this.files = []), (this.qa = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetPlanRequest.CodebaseInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: TRt, repeated: !0 },
        { no: 2, name: "qa", kind: "message", T: kRt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ZE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZE, t, e)
    }
  },
  TRt = class tI extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.interestingLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.OpusChainGetPlanRequest.CodebaseInformation.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "interesting_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new tI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tI, t, e)
    }
  },
  kRt = class eI extends h {
    constructor(t) {
      super(),
        (this.question = ""),
        (this.answer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.OpusChainGetPlanRequest.CodebaseInformation.QA"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "question", kind: "scalar", T: 9 },
        { no: 2, name: "answer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new eI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eI, t, e)
    }
  },
  SRt = class iI extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetPlanResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iI, t, e)
    }
  },
  Qnt = {
    typeName: "aiserver.v1.AiBranchService",
    methods: {
      opusChainGetPlan: {
        name: "OpusChainGetPlan",
        I: yRt,
        O: SRt,
        kind: I.ServerStreaming,
      },
      opusChainGetFileInstruction: {
        name: "OpusChainGetFileInstruction",
        I: vRt,
        O: wRt,
        kind: I.Unary,
      },
      opusChainReflect: {
        name: "OpusChainReflect",
        I: hRt,
        O: dRt,
        kind: I.ServerStreaming,
      },
      opusChainGetFilePaths: {
        name: "OpusChainGetFilePaths",
        I: cRt,
        O: lRt,
        kind: I.Unary,
      },
      recordAcceptedPatch: {
        name: "RecordAcceptedPatch",
        I: aRt,
        O: oRt,
        kind: I.Unary,
      },
      reportModeSelection: {
        name: "ReportModeSelection",
        I: rRt,
        O: nRt,
        kind: I.Unary,
      },
    },
  },
  Xnt = class sI extends h {
    constructor(t) {
      super(),
        (this.prefixUrl = ""),
        (this.docName = ""),
        (this.isDifferentPrefixOrigin = !1),
        (this.truePrefixUrl = ""),
        (this.public = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationMetadata"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prefix_url", kind: "scalar", T: 9 },
        { no: 2, name: "doc_name", kind: "scalar", T: 9 },
        { no: 3, name: "is_different_prefix_origin", kind: "scalar", T: 8 },
        { no: 4, name: "true_prefix_url", kind: "scalar", T: 9 },
        { no: 5, name: "public", kind: "scalar", T: 8 },
        { no: 6, name: "team_id", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sI, t, e)
    }
  },
  Knt = class rI extends h {
    constructor(t) {
      super(),
        (this.docName = ""),
        (this.pageUrl = ""),
        (this.documentationChunk = ""),
        (this.score = 0),
        (this.pageTitle = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_name", kind: "scalar", T: 9 },
        { no: 2, name: "page_url", kind: "scalar", T: 9 },
        { no: 3, name: "documentation_chunk", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
        { no: 5, name: "page_title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rI, t, e)
    }
  },
  ERt = class nI extends h {
    constructor(t) {
      super(),
        (this.docIdentifier = ""),
        (this.query = ""),
        (this.topK = 0),
        (this.rerankResults = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationQueryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "query", kind: "scalar", T: 9 },
        { no: 3, name: "top_k", kind: "scalar", T: 13 },
        { no: 4, name: "rerank_results", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new nI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nI, t, e)
    }
  },
  IRt = class aI extends h {
    constructor(t) {
      super(),
        (this.docIdentifier = ""),
        (this.docName = ""),
        (this.docChunks = []),
        (this.status = Zm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationQueryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "doc_name", kind: "scalar", T: 9 },
        { no: 3, name: "doc_chunks", kind: "message", T: Knt, repeated: !0 },
        { no: 4, name: "status", kind: "enum", T: n.getEnumType(Zm) },
      ])
    }
    static fromBinary(t, e) {
      return new aI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aI, t, e)
    }
  },
  Zm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NOT_FOUND = 1)] = "NOT_FOUND"),
    (i[(i.SUCCESS = 2)] = "SUCCESS"),
    (i[(i.FAILURE = 3)] = "FAILURE")
})(Zm || (Zm = {})),
  n.util.setEnumType(Zm, "aiserver.v1.DocumentationQueryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_NOT_FOUND" },
    { no: 2, name: "STATUS_SUCCESS" },
    { no: 3, name: "STATUS_FAILURE" },
  ])
var PRt = class oI extends h {
    constructor(t) {
      super(),
        (this.type = tf.UNSPECIFIED),
        (this.data = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerCapabilityRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(tf) },
        {
          no: 2,
          name: "loop_on_lints",
          kind: "message",
          T: NRt,
          oneof: "data",
        },
        {
          no: 3,
          name: "loop_on_tests",
          kind: "message",
          T: CRt,
          oneof: "data",
        },
        { no: 4, name: "mega_planner", kind: "message", T: JRt, oneof: "data" },
        {
          no: 5,
          name: "loop_on_command",
          kind: "message",
          T: LRt,
          oneof: "data",
        },
        { no: 6, name: "tool_call", kind: "message", T: RRt, oneof: "data" },
        { no: 7, name: "diff_review", kind: "message", T: DRt, oneof: "data" },
        {
          no: 8,
          name: "context_picking",
          kind: "message",
          T: ORt,
          oneof: "data",
        },
        { no: 9, name: "edit_trail", kind: "message", T: BRt, oneof: "data" },
        {
          no: 10,
          name: "auto_context",
          kind: "message",
          T: qRt,
          oneof: "data",
        },
        {
          no: 11,
          name: "context_planner",
          kind: "message",
          T: URt,
          oneof: "data",
        },
        {
          no: 12,
          name: "remember_this",
          kind: "message",
          T: MRt,
          oneof: "data",
        },
        { no: 13, name: "decomposer", kind: "message", T: _Rt, oneof: "data" },
        {
          no: 14,
          name: "cursor_rules",
          kind: "message",
          T: HRt,
          oneof: "data",
        },
      ])
    }
    static fromBinary(t, e) {
      return new oI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oI, t, e)
    }
  },
  tf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOOP_ON_LINTS = 1)] = "LOOP_ON_LINTS"),
    (i[(i.LOOP_ON_TESTS = 2)] = "LOOP_ON_TESTS"),
    (i[(i.MEGA_PLANNER = 3)] = "MEGA_PLANNER"),
    (i[(i.LOOP_ON_COMMAND = 4)] = "LOOP_ON_COMMAND"),
    (i[(i.TOOL_CALL = 5)] = "TOOL_CALL"),
    (i[(i.DIFF_REVIEW = 6)] = "DIFF_REVIEW"),
    (i[(i.CONTEXT_PICKING = 7)] = "CONTEXT_PICKING"),
    (i[(i.EDIT_TRAIL = 8)] = "EDIT_TRAIL"),
    (i[(i.AUTO_CONTEXT = 9)] = "AUTO_CONTEXT"),
    (i[(i.CONTEXT_PLANNER = 10)] = "CONTEXT_PLANNER"),
    (i[(i.DIFF_HISTORY = 11)] = "DIFF_HISTORY"),
    (i[(i.REMEMBER_THIS = 12)] = "REMEMBER_THIS"),
    (i[(i.DECOMPOSER = 13)] = "DECOMPOSER"),
    (i[(i.USES_CODEBASE = 14)] = "USES_CODEBASE"),
    (i[(i.TOOL_FORMER = 15)] = "TOOL_FORMER"),
    (i[(i.CURSOR_RULES = 16)] = "CURSOR_RULES")
})(tf || (tf = {})),
  n.util.setEnumType(
    tf,
    "aiserver.v1.ComposerCapabilityRequest.ComposerCapabilityType",
    [
      { no: 0, name: "COMPOSER_CAPABILITY_TYPE_UNSPECIFIED" },
      { no: 1, name: "COMPOSER_CAPABILITY_TYPE_LOOP_ON_LINTS" },
      { no: 2, name: "COMPOSER_CAPABILITY_TYPE_LOOP_ON_TESTS" },
      { no: 3, name: "COMPOSER_CAPABILITY_TYPE_MEGA_PLANNER" },
      { no: 4, name: "COMPOSER_CAPABILITY_TYPE_LOOP_ON_COMMAND" },
      { no: 5, name: "COMPOSER_CAPABILITY_TYPE_TOOL_CALL" },
      { no: 6, name: "COMPOSER_CAPABILITY_TYPE_DIFF_REVIEW" },
      { no: 7, name: "COMPOSER_CAPABILITY_TYPE_CONTEXT_PICKING" },
      { no: 8, name: "COMPOSER_CAPABILITY_TYPE_EDIT_TRAIL" },
      { no: 9, name: "COMPOSER_CAPABILITY_TYPE_AUTO_CONTEXT" },
      { no: 10, name: "COMPOSER_CAPABILITY_TYPE_CONTEXT_PLANNER" },
      { no: 11, name: "COMPOSER_CAPABILITY_TYPE_DIFF_HISTORY" },
      { no: 12, name: "COMPOSER_CAPABILITY_TYPE_REMEMBER_THIS" },
      { no: 13, name: "COMPOSER_CAPABILITY_TYPE_DECOMPOSER" },
      { no: 14, name: "COMPOSER_CAPABILITY_TYPE_USES_CODEBASE" },
      { no: 15, name: "COMPOSER_CAPABILITY_TYPE_TOOL_FORMER" },
      { no: 16, name: "COMPOSER_CAPABILITY_TYPE_CURSOR_RULES" },
    ],
  )
var ef
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ADD_FILE_TO_CONTEXT = 1)] = "ADD_FILE_TO_CONTEXT"),
    (i[(i.RUN_TERMINAL_COMMAND = 2)] = "RUN_TERMINAL_COMMAND"),
    (i[(i.ITERATE = 3)] = "ITERATE"),
    (i[(i.REMOVE_FILE_FROM_CONTEXT = 4)] = "REMOVE_FILE_FROM_CONTEXT"),
    (i[(i.SEMANTIC_SEARCH_CODEBASE = 5)] = "SEMANTIC_SEARCH_CODEBASE")
})(ef || (ef = {})),
  n.util.setEnumType(ef, "aiserver.v1.ComposerCapabilityRequest.ToolType", [
    { no: 0, name: "TOOL_TYPE_UNSPECIFIED" },
    { no: 1, name: "TOOL_TYPE_ADD_FILE_TO_CONTEXT" },
    { no: 2, name: "TOOL_TYPE_RUN_TERMINAL_COMMAND" },
    { no: 3, name: "TOOL_TYPE_ITERATE" },
    { no: 4, name: "TOOL_TYPE_REMOVE_FILE_FROM_CONTEXT" },
    { no: 5, name: "TOOL_TYPE_SEMANTIC_SEARCH_CODEBASE" },
  ])
var $Rt = class cI extends h {
    constructor(t) {
      super(),
        (this.type = ef.UNSPECIFIED),
        (this.name = ""),
        (this.properties = {}),
        (this.required = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerCapabilityRequest.ToolSchema"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(ef) },
        { no: 2, name: "name", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "properties",
          kind: "map",
          K: 9,
          V: { kind: "message", T: xRt },
        },
        { no: 4, name: "required", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new cI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cI, t, e)
    }
  },
  xRt = class lI extends h {
    constructor(t) {
      super(), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerCapabilityRequest.SchemaProperty"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "description", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lI, t, e)
    }
  },
  NRt = class uI extends h {
    constructor(t) {
      super(), (this.linterErrors = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.LoopOnLintsCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "linter_errors", kind: "message", T: $i, repeated: !0 },
        { no: 2, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uI, t, e)
    }
  },
  CRt = class hI extends h {
    constructor(t) {
      super(), (this.testNames = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.LoopOnTestsCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "test_names", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hI, t, e)
    }
  },
  JRt = class dI extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.MegaPlannerCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new dI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dI, t, e)
    }
  },
  LRt = class mI extends h {
    constructor(t) {
      super(), (this.command = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.LoopOnCommandCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "output", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "exit_code", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mI, t, e)
    }
  },
  RRt = class fI extends h {
    constructor(t) {
      super(),
        (this.toolSchemas = []),
        (this.relevantFiles = []),
        (this.filesInContext = []),
        (this.semanticSearchFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerCapabilityRequest.ToolCallCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "tool_schemas", kind: "message", T: $Rt, repeated: !0 },
        { no: 3, name: "relevant_files", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "files_in_context", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 5,
          name: "semantic_search_files",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new fI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fI, t, e)
    }
  },
  DRt = class pI extends h {
    constructor(t) {
      super(), (this.diffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.DiffReviewCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "diffs", kind: "message", T: FRt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new pI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pI, t, e)
    }
  },
  FRt = class gI extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.DiffReviewCapability.SimpleFileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "chunks", kind: "message", T: ARt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gI, t, e)
    }
  },
  ARt = class vI extends h {
    constructor(t) {
      super(),
        (this.oldLines = []),
        (this.newLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.DiffReviewCapability.SimpleFileDiff.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "old_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "old_range", kind: "message", T: Li },
        { no: 4, name: "new_range", kind: "message", T: Li },
      ])
    }
    static fromBinary(t, e) {
      return new vI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vI, t, e)
    }
  },
  _Rt = class wI extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.DecomposerCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wI, t, e)
    }
  },
  ORt = class yI extends h {
    constructor(t) {
      super(),
        (this.potentialContextFiles = []),
        (this.potentialContextCodeChunks = []),
        (this.filesInContext = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.ContextPickingCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "potential_context_files",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 3,
          name: "potential_context_code_chunks",
          kind: "message",
          T: Het,
          repeated: !0,
        },
        { no: 4, name: "files_in_context", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yI, t, e)
    }
  },
  BRt = class bI extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.EditTrailCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new bI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bI, t, e)
    }
  },
  qRt = class TI extends h {
    constructor(t) {
      super(), (this.additionalFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.AutoContextCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "additional_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new TI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TI, t, e)
    }
  },
  URt = class kI extends h {
    constructor(t) {
      super(), (this.attachedCodeChunks = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.ContextPlannerCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "attached_code_chunks",
          kind: "message",
          T: Het,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new kI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kI, t, e)
    }
  },
  MRt = class SI extends h {
    constructor(t) {
      super(), (this.memory = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.RememberThisCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "memory", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new SI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SI, t, e)
    }
  },
  HRt = class EI extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.CursorRulesCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new EI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EI, t, e)
    }
  },
  xn
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.CODEBASE = 1)] = "CODEBASE"),
    (i[(i.LONG_FILE = 2)] = "LONG_FILE"),
    (i[(i.DOCS = 3)] = "DOCS")
})(xn || (xn = {})),
  n.util.setEnumType(xn, "aiserver.v1.ChunkType", [
    { no: 0, name: "CHUNK_TYPE_UNSPECIFIED" },
    { no: 1, name: "CHUNK_TYPE_CODEBASE" },
    { no: 2, name: "CHUNK_TYPE_LONG_FILE" },
    { no: 3, name: "CHUNK_TYPE_DOCS" },
  ])
var WRt = class II extends h {
    constructor(t) {
      super(), (this.editPlan = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamParallelApplyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_block", kind: "message", T: Ne },
        { no: 2, name: "file", kind: "message", T: ks },
        { no: 3, name: "edit_plan", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new II().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new II().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new II().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(II, t, e)
    }
  },
  jRt = class PI extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamParallelApplyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PI, t, e)
    }
  },
  VRt = class $I extends h {
    constructor(t) {
      super(), (this.request = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatRequestWithTools"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "stream_unified_chat_request",
          kind: "message",
          T: BW,
          oneof: "request",
        },
        {
          no: 2,
          name: "client_side_tool_v2_result",
          kind: "message",
          T: WB,
          oneof: "request",
        },
      ])
    }
    static fromBinary(t, e) {
      return new $I().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $I().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $I().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($I, t, e)
    }
  },
  GRt = class xI extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatResponseWithTools"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "client_side_tool_v2_call",
          kind: "message",
          T: Lnt,
          oneof: "response",
        },
        {
          no: 2,
          name: "stream_unified_chat_response",
          kind: "message",
          T: sat,
          oneof: "response",
        },
        {
          no: 3,
          name: "conversation_summary",
          kind: "message",
          T: Nn,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new xI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xI, t, e)
    }
  },
  DXt = class NI extends h {
    constructor(t) {
      super(), (this.strategy = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationSummaryStrategy"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "plain_text_summary",
          kind: "scalar",
          T: 9,
          oneof: "strategy",
        },
        {
          no: 2,
          name: "arbitrary_summary_plus_tool_result_truncation",
          kind: "message",
          T: zRt,
          oneof: "strategy",
        },
      ])
    }
    static fromBinary(t, e) {
      return new NI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NI, t, e)
    }
  },
  zRt = class CI extends h {
    constructor(t) {
      super(),
        (this.toolResultTruncationLength = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ConversationSummaryStrategy.ArbitrarySummaryPlusToolResultTruncation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "arbitrary_summary", kind: "message", T: Nn },
        { no: 2, name: "tool_result_truncation_length", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new CI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CI, t, e)
    }
  },
  Nn = class JI extends h {
    constructor(t) {
      super(),
        (this.summary = ""),
        (this.truncationLastBubbleIdInclusive = ""),
        (this.clientShouldStartSendingFromInclusiveBubbleId = ""),
        (this.previousConversationSummaryBubbleId = ""),
        (this.includesToolResults = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationSummary"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "summary", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "truncation_last_bubble_id_inclusive",
          kind: "scalar",
          T: 9,
        },
        {
          no: 3,
          name: "client_should_start_sending_from_inclusive_bubble_id",
          kind: "scalar",
          T: 9,
        },
        {
          no: 4,
          name: "previous_conversation_summary_bubble_id",
          kind: "scalar",
          T: 9,
        },
        { no: 5, name: "includes_tool_results", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new JI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JI, t, e)
    }
  },
  Znt = class LI extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextToRank"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "line_range", kind: "message", T: Li, opt: !0 },
        { no: 4, name: "code_block", kind: "message", T: Ne, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new LI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LI, t, e)
    }
  },
  AW = class RI extends h {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RankedContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context", kind: "message", T: Znt },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new RI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RI, t, e)
    }
  },
  _W = class DI extends h {
    constructor(t) {
      super(), (this.chunks = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationCitation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: Knt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new DI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DI, t, e)
    }
  },
  tat = class FI extends h {
    constructor(t) {
      super(), (this.references = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebCitation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "references", kind: "message", T: eat, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new FI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FI, t, e)
    }
  },
  eat = class AI extends h {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.url = ""),
        (this.chunk = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebReference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "title", kind: "scalar", T: 9 },
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "chunk", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new AI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AI, t, e)
    }
  },
  VB = class _I extends h {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.url = ""),
        (this.chunk = ""),
        (this.name = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocsReference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "chunk", kind: "scalar", T: 9 },
        { no: 4, name: "name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new _I().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _I().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _I().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_I, t, e)
    }
  },
  YRt = class OI extends h {
    constructor(t) {
      super(), (this.message = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new OI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OI, t, e)
    }
  },
  iat = class BI extends h {
    constructor(t) {
      super(), (this.updates = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StatusUpdates"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "updates", kind: "message", T: YRt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new BI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BI, t, e)
    }
  },
  QRt = class qI extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.documents = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankDocumentsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "documents", kind: "message", T: KRt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new qI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qI, t, e)
    }
  },
  XRt = class UI extends h {
    constructor(t) {
      super(), (this.documents = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankDocumentsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "documents", kind: "message", T: ZRt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new UI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UI, t, e)
    }
  },
  KRt = class MI extends h {
    constructor(t) {
      super(), (this.content = ""), (this.id = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Document"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "content", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new MI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MI, t, e)
    }
  },
  ZRt = class HI extends h {
    constructor(t) {
      super(),
        (this.documentId = ""),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentIdsWithScores"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "document_id", kind: "scalar", T: 9 },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new HI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HI, t, e)
    }
  },
  OW = class WI extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diffHistory = []),
        (this.diffHistoryTimestamps = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerFileDiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 3,
          name: "diff_history_timestamps",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new WI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WI, t, e)
    }
  },
  t4t = class jI extends h {
    constructor(t) {
      super(), (this.workspaceUris = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EnvironmentInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "exthost_platform", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "exthost_arch", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "exthost_release", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "exthost_shell", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "local_timestamp", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "workspace_uris", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new jI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jI, t, e)
    }
  },
  BW = class VI extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.fullConversationHeadersOnly = []),
        (this.documentationIdentifiers = []),
        (this.externalLinks = []),
        (this.diffsForCompressingFiles = []),
        (this.multiFileLinterErrors = []),
        (this.fileDiffHistories = []),
        (this.quotes = []),
        (this.additionalRankedContext = []),
        (this.isChat = !1),
        (this.conversationId = ""),
        (this.repositoryInfoShouldQueryStaging = !1),
        (this.isAgentic = !1),
        (this.supportedTools = []),
        (this.enableYoloMode = !1),
        (this.yoloPrompt = ""),
        (this.useUnifiedChatPrompt = !1),
        (this.mcpTools = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: he, repeated: !0 },
        {
          no: 30,
          name: "full_conversation_headers_only",
          kind: "message",
          T: c4t,
          repeated: !0,
        },
        { no: 2, name: "allow_long_file_scan", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "explicit_context", kind: "message", T: Oe },
        {
          no: 4,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 5, name: "model_details", kind: "message", T: St },
        { no: 6, name: "linter_errors", kind: "message", T: $i },
        {
          no: 7,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 8, name: "use_web", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "external_links", kind: "message", T: CM, repeated: !0 },
        { no: 10, name: "project_context", kind: "message", T: he, opt: !0 },
        {
          no: 11,
          name: "diffs_for_compressing_files",
          kind: "message",
          T: e4t,
          repeated: !0,
        },
        { no: 12, name: "compress_edits", kind: "scalar", T: 8, opt: !0 },
        { no: 13, name: "should_cache", kind: "scalar", T: 8, opt: !0 },
        {
          no: 14,
          name: "multi_file_linter_errors",
          kind: "message",
          T: $i,
          repeated: !0,
        },
        { no: 15, name: "current_file", kind: "message", T: Yt },
        { no: 16, name: "recent_edits", kind: "message", T: i4t, opt: !0 },
        {
          no: 17,
          name: "use_reference_composer_diff_prompt",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 18,
          name: "file_diff_histories",
          kind: "message",
          T: OW,
          repeated: !0,
        },
        {
          no: 19,
          name: "use_new_compression_scheme",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 21, name: "quotes", kind: "message", T: z8, repeated: !0 },
        {
          no: 20,
          name: "additional_ranked_context",
          kind: "message",
          T: AW,
          repeated: !0,
        },
        { no: 22, name: "is_chat", kind: "scalar", T: 8 },
        { no: 23, name: "conversation_id", kind: "scalar", T: 9 },
        { no: 24, name: "repository_info", kind: "message", T: Mt },
        {
          no: 25,
          name: "repository_info_should_query_staging",
          kind: "scalar",
          T: 8,
        },
        { no: 26, name: "environment_info", kind: "message", T: t4t },
        { no: 27, name: "is_agentic", kind: "scalar", T: 8 },
        {
          no: 28,
          name: "conversation_summary",
          kind: "message",
          T: Nn,
          opt: !0,
        },
        {
          no: 29,
          name: "supported_tools",
          kind: "enum",
          T: n.getEnumType(As),
          repeated: !0,
        },
        { no: 31, name: "enable_yolo_mode", kind: "scalar", T: 8 },
        { no: 32, name: "yolo_prompt", kind: "scalar", T: 9 },
        { no: 33, name: "use_unified_chat_prompt", kind: "scalar", T: 8 },
        { no: 34, name: "mcp_tools", kind: "message", T: FW, repeated: !0 },
        {
          no: 35,
          name: "use_full_inputs_context",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 36, name: "is_resume", kind: "scalar", T: 8, opt: !0 },
        {
          no: 37,
          name: "allow_model_fallbacks",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 38,
          name: "number_of_times_shown_fallback_model_warning",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new VI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VI, t, e)
    }
  },
  e4t = class GI extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.redRanges = []),
        (this.redRangesReversed = []),
        (this.startHash = ""),
        (this.endHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatRequest.RedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "red_ranges", kind: "message", T: Ts, repeated: !0 },
        {
          no: 3,
          name: "red_ranges_reversed",
          kind: "message",
          T: Ts,
          repeated: !0,
        },
        { no: 4, name: "start_hash", kind: "scalar", T: 9 },
        { no: 5, name: "end_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new GI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GI, t, e)
    }
  },
  i4t = class zI extends h {
    constructor(t) {
      super(),
        (this.codeBlockInfo = []),
        (this.finalFileValues = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatRequest.RecentEdits"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "code_block_info",
          kind: "message",
          T: s4t,
          repeated: !0,
        },
        {
          no: 2,
          name: "final_file_values",
          kind: "message",
          T: r4t,
          repeated: !0,
        },
        {
          no: 3,
          name: "edits_belong_to_composer_generation_uuid",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new zI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zI, t, e)
    }
  },
  s4t = class YI extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamUnifiedChatRequest.RecentEdits.CodeBlockInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "content_before", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "content_after", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "generation_uuid", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "version", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new YI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YI, t, e)
    }
  },
  r4t = class QI extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamUnifiedChatRequest.RecentEdits.FileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new QI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QI, t, e)
    }
  },
  sat = class XI extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 22, name: "server_bubble_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "debugging_only_chat_prompt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 3,
          name: "debugging_only_token_count",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 4, name: "document_citation", kind: "message", T: _W },
        { no: 5, name: "filled_prompt", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "is_big_file", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "intermediate_text", kind: "scalar", T: 9, opt: !0 },
        {
          no: 10,
          name: "is_using_slow_request",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 8, name: "chunk_identity", kind: "message", T: n4t, opt: !0 },
        { no: 9, name: "docs_reference", kind: "message", T: VB, opt: !0 },
        { no: 11, name: "web_citation", kind: "message", T: tat, opt: !0 },
        { no: 12, name: "status_updates", kind: "message", T: iat, opt: !0 },
        { no: 13, name: "tool_call", kind: "message", T: lJt, opt: !0 },
        {
          no: 14,
          name: "should_break_ai_message",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 15, name: "partial_tool_call", kind: "message", T: cJt, opt: !0 },
        { no: 16, name: "final_tool_result", kind: "message", T: a4t, opt: !0 },
        { no: 17, name: "symbol_link", kind: "message", T: qW, opt: !0 },
        { no: 19, name: "file_link", kind: "message", T: UW, opt: !0 },
        {
          no: 18,
          name: "conversation_summary",
          kind: "message",
          T: Nn,
          opt: !0,
        },
        {
          no: 20,
          name: "service_status_update",
          kind: "message",
          T: rat,
          opt: !0,
        },
        {
          no: 21,
          name: "viewable_git_context",
          kind: "message",
          T: nat,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new XI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XI, t, e)
    }
  },
  n4t = class KI extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.text = ""),
        (this.chunkType = xn.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatResponse.ChunkIdentity"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
        { no: 5, name: "chunk_type", kind: "enum", T: n.getEnumType(xn) },
      ])
    }
    static fromBinary(t, e) {
      return new KI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KI, t, e)
    }
  },
  a4t = class ZI extends h {
    constructor(t) {
      super(), (this.toolCallId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatResponse.FinalToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 2, name: "result", kind: "message", T: WB },
      ])
    }
    static fromBinary(t, e) {
      return new ZI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZI, t, e)
    }
  },
  rat = class tP extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.codicon = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ServiceStatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "codicon", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "allow_command_links_potentially_unsafe_please_only_use_for_handwritten_trusted_markdown",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 4,
          name: "action_to_run_on_status_update",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new tP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tP, t, e)
    }
  },
  qW = class eP extends h {
    constructor(t) {
      super(),
        (this.symbolName = ""),
        (this.symbolSearchString = ""),
        (this.relativeWorkspacePath = ""),
        (this.roughLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SymbolLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol_name", kind: "scalar", T: 9 },
        { no: 2, name: "symbol_search_string", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "rough_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new eP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eP, t, e)
    }
  },
  UW = class iP extends h {
    constructor(t) {
      super(),
        (this.displayName = ""),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "display_name", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iP, t, e)
    }
  },
  o4t = class sP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.redRanges = []),
        (this.redRangesReversed = []),
        (this.startHash = ""),
        (this.endHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "red_ranges", kind: "message", T: Ts, repeated: !0 },
        {
          no: 3,
          name: "red_ranges_reversed",
          kind: "message",
          T: Ts,
          repeated: !0,
        },
        { no: 4, name: "start_hash", kind: "scalar", T: 9 },
        { no: 5, name: "end_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new sP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sP, t, e)
    }
  },
  c4t = class rP extends h {
    constructor(t) {
      super(),
        (this.bubbleId = ""),
        (this.type = Bo.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessageHeader"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bubble_id", kind: "scalar", T: 9 },
        { no: 2, name: "server_bubble_id", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "type", kind: "enum", T: n.getEnumType(Bo) },
      ])
    }
    static fromBinary(t, e) {
      return new rP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rP, t, e)
    }
  },
  MW = class nP extends h {
    constructor(t) {
      super(),
        (this.fileDetails = ""),
        (this.fileName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_details", kind: "scalar", T: 9 },
        { no: 2, name: "file_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nP, t, e)
    }
  },
  l4t = class aP extends h {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.message = ""),
        (this.files = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ViewableCommitProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "files", kind: "message", T: MW, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new aP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aP, t, e)
    }
  },
  u4t = class oP extends h {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.body = ""),
        (this.files = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ViewablePRProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "body", kind: "scalar", T: 9 },
        { no: 3, name: "files", kind: "message", T: MW, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new oP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oP, t, e)
    }
  },
  h4t = class cP extends h {
    constructor(t) {
      super(),
        (this.files = []),
        (this.diffPreface = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ViewableDiffProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: MW, repeated: !0 },
        { no: 2, name: "diff_preface", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cP, t, e)
    }
  },
  nat = class lP extends h {
    constructor(t) {
      super(), (this.diffData = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ViewableGitContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commit_data", kind: "message", T: l4t, opt: !0 },
        { no: 2, name: "pull_request_data", kind: "message", T: u4t, opt: !0 },
        { no: 3, name: "diff_data", kind: "message", T: h4t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lP, t, e)
    }
  },
  he = class uP extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.type = Bo.UNSPECIFIED),
        (this.attachedCodeChunks = []),
        (this.codebaseContextChunks = []),
        (this.commits = []),
        (this.pullRequests = []),
        (this.gitDiffs = []),
        (this.assistantSuggestedDiffs = []),
        (this.interpreterResults = []),
        (this.images = []),
        (this.attachedFolders = []),
        (this.approximateLintErrors = []),
        (this.bubbleId = ""),
        (this.attachedFoldersNew = []),
        (this.lints = []),
        (this.userResponsesToSuggestedCodeBlocks = []),
        (this.relevantFiles = []),
        (this.toolResults = []),
        (this.notepads = []),
        (this.capabilities = []),
        (this.editTrailContexts = []),
        (this.suggestedCodeBlocks = []),
        (this.diffsForCompressingFiles = []),
        (this.multiFileLinterErrors = []),
        (this.diffHistories = []),
        (this.recentlyViewedFiles = []),
        (this.recentLocationsHistory = []),
        (this.isAgentic = !1),
        (this.fileDiffTrajectories = []),
        (this.existedSubsequentTerminalCommand = !1),
        (this.existedPreviousTerminalCommand = !1),
        (this.docsReferences = []),
        (this.webReferences = []),
        (this.attachedFoldersListDirResults = []),
        (this.humanChanges = []),
        (this.attachedHumanChanges = !1),
        (this.summarizedComposers = []),
        (this.cursorRules = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "type", kind: "enum", T: n.getEnumType(Bo) },
        {
          no: 3,
          name: "attached_code_chunks",
          kind: "message",
          T: sf,
          repeated: !0,
        },
        {
          no: 4,
          name: "codebase_context_chunks",
          kind: "message",
          T: Ne,
          repeated: !0,
        },
        { no: 5, name: "commits", kind: "message", T: Ca, repeated: !0 },
        { no: 6, name: "pull_requests", kind: "message", T: aat, repeated: !0 },
        { no: 7, name: "git_diffs", kind: "message", T: V8, repeated: !0 },
        {
          no: 8,
          name: "assistant_suggested_diffs",
          kind: "message",
          T: $4t,
          repeated: !0,
        },
        {
          no: 9,
          name: "interpreter_results",
          kind: "message",
          T: P4t,
          repeated: !0,
        },
        { no: 10, name: "images", kind: "message", T: Ea, repeated: !0 },
        {
          no: 11,
          name: "attached_folders",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 12,
          name: "approximate_lint_errors",
          kind: "message",
          T: w4t,
          repeated: !0,
        },
        { no: 13, name: "bubble_id", kind: "scalar", T: 9 },
        { no: 32, name: "server_bubble_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 14,
          name: "attached_folders_new",
          kind: "message",
          T: E4t,
          repeated: !0,
        },
        { no: 15, name: "lints", kind: "message", T: y4t, repeated: !0 },
        {
          no: 16,
          name: "user_responses_to_suggested_code_blocks",
          kind: "message",
          T: C4t,
          repeated: !0,
        },
        { no: 17, name: "relevant_files", kind: "scalar", T: 9, repeated: !0 },
        { no: 18, name: "tool_results", kind: "message", T: d4t, repeated: !0 },
        { no: 19, name: "notepads", kind: "message", T: f4t, repeated: !0 },
        {
          no: 20,
          name: "is_capability_iteration",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 21, name: "capabilities", kind: "message", T: PRt, repeated: !0 },
        {
          no: 22,
          name: "edit_trail_contexts",
          kind: "message",
          T: v4t,
          repeated: !0,
        },
        {
          no: 23,
          name: "suggested_code_blocks",
          kind: "message",
          T: N4t,
          repeated: !0,
        },
        {
          no: 24,
          name: "diffs_for_compressing_files",
          kind: "message",
          T: o4t,
          repeated: !0,
        },
        {
          no: 25,
          name: "multi_file_linter_errors",
          kind: "message",
          T: pSt,
          repeated: !0,
        },
        {
          no: 26,
          name: "diff_histories",
          kind: "message",
          T: R4t,
          repeated: !0,
        },
        {
          no: 27,
          name: "recently_viewed_files",
          kind: "message",
          T: sf,
          repeated: !0,
        },
        {
          no: 28,
          name: "recent_locations_history",
          kind: "message",
          T: b4t,
          repeated: !0,
        },
        { no: 29, name: "is_agentic", kind: "scalar", T: 8 },
        {
          no: 30,
          name: "file_diff_trajectories",
          kind: "message",
          T: OW,
          repeated: !0,
        },
        {
          no: 31,
          name: "conversation_summary",
          kind: "message",
          T: Nn,
          opt: !0,
        },
        {
          no: 33,
          name: "existed_subsequent_terminal_command",
          kind: "scalar",
          T: 8,
        },
        {
          no: 34,
          name: "existed_previous_terminal_command",
          kind: "scalar",
          T: 8,
        },
        {
          no: 35,
          name: "docs_references",
          kind: "message",
          T: VB,
          repeated: !0,
        },
        {
          no: 36,
          name: "web_references",
          kind: "message",
          T: eat,
          repeated: !0,
        },
        { no: 37, name: "git_context", kind: "message", T: nat, opt: !0 },
        {
          no: 38,
          name: "attached_folders_list_dir_results",
          kind: "message",
          T: Rnt,
          repeated: !0,
        },
        {
          no: 39,
          name: "cached_conversation_summary",
          kind: "message",
          T: Nn,
          opt: !0,
        },
        {
          no: 40,
          name: "human_changes",
          kind: "message",
          T: k4t,
          repeated: !0,
        },
        { no: 41, name: "attached_human_changes", kind: "scalar", T: 8 },
        {
          no: 42,
          name: "summarized_composers",
          kind: "message",
          T: p4t,
          repeated: !0,
        },
        { no: 43, name: "cursor_rules", kind: "message", T: $M, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uP, t, e)
    }
  },
  Bo
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.HUMAN = 1)] = "HUMAN"),
    (i[(i.AI = 2)] = "AI")
})(Bo || (Bo = {})),
  n.util.setEnumType(Bo, "aiserver.v1.ConversationMessage.MessageType", [
    { no: 0, name: "MESSAGE_TYPE_UNSPECIFIED" },
    { no: 1, name: "MESSAGE_TYPE_HUMAN" },
    { no: 2, name: "MESSAGE_TYPE_AI" },
  ])
var sf = class hP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        (this.languageIdentifier = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 4,
          name: "summarization_strategy",
          kind: "enum",
          T: n.getEnumType(zB),
          opt: !0,
        },
        { no: 5, name: "language_identifier", kind: "scalar", T: 9 },
        { no: 6, name: "intent", kind: "enum", T: n.getEnumType(GB), opt: !0 },
        { no: 7, name: "is_final_version", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "is_first_version", kind: "scalar", T: 8, opt: !0 },
        { no: 9, name: "contents_are_missing", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hP, t, e)
    }
  },
  GB
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.COMPOSER_FILE = 1)] = "COMPOSER_FILE"),
    (i[(i.COMPRESSED_COMPOSER_FILE = 2)] = "COMPRESSED_COMPOSER_FILE"),
    (i[(i.RECENTLY_VIEWED_FILE = 3)] = "RECENTLY_VIEWED_FILE"),
    (i[(i.OUTLINE = 4)] = "OUTLINE"),
    (i[(i.MENTIONED_FILE = 5)] = "MENTIONED_FILE"),
    (i[(i.CODE_SELECTION = 6)] = "CODE_SELECTION")
})(GB || (GB = {})),
  n.util.setEnumType(GB, "aiserver.v1.ConversationMessage.CodeChunk.Intent", [
    { no: 0, name: "INTENT_UNSPECIFIED" },
    { no: 1, name: "INTENT_COMPOSER_FILE" },
    { no: 2, name: "INTENT_COMPRESSED_COMPOSER_FILE" },
    { no: 3, name: "INTENT_RECENTLY_VIEWED_FILE" },
    { no: 4, name: "INTENT_OUTLINE" },
    { no: 5, name: "INTENT_MENTIONED_FILE" },
    { no: 6, name: "INTENT_CODE_SELECTION" },
  ])
var zB
;(function (i) {
  ;(i[(i.NONE_UNSPECIFIED = 0)] = "NONE_UNSPECIFIED"),
    (i[(i.SUMMARIZED = 1)] = "SUMMARIZED"),
    (i[(i.EMBEDDED = 2)] = "EMBEDDED")
})(zB || (zB = {})),
  n.util.setEnumType(
    zB,
    "aiserver.v1.ConversationMessage.CodeChunk.SummarizationStrategy",
    [
      { no: 0, name: "SUMMARIZATION_STRATEGY_NONE_UNSPECIFIED" },
      { no: 1, name: "SUMMARIZATION_STRATEGY_SUMMARIZED" },
      { no: 2, name: "SUMMARIZATION_STRATEGY_EMBEDDED" },
    ],
  )
var d4t = class dP extends h {
    constructor(t) {
      super(),
        (this.toolCallId = ""),
        (this.toolName = ""),
        (this.toolIndex = 0),
        (this.args = ""),
        (this.rawArgs = ""),
        (this.attachedCodeChunks = []),
        (this.images = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.ToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 2, name: "tool_name", kind: "scalar", T: 9 },
        { no: 3, name: "tool_index", kind: "scalar", T: 13 },
        { no: 4, name: "args", kind: "scalar", T: 9 },
        { no: 5, name: "raw_args", kind: "scalar", T: 9 },
        {
          no: 6,
          name: "attached_code_chunks",
          kind: "message",
          T: sf,
          repeated: !0,
        },
        { no: 7, name: "content", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "result", kind: "message", T: WB },
        { no: 9, name: "error", kind: "message", T: LW, opt: !0 },
        { no: 10, name: "images", kind: "message", T: Ea, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new dP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dP, t, e)
    }
  },
  FXt = class mP extends h {
    constructor(t) {
      super(),
        (this.ranges = []),
        (this.content = ""),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.MultiRangeCodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranges", kind: "message", T: m4t, repeated: !0 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new mP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mP, t, e)
    }
  },
  m4t = class fP extends h {
    constructor(t) {
      super(), (this.priority = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ConversationMessage.MultiRangeCodeChunk.RangeWithPriority"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "range", kind: "message", T: Ts },
        { no: 2, name: "priority", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new fP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fP, t, e)
    }
  },
  f4t = class pP extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.text = ""),
        (this.attachedCodeChunks = []),
        (this.attachedFolders = []),
        (this.commits = []),
        (this.pullRequests = []),
        (this.gitDiffs = []),
        (this.images = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.NotepadContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "attached_code_chunks",
          kind: "message",
          T: sf,
          repeated: !0,
        },
        { no: 4, name: "attached_folders", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "commits", kind: "message", T: Ca, repeated: !0 },
        { no: 6, name: "pull_requests", kind: "message", T: aat, repeated: !0 },
        { no: 7, name: "git_diffs", kind: "message", T: V8, repeated: !0 },
        { no: 8, name: "images", kind: "message", T: Ea, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new pP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pP, t, e)
    }
  },
  p4t = class gP extends h {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.ComposerContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "conversation_summary", kind: "message", T: Nn },
      ])
    }
    static fromBinary(t, e) {
      return new gP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gP, t, e)
    }
  },
  g4t = class vP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contextLines = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.EditLocation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "range", kind: "message", T: Ts },
        { no: 4, name: "initial_range", kind: "message", T: Ts },
        { no: 5, name: "context_lines", kind: "scalar", T: 9 },
        { no: 6, name: "text", kind: "scalar", T: 9 },
        { no: 7, name: "text_range", kind: "message", T: Ts },
      ])
    }
    static fromBinary(t, e) {
      return new vP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vP, t, e)
    }
  },
  v4t = class wP extends h {
    constructor(t) {
      super(),
        (this.uniqueId = ""),
        (this.editTrailSorted = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.EditTrailContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "unique_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "edit_trail_sorted",
          kind: "message",
          T: g4t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new wP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wP, t, e)
    }
  },
  w4t = class yP extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.value = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.startColumn = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.ApproximateLintError"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 },
        { no: 3, name: "start_line", kind: "scalar", T: 5 },
        { no: 4, name: "end_line", kind: "scalar", T: 5 },
        { no: 5, name: "start_column", kind: "scalar", T: 5 },
        { no: 6, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new yP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yP, t, e)
    }
  },
  y4t = class bP extends h {
    constructor(t) {
      super(), (this.chatCodeblockModelValue = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.Lints"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lints", kind: "message", T: qB },
        { no: 2, name: "chat_codeblock_model_value", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bP, t, e)
    }
  },
  b4t = class TP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.RecentLocation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new TP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TP, t, e)
    }
  },
  T4t = class kP extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumberExclusive = 0),
        (this.beforeContextLines = []),
        (this.removedLines = []),
        (this.addedLines = []),
        (this.afterContextLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.RenderedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "before_context_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 4, name: "removed_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "added_lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 6,
          name: "after_context_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new kP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kP, t, e)
    }
  },
  k4t = class SP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.renderedDiffs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.HumanChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "rendered_diffs",
          kind: "message",
          T: T4t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new SP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SP, t, e)
    }
  },
  AXt = class EP extends h {
    constructor(t) {
      super(), (this.query = ""), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "files", kind: "message", T: S4t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new EP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EP, t, e)
    }
  },
  S4t = class IP extends h {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchFileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new IP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IP, t, e)
    }
  },
  E4t = class PP extends h {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.files = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FolderInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "files", kind: "message", T: I4t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new PP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PP, t, e)
    }
  },
  I4t = class $P extends h {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.content = ""),
        (this.truncated = !1),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FolderFileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
        { no: 3, name: "truncated", kind: "scalar", T: 8 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new $P().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $P().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $P().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($P, t, e)
    }
  },
  P4t = class xP extends h {
    constructor(t) {
      super(),
        (this.output = ""),
        (this.success = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterpreterResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "scalar", T: 9 },
        { no: 2, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new xP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xP, t, e)
    }
  },
  $4t = class NP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleFileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "chunks", kind: "message", T: x4t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new NP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NP, t, e)
    }
  },
  x4t = class CP extends h {
    constructor(t) {
      super(),
        (this.oldLines = []),
        (this.newLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleFileDiff.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "old_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "old_range", kind: "message", T: Li },
        { no: 4, name: "new_range", kind: "message", T: Li },
      ])
    }
    static fromBinary(t, e) {
      return new CP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CP, t, e)
    }
  },
  Ca = class JP extends h {
    constructor(t) {
      super(),
        (this.sha = ""),
        (this.message = ""),
        (this.description = ""),
        (this.diff = []),
        (this.author = ""),
        (this.date = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Commit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "sha", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "description", kind: "scalar", T: 9 },
        { no: 4, name: "diff", kind: "message", T: G8, repeated: !0 },
        { no: 5, name: "author", kind: "scalar", T: 9 },
        { no: 6, name: "date", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JP, t, e)
    }
  },
  aat = class LP extends h {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.body = ""),
        (this.diff = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PullRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "body", kind: "scalar", T: 9 },
        { no: 3, name: "diff", kind: "message", T: G8, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new LP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LP, t, e)
    }
  },
  N4t = class RP extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SuggestedCodeBlock"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RP, t, e)
    }
  },
  C4t = class DP extends h {
    constructor(t) {
      super(),
        (this.userResponseType = rf.UNSPECIFIED),
        (this.filePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UserResponseToSuggestedCodeBlock"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "user_response_type",
          kind: "enum",
          T: n.getEnumType(rf),
        },
        { no: 2, name: "file_path", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "user_modifications_to_suggested_code_blocks",
          kind: "message",
          T: G8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new DP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DP, t, e)
    }
  },
  rf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ACCEPT = 1)] = "ACCEPT"),
    (i[(i.REJECT = 2)] = "REJECT"),
    (i[(i.MODIFY = 3)] = "MODIFY")
})(rf || (rf = {})),
  n.util.setEnumType(
    rf,
    "aiserver.v1.UserResponseToSuggestedCodeBlock.UserResponseType",
    [
      { no: 0, name: "USER_RESPONSE_TYPE_UNSPECIFIED" },
      { no: 1, name: "USER_RESPONSE_TYPE_ACCEPT" },
      { no: 2, name: "USER_RESPONSE_TYPE_REJECT" },
      { no: 3, name: "USER_RESPONSE_TYPE_MODIFY" },
    ],
  )
var J4t = class FP extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.fileContent = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextRerankingCandidateFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "file_content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new FP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FP, t, e)
    }
  },
  oat = class AP extends h {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.editor = nf.UNSPECIFIED),
        (this.hitTimeout = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerFileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: L4t, repeated: !0 },
        { no: 2, name: "editor", kind: "enum", T: n.getEnumType(nf) },
        { no: 3, name: "hit_timeout", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new AP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AP, t, e)
    }
  },
  nf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.AI = 1)] = "AI"),
    (i[(i.HUMAN = 2)] = "HUMAN")
})(nf || (nf = {})),
  n.util.setEnumType(nf, "aiserver.v1.ComposerFileDiff.Editor", [
    { no: 0, name: "EDITOR_UNSPECIFIED" },
    { no: 1, name: "EDITOR_AI" },
    { no: 2, name: "EDITOR_HUMAN" },
  ])
var L4t = class _P extends h {
    constructor(t) {
      super(),
        (this.diffString = ""),
        (this.oldStart = 0),
        (this.newStart = 0),
        (this.oldLines = 0),
        (this.newLines = 0),
        (this.linesRemoved = 0),
        (this.linesAdded = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerFileDiff.ChunkDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_string", kind: "scalar", T: 9 },
        { no: 2, name: "old_start", kind: "scalar", T: 5 },
        { no: 3, name: "new_start", kind: "scalar", T: 5 },
        { no: 4, name: "old_lines", kind: "scalar", T: 5 },
        { no: 5, name: "new_lines", kind: "scalar", T: 5 },
        { no: 6, name: "lines_removed", kind: "scalar", T: 5 },
        { no: 7, name: "lines_added", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new _P().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _P().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _P().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_P, t, e)
    }
  },
  R4t = class OP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.diffs = []),
        (this.timestamp = 0),
        (this.uniqueId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "diffs", kind: "message", T: oat, repeated: !0 },
        { no: 3, name: "timestamp", kind: "scalar", T: 1 },
        { no: 4, name: "unique_id", kind: "scalar", T: 9 },
        { no: 5, name: "start_to_end_diff", kind: "message", T: oat },
      ])
    }
    static fromBinary(t, e) {
      return new OP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OP, t, e)
    }
  },
  qo = class BP extends h {
    constructor(t) {
      super(), (this.item = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentiallyCachedContextItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_item", kind: "message", T: cat, oneof: "item" },
        {
          no: 2,
          name: "context_item_hash",
          kind: "scalar",
          T: 9,
          oneof: "item",
        },
      ])
    }
    static fromBinary(t, e) {
      return new BP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BP, t, e)
    }
  },
  YB = class qP extends h {
    constructor(t) {
      super(), (this.contextItemStatuses = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextStatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "context_item_statuses",
          kind: "message",
          T: D4t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new qP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qP, t, e)
    }
  },
  QB = class UP extends h {
    constructor(t) {
      super(), (this.missingContextItemHashes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MissingContextItems"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 2,
          name: "missing_context_item_hashes",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new UP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UP, t, e)
    }
  },
  D4t = class MP extends h {
    constructor(t) {
      super(),
        (this.contextItemHash = ""),
        (this.shownToTheModel = !1),
        (this.score = 0),
        (this.percentageOfAvailableSpace = 0),
        (this.postGenerationEvaluation = af.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItemStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_item_hash", kind: "scalar", T: 9 },
        { no: 2, name: "shown_to_the_model", kind: "scalar", T: 8 },
        { no: 3, name: "score", kind: "scalar", T: 2 },
        { no: 4, name: "percentage_of_available_space", kind: "scalar", T: 2 },
        {
          no: 5,
          name: "post_generation_evaluation",
          kind: "enum",
          T: n.getEnumType(af),
        },
      ])
    }
    static fromBinary(t, e) {
      return new MP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MP, t, e)
    }
  },
  af
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.USEFUL = 1)] = "USEFUL"),
    (i[(i.USELESS = 2)] = "USELESS")
})(af || (af = {})),
  n.util.setEnumType(
    af,
    "aiserver.v1.ContextItemStatus.PostGenerationEvaluation",
    [
      { no: 0, name: "POST_GENERATION_EVALUATION_UNSPECIFIED" },
      { no: 1, name: "POST_GENERATION_EVALUATION_USEFUL" },
      { no: 2, name: "POST_GENERATION_EVALUATION_USELESS" },
    ],
  )
var cat = class HP extends h {
    constructor(t) {
      super(), (this.item = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "intent", kind: "message", T: tDt },
        { no: 2, name: "file_chunk", kind: "message", T: lat, oneof: "item" },
        {
          no: 3,
          name: "outline_chunk",
          kind: "message",
          T: _4t,
          oneof: "item",
        },
        {
          no: 4,
          name: "cmd_k_selection",
          kind: "message",
          T: uat,
          oneof: "item",
        },
        {
          no: 5,
          name: "cmd_k_immediate_context",
          kind: "message",
          T: hat,
          oneof: "item",
        },
        { no: 6, name: "cmd_k_query", kind: "message", T: HW, oneof: "item" },
        {
          no: 7,
          name: "cmd_k_query_history",
          kind: "message",
          T: U4t,
          oneof: "item",
        },
        {
          no: 8,
          name: "custom_instructions",
          kind: "message",
          T: V4t,
          oneof: "item",
        },
        {
          no: 9,
          name: "go_to_definition_result",
          kind: "message",
          T: G4t,
          oneof: "item",
        },
        {
          no: 10,
          name: "documentation_chunk",
          kind: "message",
          T: z4t,
          oneof: "item",
        },
        { no: 11, name: "lints", kind: "message", T: Y4t, oneof: "item" },
        {
          no: 12,
          name: "chat_history",
          kind: "message",
          T: W4t,
          oneof: "item",
        },
        {
          no: 13,
          name: "notebook_cell_output",
          kind: "message",
          T: X4t,
          oneof: "item",
        },
        {
          no: 14,
          name: "terminal_history",
          kind: "message",
          T: j4t,
          oneof: "item",
        },
        {
          no: 15,
          name: "terminal_cmd_k_query",
          kind: "message",
          T: dat,
          oneof: "item",
        },
        {
          no: 16,
          name: "terminal_cmd_k_query_history",
          kind: "message",
          T: q4t,
          oneof: "item",
        },
        {
          no: 17,
          name: "sparse_file_chunk",
          kind: "message",
          T: F4t,
          oneof: "item",
        },
        {
          no: 18,
          name: "lsp_subgraph_chunk",
          kind: "message",
          T: K4t,
          oneof: "item",
        },
        {
          no: 19,
          name: "commit_note_chunk",
          kind: "message",
          T: Z4t,
          oneof: "item",
        },
        {
          no: 20,
          name: "file_diff_history",
          kind: "message",
          T: O4t,
          oneof: "item",
        },
        {
          no: 21,
          name: "cmd_k_query_history_in_diff_session",
          kind: "message",
          T: M4t,
          oneof: "item",
        },
      ])
    }
    static fromBinary(t, e) {
      return new HP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HP, t, e)
    }
  },
  lat = class WP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunkContents = ""),
        (this.startLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.FileChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "chunk_contents", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new WP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WP, t, e)
    }
  },
  F4t = class jP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lines = []),
        (this.totalNumberOfLinesInFile = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.SparseFileChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "message", T: A4t, repeated: !0 },
        { no: 3, name: "total_number_of_lines_in_file", kind: "scalar", T: 5 },
        { no: 4, name: "cell_number", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new jP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jP, t, e)
    }
  },
  A4t = class VP extends h {
    constructor(t) {
      super(),
        (this.line = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.SparseFileChunk.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new VP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VP, t, e)
    }
  },
  _4t = class GP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.OutlineChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "full_range", kind: "message", T: Li },
      ])
    }
    static fromBinary(t, e) {
      return new GP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GP, t, e)
    }
  },
  uat = class zP extends h {
    constructor(t) {
      super(),
        (this.lines = []),
        (this.startLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new zP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zP, t, e)
    }
  },
  O4t = class YP extends h {
    constructor(t) {
      super(),
        (this.howManyDiffsAgo = 0),
        (this.isVeryRecent = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.FileDiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_file_diff_history", kind: "message", T: Xi },
        { no: 2, name: "how_many_diffs_ago", kind: "scalar", T: 5 },
        { no: 3, name: "is_very_recent", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new YP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YP, t, e)
    }
  },
  hat = class QP extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lines = []),
        (this.totalNumberOfLinesInFile = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKImmediateContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "message", T: B4t, repeated: !0 },
        { no: 3, name: "total_number_of_lines_in_file", kind: "scalar", T: 5 },
        { no: 4, name: "cell_number", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new QP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QP, t, e)
    }
  },
  B4t = class XP extends h {
    constructor(t) {
      super(),
        (this.line = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKImmediateContext.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new XP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XP, t, e)
    }
  },
  HW = class KP extends h {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKQuery"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new KP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KP, t, e)
    }
  },
  dat = class ZP extends h {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.TerminalCmdKQuery"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ZP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZP, t, e)
    }
  },
  q4t = class yu extends h {
    constructor(t) {
      super(),
        (this.contextItemHashes = []),
        (this.suggestedCommand = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.TerminalCmdKQueryHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "message", T: dat },
        { no: 2, name: "query_history", kind: "message", T: yu },
        {
          no: 5,
          name: "context_item_hashes",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "suggested_command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new yu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yu, t, e)
    }
  },
  U4t = class bu extends h {
    constructor(t) {
      super(), (this.contextItemHashes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKQueryHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "message", T: HW },
        { no: 2, name: "immediate_context", kind: "message", T: hat },
        { no: 3, name: "selection", kind: "message", T: uat },
        { no: 4, name: "query_history", kind: "message", T: bu },
        {
          no: 5,
          name: "context_item_hashes",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "timestamp", kind: "scalar", T: 3, opt: !0 },
        { no: 7, name: "timestamp_double", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new bu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bu, t, e)
    }
  },
  M4t = class t$ extends h {
    constructor(t) {
      super(),
        (this.pastCmdkQueries = []),
        (this.currTimestampDouble = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKQueryHistoryInDiffSession"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "past_cmdk_queries",
          kind: "message",
          T: H4t,
          repeated: !0,
        },
        { no: 3, name: "curr_timestamp_double", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new t$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t$, t, e)
    }
  },
  H4t = class e$ extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.timestampDouble = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ContextItem.CmdKQueryHistoryInDiffSession.PastCmdKQueryInDiffSession"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "message", T: HW },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 5, name: "cmdk_was_accepted", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "timestamp_double", kind: "scalar", T: 1 },
        {
          no: 7,
          name: "timestamp_for_diff_interleaving",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        { no: 8, name: "request_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new e$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e$, t, e)
    }
  },
  W4t = class Tu extends h {
    constructor(t) {
      super(),
        (this.userMessage = ""),
        (this.assistantResponse = ""),
        (this.activeForCmdK = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.ChatHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_message", kind: "scalar", T: 9 },
        { no: 2, name: "assistant_response", kind: "scalar", T: 9 },
        { no: 3, name: "chat_history", kind: "message", T: Tu },
        { no: 4, name: "active_for_cmd_k", kind: "scalar", T: 8 },
        { no: 5, name: "timestamp", kind: "scalar", T: 3, opt: !0 },
        { no: 6, name: "timestamp_double", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Tu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tu, t, e)
    }
  },
  j4t = class i$ extends h {
    constructor(t) {
      super(),
        (this.history = ""),
        (this.cwdFull = ""),
        (this.cwdRelativeWorkspacePath = ""),
        (this.activeForCmdK = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.TerminalHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "history", kind: "scalar", T: 9 },
        { no: 5, name: "cwd_full", kind: "scalar", T: 9 },
        { no: 6, name: "cwd_relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "active_for_cmd_k", kind: "scalar", T: 8 },
        { no: 7, name: "timestamp", kind: "scalar", T: 3, opt: !0 },
        { no: 8, name: "timestamp_double", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new i$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i$, t, e)
    }
  },
  V4t = class s$ extends h {
    constructor(t) {
      super(), (this.instructions = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CustomInstructions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instructions", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new s$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s$, t, e)
    }
  },
  G4t = class r$ extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.line = ""),
        (this.lineNumber = 0),
        (this.columnNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.GoToDefinitionResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line", kind: "scalar", T: 9 },
        { no: 3, name: "line_number", kind: "scalar", T: 5 },
        { no: 4, name: "column_number", kind: "scalar", T: 5 },
        { no: 5, name: "definition_chunk", kind: "message", T: lat },
      ])
    }
    static fromBinary(t, e) {
      return new r$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r$, t, e)
    }
  },
  z4t = class n$ extends h {
    constructor(t) {
      super(),
        (this.docName = ""),
        (this.pageUrl = ""),
        (this.documentationChunk = ""),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.DocumentationChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_name", kind: "scalar", T: 9 },
        { no: 2, name: "page_url", kind: "scalar", T: 9 },
        { no: 3, name: "documentation_chunk", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new n$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n$, t, e)
    }
  },
  Y4t = class a$ extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lints = []),
        (this.contextLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.Lints"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "lints", kind: "message", T: uSt, repeated: !0 },
        { no: 3, name: "context_lines", kind: "message", T: Q4t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new a$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a$, t, e)
    }
  },
  Q4t = class o$ extends h {
    constructor(t) {
      super(),
        (this.line = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.Lints.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new o$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o$, t, e)
    }
  },
  X4t = class c$ extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.cellOutput = ""),
        (this.cellNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.NotebookCellOutput"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "cell_output", kind: "scalar", T: 9 },
        { no: 3, name: "cell_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new c$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c$, t, e)
    }
  },
  K4t = class l$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.LspSubgraphChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lsp_subgraph_full_context", kind: "message", T: DM },
      ])
    }
    static fromBinary(t, e) {
      return new l$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l$, t, e)
    }
  },
  Z4t = class u$ extends h {
    constructor(t) {
      super(), (this.note = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CommitNoteChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "note", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new u$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u$, t, e)
    }
  },
  tDt = class h$ extends h {
    constructor(t) {
      super(),
        (this.type = of.UNSPECIFIED),
        (this.uuid = ""),
        (this.intent = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(of) },
        { no: 15, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "file", kind: "message", T: iDt, oneof: "intent" },
        {
          no: 3,
          name: "code_selection",
          kind: "message",
          T: sDt,
          oneof: "intent",
        },
        { no: 5, name: "lints", kind: "message", T: nDt, oneof: "intent" },
        {
          no: 6,
          name: "recent_locations",
          kind: "message",
          T: cDt,
          oneof: "intent",
        },
        {
          no: 8,
          name: "cmd_k_current_file",
          kind: "message",
          T: hDt,
          oneof: "intent",
        },
        {
          no: 9,
          name: "cmd_k_query_etc",
          kind: "message",
          T: dDt,
          oneof: "intent",
        },
        {
          no: 14,
          name: "terminal_cmd_k_defaults",
          kind: "message",
          T: vDt,
          oneof: "intent",
        },
        {
          no: 10,
          name: "cmd_k_definitions",
          kind: "message",
          T: fDt,
          oneof: "intent",
        },
        {
          no: 11,
          name: "documentation",
          kind: "message",
          T: eDt,
          oneof: "intent",
        },
        {
          no: 12,
          name: "custom_instructions",
          kind: "message",
          T: mDt,
          oneof: "intent",
        },
        {
          no: 13,
          name: "chat_history",
          kind: "message",
          T: pDt,
          oneof: "intent",
        },
        {
          no: 16,
          name: "terminal_history",
          kind: "message",
          T: wDt,
          oneof: "intent",
        },
        {
          no: 17,
          name: "visible_tabs",
          kind: "message",
          T: uDt,
          oneof: "intent",
        },
        {
          no: 18,
          name: "lsp_subgraph",
          kind: "message",
          T: yDt,
          oneof: "intent",
        },
        {
          no: 19,
          name: "commit_notes",
          kind: "message",
          T: rDt,
          oneof: "intent",
        },
        {
          no: 20,
          name: "diff_history",
          kind: "message",
          T: gDt,
          oneof: "intent",
        },
        {
          no: 21,
          name: "past_cmdk_messages_in_diff_sessions",
          kind: "message",
          T: lDt,
          oneof: "intent",
        },
      ])
    }
    static fromBinary(t, e) {
      return new h$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h$, t, e)
    }
  },
  of
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.USER_ADDED = 1)] = "USER_ADDED"),
    (i[(i.AUTOMATIC = 2)] = "AUTOMATIC")
})(of || (of = {})),
  n.util.setEnumType(of, "aiserver.v1.ContextIntent.Type", [
    { no: 0, name: "TYPE_UNSPECIFIED" },
    { no: 1, name: "TYPE_USER_ADDED" },
    { no: 2, name: "TYPE_AUTOMATIC" },
  ])
var eDt = class d$ extends h {
    constructor(t) {
      super(), (this.documentationIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Documentation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "documentation_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new d$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d$, t, e)
    }
  },
  iDt = class m$ extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.mode = cf.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "mode", kind: "enum", T: n.getEnumType(cf) },
      ])
    }
    static fromBinary(t, e) {
      return new m$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m$, t, e)
    }
  },
  cf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FULL = 1)] = "FULL"),
    (i[(i.OUTLINE = 2)] = "OUTLINE"),
    (i[(i.CHUNKS = 3)] = "CHUNKS")
})(cf || (cf = {})),
  n.util.setEnumType(cf, "aiserver.v1.ContextIntent.File.Mode", [
    { no: 0, name: "MODE_UNSPECIFIED" },
    { no: 1, name: "MODE_FULL" },
    { no: 2, name: "MODE_OUTLINE" },
    { no: 3, name: "MODE_CHUNKS" },
  ])
var sDt = class f$ extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CodeSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "potentially_out_of_date_range",
          kind: "message",
          T: Pi,
        },
        { no: 3, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new f$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f$, t, e)
    }
  },
  _Xt = class p$ extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Symbol"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol", kind: "message", T: xM },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new p$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p$, t, e)
    }
  },
  rDt = class g$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CommitNotes"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new g$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g$, t, e)
    }
  },
  nDt = class v$ extends h {
    constructor(t) {
      super(),
        (this.scope = { case: void 0 }),
        (this.filterToSeverities = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Lints"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cmdk_scope", kind: "message", T: aDt, oneof: "scope" },
        { no: 2, name: "file_scope", kind: "message", T: oDt, oneof: "scope" },
        {
          no: 3,
          name: "filter_to_severities",
          kind: "enum",
          T: n.getEnumType(Jl),
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new v$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v$, t, e)
    }
  },
  aDt = class w$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Lints.CmdKScope"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new w$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w$, t, e)
    }
  },
  oDt = class y$ extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Lints.FileScope"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "filter_range", kind: "message", T: Li, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new y$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y$, t, e)
    }
  },
  cDt = class b$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.RecentLocations"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "timestamp", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new b$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b$, t, e)
    }
  },
  lDt = class T$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ContextIntent.PastCmdkConversationsInDiffSessions"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new T$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T$, t, e)
    }
  },
  uDt = class k$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.VisibleTabs"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new k$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k$, t, e)
    }
  },
  OXt = class S$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CodebaseChunks"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new S$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S$, t, e)
    }
  },
  hDt = class E$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CmdKCurrentFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new E$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E$, t, e)
    }
  },
  dDt = class I$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CmdKQueryEtc"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new I$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I$, t, e)
    }
  },
  mDt = class P$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CustomInstructions"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new P$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P$, t, e)
    }
  },
  fDt = class $$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CmdKDefinitions"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new $$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($$, t, e)
    }
  },
  pDt = class x$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.ChatHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new x$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x$, t, e)
    }
  },
  gDt = class N$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.DiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new N$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N$, t, e)
    }
  },
  vDt = class C$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.TerminalCmdKDefaults"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new C$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C$, t, e)
    }
  },
  wDt = class J$ extends h {
    constructor(t) {
      super(),
        (this.instanceId = 0),
        (this.activeForCmdK = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.TerminalHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instance_id", kind: "scalar", T: 5 },
        { no: 2, name: "active_for_cmd_k", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "use_active_instance_as_fallback",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new J$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J$, t, e)
    }
  },
  yDt = class L$ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.LspSubgraph"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new L$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L$, t, e)
    }
  },
  bDt = class R$ extends h {
    constructor(t) {
      super(), (this.contextItems = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankCmdKContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: qo, repeated: !0 },
        { no: 3, name: "legacy_context", kind: "message", T: lf },
        { no: 2, name: "cmd_k_options", kind: "message", T: XB },
      ])
    }
    static fromBinary(t, e) {
      return new R$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R$, t, e)
    }
  },
  TDt = class D$ extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankCmdKContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "context_status_update",
          kind: "message",
          T: YB,
          oneof: "response",
        },
        {
          no: 2,
          name: "missing_context_items",
          kind: "message",
          T: QB,
          oneof: "response",
        },
        { no: 3, name: "did_call", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new D$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D$, t, e)
    }
  },
  kDt = class F$ extends h {
    constructor(t) {
      super(), (this.contextItems = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankTerminalCmdKContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: qo, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: mat },
      ])
    }
    static fromBinary(t, e) {
      return new F$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F$, t, e)
    }
  },
  SDt = class A$ extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankTerminalCmdKContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "context_status_update",
          kind: "message",
          T: YB,
          oneof: "response",
        },
        {
          no: 2,
          name: "missing_context_items",
          kind: "message",
          T: QB,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new A$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A$, t, e)
    }
  },
  mat = class _$ extends h {
    constructor(t) {
      super(),
        (this.chatMode = !1),
        (this.adaCmdKContext = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TerminalCmdKOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 3, name: "model_details", kind: "message", T: St },
        { no: 1, name: "chat_mode", kind: "scalar", T: 8 },
        { no: 2, name: "ada_cmd_k_context", kind: "scalar", T: 8 },
        { no: 4, name: "use_web", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_$, t, e)
    }
  },
  XB = class O$ extends h {
    constructor(t) {
      super(),
        (this.chatMode = !1),
        (this.adaCmdKContext = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 3, name: "model_details", kind: "message", T: St },
        { no: 1, name: "chat_mode", kind: "scalar", T: 8 },
        { no: 2, name: "ada_cmd_k_context", kind: "scalar", T: 8 },
        { no: 4, name: "use_reranker", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "use_web", kind: "scalar", T: 8, opt: !0 },
        {
          no: 6,
          name: "request_is_for_caching",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new O$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O$, t, e)
    }
  },
  fat = class B$ extends h {
    constructor(t) {
      super(),
        (this.originalLines = []),
        (this.relativePath = ""),
        (this.extraContextAbove = []),
        (this.extraContextBelow = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKUpcomingEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "relative_path", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "extra_context_above",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 5,
          name: "extra_context_below",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new B$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B$, t, e)
    }
  },
  KB = class q$ extends h {
    constructor(t) {
      super(),
        (this.originalLines = []),
        (this.newLines = []),
        (this.relativePath = ""),
        (this.extraContextAbove = []),
        (this.extraContextBelow = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKPreviousEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "relative_path", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "extra_context_above",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 5,
          name: "extra_context_below",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new q$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q$, t, e)
    }
  },
  EDt = class U$ extends h {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.sessionId = ""),
        (this.previousEdits = []),
        (this.upcomingEdits = []),
        (this.images = []),
        (this.links = []),
        (this.diffHistory = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHypermodeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: qo, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: XB },
        { no: 4, name: "cmd_k_debug_info", kind: "message", T: Rs },
        { no: 6, name: "session_id", kind: "scalar", T: 9 },
        { no: 5, name: "legacy_context", kind: "message", T: lf },
        { no: 7, name: "previous_edit", kind: "message", T: KB, opt: !0 },
        { no: 8, name: "previous_edits", kind: "message", T: KB, repeated: !0 },
        {
          no: 12,
          name: "upcoming_edits",
          kind: "message",
          T: fat,
          repeated: !0,
        },
        {
          no: 9,
          name: "use_big_cmdk_for_multi_file_edit",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 10, name: "images", kind: "message", T: Ea, repeated: !0 },
        { no: 11, name: "links", kind: "message", T: JM, repeated: !0 },
        { no: 13, name: "diff_history", kind: "message", T: Xi, repeated: !0 },
        { no: 14, name: "hyper_model", kind: "scalar", T: 9, opt: !0 },
        { no: 15, name: "timing_info", kind: "message", T: pat, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new U$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U$, t, e)
    }
  },
  IDt = class M$ extends h {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.sessionId = ""),
        (this.previousEdits = []),
        (this.upcomingEdits = []),
        (this.images = []),
        (this.links = []),
        (this.diffHistory = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: qo, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: XB },
        { no: 4, name: "cmd_k_debug_info", kind: "message", T: Rs },
        { no: 6, name: "session_id", kind: "scalar", T: 9 },
        { no: 5, name: "legacy_context", kind: "message", T: lf },
        { no: 7, name: "previous_edit", kind: "message", T: KB, opt: !0 },
        { no: 8, name: "previous_edits", kind: "message", T: KB, repeated: !0 },
        {
          no: 12,
          name: "upcoming_edits",
          kind: "message",
          T: fat,
          repeated: !0,
        },
        {
          no: 9,
          name: "use_big_cmdk_for_multi_file_edit",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 10, name: "images", kind: "message", T: Ea, repeated: !0 },
        { no: 11, name: "links", kind: "message", T: JM, repeated: !0 },
        { no: 13, name: "diff_history", kind: "message", T: Xi, repeated: !0 },
        {
          no: 14,
          name: "diff_to_base_branch",
          kind: "message",
          T: PDt,
          opt: !0,
        },
        { no: 15, name: "timing_info", kind: "message", T: pat, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new M$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M$, t, e)
    }
  },
  PDt = class H$ extends h {
    constructor(t) {
      super(),
        (this.fileDiffs = []),
        (this.commits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKRequest.BranchDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: $Dt, repeated: !0 },
        { no: 2, name: "commits", kind: "message", T: Ca, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new H$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H$, t, e)
    }
  },
  $Dt = class W$ extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diff = ""),
        (this.tooBig = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKRequest.BranchDiff.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
        { no: 3, name: "too_big", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new W$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W$, t, e)
    }
  },
  pat = class j$ extends h {
    constructor(t) {
      super(),
        (this.userInputTime = 0),
        (this.streamCmdkTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TimingInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_input_time", kind: "scalar", T: 1 },
        { no: 2, name: "stream_cmdk_time", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new j$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j$, t, e)
    }
  },
  xDt = class V$ extends h {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.sessionId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: qo, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: mat },
        { no: 6, name: "session_id", kind: "scalar", T: 9 },
        { no: 5, name: "legacy_context", kind: "message", T: lf },
      ])
    }
    static fromBinary(t, e) {
      return new V$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V$, t, e)
    }
  },
  lf = class G$ extends h {
    constructor(t) {
      super(),
        (this.promptCodeBlocks = []),
        (this.documentationIdentifiers = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKLegacyContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        {
          no: 12,
          name: "prompt_code_blocks",
          kind: "message",
          T: Ne,
          repeated: !0,
        },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new G$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G$, t, e)
    }
  },
  gat = class z$ extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponseContextWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: WW,
          oneof: "response",
        },
        {
          no: 2,
          name: "context_status_update",
          kind: "message",
          T: YB,
          oneof: "response",
        },
        {
          no: 3,
          name: "missing_context_items",
          kind: "message",
          T: QB,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new z$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z$, t, e)
    }
  },
  NDt = class Y$ extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponseContextWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: CDt,
          oneof: "response",
        },
        {
          no: 2,
          name: "context_status_update",
          kind: "message",
          T: YB,
          oneof: "response",
        },
        {
          no: 3,
          name: "missing_context_items",
          kind: "message",
          T: QB,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Y$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y$, t, e)
    }
  },
  CDt = class Q$ extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "terminal_command",
          kind: "message",
          T: JDt,
          oneof: "response",
        },
        { no: 4, name: "chat", kind: "message", T: LDt, oneof: "response" },
        {
          no: 5,
          name: "status_update",
          kind: "message",
          T: RDt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Q$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q$, t, e)
    }
  },
  JDt = class X$ extends h {
    constructor(t) {
      super(), (this.partialCommand = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponse.TerminalCommand"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "partial_command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new X$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X$, t, e)
    }
  },
  LDt = class K$ extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponse.Chat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new K$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K$, t, e)
    }
  },
  RDt = class Z$ extends h {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponse.StatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Z$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z$, t, e)
    }
  },
  WW = class tx extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "edit_start",
          kind: "message",
          T: DDt,
          oneof: "response",
        },
        {
          no: 2,
          name: "edit_stream",
          kind: "message",
          T: FDt,
          oneof: "response",
        },
        { no: 3, name: "edit_end", kind: "message", T: ADt, oneof: "response" },
        { no: 4, name: "chat", kind: "message", T: _Dt, oneof: "response" },
        {
          no: 5,
          name: "status_update",
          kind: "message",
          T: ODt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new tx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tx, t, e)
    }
  },
  DDt = class ex extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.editId = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.EditStart"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "edit_id", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "max_end_line_number_exclusive",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 4, name: "file_path", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ex().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ex().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ex().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ex, t, e)
    }
  },
  FDt = class ix extends h {
    constructor(t) {
      super(), (this.text = ""), (this.editId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.EditStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "edit_id", kind: "scalar", T: 5 },
        { no: 3, name: "file_path", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ix().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ix().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ix().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ix, t, e)
    }
  },
  ADt = class sx extends h {
    constructor(t) {
      super(),
        (this.endLineNumberExclusive = 0),
        (this.editId = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.EditEnd"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
        { no: 2, name: "edit_id", kind: "scalar", T: 5 },
        { no: 3, name: "file_path", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sx, t, e)
    }
  },
  _Dt = class rx extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.Chat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rx, t, e)
    }
  },
  ODt = class nx extends h {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.StatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new nx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nx, t, e)
    }
  },
  BDt = class ax extends h {
    constructor(t) {
      super(),
        (this.codeBlocks = []),
        (this.contextItems = []),
        (this.sessionId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelevantChunksRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: XB },
        { no: 3, name: "context_items", kind: "message", T: qo, repeated: !0 },
        { no: 4, name: "session_id", kind: "scalar", T: 9 },
        { no: 5, name: "legacy_context", kind: "message", T: lf },
      ])
    }
    static fromBinary(t, e) {
      return new ax().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ax().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ax().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ax, t, e)
    }
  },
  qDt = class ox extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamGetRelevantChunksResponseContextWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: UDt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new ox().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ox().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ox().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ox, t, e)
    }
  },
  UDt = class cx extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelevantChunksResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "code_blocks",
          kind: "message",
          T: HDt,
          oneof: "response",
        },
        {
          no: 2,
          name: "chain_of_thought_stream",
          kind: "message",
          T: MDt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new cx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cx, t, e)
    }
  },
  MDt = class lx extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.GetRelevantChunksResponse.ChainOfThoughtStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lx, t, e)
    }
  },
  HDt = class ux extends h {
    constructor(t) {
      super(), (this.codeBlocks = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelevantChunksResponse.CodeBlocks"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ux().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ux().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ux().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ux, t, e)
    }
  },
  ZB
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ACCEPTED = 1)] = "ACCEPTED"),
    (i[(i.REJECTED = 2)] = "REJECTED"),
    (i[(i.PARTIALLY_ACCEPTED = 3)] = "PARTIALLY_ACCEPTED")
})(ZB || (ZB = {})),
  n.util.setEnumType(ZB, "aiserver.v1.EditFate", [
    { no: 0, name: "EDIT_FATE_UNSPECIFIED" },
    { no: 1, name: "EDIT_FATE_ACCEPTED" },
    { no: 2, name: "EDIT_FATE_REJECTED" },
    { no: 3, name: "EDIT_FATE_PARTIALLY_ACCEPTED" },
  ])
var Wl
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.COMPOSER = 1)] = "COMPOSER"),
    (i[(i.CLICKED_APPLY = 2)] = "CLICKED_APPLY"),
    (i[(i.CACHED_APPLY = 3)] = "CACHED_APPLY"),
    (i[(i.COMPOSER_AGENT = 4)] = "COMPOSER_AGENT")
})(Wl || (Wl = {})),
  n.util.setEnumType(Wl, "aiserver.v1.FastApplySource", [
    { no: 0, name: "FAST_APPLY_SOURCE_UNSPECIFIED" },
    { no: 1, name: "FAST_APPLY_SOURCE_COMPOSER" },
    { no: 2, name: "FAST_APPLY_SOURCE_CLICKED_APPLY" },
    { no: 3, name: "FAST_APPLY_SOURCE_CACHED_APPLY" },
    { no: 4, name: "FAST_APPLY_SOURCE_COMPOSER_AGENT" },
  ])
var WDt = class hx extends h {
    constructor(t) {
      super(), (this.requestId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportEditFateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "fate", kind: "enum", T: n.getEnumType(ZB), opt: !0 },
        {
          no: 3,
          name: "num_accepted_partial_diffs",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "num_rejected_partial_diffs",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new hx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hx, t, e)
    }
  },
  jDt = class dx extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportEditFateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new dx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dx, t, e)
    }
  },
  VDt = class mx extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.source = Wl.UNSPECIFIED),
        (this.willingToPayExtraForSpeed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmApplyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "current_file", kind: "message", T: Yt },
        { no: 3, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "source", kind: "enum", T: n.getEnumType(Wl) },
        { no: 6, name: "willing_to_pay_extra_for_speed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new mx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mx, t, e)
    }
  },
  GDt = class fx extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmApplyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new fx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fx, t, e)
    }
  },
  Uo
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SPECIFIC_RULES = 1)] = "SPECIFIC_RULES"),
    (i[(i.COMPILE_ERRORS = 2)] = "COMPILE_ERRORS"),
    (i[(i.CHANGE_BEHAVIOR = 3)] = "CHANGE_BEHAVIOR"),
    (i[(i.RELEVANCE = 5)] = "RELEVANCE"),
    (i[(i.USER_AWARENESS = 6)] = "USER_AWARENESS"),
    (i[(i.CORRECTNESS = 7)] = "CORRECTNESS"),
    (i[(i.CHUNKING = 8)] = "CHUNKING"),
    (i[(i.TYPO = 9)] = "TYPO"),
    (i[(i.CONFIDENCE = 10)] = "CONFIDENCE"),
    (i[(i.DISMISSED_BUGS = 11)] = "DISMISSED_BUGS")
})(Uo || (Uo = {})),
  n.util.setEnumType(Uo, "aiserver.v1.LintDiscriminator", [
    { no: 0, name: "LINT_DISCRIMINATOR_UNSPECIFIED" },
    { no: 1, name: "LINT_DISCRIMINATOR_SPECIFIC_RULES" },
    { no: 2, name: "LINT_DISCRIMINATOR_COMPILE_ERRORS" },
    { no: 3, name: "LINT_DISCRIMINATOR_CHANGE_BEHAVIOR" },
    { no: 5, name: "LINT_DISCRIMINATOR_RELEVANCE" },
    { no: 6, name: "LINT_DISCRIMINATOR_USER_AWARENESS" },
    { no: 7, name: "LINT_DISCRIMINATOR_CORRECTNESS" },
    { no: 8, name: "LINT_DISCRIMINATOR_CHUNKING" },
    { no: 9, name: "LINT_DISCRIMINATOR_TYPO" },
    { no: 10, name: "LINT_DISCRIMINATOR_CONFIDENCE" },
    { no: 11, name: "LINT_DISCRIMINATOR_DISMISSED_BUGS" },
  ])
var Mo
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NAIVE = 1)] = "NAIVE"),
    (i[(i.COMMENT_PIPELINE = 2)] = "COMMENT_PIPELINE"),
    (i[(i.SIMPLE_BUG = 3)] = "SIMPLE_BUG"),
    (i[(i.SIMPLE_LINT_RULES = 4)] = "SIMPLE_LINT_RULES")
})(Mo || (Mo = {})),
  n.util.setEnumType(Mo, "aiserver.v1.LintGenerator", [
    { no: 0, name: "LINT_GENERATOR_UNSPECIFIED" },
    { no: 1, name: "LINT_GENERATOR_NAIVE" },
    { no: 2, name: "LINT_GENERATOR_COMMENT_PIPELINE" },
    { no: 3, name: "LINT_GENERATOR_SIMPLE_BUG" },
    { no: 4, name: "LINT_GENERATOR_SIMPLE_LINT_RULES" },
  ])
var vat = class px extends h {
    constructor(t) {
      super(),
        (this.relativeFilePath = ""),
        (this.lineSelection = ""),
        (this.tokenStartIndex = 0),
        (this.tokenEndIndex = 0),
        (this.likelyAlternateToken = ""),
        (this.lineChunkIndexZeroBased = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintExplanationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
        { no: 2, name: "chunk", kind: "message", T: uf },
        { no: 3, name: "line_selection", kind: "scalar", T: 9 },
        { no: 4, name: "token_start_index", kind: "scalar", T: 5 },
        { no: 5, name: "token_end_index", kind: "scalar", T: 5 },
        { no: 6, name: "likely_alternate_token", kind: "scalar", T: 9 },
        { no: 7, name: "line_chunk_index_zero_based", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new px().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new px().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new px().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(px, t, e)
    }
  },
  zDt = class gx extends h {
    constructor(t) {
      super(), (this.explanation = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintExplanationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "explanation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new gx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gx, t, e)
    }
  },
  YDt = class vx extends h {
    constructor(t) {
      super(),
        (this.origLine = ""),
        (this.newLine = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintExplanationResponse2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "orig_line", kind: "scalar", T: 9 },
        { no: 2, name: "new_line", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new vx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vx, t, e)
    }
  },
  uf = class wx extends h {
    constructor(t) {
      super(),
        (this.chunkContents = ""),
        (this.startLineNumber = 0),
        (this.numRemainingLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "chunk_contents", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "num_remaining_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new wx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wx, t, e)
    }
  },
  QDt = class yx extends h {
    constructor(t) {
      super(), (this.relativeFilePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintChunkRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
        { no: 2, name: "chunk", kind: "message", T: uf },
        {
          no: 3,
          name: "use_speculative_linter",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new yx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yx, t, e)
    }
  },
  XDt = class bx extends h {
    constructor(t) {
      super(), (this.chunkTokens = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintChunkResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk_tokens", kind: "message", T: jW, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new bx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bx, t, e)
    }
  },
  KDt = class Tx extends h {
    constructor(t) {
      super(), (this.relativeFilePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintFimChunkRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
        { no: 2, name: "prefix", kind: "message", T: uf },
        { no: 3, name: "suffix", kind: "message", T: uf },
        { no: 4, name: "middle", kind: "message", T: uf },
      ])
    }
    static fromBinary(t, e) {
      return new Tx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tx, t, e)
    }
  },
  ZDt = class kx extends h {
    constructor(t) {
      super(), (this.middleChunkTokens = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintFimChunkResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "middle_chunk_tokens",
          kind: "message",
          T: jW,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new kx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kx, t, e)
    }
  },
  tFt = class Sx extends h {
    constructor(t) {
      super(),
        (this.relativeFilePath = ""),
        (this.fileContents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Sx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sx, t, e)
    }
  },
  eFt = class Ex extends h {
    constructor(t) {
      super(),
        (this.token = ""),
        (this.logProbability = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TokensWithLogprobs"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "token", kind: "scalar", T: 9 },
        { no: 2, name: "log_probability", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new Ex().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ex().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ex().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ex, t, e)
    }
  },
  jW = class Ix extends h {
    constructor(t) {
      super(),
        (this.tokensWithLogprobs = []),
        (this.actualToken = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TokenIndex"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "tokens_with_logprobs",
          kind: "message",
          T: eFt,
          repeated: !0,
        },
        { no: 2, name: "actual_token", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ix().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ix().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ix().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ix, t, e)
    }
  },
  iFt = class Px extends h {
    constructor(t) {
      super(), (this.tokens = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tokens", kind: "message", T: jW, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Px().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Px().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Px().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Px, t, e)
    }
  },
  sFt = class $x extends h {
    constructor(t) {
      super(),
        (this.discriminator = Uo.UNSPECIFIED),
        (this.allow = !1),
        (this.reasoning = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintDiscriminatorResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "discriminator", kind: "enum", T: n.getEnumType(Uo) },
        { no: 2, name: "allow", kind: "scalar", T: 8 },
        { no: 3, name: "reasoning", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $x().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $x().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $x().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($x, t, e)
    }
  },
  t3 = class xx extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.uuid = ""),
        (this.message = ""),
        (this.replaceText = ""),
        (this.replaceInitialText = ""),
        (this.reevaluateInitialText = ""),
        (this.generator = Mo.UNSPECIFIED),
        (this.discriminatorResults = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiLintBug"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 8, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "replace_range", kind: "message", T: Pi },
        { no: 4, name: "replace_text", kind: "scalar", T: 9 },
        { no: 5, name: "replace_initial_text", kind: "scalar", T: 9 },
        { no: 6, name: "reevaluate_range", kind: "message", T: Pi },
        { no: 7, name: "reevaluate_initial_text", kind: "scalar", T: 9 },
        { no: 9, name: "generator", kind: "enum", T: n.getEnumType(Mo) },
        {
          no: 10,
          name: "discriminator_results",
          kind: "message",
          T: sFt,
          repeated: !0,
        },
        { no: 11, name: "logprobs_payload", kind: "message", T: rFt },
      ])
    }
    static fromBinary(t, e) {
      return new xx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xx, t, e)
    }
  },
  rFt = class Nx extends h {
    constructor(t) {
      super(),
        (this.chunk = ""),
        (this.problematicLine = ""),
        (this.startCol = 0),
        (this.endCol = 0),
        (this.mostLikelyReplace = ""),
        (this.lineChunkIndexZeroBased = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogprobsLintPayload"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk", kind: "scalar", T: 9 },
        { no: 2, name: "problematic_line", kind: "scalar", T: 9 },
        { no: 3, name: "start_col", kind: "scalar", T: 5 },
        { no: 4, name: "end_col", kind: "scalar", T: 5 },
        { no: 5, name: "most_likely_replace", kind: "scalar", T: 9 },
        { no: 6, name: "line_chunk_index_zero_based", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Nx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nx, t, e)
    }
  },
  BXt = class Cx extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.uuid = ""),
        (this.message = ""),
        (this.lineNumber = 0),
        (this.reevaluateInitialText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiLintInlineSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 8, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "line_number", kind: "scalar", T: 5 },
        { no: 4, name: "reevaluate_range", kind: "message", T: Pi },
        { no: 5, name: "reevaluate_initial_text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Cx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cx, t, e)
    }
  },
  qXt = class Jx extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.uuid = ""),
        (this.message = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiLintOutOfFlowSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 8, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Jx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jx, t, e)
    }
  },
  nFt = class Lx extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiLintRule"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Lx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lx, t, e)
    }
  },
  wat = class Rx extends h {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextAST"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: aFt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Rx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rx, t, e)
    }
  },
  aFt = class Dx extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.nodes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTree"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "nodes", kind: "message", T: yat, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Dx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dx, t, e)
    }
  },
  yat = class Fx extends h {
    constructor(t) {
      super(), (this.node = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "container", kind: "message", T: cFt, oneof: "node" },
        { no: 2, name: "blob", kind: "message", T: lFt, oneof: "node" },
        { no: 3, name: "symbol", kind: "message", T: oFt, oneof: "node" },
      ])
    }
    static fromBinary(t, e) {
      return new Fx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fx, t, e)
    }
  },
  oFt = class Ax extends h {
    constructor(t) {
      super(),
        (this.docString = ""),
        (this.value = ""),
        (this.references = []),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode.Symbol"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_string", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 },
        { no: 6, name: "references", kind: "message", T: bat, repeated: !0 },
        { no: 7, name: "score", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new Ax().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ax().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ax().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ax, t, e)
    }
  },
  cFt = class _x extends h {
    constructor(t) {
      super(),
        (this.docString = ""),
        (this.header = ""),
        (this.trailer = ""),
        (this.children = []),
        (this.references = []),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode.Container"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_string", kind: "scalar", T: 9 },
        { no: 2, name: "header", kind: "scalar", T: 9 },
        { no: 3, name: "trailer", kind: "scalar", T: 9 },
        { no: 5, name: "children", kind: "message", T: yat, repeated: !0 },
        { no: 6, name: "references", kind: "message", T: bat, repeated: !0 },
        { no: 7, name: "score", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new _x().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _x().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _x().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_x, t, e)
    }
  },
  lFt = class Ox extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode.Blob"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ox().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ox().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ox().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ox, t, e)
    }
  },
  bat = class Bx extends h {
    constructor(t) {
      super(),
        (this.value = ""),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode.Reference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Bx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bx, t, e)
    }
  },
  VW = class qx extends h {
    constructor(t) {
      super(), (this.feature = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chat", kind: "message", T: hFt, oneof: "feature" },
        {
          no: 2,
          name: "context_chat",
          kind: "message",
          T: gFt,
          oneof: "feature",
        },
        { no: 3, name: "cmd_k", kind: "message", T: vFt, oneof: "feature" },
        {
          no: 4,
          name: "terminal_cmd_k",
          kind: "message",
          T: wFt,
          oneof: "feature",
        },
        {
          no: 5,
          name: "ai_review_accepted_comment",
          kind: "message",
          T: yFt,
          oneof: "feature",
        },
        {
          no: 6,
          name: "interpreter_chat",
          kind: "message",
          T: bFt,
          oneof: "feature",
        },
        {
          no: 7,
          name: "slash_edit",
          kind: "message",
          T: TFt,
          oneof: "feature",
        },
        { no: 8, name: "composer", kind: "message", T: mFt, oneof: "feature" },
        {
          no: 9,
          name: "fast_apply",
          kind: "message",
          T: dFt,
          oneof: "feature",
        },
        {
          no: 10,
          name: "warm_composer",
          kind: "message",
          T: pFt,
          oneof: "feature",
        },
        {
          no: 11,
          name: "bug_finder_trigger_v1",
          kind: "message",
          T: uFt,
          oneof: "feature",
        },
        {
          no: 12,
          name: "tool_call_composer",
          kind: "message",
          T: fFt,
          oneof: "feature",
        },
        {
          no: 13,
          name: "override_num_requests_counted",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new qx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qx, t, e)
    }
  },
  uFt = class Ux extends h {
    constructor(t) {
      super(),
        (this.inBackgroundSubsidized = !1),
        (this.costCents = 0),
        (this.isFast = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.BugFinderTriggerV1"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "in_background_subsidized", kind: "scalar", T: 8 },
        { no: 2, name: "cost_cents", kind: "scalar", T: 5 },
        { no: 3, name: "is_fast", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Ux().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ux().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ux().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ux, t, e)
    }
  },
  hFt = class Mx extends h {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.Chat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Mx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mx, t, e)
    }
  },
  dFt = class Hx extends h {
    constructor(t) {
      super(),
        (this.isOptimistic = !1),
        (this.willingToPayExtraForSpeed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.FastApply"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_optimistic", kind: "scalar", T: 8 },
        { no: 2, name: "willing_to_pay_extra_for_speed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Hx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hx, t, e)
    }
  },
  mFt = class Wx extends h {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.Composer"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Wx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wx, t, e)
    }
  },
  fFt = class jx extends h {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.ToolCallComposer"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jx, t, e)
    }
  },
  pFt = class Vx extends h {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.WarmComposer"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Vx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vx, t, e)
    }
  },
  gFt = class Gx extends h {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.ContextChat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Gx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gx, t, e)
    }
  },
  vFt = class zx extends h {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.CmdK"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new zx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zx, t, e)
    }
  },
  wFt = class Yx extends h {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.TerminalCmdK"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Yx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yx, t, e)
    }
  },
  yFt = class Qx extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.AiReviewAcceptedComment"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Qx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qx, t, e)
    }
  },
  bFt = class Xx extends h {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.InterpreterChat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Xx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xx, t, e)
    }
  },
  TFt = class Kx extends h {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.SlashEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Kx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kx, t, e)
    }
  },
  kFt = class Zx extends h {
    constructor(t) {
      super(),
        (this.timestamp = _e.zero),
        (this.isSlow = !1),
        (this.status = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "timestamp", kind: "scalar", T: 3 },
        { no: 2, name: "details", kind: "message", T: VW },
        {
          no: 3,
          name: "subscription_product_id",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 4, name: "usage_price_id", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "is_slow", kind: "scalar", T: 8 },
        { no: 6, name: "status", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Zx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zx, t, e)
    }
  },
  Tat = class tN extends h {
    constructor(t) {
      super(),
        (this.interfaceRelativeWorkspacePath = ""),
        (this.interfaceLines = []),
        (this.testLines = []),
        (this.implementationLines = []),
        (this.language = ""),
        (this.testingFramework = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterfaceAgentClientState"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 3,
          name: "interface_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
        { no: 4, name: "interface_lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 5,
          name: "test_relative_workspace_path",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 10, name: "test_lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 6,
          name: "implementation_relative_workspace_path",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 7,
          name: "implementation_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 8, name: "language", kind: "scalar", T: 9 },
        { no: 9, name: "testing_framework", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new tN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tN, t, e)
    }
  },
  kat = class eN extends h {
    constructor(t) {
      super(),
        (this.validateConfiguration = vi.UNSPECIFIED),
        (this.stubNewFunction = vi.UNSPECIFIED),
        (this.verifySpec = vi.UNSPECIFIED),
        (this.writeTestPlan = vi.UNSPECIFIED),
        (this.writeTests = vi.UNSPECIFIED),
        (this.writeImplementation = vi.UNSPECIFIED),
        (this.implementNewFunction = vi.UNSPECIFIED),
        (this.runTests = vi.UNSPECIFIED),
        (this.validateConfigurationMessage = ""),
        (this.stubNewFunctionMessage = ""),
        (this.verifySpecMessage = ""),
        (this.writeTestPlanMessage = ""),
        (this.writeTestsMessage = ""),
        (this.writeImplementationMessage = ""),
        (this.implementNewFunctionMessage = ""),
        (this.runTestsMessage = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterfaceAgentStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "validate_configuration",
          kind: "enum",
          T: n.getEnumType(vi),
        },
        {
          no: 2,
          name: "stub_new_function",
          kind: "enum",
          T: n.getEnumType(vi),
        },
        { no: 3, name: "verify_spec", kind: "enum", T: n.getEnumType(vi) },
        { no: 15, name: "write_test_plan", kind: "enum", T: n.getEnumType(vi) },
        { no: 4, name: "write_tests", kind: "enum", T: n.getEnumType(vi) },
        {
          no: 5,
          name: "write_implementation",
          kind: "enum",
          T: n.getEnumType(vi),
        },
        {
          no: 6,
          name: "implement_new_function",
          kind: "enum",
          T: n.getEnumType(vi),
        },
        { no: 7, name: "run_tests", kind: "enum", T: n.getEnumType(vi) },
        { no: 8, name: "validate_configuration_message", kind: "scalar", T: 9 },
        { no: 9, name: "stub_new_function_message", kind: "scalar", T: 9 },
        { no: 10, name: "verify_spec_message", kind: "scalar", T: 9 },
        { no: 16, name: "write_test_plan_message", kind: "scalar", T: 9 },
        { no: 11, name: "write_tests_message", kind: "scalar", T: 9 },
        { no: 12, name: "write_implementation_message", kind: "scalar", T: 9 },
        {
          no: 13,
          name: "implement_new_function_message",
          kind: "scalar",
          T: 9,
        },
        { no: 14, name: "run_tests_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new eN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eN, t, e)
    }
  },
  vi
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.WAITING = 1)] = "WAITING"),
    (i[(i.RUNNING = 2)] = "RUNNING"),
    (i[(i.SUCCESS = 3)] = "SUCCESS"),
    (i[(i.FAILURE = 4)] = "FAILURE")
})(vi || (vi = {})),
  n.util.setEnumType(vi, "aiserver.v1.InterfaceAgentStatus.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_WAITING" },
    { no: 2, name: "STATUS_RUNNING" },
    { no: 3, name: "STATUS_SUCCESS" },
    { no: 4, name: "STATUS_FAILURE" },
  ])
var jl
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.RUNNING = 1)] = "RUNNING"),
    (i[(i.PAUSED = 2)] = "PAUSED"),
    (i[(i.DONE = 3)] = "DONE"),
    (i[(i.NOT_STARTED = 4)] = "NOT_STARTED")
})(jl || (jl = {})),
  n.util.setEnumType(jl, "aiserver.v1.TaskStatus", [
    { no: 0, name: "TASK_STATUS_UNSPECIFIED" },
    { no: 1, name: "TASK_STATUS_RUNNING" },
    { no: 2, name: "TASK_STATUS_PAUSED" },
    { no: 3, name: "TASK_STATUS_DONE" },
    { no: 4, name: "TASK_STATUS_NOT_STARTED" },
  ])
var Sat = class iN extends h {
    constructor(t) {
      super(), (this.terminalContent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsTerminalFinishedRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "terminal_content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iN, t, e)
    }
  },
  SFt = class sN extends h {
    constructor(t) {
      super(), (this.isFinished = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsTerminalFinishedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_finished", kind: "scalar", T: 8 },
        { no: 2, name: "reason", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sN, t, e)
    }
  },
  EFt = class rN extends h {
    constructor(t) {
      super(), (this.isFinished = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsTerminalFinishedResponseV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_finished", kind: "scalar", T: 8 },
        {
          no: 2,
          name: "ended_reason",
          kind: "enum",
          T: n.getEnumType(Hl),
          opt: !0,
        },
        { no: 3, name: "exit_code", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new rN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rN, t, e)
    }
  },
  IFt = class nN extends h {
    constructor(t) {
      super(), (this.message = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TestBidiRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nN, t, e)
    }
  },
  PFt = class aN extends h {
    constructor(t) {
      super(), (this.message = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TestBidiResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new aN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aN, t, e)
    }
  },
  $Ft = class oN extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContent = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoContextFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new oN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oN, t, e)
    }
  },
  xFt = class cN extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.candidateFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "candidate_files",
          kind: "message",
          T: $Ft,
          repeated: !0,
        },
        { no: 3, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new cN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cN, t, e)
    }
  },
  NFt = class lN extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.rerankingScore = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoContextRankedFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "reranking_score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new lN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lN, t, e)
    }
  },
  CFt = class uN extends h {
    constructor(t) {
      super(), (this.rankedFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranked_files", kind: "message", T: NFt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uN, t, e)
    }
  },
  JFt = class hN extends h {
    constructor(t) {
      super(),
        (this.diffCharLen = 0),
        (this.iterations = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckBugBotPriceRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_char_len", kind: "scalar", T: 5 },
        { no: 2, name: "iterations", kind: "scalar", T: 5 },
        { no: 3, name: "model_details", kind: "message", T: St },
        { no: 4, name: "session_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hN, t, e)
    }
  },
  LFt = class dN extends h {
    constructor(t) {
      super(), (this.cost = 0), (this.priceId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckBugBotPriceResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cost", kind: "scalar", T: 1 },
        { no: 2, name: "price_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new dN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dN, t, e)
    }
  },
  RFt = class mN extends h {
    constructor(t) {
      super(), (this.sessionId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckBugBotTelemetryHealthyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new mN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mN, t, e)
    }
  },
  DFt = class fN extends h {
    constructor(t) {
      super(), (this.isHealthy = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckBugBotTelemetryHealthyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_healthy", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new fN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fN, t, e)
    }
  },
  FFt = class pN extends h {
    constructor(t) {
      super(), (this.diffCharLen = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSuggestedBugBotIterationsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_char_len", kind: "scalar", T: 5 },
        { no: 2, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new pN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pN, t, e)
    }
  },
  AFt = class gN extends h {
    constructor(t) {
      super(), (this.iterations = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSuggestedBugBotIterationsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "iterations", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new gN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gN, t, e)
    }
  },
  _Ft = class vN extends h {
    constructor(t) {
      super(),
        (this.status = hf.UNSPECIFIED),
        (this.message = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(hf) },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "iterations_completed", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "total_iterations", kind: "scalar", T: 5, opt: !0 },
        { no: 5, name: "total_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 6, name: "processed_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 7, name: "processed_cost", kind: "scalar", T: 2, opt: !0 },
        { no: 8, name: "thinking_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 9, name: "thinking_cost", kind: "scalar", T: 2, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new vN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vN, t, e)
    }
  },
  hf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.IN_PROGRESS = 1)] = "IN_PROGRESS"),
    (i[(i.IN_PROGRESS_ITERATIONS = 2)] = "IN_PROGRESS_ITERATIONS"),
    (i[(i.DONE = 3)] = "DONE")
})(hf || (hf = {})),
  n.util.setEnumType(hf, "aiserver.v1.BugBotStatus.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_IN_PROGRESS" },
    { no: 2, name: "STATUS_IN_PROGRESS_ITERATIONS" },
    { no: 3, name: "STATUS_DONE" },
  ])
var OFt = class wN extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_reports", kind: "message", T: jet, opt: !0 },
        { no: 2, name: "status", kind: "message", T: _Ft },
      ])
    }
    static fromBinary(t, e) {
      return new wN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wN, t, e)
    }
  },
  BFt = class yN extends h {
    constructor(t) {
      super(),
        (this.chatConversationHistory = []),
        (this.cppDiffTrajectories = []),
        (this.candidateFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextRerankingRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt, opt: !0 },
        {
          no: 2,
          name: "chat_conversation_history",
          kind: "message",
          T: he,
          repeated: !0,
        },
        {
          no: 3,
          name: "cpp_diff_trajectories",
          kind: "message",
          T: Xi,
          repeated: !0,
        },
        {
          no: 4,
          name: "candidate_files",
          kind: "message",
          T: J4t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new yN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yN, t, e)
    }
  },
  qFt = class bN extends h {
    constructor(t) {
      super(), (this.rerankingScores = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextRerankingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "reranking_scores", kind: "scalar", T: 2, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new bN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bN, t, e)
    }
  },
  UFt = class TN extends h {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NameTabRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "message", T: he, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new TN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TN, t, e)
    }
  },
  MFt = class kN extends h {
    constructor(t) {
      super(), (this.name = ""), (this.reason = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NameTabResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "reason", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kN, t, e)
    }
  },
  HFt = class SN extends h {
    constructor(t) {
      super(), (this.modelName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TestModelStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new SN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SN, t, e)
    }
  },
  WFt = class EN extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.latency = 0),
        (this.ttft = 0),
        (this.maxTimeBetweenChunks = 0),
        (this.serverTiming = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TestModelStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "latency", kind: "scalar", T: 2 },
        { no: 3, name: "ttft", kind: "scalar", T: 2 },
        { no: 4, name: "max_time_between_chunks", kind: "scalar", T: 2 },
        { no: 5, name: "server_timing", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new EN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EN, t, e)
    }
  },
  jFt = class IN extends h {
    constructor(t) {
      super(),
        (this.workspaceRelativePath = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TryParseTypeScriptTreeSitterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new IN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IN, t, e)
    }
  },
  VFt = class PN extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TryParseTypeScriptTreeSitterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PN, t, e)
    }
  },
  GFt = class $N extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DevOnlyGetPastRequestIdsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "count", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "page", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new $N().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $N().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $N().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($N, t, e)
    }
  },
  zFt = class xN extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.dateTime = ""),
        (this.modelName = ""),
        (this.featureName = ""),
        (this.s3Uri = ""),
        (this.status = ""),
        (this.numPromptTokens = 0),
        (this.numCompletionTokens = 0),
        (this.apiCallMethod = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DevOnlyPastRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "date_time", kind: "scalar", T: 9 },
        { no: 3, name: "model_name", kind: "scalar", T: 9 },
        { no: 4, name: "feature_name", kind: "scalar", T: 9 },
        { no: 5, name: "s3_uri", kind: "scalar", T: 9 },
        { no: 6, name: "status", kind: "scalar", T: 9 },
        { no: 7, name: "num_prompt_tokens", kind: "scalar", T: 5 },
        { no: 8, name: "num_completion_tokens", kind: "scalar", T: 5 },
        { no: 9, name: "api_call_method", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xN, t, e)
    }
  },
  YFt = class NN extends h {
    constructor(t) {
      super(),
        (this.pastRequests = []),
        (this.totalCount = 0),
        (this.hasMore = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DevOnlyGetPastRequestIdsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "past_requests", kind: "message", T: zFt, repeated: !0 },
        { no: 10, name: "total_count", kind: "scalar", T: 5 },
        { no: 11, name: "has_more", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new NN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NN, t, e)
    }
  },
  QFt = class CN extends h {
    constructor(t) {
      super(), (this.contextToRank = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRankedContextFromContextBankRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "composer_request", kind: "message", T: s3 },
        {
          no: 2,
          name: "context_to_rank",
          kind: "message",
          T: Znt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new CN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CN, t, e)
    }
  },
  XFt = class JN extends h {
    constructor(t) {
      super(), (this.rankedContext = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRankedContextFromContextBankResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranked_context", kind: "message", T: AW, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new JN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JN, t, e)
    }
  },
  KFt = class LN extends h {
    constructor(t) {
      super(), (this.questions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCodebaseQuestionsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "questions", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new LN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LN, t, e)
    }
  },
  ZFt = class RN extends h {
    constructor(t) {
      super(),
        (this.index = 0),
        (this.text = ""),
        (this.type = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AtSymbolOption"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index", kind: "scalar", T: 5 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "type", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RN, t, e)
    }
  },
  tAt = class DN extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.fromFile = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AtSymbolDependencyInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "from_file", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new DN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DN, t, e)
    }
  },
  eAt = class FN extends h {
    constructor(t) {
      super(),
        (this.atSymbolDependencies = []),
        (this.atSymbolOptions = []),
        (this.userQuery = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetAtSymbolSuggestionsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file_info", kind: "message", T: Yt },
        {
          no: 2,
          name: "at_symbol_dependencies",
          kind: "message",
          T: tAt,
          repeated: !0,
        },
        {
          no: 3,
          name: "at_symbol_options",
          kind: "message",
          T: ZFt,
          repeated: !0,
        },
        { no: 4, name: "user_query", kind: "scalar", T: 9 },
        { no: 5, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new FN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FN, t, e)
    }
  },
  iAt = class AN extends h {
    constructor(t) {
      super(),
        (this.indices = []),
        (this.explanation = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetAtSymbolSuggestionsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "indices", kind: "scalar", T: 5, repeated: !0 },
        { no: 2, name: "explanation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new AN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AN, t, e)
    }
  },
  sAt = class _N extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.isFolder = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CurrentFolderFileOrFolder"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "is_folder", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new _N().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _N().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _N().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_N, t, e)
    }
  },
  rAt = class ON extends h {
    constructor(t) {
      super(),
        (this.currentCommand = ""),
        (this.commandHistory = []),
        (this.fileDiffHistories = []),
        (this.commitHistory = []),
        (this.pastResults = []),
        (this.userPlatform = ""),
        (this.currentFolder = ""),
        (this.currentFolderStructure = []),
        (this.relevantFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTerminalCompletionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_command", kind: "scalar", T: 9 },
        { no: 2, name: "command_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "file_diff_histories",
          kind: "message",
          T: Xi,
          repeated: !0,
        },
        { no: 5, name: "git_diff", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "commit_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 7, name: "past_results", kind: "scalar", T: 9, repeated: !0 },
        { no: 8, name: "model_details", kind: "message", T: St },
        { no: 9, name: "user_platform", kind: "scalar", T: 9 },
        { no: 10, name: "current_folder", kind: "scalar", T: 9 },
        {
          no: 11,
          name: "current_folder_structure",
          kind: "message",
          T: sAt,
          repeated: !0,
        },
        {
          no: 12,
          name: "relevant_files",
          kind: "message",
          T: ks,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ON().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ON().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ON().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ON, t, e)
    }
  },
  nAt = class BN extends h {
    constructor(t) {
      super(), (this.command = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTerminalCompletionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new BN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BN, t, e)
    }
  },
  aAt = class qN extends h {
    constructor(t) {
      super(),
        (this.type = df.UNSPECIFIED),
        (this.startLine = 0),
        (this.endLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeuristicsSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(df) },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new qN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qN, t, e)
    }
  },
  df
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GROUP = 1)] = "GROUP"),
    (i[(i.LINE = 2)] = "LINE"),
    (i[(i.FOLDING = 3)] = "FOLDING")
})(df || (df = {})),
  n.util.setEnumType(
    df,
    "aiserver.v1.HeuristicsSelection.HeuristicsSelectionType",
    [
      { no: 0, name: "HEURISTICS_SELECTION_TYPE_UNSPECIFIED" },
      { no: 1, name: "HEURISTICS_SELECTION_TYPE_GROUP" },
      { no: 2, name: "HEURISTICS_SELECTION_TYPE_LINE" },
      { no: 3, name: "HEURISTICS_SELECTION_TYPE_FOLDING" },
    ],
  )
var oAt = class UN extends h {
    constructor(t) {
      super(), (this.heuristicsSelections = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CalculateAutoSelectionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file_info", kind: "message", T: Yt },
        { no: 2, name: "cursor_position", kind: "message", T: ba },
        { no: 3, name: "selection_range", kind: "message", T: Pi },
        { no: 4, name: "model_details", kind: "message", T: St },
        {
          no: 5,
          name: "heuristics_selections",
          kind: "message",
          T: aAt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new UN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UN, t, e)
    }
  },
  cAt = class MN extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoSelectionInstructions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new MN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MN, t, e)
    }
  },
  lAt = class HN extends h {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.instructions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoSelectionResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line", kind: "scalar", T: 5 },
        { no: 3, name: "instructions", kind: "message", T: cAt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new HN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HN, t, e)
    }
  },
  uAt = class WN extends h {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CalculateAutoSelectionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: lAt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new WN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WN, t, e)
    }
  },
  hAt = class jN extends h {
    constructor(t) {
      super(), (this.instruction = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCursorMotionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file_info", kind: "message", T: Yt },
        { no: 2, name: "selection_range", kind: "message", T: Pi },
        { no: 3, name: "instruction", kind: "scalar", T: 9 },
        { no: 4, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new jN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jN, t, e)
    }
  },
  dAt = class VN extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCursorMotionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new VN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VN, t, e)
    }
  },
  mAt = class GN extends h {
    constructor(t) {
      super(),
        (this.instruction = ""),
        (this.type = mf.UNSPECIFIED),
        (this.proposedChangeHistory = []),
        (this.relatedCodeBlocks = []),
        (this.diffHistory = []),
        (this.linterErrors = []),
        (this.usefulTypes = []),
        (this.recentlyViewedFiles = []),
        (this.recentDiffs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "scalar", T: 9 },
        { no: 2, name: "current_file", kind: "message", T: Yt },
        { no: 3, name: "selection_range", kind: "message", T: Pi },
        { no: 4, name: "type", kind: "enum", T: n.getEnumType(mf) },
        {
          no: 5,
          name: "proposed_change_history",
          kind: "message",
          T: gAt,
          repeated: !0,
        },
        {
          no: 6,
          name: "related_code_blocks",
          kind: "message",
          T: Ne,
          repeated: !0,
        },
        { no: 7, name: "diff_history", kind: "message", T: Xi, repeated: !0 },
        { no: 8, name: "linter_errors", kind: "message", T: Eat, repeated: !0 },
        { no: 9, name: "useful_types", kind: "message", T: vAt, repeated: !0 },
        {
          no: 10,
          name: "recently_viewed_files",
          kind: "message",
          T: wAt,
          repeated: !0,
        },
        { no: 11, name: "recent_diffs", kind: "message", T: bAt, repeated: !0 },
        { no: 12, name: "multiple_completions", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new GN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GN, t, e)
    }
  },
  mf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.REFLECT = 1)] = "REFLECT"),
    (i[(i.LOOP_ON_LINTS = 2)] = "LOOP_ON_LINTS"),
    (i[(i.CHAT_AND_APPLY = 3)] = "CHAT_AND_APPLY"),
    (i[(i.COALESCE_GENERATIONS = 4)] = "COALESCE_GENERATIONS"),
    (i[(i.CODEBASE_CHUNKS = 5)] = "CODEBASE_CHUNKS"),
    (i[(i.SPEC_AND_APPLY = 6)] = "SPEC_AND_APPLY"),
    (i[(i.ASK_CODEBASE = 7)] = "ASK_CODEBASE"),
    (i[(i.FINETUNED_INSTRUCTIONS = 8)] = "FINETUNED_INSTRUCTIONS"),
    (i[(i.USEFUL_TYPES = 9)] = "USEFUL_TYPES"),
    (i[(i.CHAT_AND_APPLY_UNDERSPECIFIED = 10)] =
      "CHAT_AND_APPLY_UNDERSPECIFIED")
})(mf || (mf = {})),
  n.util.setEnumType(mf, "aiserver.v1.BackgroundCmdKRequest.Type", [
    { no: 0, name: "TYPE_UNSPECIFIED" },
    { no: 1, name: "TYPE_REFLECT" },
    { no: 2, name: "TYPE_LOOP_ON_LINTS" },
    { no: 3, name: "TYPE_CHAT_AND_APPLY" },
    { no: 4, name: "TYPE_COALESCE_GENERATIONS" },
    { no: 5, name: "TYPE_CODEBASE_CHUNKS" },
    { no: 6, name: "TYPE_SPEC_AND_APPLY" },
    { no: 7, name: "TYPE_ASK_CODEBASE" },
    { no: 8, name: "TYPE_FINETUNED_INSTRUCTIONS" },
    { no: 9, name: "TYPE_USEFUL_TYPES" },
    { no: 10, name: "TYPE_CHAT_AND_APPLY_UNDERSPECIFIED" },
  ])
var Eat = class zN extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        (this.quickFixes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.Lint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 5, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 6,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 7, name: "end_column_one_indexed", kind: "scalar", T: 5 },
        { no: 9, name: "quick_fixes", kind: "message", T: fAt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zN, t, e)
    }
  },
  fAt = class YN extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.kind = ""),
        (this.isPreferred = !1),
        (this.edits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.Lint.QuickFix"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8 },
        { no: 4, name: "edits", kind: "message", T: pAt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new YN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YN, t, e)
    }
  },
  pAt = class QN extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.Lint.QuickFix.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 4, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 6, name: "end_column_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new QN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QN, t, e)
    }
  },
  gAt = class XN extends h {
    constructor(t) {
      super(),
        (this.change = ""),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.ProposedChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "change", kind: "scalar", T: 9 },
        { no: 2, name: "linter_errors", kind: "message", T: Eat, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new XN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XN, t, e)
    }
  },
  vAt = class KN extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.UsefulType"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "text", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new KN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KN, t, e)
    }
  },
  wAt = class ZN extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.visibleRanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.RecentlyViewedFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "visible_ranges",
          kind: "message",
          T: yAt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ZN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZN, t, e)
    }
  },
  yAt = class t9 extends h {
    constructor(t) {
      super(),
        (this.startLineNumberInclusive = 0),
        (this.endLineNumberExclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.BackgroundCmdKRequest.RecentlyViewedFile.VisibleRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number_inclusive", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
        { no: 3, name: "viewed_at", kind: "scalar", T: 5, opt: !0 },
        {
          no: 4,
          name: "global_order_descending",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new t9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t9, t, e)
    }
  },
  bAt = class e9 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.diff = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.Diff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new e9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e9, t, e)
    }
  },
  TAt = class i9 extends h {
    constructor(t) {
      super(), (this.proposedChange = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "proposed_change", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new i9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i9, t, e)
    }
  },
  kAt = class s9 extends h {
    constructor(t) {
      super(),
        (this.instruction = ""),
        (this.groundTruth = ""),
        (this.experiment = ff.UNSPECIFIED),
        (this.runAutomatedEval = !1),
        (this.proposedChangeHistory = []),
        (this.commitNotes = []),
        (this.relatedCodeBlocks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "scalar", T: 9 },
        { no: 2, name: "current_file", kind: "message", T: Yt },
        { no: 3, name: "selection_range", kind: "message", T: Pi },
        { no: 4, name: "ground_truth", kind: "scalar", T: 9 },
        { no: 5, name: "experiment", kind: "enum", T: n.getEnumType(ff) },
        { no: 6, name: "run_automated_eval", kind: "scalar", T: 8 },
        {
          no: 7,
          name: "proposed_change_history",
          kind: "message",
          T: PAt,
          repeated: !0,
        },
        { no: 8, name: "commit_notes", kind: "message", T: LM, repeated: !0 },
        {
          no: 9,
          name: "related_code_blocks",
          kind: "message",
          T: Ne,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new s9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s9, t, e)
    }
  },
  ff
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.REFLECT = 1)] = "REFLECT"),
    (i[(i.CMD_K_ORIGINAL_RADIUS = 2)] = "CMD_K_ORIGINAL_RADIUS"),
    (i[(i.LOOP_ON_LINTS = 3)] = "LOOP_ON_LINTS"),
    (i[(i.CHAT_AND_APPLY = 4)] = "CHAT_AND_APPLY"),
    (i[(i.COMMIT_NOTES = 5)] = "COMMIT_NOTES"),
    (i[(i.COALESCE_GENERATIONS = 6)] = "COALESCE_GENERATIONS"),
    (i[(i.REWORD_INSTRUCTIONS = 7)] = "REWORD_INSTRUCTIONS"),
    (i[(i.CODEBASE_CHUNKS = 8)] = "CODEBASE_CHUNKS"),
    (i[(i.SPEC_AND_APPLY = 9)] = "SPEC_AND_APPLY"),
    (i[(i.ASK_CODEBASE = 10)] = "ASK_CODEBASE")
})(ff || (ff = {})),
  n.util.setEnumType(ff, "aiserver.v1.BackgroundCmdKEvalRequest.Experiment", [
    { no: 0, name: "EXPERIMENT_UNSPECIFIED" },
    { no: 1, name: "EXPERIMENT_REFLECT" },
    { no: 2, name: "EXPERIMENT_CMD_K_ORIGINAL_RADIUS" },
    { no: 3, name: "EXPERIMENT_LOOP_ON_LINTS" },
    { no: 4, name: "EXPERIMENT_CHAT_AND_APPLY" },
    { no: 5, name: "EXPERIMENT_COMMIT_NOTES" },
    { no: 6, name: "EXPERIMENT_COALESCE_GENERATIONS" },
    { no: 7, name: "EXPERIMENT_REWORD_INSTRUCTIONS" },
    { no: 8, name: "EXPERIMENT_CODEBASE_CHUNKS" },
    { no: 9, name: "EXPERIMENT_SPEC_AND_APPLY" },
    { no: 10, name: "EXPERIMENT_ASK_CODEBASE" },
  ])
var SAt = class r9 extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        (this.quickFixes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest.Lint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 5, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 6,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 7, name: "end_column_one_indexed", kind: "scalar", T: 5 },
        { no: 9, name: "quick_fixes", kind: "message", T: EAt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new r9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r9, t, e)
    }
  },
  EAt = class n9 extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.kind = ""),
        (this.isPreferred = !1),
        (this.edits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest.Lint.QuickFix"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8 },
        { no: 4, name: "edits", kind: "message", T: IAt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new n9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n9, t, e)
    }
  },
  IAt = class a9 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest.Lint.QuickFix.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 4, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 6, name: "end_column_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new a9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a9, t, e)
    }
  },
  PAt = class o9 extends h {
    constructor(t) {
      super(),
        (this.change = ""),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest.ProposedChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "change", kind: "scalar", T: 9 },
        { no: 2, name: "linter_errors", kind: "message", T: SAt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new o9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o9, t, e)
    }
  },
  $At = class c9 extends h {
    constructor(t) {
      super(), (this.proposedChange = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "proposed_change", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new c9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c9, t, e)
    }
  },
  xAt = class l9 extends h {
    constructor(t) {
      super(), (this.requestId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetThoughtAnnotationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new l9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l9, t, e)
    }
  },
  NAt = class u9 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetThoughtAnnotationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought_annotation", kind: "message", T: CAt },
      ])
    }
    static fromBinary(t, e) {
      return new u9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u9, t, e)
    }
  },
  CAt = class h9 extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.authId = ""),
        (this.thought = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiThoughtAnnotation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "auth_id", kind: "scalar", T: 9 },
        { no: 3, name: "debug_info", kind: "message", T: Rs },
        { no: 4, name: "thought", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new h9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h9, t, e)
    }
  },
  JAt = class d9 extends h {
    constructor(t) {
      super(), (this.texts = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BulkEmbedRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "texts", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new d9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d9, t, e)
    }
  },
  LAt = class m9 extends h {
    constructor(t) {
      super(), (this.embeddings = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BulkEmbedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "embeddings", kind: "message", T: RAt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new m9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m9, t, e)
    }
  },
  RAt = class f9 extends h {
    constructor(t) {
      super(), (this.embedding = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmbeddingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "embedding", kind: "scalar", T: 1, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new f9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f9, t, e)
    }
  },
  DAt = class p9 extends h {
    constructor(t) {
      super(), (this.commitHash = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TakeNotesOnCommitDiffRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff", kind: "message", T: kSt },
        { no: 2, name: "commit_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new p9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p9, t, e)
    }
  },
  FAt = class g9 extends h {
    constructor(t) {
      super(), (this.notes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TakeNotesOnCommitDiffResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "notes", kind: "message", T: TSt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new g9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g9, t, e)
    }
  },
  AAt = class v9 extends h {
    constructor(t) {
      super(),
        (this.sessionId = ""),
        (this.commits = []),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContinueChatRequestWithCommitsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_id", kind: "scalar", T: 9 },
        { no: 2, name: "commits", kind: "message", T: _At, repeated: !0 },
        { no: 3, name: "request_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new v9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v9, t, e)
    }
  },
  _At = class w9 extends h {
    constructor(t) {
      super(),
        (this.commitHash = ""),
        (this.diff = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleCommitWithDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commit_hash", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new w9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w9, t, e)
    }
  },
  OAt = class y9 extends h {
    constructor(t) {
      super(), (this.aiResponse = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchFileSelectionsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ai_response", kind: "scalar", T: 9 },
        { no: 2, name: "override_model", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "override_token_limit", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new y9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y9, t, e)
    }
  },
  BAt = class b9 extends h {
    constructor(t) {
      super(), (this.fileInstructions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchFileSelectionsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "file_instructions",
          kind: "message",
          T: qAt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new b9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b9, t, e)
    }
  },
  qAt = class T9 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.instruction = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamBranchFileSelectionsResponse.FileInstruction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "instruction", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new T9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T9, t, e)
    }
  },
  UAt = class k9 extends h {
    constructor(t) {
      super(),
        (this.branchName = ""),
        (this.branchNotes = ""),
        (this.globalNotes = ""),
        (this.pastThoughts = []),
        (this.potentiallyRelevantCommits = []),
        (this.files = []),
        (this.contextGraphFiles = []),
        (this.crucialFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "branch_name", kind: "scalar", T: 9 },
        { no: 2, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 3, name: "global_notes", kind: "scalar", T: 9 },
        { no: 4, name: "past_thoughts", kind: "message", T: WAt, repeated: !0 },
        { no: 5, name: "diff_to_base_branch", kind: "message", T: MAt },
        {
          no: 6,
          name: "potentially_relevant_commits",
          kind: "message",
          T: Ca,
          repeated: !0,
        },
        { no: 7, name: "files", kind: "message", T: Iat, repeated: !0 },
        {
          no: 8,
          name: "context_graph_files",
          kind: "message",
          T: jAt,
          repeated: !0,
        },
        {
          no: 12,
          name: "crucial_files",
          kind: "message",
          T: Iat,
          repeated: !0,
        },
        { no: 9, name: "override_model", kind: "scalar", T: 9, opt: !0 },
        { no: 10, name: "override_token_limit", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new k9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k9, t, e)
    }
  },
  MAt = class S9 extends h {
    constructor(t) {
      super(),
        (this.fileDiffs = []),
        (this.commits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest.BranchDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: HAt, repeated: !0 },
        { no: 2, name: "commits", kind: "message", T: Ca, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new S9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S9, t, e)
    }
  },
  HAt = class E9 extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diff = ""),
        (this.tooBig = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamBranchGeminiRequest.BranchDiff.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
        { no: 3, name: "too_big", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new E9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E9, t, e)
    }
  },
  WAt = class I9 extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.timeInUnixSeconds = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest.PastThought"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "time_in_unix_seconds", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new I9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I9, t, e)
    }
  },
  Iat = class P9 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new P9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P9, t, e)
    }
  },
  jAt = class $9 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.priority = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest.FileWithPriority"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "priority", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new $9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($9, t, e)
    }
  },
  VAt = class x9 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "cached_prompt", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new x9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x9, t, e)
    }
  },
  GAt = class N9 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsCursorPredictionEnabledRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new N9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N9, t, e)
    }
  },
  zAt = class C9 extends h {
    constructor(t) {
      super(), (this.enabled = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsCursorPredictionEnabledResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new C9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C9, t, e)
    }
  },
  YAt = class J9 extends h {
    constructor(t) {
      super(),
        (this.diffHistory = []),
        (this.contextItems = []),
        (this.diffHistoryKeys = []),
        (this.fileDiffHistories = []),
        (this.mergedDiffHistories = []),
        (this.blockDiffPatches = []),
        (this.parameterHints = []),
        (this.lspContexts = []),
        (this.fileSyncUpdates = []),
        (this.fileVisibleRanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamNextCursorPredictionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "linter_errors", kind: "message", T: $i, opt: !0 },
        { no: 13, name: "context_items", kind: "message", T: OM, repeated: !0 },
        {
          no: 5,
          name: "diff_history_keys",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "give_debug_output", kind: "scalar", T: 8, opt: !0 },
        {
          no: 7,
          name: "file_diff_histories",
          kind: "message",
          T: Xi,
          repeated: !0,
        },
        {
          no: 8,
          name: "merged_diff_histories",
          kind: "message",
          T: Xi,
          repeated: !0,
        },
        {
          no: 9,
          name: "block_diff_patches",
          kind: "message",
          T: UM,
          repeated: !0,
        },
        { no: 10, name: "is_nightly", kind: "scalar", T: 8, opt: !0 },
        { no: 11, name: "is_debug", kind: "scalar", T: 8, opt: !0 },
        { no: 12, name: "immediately_ack", kind: "scalar", T: 8, opt: !0 },
        { no: 17, name: "enable_more_context", kind: "scalar", T: 8, opt: !0 },
        {
          no: 14,
          name: "parameter_hints",
          kind: "message",
          T: zet,
          repeated: !0,
        },
        { no: 15, name: "lsp_contexts", kind: "message", T: DM, repeated: !0 },
        { no: 16, name: "cpp_intent_info", kind: "message", T: Vet, opt: !0 },
        { no: 18, name: "workspace_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 19,
          name: "file_sync_updates",
          kind: "message",
          T: qd,
          repeated: !0,
        },
        {
          no: 20,
          name: "file_visible_ranges",
          kind: "message",
          T: XAt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new J9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J9, t, e)
    }
  },
  QAt = class L9 extends h {
    constructor(t) {
      super(),
        (this.startLineNumberInclusive = 0),
        (this.endLineNumberExclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamNextCursorPredictionRequest.VisibleRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number_inclusive", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new L9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L9, t, e)
    }
  },
  XAt = class R9 extends h {
    constructor(t) {
      super(),
        (this.filename = ""),
        (this.visibleRanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamNextCursorPredictionRequest.FileVisibleRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "filename", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "visible_ranges",
          kind: "message",
          T: QAt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new R9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R9, t, e)
    }
  },
  KAt = class D9 extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamNextCursorPredictionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "line_number", kind: "scalar", T: 5, oneof: "response" },
        {
          no: 3,
          name: "is_not_in_range",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
        { no: 4, name: "file_name", kind: "scalar", T: 9, oneof: "response" },
      ])
    }
    static fromBinary(t, e) {
      return new D9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D9, t, e)
    }
  },
  ZAt = class F9 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.prompt = ""),
        (this.images = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamWebCmdKV1Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        { no: 3, name: "prompt", kind: "scalar", T: 9 },
        { no: 4, name: "selection_range", kind: "message", T: Li },
        { no: 5, name: "model_details", kind: "message", T: St },
        { no: 10, name: "images", kind: "message", T: Ea, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new F9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F9, t, e)
    }
  },
  t_t = class A9 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamWebCmdKV1Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cmd_k_response", kind: "message", T: WW },
      ])
    }
    static fromBinary(t, e) {
      return new A9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A9, t, e)
    }
  },
  e_t = class _9 extends h {
    constructor(t) {
      super(),
        (this.sourceRange = ""),
        (this.methodSignatures = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextScoresRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "source_range", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "method_signatures",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new _9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_9, t, e)
    }
  },
  i_t = class O9 extends h {
    constructor(t) {
      super(), (this.scores = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextScoresResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "scores", kind: "scalar", T: 2, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new O9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O9, t, e)
    }
  },
  s_t = class B9 extends h {
    constructor(t) {
      super(),
        (this.feedbackType = pf.UNSPECIFIED),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportGenerationFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback_type", kind: "enum", T: n.getEnumType(pf) },
        { no: 2, name: "request_id", kind: "scalar", T: 9 },
        { no: 3, name: "comment", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new B9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B9, t, e)
    }
  },
  pf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.THUMBS_UP = 1)] = "THUMBS_UP"),
    (i[(i.THUMBS_DOWN = 2)] = "THUMBS_DOWN"),
    (i[(i.NEUTRAL = 3)] = "NEUTRAL")
})(pf || (pf = {})),
  n.util.setEnumType(
    pf,
    "aiserver.v1.ReportGenerationFeedbackRequest.FeedbackType",
    [
      { no: 0, name: "FEEDBACK_TYPE_UNSPECIFIED" },
      { no: 1, name: "FEEDBACK_TYPE_THUMBS_UP" },
      { no: 2, name: "FEEDBACK_TYPE_THUMBS_DOWN" },
      { no: 3, name: "FEEDBACK_TYPE_NEUTRAL" },
    ],
  )
var r_t = class q9 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportGenerationFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new q9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q9, t, e)
    }
  },
  n_t = class U9 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShowWelcomeScreenRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new U9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U9, t, e)
    }
  },
  a_t = class M9 extends h {
    constructor(t) {
      super(), (this.enableCards = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShowWelcomeScreenResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enable_cards", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new M9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M9, t, e)
    }
  },
  o_t = class H9 extends h {
    constructor(t) {
      super(), (this.description = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new H9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H9, t, e)
    }
  },
  c_t = class W9 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new W9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W9, t, e)
    }
  },
  l_t = class j9 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToCamelCaseRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new j9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j9, t, e)
    }
  },
  u_t = class V9 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToCamelCaseResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new V9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V9, t, e)
    }
  },
  h_t = class G9 extends h {
    constructor(t) {
      super(),
        (this.promptProps = ""),
        (this.promptPropsTypeName = ""),
        (this.skipLoginCheck = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPriomptPromptRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "prompt_props", kind: "scalar", T: 9 },
        { no: 3, name: "prompt_props_type_name", kind: "scalar", T: 9 },
        { no: 5, name: "skip_login_check", kind: "scalar", T: 8 },
        { no: 4, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new G9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G9, t, e)
    }
  },
  d_t = class z9 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPriomptPromptResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new z9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z9, t, e)
    }
  },
  m_t = class Y9 extends h {
    constructor(t) {
      super(), (this.featureName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckFeatureStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feature_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Y9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y9, t, e)
    }
  },
  f_t = class Q9 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEffectiveTokenLimitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new Q9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q9, t, e)
    }
  },
  p_t = class X9 extends h {
    constructor(t) {
      super(), (this.tokenLimit = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEffectiveTokenLimitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "token_limit", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new X9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X9, t, e)
    }
  },
  g_t = class K9 extends h {
    constructor(t) {
      super(), (this.enabled = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckFeatureStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new K9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K9, t, e)
    }
  },
  v_t = class Z9 extends h {
    constructor(t) {
      super(), (this.key = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckNumberConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "key", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Z9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z9, t, e)
    }
  },
  w_t = class tC extends h {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckNumberConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new tC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tC, t, e)
    }
  },
  y_t = class eC extends h {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IntentPredictionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "message", T: he, repeated: !0 },
        { no: 2, name: "context_options", kind: "message", T: E_t },
        { no: 3, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new eC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eC, t, e)
    }
  },
  b_t = class iC extends h {
    constructor(t) {
      super(),
        (this.useGlobalContext = !1),
        (this.useWithFolderContext = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IntentPredictionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chosen_documentation", kind: "message", T: T_t },
        { no: 2, name: "chosen_file_contents", kind: "message", T: k_t },
        { no: 3, name: "chosen_linter_diagnostics", kind: "message", T: S_t },
        { no: 4, name: "use_global_context", kind: "scalar", T: 8 },
        { no: 5, name: "use_with_folder_context", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new iC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iC, t, e)
    }
  },
  T_t = class sC extends h {
    constructor(t) {
      super(),
        (this.docIndices = []),
        (this.docIdentifiers = []),
        (this.docNames = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IntentPredictionResponse.ChosenDocumentation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_indices", kind: "scalar", T: 5, repeated: !0 },
        { no: 2, name: "doc_identifiers", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "doc_names", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sC, t, e)
    }
  },
  k_t = class rC extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IntentPredictionResponse.ChosenFileContents"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new rC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rC, t, e)
    }
  },
  S_t = class nC extends h {
    constructor(t) {
      super(), (this.diagnosticIndices = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.IntentPredictionResponse.ChosenLinterDiagnostics"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "diagnostic_indices",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new nC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nC, t, e)
    }
  },
  E_t = class aC extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "all_documentation", kind: "message", T: I_t },
        { no: 2, name: "current_file_contents", kind: "message", T: $_t },
        { no: 3, name: "linter_diagnostics", kind: "message", T: x_t },
        { no: 4, name: "global_context", kind: "message", T: C_t },
      ])
    }
    static fromBinary(t, e) {
      return new aC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aC, t, e)
    }
  },
  I_t = class oC extends h {
    constructor(t) {
      super(), (this.availableDocs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.AllDocumentation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "available_docs",
          kind: "message",
          T: P_t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new oC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oC, t, e)
    }
  },
  P_t = class cC extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.url = ""),
        (this.identifier = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ContextOptions.AllDocumentation.Documentation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cC, t, e)
    }
  },
  $_t = class lC extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.dataframes = []),
        (this.languageId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.CurrentFileContents"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "cursor_position", kind: "message", T: ba },
        { no: 4, name: "dataframes", kind: "message", T: qet, repeated: !0 },
        { no: 5, name: "language_id", kind: "scalar", T: 9 },
        { no: 6, name: "selection", kind: "message", T: Ta },
      ])
    }
    static fromBinary(t, e) {
      return new lC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lC, t, e)
    }
  },
  x_t = class uC extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.diagnostics = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.LinterDiagnostics"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "diagnostics", kind: "message", T: N_t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uC, t, e)
    }
  },
  N_t = class hC extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.source = ""),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.LinterDiagnostics.Diagnostic"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "source", kind: "scalar", T: 9 },
        { no: 3, name: "range", kind: "message", T: Ta },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new hC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hC, t, e)
    }
  },
  C_t = class dC extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.GlobalContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new dC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dC, t, e)
    }
  },
  J_t = class mC extends h {
    constructor(t) {
      super(), (this.conversation = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCursorTutorRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 2, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new mC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mC, t, e)
    }
  },
  L_t = class fC extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCursorTutorResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new fC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fC, t, e)
    }
  },
  Pat = class pC extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.queryType = gf.UNSPECIFIED),
        (this.fasterAndStupider = !1),
        (this.useGlobs = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: St },
        { no: 8, name: "query_type", kind: "enum", T: n.getEnumType(gf) },
        { no: 9, name: "repository_info", kind: "message", T: Mt },
        { no: 10, name: "faster_and_stupider", kind: "scalar", T: 8 },
        { no: 11, name: "use_globs", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new pC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pC, t, e)
    }
  },
  gf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.KEYWORDS = 1)] = "KEYWORDS"),
    (i[(i.EMBEDDINGS = 2)] = "EMBEDDINGS")
})(gf || (gf = {})),
  n.util.setEnumType(gf, "aiserver.v1.ModelQueryRequest.QueryType", [
    { no: 0, name: "QUERY_TYPE_UNSPECIFIED" },
    { no: 1, name: "QUERY_TYPE_KEYWORDS" },
    { no: 2, name: "QUERY_TYPE_EMBEDDINGS" },
  ])
var R_t = class gC extends h {
    constructor(t) {
      super(), (this.queries = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "queries", kind: "message", T: D_t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gC, t, e)
    }
  },
  D_t = class vC extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.successfulParse = !1),
        (this.goodFileExtensions = []),
        (this.badFileExtensions = []),
        (this.goodPaths = []),
        (this.badPaths = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryResponse.Query"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "successful_parse", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "good_file_extensions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 4,
          name: "bad_file_extensions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 5, name: "good_paths", kind: "scalar", T: 9, repeated: !0 },
        { no: 6, name: "bad_paths", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new vC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vC, t, e)
    }
  },
  F_t = class wC extends h {
    constructor(t) {
      super(),
        (this.queryOrReasoning = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryResponseV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "query",
          kind: "message",
          T: A_t,
          oneof: "query_or_reasoning",
        },
        {
          no: 2,
          name: "reasoning",
          kind: "scalar",
          T: 9,
          oneof: "query_or_reasoning",
        },
      ])
    }
    static fromBinary(t, e) {
      return new wC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wC, t, e)
    }
  },
  A_t = class yC extends h {
    constructor(t) {
      super(),
        (this.partialQuery = { case: void 0 }),
        (this.index = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryResponseV2.QueryItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9, oneof: "partial_query" },
        { no: 2, name: "glob", kind: "scalar", T: 9, oneof: "partial_query" },
        { no: 3, name: "index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new yC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yC, t, e)
    }
  },
  __t = class bC extends h {
    constructor(t) {
      super(), (this.apiKey = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ApiDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "api_key", kind: "scalar", T: 9 },
        { no: 2, name: "enable_ghost_mode", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new bC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bC, t, e)
    }
  },
  e3 = class TC extends h {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FullFileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: DCt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new TC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TC, t, e)
    }
  },
  i3 = class kC extends h {
    constructor(t) {
      super(),
        (this.results = []),
        (this.allFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: xi, repeated: !0 },
        { no: 2, name: "all_files", kind: "message", T: ks, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new kC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kC, t, e)
    }
  },
  O_t = class SC extends h {
    constructor(t) {
      super(),
        (this.codeResults = []),
        (this.query = ""),
        (this.numBlocks = 0),
        (this.conversation = []),
        (this.contextResults = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankerRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: xi, repeated: !0 },
        { no: 2, name: "query", kind: "scalar", T: 9 },
        { no: 3, name: "num_blocks", kind: "scalar", T: 5 },
        { no: 4, name: "current_file", kind: "message", T: Yt },
        { no: 5, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 6, name: "api_details", kind: "message", T: __t },
        {
          no: 7,
          name: "file_search_results",
          kind: "message",
          T: e3,
          oneof: "context_results",
        },
        {
          no: 8,
          name: "code_search_results",
          kind: "message",
          T: i3,
          oneof: "context_results",
        },
      ])
    }
    static fromBinary(t, e) {
      return new SC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SC, t, e)
    }
  },
  B_t = class EC extends h {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankerResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: xi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new EC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EC, t, e)
    }
  },
  q_t = class IC extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GenerateTldrRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new IC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IC, t, e)
    }
  },
  U_t = class PC extends h {
    constructor(t) {
      super(), (this.summary = ""), (this.all = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GenerateTldrResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "summary", kind: "scalar", T: 9 },
        { no: 2, name: "all", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PC, t, e)
    }
  },
  M_t = class $C extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: St },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 14, name: "linter_errors", kind: "message", T: $i },
        { no: 15, name: "advanced_codebase_context", kind: "message", T: H_t },
        { no: 16, name: "is_eval", kind: "scalar", T: 8, opt: !0 },
        { no: 17, name: "request_id", kind: "scalar", T: 9 },
        { no: 18, name: "desired_token_limit", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new $C().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $C().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $C().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($C, t, e)
    }
  },
  H_t = class xC extends h {
    constructor(t) {
      super(),
        (this.numResultsPerSearch = 0),
        (this.reranker = Em.UNSPECIFIED),
        (this.reasoningStep = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AdvancedCodebaseContextOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_results_per_search", kind: "scalar", T: 5 },
        { no: 2, name: "include_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "exclude_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "reranker", kind: "enum", T: n.getEnumType(Em) },
        { no: 5, name: "index_id", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "reasoning_step", kind: "scalar", T: 8 },
        {
          no: 7,
          name: "rechunker",
          kind: "enum",
          T: n.getEnumType(HB),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new xC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xC, t, e)
    }
  },
  W_t = class NC extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "message", T: j_t, oneof: "response" },
        {
          no: 2,
          name: "gathering_step",
          kind: "message",
          T: G_t,
          oneof: "response",
        },
        {
          no: 3,
          name: "gathering_file",
          kind: "message",
          T: V_t,
          oneof: "response",
        },
        {
          no: 4,
          name: "reranking_step",
          kind: "message",
          T: z_t,
          oneof: "response",
        },
        {
          no: 5,
          name: "reranking_file",
          kind: "message",
          T: Y_t,
          oneof: "response",
        },
        {
          no: 6,
          name: "reasoning_step",
          kind: "message",
          T: Q_t,
          oneof: "response",
        },
        {
          no: 7,
          name: "reasoning_substep",
          kind: "message",
          T: X_t,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new NC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NC, t, e)
    }
  },
  j_t = class CC extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.Output"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new CC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CC, t, e)
    }
  },
  V_t = class JC extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.stepIndex = 0),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.GatheringFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Pi },
        { no: 3, name: "step_index", kind: "scalar", T: 5 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new JC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JC, t, e)
    }
  },
  G_t = class LC extends h {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.index = 0),
        (this.query = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.GatheringStep"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "index", kind: "scalar", T: 5 },
        { no: 3, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new LC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LC, t, e)
    }
  },
  z_t = class RC extends h {
    constructor(t) {
      super(), (this.title = ""), (this.index = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.RerankingStep"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new RC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RC, t, e)
    }
  },
  Y_t = class DC extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.reason = ""),
        (this.failed = !1),
        (this.score = 0),
        (this.stepIndex = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.RerankingFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: Pi },
        { no: 3, name: "reason", kind: "scalar", T: 9 },
        { no: 4, name: "failed", kind: "scalar", T: 8 },
        { no: 5, name: "score", kind: "scalar", T: 2 },
        { no: 6, name: "step_index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new DC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DC, t, e)
    }
  },
  Q_t = class FC extends h {
    constructor(t) {
      super(), (this.title = ""), (this.index = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.ReasoningStep"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new FC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FC, t, e)
    }
  },
  X_t = class AC extends h {
    constructor(t) {
      super(),
        (this.markdownExplanation = ""),
        (this.stepIndex = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.TaskStreamChatContextResponse.ReasoningSubstep"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "markdown_explanation", kind: "scalar", T: 9 },
        { no: 2, name: "step_index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new AC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AC, t, e)
    }
  },
  K_t = class _C extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: W_t,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new _C().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _C().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _C().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_C, t, e)
    }
  },
  $at = class OC extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.query = ""),
        (this.rerankResults = !1),
        (this.contextResults = { case: void 0 }),
        (this.rerankResultsV2 = !1),
        (this.conversationId = ""),
        (this.canHandleFilenamesAfterLanguageIds = !1),
        (this.longContextMode = !1),
        (this.isEval = !1),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: St },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 9, name: "query", kind: "scalar", T: 9 },
        { no: 10, name: "code_context", kind: "message", T: Z_t },
        { no: 11, name: "rerank_results", kind: "scalar", T: 8 },
        {
          no: 12,
          name: "file_search_results",
          kind: "message",
          T: e3,
          oneof: "context_results",
        },
        {
          no: 13,
          name: "code_search_results",
          kind: "message",
          T: i3,
          oneof: "context_results",
        },
        { no: 14, name: "linter_errors", kind: "message", T: $i },
        { no: 15, name: "is_bash", kind: "scalar", T: 8, opt: !0 },
        { no: 16, name: "rerank_results_v2", kind: "scalar", T: 8 },
        { no: 17, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 18,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
        },
        { no: 19, name: "long_context_mode", kind: "scalar", T: 8 },
        { no: 20, name: "is_eval", kind: "scalar", T: 8 },
        { no: 21, name: "request_id", kind: "scalar", T: 9 },
        { no: 22, name: "desired_max_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 23, name: "runnable_code_blocks", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new OC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OC, t, e)
    }
  },
  Z_t = class BC extends h {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.scoredChunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextRequest.CodeContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: Ne, repeated: !0 },
        { no: 2, name: "scored_chunks", kind: "message", T: xi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new BC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BC, t, e)
    }
  },
  xat = class qC extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "debugging_only_chat_prompt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 3,
          name: "debugging_only_token_count",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 4, name: "document_citation", kind: "message", T: _W },
        { no: 5, name: "filled_prompt", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "used_code", kind: "message", T: t6t },
        { no: 7, name: "code_link", kind: "message", T: e6t },
        { no: 8, name: "chunk_identity", kind: "message", T: i6t, opt: !0 },
        { no: 9, name: "docs_reference", kind: "message", T: VB, opt: !0 },
        { no: 10, name: "symbol_link", kind: "message", T: qW, opt: !0 },
        { no: 11, name: "file_link", kind: "message", T: UW, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new qC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qC, t, e)
    }
  },
  t6t = class UC extends h {
    constructor(t) {
      super(), (this.codeResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextResponse.UsedCode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: xi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new UC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UC, t, e)
    }
  },
  e6t = class MC extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextResponse.CodeLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new MC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MC, t, e)
    }
  },
  i6t = class HC extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.text = ""),
        (this.chunkType = xn.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextResponse.ChunkIdentity"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
        { no: 5, name: "chunk_type", kind: "enum", T: n.getEnumType(xn) },
      ])
    }
    static fromBinary(t, e) {
      return new HC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HC, t, e)
    }
  },
  s6t = class WC extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.rerankResults = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatDeepContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 2, name: "explicit_context", kind: "message", T: Oe },
        { no: 3, name: "model_details", kind: "message", T: St },
        { no: 4, name: "context_results", kind: "message", T: YCt },
        { no: 5, name: "rerank_results", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new WC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WC, t, e)
    }
  },
  r6t = class jC extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatDeepContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jC, t, e)
    }
  },
  n6t = class VC extends h {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "message", T: Xnt },
      ])
    }
    static fromBinary(t, e) {
      return new VC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VC, t, e)
    }
  },
  a6t = class GC extends h {
    constructor(t) {
      super(),
        (this.partialDoc = { case: void 0 }),
        (this.additionalDocIdentifiers = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableDocsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "partial_url",
          kind: "scalar",
          T: 9,
          oneof: "partial_doc",
        },
        {
          no: 2,
          name: "partial_doc_name",
          kind: "scalar",
          T: 9,
          oneof: "partial_doc",
        },
        { no: 3, name: "get_all", kind: "scalar", T: 8, oneof: "partial_doc" },
        {
          no: 4,
          name: "additional_doc_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new GC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GC, t, e)
    }
  },
  o6t = class zC extends h {
    constructor(t) {
      super(), (this.docs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableDocsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "docs", kind: "message", T: n6t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zC, t, e)
    }
  },
  c6t = class YC extends h {
    constructor(t) {
      super(), (this.error = Sa.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ThrowErrorCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error", kind: "enum", T: n.getEnumType(Sa) },
      ])
    }
    static fromBinary(t, e) {
      return new YC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YC, t, e)
    }
  },
  l6t = class QC extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ThrowErrorCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new QC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QC, t, e)
    }
  },
  u6t = class XC extends h {
    constructor(t) {
      super(),
        (this.isNightly = !1),
        (this.includeLongContextModels = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableModelsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_nightly", kind: "scalar", T: 8 },
        { no: 2, name: "include_long_context_models", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new XC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XC, t, e)
    }
  },
  h6t = class KC extends h {
    constructor(t) {
      super(),
        (this.models = []),
        (this.modelNames = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableModelsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "models", kind: "message", T: d6t, repeated: !0 },
        { no: 1, name: "model_names", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new KC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KC, t, e)
    }
  },
  d6t = class ZC extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.defaultOn = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableModelsResponse.AvailableModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "default_on", kind: "scalar", T: 8 },
        { no: 3, name: "is_long_context_only", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "is_chat_only", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ZC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZC, t, e)
    }
  },
  Nat = class tJ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HealthCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new tJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tJ, t, e)
    }
  },
  m6t = class eJ extends h {
    constructor(t) {
      super(), (this.status = vf.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HealthCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(vf) },
      ])
    }
    static fromBinary(t, e) {
      return new eJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eJ, t, e)
    }
  },
  vf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"), (i[(i.HEALTHY = 1)] = "HEALTHY")
})(vf || (vf = {})),
  n.util.setEnumType(vf, "aiserver.v1.HealthCheckResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_HEALTHY" },
  ])
var f6t = class iJ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PrivacyCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new iJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iJ, t, e)
    }
  },
  p6t = class sJ extends h {
    constructor(t) {
      super(),
        (this.isOnPrivacyPod = !1),
        (this.isGhostModeOn = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PrivacyCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_on_privacy_pod", kind: "scalar", T: 8 },
        { no: 2, name: "is_ghost_mode_on", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new sJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sJ, t, e)
    }
  },
  g6t = class rJ extends h {
    constructor(t) {
      super(), (this.timeLeft = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TimeLeftHealthCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "time_left", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rJ, t, e)
    }
  },
  v6t = class ku extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.promptCodeBlocks = []),
        (this.sessionId = ""),
        (this.fastMode = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamGenerateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 9, name: "model_details", kind: "message", T: St },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "linter_errors", kind: "message", T: $i },
        {
          no: 12,
          name: "prompt_code_blocks",
          kind: "message",
          T: Ne,
          repeated: !0,
        },
        { no: 14, name: "session_id", kind: "scalar", T: 9 },
        { no: 13, name: "cmd_k_debug_info", kind: "message", T: Rs },
        { no: 15, name: "fast_mode", kind: "scalar", T: 8 },
        { no: 16, name: "original_request", kind: "message", T: ku },
      ])
    }
    static fromBinary(t, e) {
      return new ku().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ku().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ku().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ku, t, e)
    }
  },
  w6t = class nJ extends h {
    constructor(t) {
      super(),
        (this.chunk = ""),
        (this.fileContext = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk", kind: "scalar", T: 9 },
        { no: 2, name: "file_context", kind: "scalar", T: 9 },
        { no: 3, name: "chunk_range", kind: "message", T: Li },
        { no: 4, name: "diff_string", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new nJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nJ, t, e)
    }
  },
  Cat = class aJ extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.type = wf.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "type", kind: "enum", T: n.getEnumType(wf) },
      ])
    }
    static fromBinary(t, e) {
      return new aJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aJ, t, e)
    }
  },
  wf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.HUMAN = 1)] = "HUMAN"),
    (i[(i.AI = 2)] = "AI")
})(wf || (wf = {})),
  n.util.setEnumType(
    wf,
    "aiserver.v1.ReviewChatMessage.ReviewChatMessageType",
    [
      { no: 0, name: "REVIEW_CHAT_MESSAGE_TYPE_UNSPECIFIED" },
      { no: 1, name: "REVIEW_CHAT_MESSAGE_TYPE_HUMAN" },
      { no: 2, name: "REVIEW_CHAT_MESSAGE_TYPE_AI" },
    ],
  )
var y6t = class oJ extends h {
    constructor(t) {
      super(),
        (this.chunk = ""),
        (this.fileContext = ""),
        (this.messages = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk", kind: "scalar", T: 9 },
        { no: 2, name: "file_context", kind: "scalar", T: 9 },
        { no: 3, name: "chunk_range", kind: "message", T: Li },
        { no: 4, name: "messages", kind: "message", T: Cat, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new oJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oJ, t, e)
    }
  },
  b6t = class cJ extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "should_resolve", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new cJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cJ, t, e)
    }
  },
  T6t = class lJ extends h {
    constructor(t) {
      super(), (this.id = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewBug"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "end_line", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "description", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "severity", kind: "scalar", T: 5, opt: !0 },
        { no: 6, name: "tldr", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lJ, t, e)
    }
  },
  k6t = class uJ extends h {
    constructor(t) {
      super(), (this.text = ""), (this.bugs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "prompt", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "tldr", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "is_bug", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "bugs", kind: "message", T: T6t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uJ, t, e)
    }
  },
  S6t = class hJ extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.isCmdI = !1),
        (this.files = []),
        (this.useFastApply = !1),
        (this.fastApplyModelType = yf.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SlashEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "current_file", kind: "message", T: Yt },
        { no: 3, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 7, name: "model_details", kind: "message", T: St },
        { no: 8, name: "is_cmd_i", kind: "scalar", T: 8 },
        { no: 11, name: "summary", kind: "scalar", T: 9, opt: !0 },
        {
          no: 12,
          name: "summary_up_until_index",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 13,
          name: "should_use_turbo_debug_prompt",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 14, name: "edit_selection", kind: "message", T: Li, opt: !0 },
        { no: 15, name: "files", kind: "message", T: Yt, repeated: !0 },
        {
          no: 16,
          name: "clicked_code_block_contents",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 17,
          name: "is_an_optimistic_request_for_caching_and_linting",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 18,
          name: "specific_instructions",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 19, name: "use_fast_apply", kind: "scalar", T: 8 },
        {
          no: 20,
          name: "fast_apply_model_type",
          kind: "enum",
          T: n.getEnumType(yf),
        },
        {
          no: 25,
          name: "use_chunk_speculation_for_long_files",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 26, name: "parent_request_id", kind: "scalar", T: 9, opt: !0 },
        { no: 27, name: "source", kind: "enum", T: n.getEnumType(Wl), opt: !0 },
        { no: 28, name: "is_reapply", kind: "scalar", T: 8, opt: !0 },
        {
          no: 29,
          name: "willing_to_pay_extra_for_speed",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new hJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hJ, t, e)
    }
  },
  yf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DEFAULT = 1)] = "DEFAULT"),
    (i[(i.DEEPSEEK = 2)] = "DEEPSEEK"),
    (i[(i.SONNET = 3)] = "SONNET"),
    (i[(i.OPUS_DIFF = 4)] = "OPUS_DIFF"),
    (i[(i.SMART_REWRITE = 5)] = "SMART_REWRITE"),
    (i[(i.GPT4 = 6)] = "GPT4"),
    (i[(i.GPT4_NOSPEC = 7)] = "GPT4_NOSPEC"),
    (i[(i.SMART_REWRITE_NOSPEC = 8)] = "SMART_REWRITE_NOSPEC"),
    (i[(i.OPUS = 9)] = "OPUS"),
    (i[(i.HAIKU = 10)] = "HAIKU"),
    (i[(i.GPT4O_NOSPEC = 11)] = "GPT4O_NOSPEC"),
    (i[(i.GPT4O_DIFF = 12)] = "GPT4O_DIFF"),
    (i[(i.CODESTRAL_REWRITE = 13)] = "CODESTRAL_REWRITE"),
    (i[(i.DEEPSEEK_33B = 14)] = "DEEPSEEK_33B"),
    (i[(i.SONNET_35_DIFF = 15)] = "SONNET_35_DIFF"),
    (i[(i.SONNET_35_REWRITE = 16)] = "SONNET_35_REWRITE"),
    (i[(i.PROMPTED_DEEPSEEK_V2 = 17)] = "PROMPTED_DEEPSEEK_V2"),
    (i[(i.CODESTRAL_REWRITE_OLD = 18)] = "CODESTRAL_REWRITE_OLD"),
    (i[(i.CODESTRAL_REWRITE_FP16 = 19)] = "CODESTRAL_REWRITE_FP16"),
    (i[(i.DEEPSEEK_33B_V2 = 20)] = "DEEPSEEK_33B_V2"),
    (i[(i.CODESTRAL_V4 = 21)] = "CODESTRAL_V4"),
    (i[(i.CODESTRAL_V5 = 22)] = "CODESTRAL_V5"),
    (i[(i.CODESTRAL_V6 = 23)] = "CODESTRAL_V6"),
    (i[(i.CODESTRAL_V7 = 24)] = "CODESTRAL_V7")
})(yf || (yf = {})),
  n.util.setEnumType(yf, "aiserver.v1.SlashEditRequest.FastApplyModelType", [
    { no: 0, name: "FAST_APPLY_MODEL_TYPE_UNSPECIFIED" },
    { no: 1, name: "FAST_APPLY_MODEL_TYPE_DEFAULT" },
    { no: 2, name: "FAST_APPLY_MODEL_TYPE_DEEPSEEK" },
    { no: 3, name: "FAST_APPLY_MODEL_TYPE_SONNET" },
    { no: 4, name: "FAST_APPLY_MODEL_TYPE_OPUS_DIFF" },
    { no: 5, name: "FAST_APPLY_MODEL_TYPE_SMART_REWRITE" },
    { no: 6, name: "FAST_APPLY_MODEL_TYPE_GPT4" },
    { no: 7, name: "FAST_APPLY_MODEL_TYPE_GPT4_NOSPEC" },
    { no: 8, name: "FAST_APPLY_MODEL_TYPE_SMART_REWRITE_NOSPEC" },
    { no: 9, name: "FAST_APPLY_MODEL_TYPE_OPUS" },
    { no: 10, name: "FAST_APPLY_MODEL_TYPE_HAIKU" },
    { no: 11, name: "FAST_APPLY_MODEL_TYPE_GPT4O_NOSPEC" },
    { no: 12, name: "FAST_APPLY_MODEL_TYPE_GPT4O_DIFF" },
    { no: 13, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_REWRITE" },
    { no: 14, name: "FAST_APPLY_MODEL_TYPE_DEEPSEEK_33B" },
    { no: 15, name: "FAST_APPLY_MODEL_TYPE_SONNET_35_DIFF" },
    { no: 16, name: "FAST_APPLY_MODEL_TYPE_SONNET_35_REWRITE" },
    { no: 17, name: "FAST_APPLY_MODEL_TYPE_PROMPTED_DEEPSEEK_V2" },
    { no: 18, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_REWRITE_OLD" },
    { no: 19, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_REWRITE_FP16" },
    { no: 20, name: "FAST_APPLY_MODEL_TYPE_DEEPSEEK_33B_V2" },
    { no: 21, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_V4" },
    { no: 22, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_V5" },
    { no: 23, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_V6" },
    { no: 24, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_V7" },
  ])
var E6t = class dJ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SlashEditResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cmd_k_response", kind: "message", T: WW },
      ])
    }
    static fromBinary(t, e) {
      return new dJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dJ, t, e)
    }
  },
  Jat = class mJ extends h {
    constructor(t) {
      super(),
        (this.originalLines = []),
        (this.newLines = []),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SlashEditPreviousEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "range", kind: "message", T: Li },
      ])
    }
    static fromBinary(t, e) {
      return new mJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mJ, t, e)
    }
  },
  I6t = class fJ extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.previousEdits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SlashEditFollowUpWithPreviousEditsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 2, name: "model_details", kind: "message", T: St },
        {
          no: 3,
          name: "previous_edits",
          kind: "message",
          T: Jat,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new fJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fJ, t, e)
    }
  },
  P6t = class pJ extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamSlashEditFollowUpWithPreviousEditsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chat", kind: "message", T: $6t, oneof: "response" },
        {
          no: 2,
          name: "edits_to_update",
          kind: "message",
          T: x6t,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new pJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pJ, t, e)
    }
  },
  $6t = class gJ extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamSlashEditFollowUpWithPreviousEditsResponse.Chat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new gJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gJ, t, e)
    }
  },
  x6t = class vJ extends h {
    constructor(t) {
      super(), (this.previousEdits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamSlashEditFollowUpWithPreviousEditsResponse.EditsToUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "previous_edits",
          kind: "message",
          T: Jat,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vJ, t, e)
    }
  },
  N6t = class wJ extends h {
    constructor(t) {
      super(),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamFastEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 9, name: "model_details", kind: "message", T: St },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "linter_errors", kind: "message", T: $i },
      ])
    }
    static fromBinary(t, e) {
      return new wJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wJ, t, e)
    }
  },
  C6t = class yJ extends h {
    constructor(t) {
      super(),
        (this.lineNumber = 0),
        (this.replaceNumLines = 0),
        (this.editUuid = ""),
        (this.resetNewLines = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamFastEditResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "replace_num_lines", kind: "scalar", T: 5 },
        { no: 5, name: "edit_uuid", kind: "scalar", T: 9 },
        { no: 4, name: "done", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "new_line", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "reset_new_lines", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new yJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yJ, t, e)
    }
  },
  Lat = class Su extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.promptCodeBlocks = []),
        (this.sessionId = ""),
        (this.fastMode = !1),
        (this.images = []),
        (this.links = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 9, name: "model_details", kind: "message", T: St },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "linter_errors", kind: "message", T: $i },
        {
          no: 12,
          name: "prompt_code_blocks",
          kind: "message",
          T: Ne,
          repeated: !0,
        },
        { no: 14, name: "session_id", kind: "scalar", T: 9 },
        { no: 13, name: "cmd_k_debug_info", kind: "message", T: Rs },
        { no: 15, name: "fast_mode", kind: "scalar", T: 8 },
        { no: 16, name: "original_request", kind: "message", T: Su },
        { no: 17, name: "images", kind: "message", T: Ea, repeated: !0 },
        { no: 18, name: "links", kind: "message", T: JM, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Su().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Su().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Su().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Su, t, e)
    }
  },
  J6t = class bJ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PreloadEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "req", kind: "message", T: Lat },
      ])
    }
    static fromBinary(t, e) {
      return new bJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bJ, t, e)
    }
  },
  L6t = class TJ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PreloadEditResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new TJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TJ, t, e)
    }
  },
  R6t = class kJ extends h {
    constructor(t) {
      super(),
        (this.chunksToAnalyze = []),
        (this.dismissedBugs = []),
        (this.activeBugs = []),
        (this.lintRules = []),
        (this.clients = []),
        (this.forceEnableDiscriminators = []),
        (this.forceDisableDiscriminators = []),
        (this.forceEnableGenerators = []),
        (this.forceDisableGenerators = []),
        (this.version = 0),
        (this.debugMode = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "chunks_to_analyze",
          kind: "message",
          T: Rat,
          repeated: !0,
        },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "model_details", kind: "message", T: St },
        {
          no: 10,
          name: "dismissed_bugs",
          kind: "message",
          T: t3,
          repeated: !0,
        },
        { no: 11, name: "active_bugs", kind: "message", T: t3, repeated: !0 },
        { no: 12, name: "lint_rules", kind: "message", T: nFt, repeated: !0 },
        { no: 14, name: "clients", kind: "message", T: D6t, repeated: !0 },
        {
          no: 17,
          name: "force_enable_discriminators",
          kind: "enum",
          T: n.getEnumType(Uo),
          repeated: !0,
        },
        {
          no: 18,
          name: "force_disable_discriminators",
          kind: "enum",
          T: n.getEnumType(Uo),
          repeated: !0,
        },
        {
          no: 19,
          name: "force_enable_generators",
          kind: "enum",
          T: n.getEnumType(Mo),
          repeated: !0,
        },
        {
          no: 20,
          name: "force_disable_generators",
          kind: "enum",
          T: n.getEnumType(Mo),
          repeated: !0,
        },
        { no: 21, name: "version", kind: "scalar", T: 5 },
        {
          no: 15,
          name: "discriminator_options",
          kind: "message",
          T: F6t,
          opt: !0,
        },
        { no: 16, name: "debug_mode", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new kJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kJ, t, e)
    }
  },
  Rat = class SJ extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        (this.contextLinesBefore = []),
        (this.contextLinesAfter = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugRequest.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 4,
          name: "context_lines_before",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 5,
          name: "context_lines_after",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new SJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SJ, t, e)
    }
  },
  D6t = class EJ extends h {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.referredStartLines = []),
        (this.referredEndLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugRequest.CodeChunkList"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 13, name: "chunks", kind: "message", T: Rat, repeated: !0 },
        {
          no: 14,
          name: "referred_start_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
        {
          no: 15,
          name: "referred_end_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new EJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EJ, t, e)
    }
  },
  F6t = class IJ extends h {
    constructor(t) {
      super(),
        (this.specificRules = !1),
        (this.compileErrors = !1),
        (this.changeBehavior = !1),
        (this.matchCode = !1),
        (this.relevance = !1),
        (this.userAwareness = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugRequest.DiscriminatorOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "specific_rules", kind: "scalar", T: 8 },
        { no: 2, name: "compile_errors", kind: "scalar", T: 8 },
        { no: 3, name: "change_behavior", kind: "scalar", T: 8 },
        { no: 4, name: "match_code", kind: "scalar", T: 8 },
        { no: 5, name: "relevance", kind: "scalar", T: 8 },
        { no: 6, name: "user_awareness", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new IJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IJ, t, e)
    }
  },
  A6t = class PJ extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "message", T: t3, oneof: "response" },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new PJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PJ, t, e)
    }
  },
  _6t = class $J extends h {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.userAction = ""),
        (this.debugMode = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogUserLintReplyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "user_action", kind: "scalar", T: 9 },
        { no: 3, name: "debug_mode", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new $J().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $J().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $J().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($J, t, e)
    }
  },
  O6t = class xJ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogUserLintReplyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new xJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xJ, t, e)
    }
  },
  B6t = class NJ extends h {
    constructor(t) {
      super(),
        (this.userFeedback = bf.UNSPECIFIED),
        (this.userFeedbackDetails = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogLinterExplicitUserFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "message", T: t3 },
        { no: 3, name: "user_feedback", kind: "enum", T: n.getEnumType(bf) },
        { no: 4, name: "user_feedback_details", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new NJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NJ, t, e)
    }
  },
  bf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.CORRECT = 1)] = "CORRECT"),
    (i[(i.INCORRECT = 2)] = "INCORRECT"),
    (i[(i.OTHER = 3)] = "OTHER")
})(bf || (bf = {})),
  n.util.setEnumType(
    bf,
    "aiserver.v1.LogLinterExplicitUserFeedbackRequest.LinterUserFeedback",
    [
      { no: 0, name: "LINTER_USER_FEEDBACK_UNSPECIFIED" },
      { no: 1, name: "LINTER_USER_FEEDBACK_CORRECT" },
      { no: 2, name: "LINTER_USER_FEEDBACK_INCORRECT" },
      { no: 3, name: "LINTER_USER_FEEDBACK_OTHER" },
    ],
  )
var q6t = class CJ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogLinterExplicitUserFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new CJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CJ, t, e)
    }
  },
  U6t = class JJ extends h {
    constructor(t) {
      super(),
        (this.currentRules = ""),
        (this.dismissedBug = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamNewRuleRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_rules", kind: "scalar", T: 9 },
        { no: 2, name: "dismissed_bug", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JJ, t, e)
    }
  },
  M6t = class LJ extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.sessionId = ""),
        (this.documentationIdentifiers = []),
        (this.promptCodeBlocks = []),
        (this.fastMode = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamGPTFourEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 14, name: "session_id", kind: "scalar", T: 9 },
        { no: 9, name: "model_details", kind: "message", T: St },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "linter_errors", kind: "message", T: $i },
        {
          no: 12,
          name: "prompt_code_blocks",
          kind: "message",
          T: Ne,
          repeated: !0,
        },
        { no: 13, name: "fast_mode", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new LJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LJ, t, e)
    }
  },
  H6t = class RJ extends h {
    constructor(t) {
      super(),
        (this.id = ""),
        (this.role = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorHelpConversationMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "role", kind: "scalar", T: 9 },
        { no: 3, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RJ, t, e)
    }
  },
  W6t = class DJ extends h {
    constructor(t) {
      super(),
        (this.messages = []),
        (this.userOs = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiCursorHelpRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "message", T: H6t, repeated: !0 },
        { no: 2, name: "user_os", kind: "scalar", T: 9 },
        { no: 3, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new DJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DJ, t, e)
    }
  },
  j6t = class FJ extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.actions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiCursorHelpResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "actions", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new FJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FJ, t, e)
    }
  },
  V6t = class AJ extends h {
    constructor(t) {
      super(),
        (this.currentCommand = ""),
        (this.commandHistory = []),
        (this.fileDiffHistories = []),
        (this.commitHistory = []),
        (this.pastResults = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalAutocompleteRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_command", kind: "scalar", T: 9 },
        { no: 2, name: "command_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "file_diff_histories",
          kind: "message",
          T: Xi,
          repeated: !0,
        },
        { no: 5, name: "git_diff", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "commit_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 7, name: "past_results", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new AJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AJ, t, e)
    }
  },
  Dat = class _J extends h {
    constructor(t) {
      super(), (this.content = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PseudocodeTarget"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "range", kind: "message", T: Pi },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new _J().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _J().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _J().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_J, t, e)
    }
  },
  G6t = class OJ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPseudocodeGeneratorRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "target", kind: "message", T: Dat },
      ])
    }
    static fromBinary(t, e) {
      return new OJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OJ, t, e)
    }
  },
  z6t = class BJ extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPseudocodeGeneratorResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new BJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BJ, t, e)
    }
  },
  Y6t = class qJ extends h {
    constructor(t) {
      super(), (this.pseudocode = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPseudocodeMapperRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "target", kind: "message", T: Dat },
        { no: 1, name: "pseudocode", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qJ, t, e)
    }
  },
  Q6t = class UJ extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPseudocodeMapperResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new UJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UJ, t, e)
    }
  },
  X6t = class MJ extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalAutocompleteResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "done_stream", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new MJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MJ, t, e)
    }
  },
  K6t = class HJ extends h {
    constructor(t) {
      super(),
        (this.repositories = []),
        (this.gitDiff = ""),
        (this.conversation = []),
        (this.query = ""),
        (this.stop = ""),
        (this.importLineInDiff = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBackgroundEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 3, name: "explicit_context", kind: "message", T: Oe },
        { no: 4, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "git_diff", kind: "scalar", T: 9 },
        { no: 6, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 7, name: "query", kind: "scalar", T: 9 },
        { no: 8, name: "model_details", kind: "message", T: St },
        { no: 9, name: "stop", kind: "scalar", T: 9 },
        { no: 10, name: "import_line_in_diff", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new HJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HJ, t, e)
    }
  },
  Z6t = class WJ extends h {
    constructor(t) {
      super(),
        (this.callStack = []),
        (this.history = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "breakpoint", kind: "message", T: sOt },
        { no: 2, name: "call_stack", kind: "message", T: iOt, repeated: !0 },
        { no: 3, name: "history", kind: "message", T: Ne, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new WJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WJ, t, e)
    }
  },
  tOt = class jJ extends h {
    constructor(t) {
      super(), (this.name = ""), (this.value = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo.Variable"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 },
        { no: 3, name: "type", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new jJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jJ, t, e)
    }
  },
  eOt = class VJ extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.variables = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo.Scope"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "variables", kind: "message", T: tOt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new VJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VJ, t, e)
    }
  },
  iOt = class GJ extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lineNumber = 0),
        (this.functionName = ""),
        (this.scopes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo.CallStackFrame"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "function_name", kind: "scalar", T: 9 },
        { no: 4, name: "scopes", kind: "message", T: eOt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new GJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GJ, t, e)
    }
  },
  sOt = class zJ extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lineNumber = 0),
        (this.linesBeforeBreakpoint = []),
        (this.linesAfterBreakpoint = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo.Breakpoint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "lines_before_breakpoint",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 4,
          name: "lines_after_breakpoint",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 5, name: "exception_info", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zJ, t, e)
    }
  },
  Ja = class YJ extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.requestId = ""),
        (this.conversationId = ""),
        (this.quotes = []),
        (this.externalLinks = []),
        (this.commitNotes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: St },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 9, name: "request_id", kind: "scalar", T: 9 },
        { no: 10, name: "linter_errors", kind: "message", T: $i },
        { no: 11, name: "summary", kind: "scalar", T: 9, opt: !0 },
        {
          no: 12,
          name: "summary_up_until_index",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 13, name: "allow_long_file_scan", kind: "scalar", T: 8, opt: !0 },
        { no: 14, name: "is_bash", kind: "scalar", T: 8, opt: !0 },
        { no: 15, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 16,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 17, name: "use_web", kind: "scalar", T: 9, opt: !0 },
        { no: 18, name: "quotes", kind: "message", T: z8, repeated: !0 },
        { no: 19, name: "debug_info", kind: "message", T: Z6t, opt: !0 },
        { no: 20, name: "workspace_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 21,
          name: "external_links",
          kind: "message",
          T: bSt,
          repeated: !0,
        },
        { no: 23, name: "commit_notes", kind: "message", T: LM, repeated: !0 },
        { no: 22, name: "long_context_mode", kind: "scalar", T: 8, opt: !0 },
        { no: 24, name: "is_eval", kind: "scalar", T: 8, opt: !0 },
        { no: 26, name: "desired_max_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 25, name: "context_ast", kind: "message", T: wat },
        { no: 27, name: "is_composer", kind: "scalar", T: 8, opt: !0 },
        { no: 28, name: "runnable_code_blocks", kind: "scalar", T: 8, opt: !0 },
        { no: 29, name: "should_cache", kind: "scalar", T: 8, opt: !0 },
        {
          no: 30,
          name: "allow_model_fallbacks",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 31,
          name: "number_of_times_shown_fallback_model_warning",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new YJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YJ, t, e)
    }
  },
  rOt = class QJ extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.documentationIdentifiers = []),
        (this.externalLinks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetNotepadChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 2, name: "allow_long_file_scan", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "explicit_context", kind: "message", T: Oe },
        {
          no: 4,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 5, name: "model_details", kind: "message", T: St },
        { no: 6, name: "linter_errors", kind: "message", T: $i },
        {
          no: 7,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 8, name: "use_web", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "external_links", kind: "message", T: CM, repeated: !0 },
        { no: 10, name: "project_context", kind: "message", T: he, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new QJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QJ, t, e)
    }
  },
  nOt = class XJ extends h {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsInitialQueriesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XJ, t, e)
    }
  },
  aOt = class KJ extends h {
    constructor(t) {
      super(), (this.hydeQuery = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsInitialQueriesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "hyde_query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new KJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KJ, t, e)
    }
  },
  oOt = class ZJ extends h {
    constructor(t) {
      super(),
        (this.file = ""),
        (this.ranges = []),
        (this.query = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsUnderneathRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "scalar", T: 9 },
        { no: 2, name: "ranges", kind: "message", T: Ts, repeated: !0 },
        { no: 3, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ZJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZJ, t, e)
    }
  },
  cOt = class tL extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsUnderneathResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new tL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tL, t, e)
    }
  },
  lOt = class eL extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new eL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eL, t, e)
    }
  },
  uOt = class iL extends h {
    constructor(t) {
      super(), (this.potentialLoc = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "potential_loc", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iL, t, e)
    }
  },
  s3 = class sL extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.documentationIdentifiers = []),
        (this.externalLinks = []),
        (this.diffsForCompressingFiles = []),
        (this.multiFileLinterErrors = []),
        (this.fileDiffHistories = []),
        (this.additionalRankedContext = []),
        (this.quotes = []),
        (this.conversationId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetComposerChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 2, name: "allow_long_file_scan", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "explicit_context", kind: "message", T: Oe },
        {
          no: 4,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 5, name: "model_details", kind: "message", T: St },
        { no: 6, name: "linter_errors", kind: "message", T: $i },
        {
          no: 7,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 8, name: "use_web", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "external_links", kind: "message", T: CM, repeated: !0 },
        { no: 10, name: "project_context", kind: "message", T: he, opt: !0 },
        {
          no: 11,
          name: "diffs_for_compressing_files",
          kind: "message",
          T: hOt,
          repeated: !0,
        },
        { no: 12, name: "compress_edits", kind: "scalar", T: 8, opt: !0 },
        { no: 13, name: "should_cache", kind: "scalar", T: 8, opt: !0 },
        {
          no: 14,
          name: "multi_file_linter_errors",
          kind: "message",
          T: $i,
          repeated: !0,
        },
        { no: 15, name: "current_file", kind: "message", T: Yt },
        { no: 16, name: "recent_edits", kind: "message", T: dOt, opt: !0 },
        {
          no: 17,
          name: "use_reference_composer_diff_prompt",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 18,
          name: "file_diff_histories",
          kind: "message",
          T: OW,
          repeated: !0,
        },
        {
          no: 19,
          name: "use_new_compression_scheme",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 20,
          name: "additional_ranked_context",
          kind: "message",
          T: AW,
          repeated: !0,
        },
        { no: 21, name: "quotes", kind: "message", T: z8, repeated: !0 },
        {
          no: 22,
          name: "willing_to_pay_extra_for_speed",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 23, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 24,
          name: "use_unified_chat_prompt",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 25,
          name: "use_full_inputs_context",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 26, name: "is_resume", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sL, t, e)
    }
  },
  hOt = class rL extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.redRanges = []),
        (this.redRangesReversed = []),
        (this.startHash = ""),
        (this.endHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetComposerChatRequest.RedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "red_ranges", kind: "message", T: Ts, repeated: !0 },
        {
          no: 3,
          name: "red_ranges_reversed",
          kind: "message",
          T: Ts,
          repeated: !0,
        },
        { no: 4, name: "start_hash", kind: "scalar", T: 9 },
        { no: 5, name: "end_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rL, t, e)
    }
  },
  dOt = class nL extends h {
    constructor(t) {
      super(),
        (this.codeBlockInfo = []),
        (this.finalFileValues = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetComposerChatRequest.RecentEdits"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "code_block_info",
          kind: "message",
          T: mOt,
          repeated: !0,
        },
        {
          no: 2,
          name: "final_file_values",
          kind: "message",
          T: fOt,
          repeated: !0,
        },
        {
          no: 3,
          name: "edits_belong_to_composer_generation_uuid",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new nL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nL, t, e)
    }
  },
  mOt = class aL extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.GetComposerChatRequest.RecentEdits.CodeBlockInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "content_before", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "content_after", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "generation_uuid", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "version", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new aL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aL, t, e)
    }
  },
  fOt = class oL extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetComposerChatRequest.RecentEdits.FileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new oL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oL, t, e)
    }
  },
  UXt = class cL extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.query = ""),
        (this.rerankResults = !1),
        (this.contextResults = { case: void 0 }),
        (this.rerankResultsV2 = !1),
        (this.conversationId = ""),
        (this.canHandleFilenamesAfterLanguageIds = !1),
        (this.longContextMode = !1),
        (this.isEval = !1),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamComposerContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: St },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 9, name: "query", kind: "scalar", T: 9 },
        { no: 10, name: "code_context", kind: "message", T: pOt },
        { no: 11, name: "rerank_results", kind: "scalar", T: 8 },
        {
          no: 12,
          name: "file_search_results",
          kind: "message",
          T: e3,
          oneof: "context_results",
        },
        {
          no: 13,
          name: "code_search_results",
          kind: "message",
          T: i3,
          oneof: "context_results",
        },
        { no: 14, name: "linter_errors", kind: "message", T: $i },
        { no: 15, name: "is_bash", kind: "scalar", T: 8, opt: !0 },
        { no: 16, name: "rerank_results_v2", kind: "scalar", T: 8 },
        { no: 17, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 18,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
        },
        { no: 19, name: "long_context_mode", kind: "scalar", T: 8 },
        { no: 20, name: "is_eval", kind: "scalar", T: 8 },
        { no: 21, name: "request_id", kind: "scalar", T: 9 },
        { no: 22, name: "desired_max_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 23, name: "runnable_code_blocks", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new cL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cL, t, e)
    }
  },
  pOt = class lL extends h {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.scoredChunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamComposerContextRequest.CodeContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: Ne, repeated: !0 },
        { no: 2, name: "scored_chunks", kind: "message", T: xi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lL, t, e)
    }
  },
  gOt = class uL extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckUsageBasedPriceRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "usage_event_details", kind: "message", T: VW },
      ])
    }
    static fromBinary(t, e) {
      return new uL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uL, t, e)
    }
  },
  vOt = class hL extends h {
    constructor(t) {
      super(),
        (this.markdownResponse = ""),
        (this.cents = 0),
        (this.priceId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckUsageBasedPriceResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "markdown_response", kind: "scalar", T: 9 },
        { no: 2, name: "cents", kind: "scalar", T: 5 },
        { no: 3, name: "price_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new hL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hL, t, e)
    }
  },
  wOt = class dL extends h {
    constructor(t) {
      super(),
        (this.origRequestId = ""),
        (this.usageUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckQueuePositionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "orig_request_id", kind: "scalar", T: 9 },
        { no: 2, name: "model_details", kind: "message", T: St },
        { no: 3, name: "usage_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new dL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dL, t, e)
    }
  },
  yOt = class mL extends h {
    constructor(t) {
      super(),
        (this.position = 0),
        (this.hitHardLimit = !1),
        (this.couldEnableUsageBasedPricingToSkip = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckQueuePositionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "position", kind: "scalar", T: 5 },
        { no: 2, name: "seconds_left_to_wait", kind: "scalar", T: 5, opt: !0 },
        { no: 7, name: "new_queue_position", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "hit_hard_limit", kind: "scalar", T: 8 },
        {
          no: 4,
          name: "could_enable_usage_based_pricing_to_skip",
          kind: "scalar",
          T: 8,
        },
        { no: 5, name: "usage_event_details", kind: "message", T: VW },
        { no: 6, name: "custom_link", kind: "message", T: bOt },
      ])
    }
    static fromBinary(t, e) {
      return new mL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mL, t, e)
    }
  },
  bOt = class fL extends h {
    constructor(t) {
      super(),
        (this.address = ""),
        (this.message = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckQueuePositionResponse.CustomLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "address", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new fL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fL, t, e)
    }
  },
  TOt = class pL extends h {
    constructor(t) {
      super(),
        (this.fileContent = ""),
        (this.languageId = ""),
        (this.commandId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsolatedTreesitterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_content", kind: "scalar", T: 9 },
        { no: 2, name: "language_id", kind: "scalar", T: 9 },
        { no: 3, name: "command_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new pL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pL, t, e)
    }
  },
  kOt = class gL extends h {
    constructor(t) {
      super(), (this.items = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsolatedTreesitterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "items", kind: "message", T: SOt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gL, t, e)
    }
  },
  Fat = class vL extends h {
    constructor(t) {
      super(), (this.row = 0), (this.column = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.IsolatedTreesitterResponse.TreeSitterPosition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "row", kind: "scalar", T: 5 },
        { no: 2, name: "column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new vL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vL, t, e)
    }
  },
  SOt = class wL extends h {
    constructor(t) {
      super(), (this.symbolName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.IsolatedTreesitterResponse.TreesitterSymbolNameItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_position", kind: "message", T: Fat, opt: !0 },
        { no: 3, name: "end_position", kind: "message", T: Fat, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wL, t, e)
    }
  },
  EOt = class yL extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.answerPlaceholder = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSimplePromptRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "answer_placeholder", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new yL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yL, t, e)
    }
  },
  IOt = class bL extends h {
    constructor(t) {
      super(), (this.result = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSimplePromptResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "result", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bL, t, e)
    }
  },
  POt = class TL extends h {
    constructor(t) {
      super(), (this.didFit = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckLongFilesFitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_fit", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new TL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TL, t, e)
    }
  },
  $Ot = class kL extends h {
    constructor(t) {
      super(),
        (this.promptType = Tf.UNSPECIFIED),
        (this.query = ""),
        (this.bucketId = ""),
        (this.queryStrategy = ""),
        (this.tokenLimit = 0),
        (this.rerankingStrategy = kf.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEvaluationPromptRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt_type", kind: "enum", T: n.getEnumType(Tf) },
        { no: 2, name: "current_file", kind: "message", T: Yt },
        { no: 3, name: "query", kind: "scalar", T: 9 },
        { no: 4, name: "bucket_id", kind: "scalar", T: 9 },
        { no: 5, name: "query_strategy", kind: "scalar", T: 9 },
        { no: 6, name: "token_limit", kind: "scalar", T: 5 },
        {
          no: 7,
          name: "reranking_strategy",
          kind: "enum",
          T: n.getEnumType(kf),
        },
      ])
    }
    static fromBinary(t, e) {
      return new kL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kL, t, e)
    }
  },
  Tf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GENERATE = 1)] = "GENERATE"),
    (i[(i.CHAT = 2)] = "CHAT")
})(Tf || (Tf = {})),
  n.util.setEnumType(
    Tf,
    "aiserver.v1.GetEvaluationPromptRequest.EvaluationPromptType",
    [
      { no: 0, name: "EVALUATION_PROMPT_TYPE_UNSPECIFIED" },
      { no: 1, name: "EVALUATION_PROMPT_TYPE_GENERATE" },
      { no: 2, name: "EVALUATION_PROMPT_TYPE_CHAT" },
    ],
  )
var kf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DISTANCE_ONLY = 1)] = "DISTANCE_ONLY"),
    (i[(i.GPT4_RELEVANCE = 2)] = "GPT4_RELEVANCE")
})(kf || (kf = {})),
  n.util.setEnumType(
    kf,
    "aiserver.v1.GetEvaluationPromptRequest.RerankingStrategy",
    [
      { no: 0, name: "RERANKING_STRATEGY_UNSPECIFIED" },
      { no: 1, name: "RERANKING_STRATEGY_DISTANCE_ONLY" },
      { no: 2, name: "RERANKING_STRATEGY_GPT4_RELEVANCE" },
    ],
  )
var xOt = class SL extends h {
    constructor(t) {
      super(),
        (this.prompt = ""),
        (this.tokenCount = 0),
        (this.estimatedTokenCount = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEvaluationPromptResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt", kind: "scalar", T: 9 },
        { no: 2, name: "token_count", kind: "scalar", T: 5 },
        { no: 3, name: "estimated_token_count", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new SL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SL, t, e)
    }
  },
  NOt = class EL extends h {
    constructor(t) {
      super(),
        (this.prompt = ""),
        (this.repositories = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInlineEditsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "prompt", kind: "scalar", T: 9 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
      ])
    }
    static fromBinary(t, e) {
      return new EL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EL, t, e)
    }
  },
  COt = class IL extends h {
    constructor(t) {
      super(), (this.line = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInlineEditsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 9 },
        { no: 2, name: "debugging_only_prompt", kind: "scalar", T: 9, opt: !0 },
        {
          no: 3,
          name: "debugging_only_token_count",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new IL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IL, t, e)
    }
  },
  JOt = class PL extends h {
    constructor(t) {
      super(),
        (this.didSummarize = !1),
        (this.upUntilIndex = 0),
        (this.summary = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeConversationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_summarize", kind: "scalar", T: 8 },
        { no: 2, name: "up_until_index", kind: "scalar", T: 5 },
        { no: 3, name: "summary", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PL, t, e)
    }
  },
  LOt = class $L extends h {
    constructor(t) {
      super(), (this.conversation = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetChatTitleRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new $L().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $L().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $L().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($L, t, e)
    }
  },
  ROt = class xL extends h {
    constructor(t) {
      super(), (this.title = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetChatTitleResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xL, t, e)
    }
  },
  MXt = class NL extends h {
    constructor(t) {
      super(),
        (this.prompt = ""),
        (this.tokenCount = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetChatPromptResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt", kind: "scalar", T: 9 },
        { no: 2, name: "token_count", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new NL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NL, t, e)
    }
  },
  DOt = class CL extends h {
    constructor(t) {
      super(),
        (this.serverStartTime = 0),
        (this.serverFirstTokenTime = 0),
        (this.serverRequestSentTime = 0),
        (this.serverEndTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ServerTimingInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "server_start_time", kind: "scalar", T: 1 },
        { no: 2, name: "server_first_token_time", kind: "scalar", T: 1 },
        { no: 3, name: "server_request_sent_time", kind: "scalar", T: 1 },
        { no: 4, name: "server_end_time", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new CL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CL, t, e)
    }
  },
  _s = class JL extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 22, name: "server_bubble_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "debugging_only_chat_prompt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 3,
          name: "debugging_only_token_count",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 4, name: "document_citation", kind: "message", T: _W },
        { no: 5, name: "filled_prompt", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "is_big_file", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "intermediate_text", kind: "scalar", T: 9, opt: !0 },
        {
          no: 10,
          name: "is_using_slow_request",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 8, name: "chunk_identity", kind: "message", T: FOt, opt: !0 },
        { no: 9, name: "docs_reference", kind: "message", T: VB, opt: !0 },
        { no: 11, name: "web_citation", kind: "message", T: tat, opt: !0 },
        { no: 12, name: "status_updates", kind: "message", T: iat, opt: !0 },
        { no: 13, name: "timing_info", kind: "message", T: DOt, opt: !0 },
        { no: 14, name: "symbol_link", kind: "message", T: qW, opt: !0 },
        { no: 15, name: "file_link", kind: "message", T: UW, opt: !0 },
        {
          no: 16,
          name: "conversation_summary",
          kind: "message",
          T: Nn,
          opt: !0,
        },
        {
          no: 17,
          name: "service_status_update",
          kind: "message",
          T: rat,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new JL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JL, t, e)
    }
  },
  FOt = class LL extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.text = ""),
        (this.chunkType = xn.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatResponse.ChunkIdentity"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
        { no: 5, name: "chunk_type", kind: "enum", T: n.getEnumType(xn) },
      ])
    }
    static fromBinary(t, e) {
      return new LL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LL, t, e)
    }
  },
  AOt = class RL extends h {
    constructor(t) {
      super(), (this.didWarmCache = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmComposerCacheResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_warm_cache", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new RL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RL, t, e)
    }
  },
  _Ot = class DL extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmChatCacheRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: Ja },
      ])
    }
    static fromBinary(t, e) {
      return new DL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DL, t, e)
    }
  },
  OOt = class FL extends h {
    constructor(t) {
      super(), (this.didWarmCache = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmChatCacheResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_warm_cache", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new FL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FL, t, e)
    }
  },
  BOt = class AL extends h {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SurroundingLines"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new AL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AL, t, e)
    }
  },
  qOt = class _L extends h {
    constructor(t) {
      super(), (this.suggestionsFromEditor = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCompletionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_identifier", kind: "message", T: jOt },
        { no: 2, name: "cursor_position", kind: "message", T: ba },
        { no: 3, name: "surrounding_lines", kind: "message", T: BOt },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        {
          no: 5,
          name: "suggestions_from_editor",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new _L().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _L().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _L().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_L, t, e)
    }
  },
  UOt = class OL extends h {
    constructor(t) {
      super(),
        (this.completion = ""),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCompletionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "completion", kind: "scalar", T: 9 },
        { no: 2, name: "score", kind: "scalar", T: 2 },
        {
          no: 3,
          name: "debugging_only_completion_prompt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new OL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OL, t, e)
    }
  },
  MOt = class BL extends h {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.repositories = []),
        (this.topK = 0),
        (this.restrictToBuckets = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSearchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 3, name: "top_k", kind: "scalar", T: 5 },
        {
          no: 4,
          name: "restrict_to_buckets",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new BL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BL, t, e)
    }
  },
  HOt = class qL extends h {
    constructor(t) {
      super(),
        (this.repositoryRelativeWorkspacePath = ""),
        (this.fileRelativeRepositoryPath = ""),
        (this.chunk = ""),
        (this.distance = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "repository_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
        { no: 2, name: "file_relative_repository_path", kind: "scalar", T: 9 },
        { no: 3, name: "chunk", kind: "scalar", T: 9 },
        { no: 4, name: "distance", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new qL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qL, t, e)
    }
  },
  WOt = class UL extends h {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSearchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: HOt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new UL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UL, t, e)
    }
  },
  jOt = class ML extends h {
    constructor(t) {
      super(),
        (this.projectUuid = ""),
        (this.relativePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UniqueFileIdentifier"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "project_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "relative_path", kind: "scalar", T: 9 },
        { no: 3, name: "language_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ML().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ML().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ML().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ML, t, e)
    }
  },
  VOt = class HL extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUserInfoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new HL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HL, t, e)
    }
  },
  GOt = class WL extends h {
    constructor(t) {
      super(),
        (this.gpt4Requests = 0),
        (this.gpt4MaxRequests = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "gpt4_requests", kind: "scalar", T: 5 },
        { no: 3, name: "gpt4_max_requests", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new WL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WL, t, e)
    }
  },
  zOt = class jL extends h {
    constructor(t) {
      super(),
        (this.userId = ""),
        (this.jupyterToken = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUserInfoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_id", kind: "scalar", T: 9 },
        { no: 2, name: "jupyter_token", kind: "scalar", T: 9 },
        { no: 3, name: "usage", kind: "message", T: GOt },
      ])
    }
    static fromBinary(t, e) {
      return new jL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jL, t, e)
    }
  },
  YOt = class VL extends h {
    constructor(t) {
      super(), (this.bucketId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClearAndRedoEntireBucketRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bucket_id", kind: "scalar", T: 9 },
        { no: 2, name: "commit", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new VL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VL, t, e)
    }
  },
  QOt = class GL extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClearAndRedoEntireBucketResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new GL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GL, t, e)
    }
  },
  XOt = class zL extends h {
    constructor(t) {
      super(),
        (this.generationUuid = ""),
        (this.completion = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "generation_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "completion", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new zL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zL, t, e)
    }
  },
  Aat = class YL extends h {
    constructor(t) {
      super(),
        (this.action = { case: void 0 }),
        (this.reasoning = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "skip_action",
          kind: "message",
          T: KOt,
          oneof: "action",
        },
        {
          no: 2,
          name: "edit_action",
          kind: "message",
          T: ZOt,
          oneof: "action",
        },
        {
          no: 3,
          name: "create_action",
          kind: "message",
          T: t8t,
          oneof: "action",
        },
        { no: 4, name: "run_action", kind: "message", T: e8t, oneof: "action" },
        { no: 5, name: "reasoning", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new YL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YL, t, e)
    }
  },
  KOt = class QL extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse.SkipAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new QL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QL, t, e)
    }
  },
  ZOt = class XL extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse.EditAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XL, t, e)
    }
  },
  t8t = class KL extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse.CreateAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new KL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KL, t, e)
    }
  },
  e8t = class ZL extends h {
    constructor(t) {
      super(), (this.command = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse.RunAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ZL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZL, t, e)
    }
  },
  i8t = class t5 extends h {
    constructor(t) {
      super(),
        (this.generationUuid = ""),
        (this.completion = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "generation_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "completion", kind: "scalar", T: 9 },
        { no: 3, name: "action", kind: "message", T: Aat },
      ])
    }
    static fromBinary(t, e) {
      return new t5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t5, t, e)
    }
  },
  s8t = class e5 extends h {
    constructor(t) {
      super(), (this.event = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "update_status",
          kind: "message",
          T: r8t,
          oneof: "event",
        },
      ])
    }
    static fromBinary(t, e) {
      return new e5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e5, t, e)
    }
  },
  r8t = class i5 extends h {
    constructor(t) {
      super(), (this.status = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeResponse.UpdateStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new i5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i5, t, e)
    }
  },
  n8t = class s5 extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: s8t,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new s5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s5, t, e)
    }
  },
  a8t = class r5 extends h {
    constructor(t) {
      super(), (this.toolformerSessionId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerContinueRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "toolformer_session_id", kind: "scalar", T: 9 },
        { no: 2, name: "tool_result", kind: "message", T: DW },
      ])
    }
    static fromBinary(t, e) {
      return new r5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r5, t, e)
    }
  },
  _at = class n5 extends h {
    constructor(t) {
      super(),
        (this.responseType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "toolformer_session_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "output",
          kind: "message",
          T: o8t,
          oneof: "response_type",
        },
        {
          no: 3,
          name: "tool_action",
          kind: "message",
          T: l8t,
          oneof: "response_type",
        },
        {
          no: 4,
          name: "thought",
          kind: "message",
          T: c8t,
          oneof: "response_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new n5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n5, t, e)
    }
  },
  o8t = class a5 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerResponse.Output"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new a5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a5, t, e)
    }
  },
  c8t = class o5 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerResponse.Thought"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new o5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o5, t, e)
    }
  },
  l8t = class c5 extends h {
    constructor(t) {
      super(),
        (this.userFacingText = ""),
        (this.rawModelOutput = ""),
        (this.moreToCome = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerResponse.ToolAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_facing_text", kind: "scalar", T: 9 },
        { no: 3, name: "raw_model_output", kind: "scalar", T: 9 },
        { no: 2, name: "tool_call", kind: "message", T: Wnt },
        { no: 4, name: "more_to_come", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new c5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c5, t, e)
    }
  },
  Oat = class l5 extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.attachedCodeChunks = []),
        (this.repositories = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInstruction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "attached_code_chunks",
          kind: "message",
          T: u8t,
          repeated: !0,
        },
        { no: 3, name: "current_file", kind: "message", T: Yt },
        { no: 4, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 5, name: "explicit_context", kind: "message", T: Oe },
      ])
    }
    static fromBinary(t, e) {
      return new l5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l5, t, e)
    }
  },
  u8t = class u5 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInstruction.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new u5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u5, t, e)
    }
  },
  Bat = class h5 extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.attachedCodeChunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskUserMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "attached_code_chunks",
          kind: "message",
          T: h8t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new h5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h5, t, e)
    }
  },
  h8t = class d5 extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskUserMessage.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new d5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d5, t, e)
    }
  },
  d8t = class m5 extends h {
    constructor(t) {
      super(),
        (this.thought = ""),
        (this.automated = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PushAiThoughtRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9 },
        { no: 2, name: "cmd_k_debug_info", kind: "message", T: Rs },
        { no: 3, name: "automated", kind: "scalar", T: 8 },
        { no: 4, name: "metadata", kind: "message", T: m8t, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new m5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m5, t, e)
    }
  },
  m8t = class f5 extends h {
    constructor(t) {
      super(), (this.event = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PushAiThoughtRequest.Metadata"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "accepted_hallucinated_function_event",
          kind: "message",
          T: f8t,
          oneof: "event",
        },
      ])
    }
    static fromBinary(t, e) {
      return new f5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f5, t, e)
    }
  },
  f8t = class p5 extends h {
    constructor(t) {
      super(),
        (this.implementationUuid = ""),
        (this.hallucinatedFunctionUuid = ""),
        (this.implementation = ""),
        (this.source = ""),
        (this.implementationReqid = ""),
        (this.planReqid = ""),
        (this.reflectionReqid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.PushAiThoughtRequest.Metadata.AcceptedHallucinatedFunctionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "implementation_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "hallucinated_function_uuid", kind: "scalar", T: 9 },
        { no: 3, name: "implementation", kind: "scalar", T: 9 },
        { no: 4, name: "source", kind: "scalar", T: 9 },
        { no: 5, name: "implementation_reqid", kind: "scalar", T: 9 },
        { no: 6, name: "plan_reqid", kind: "scalar", T: 9 },
        { no: 7, name: "reflection_reqid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new p5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p5, t, e)
    }
  },
  p8t = class g5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PushAiThoughtResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new g5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g5, t, e)
    }
  },
  g8t = class v5 extends h {
    constructor(t) {
      super(), (this.modelOutput = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckDoableAsTaskRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_output", kind: "scalar", T: 9 },
        { no: 2, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new v5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v5, t, e)
    }
  },
  v8t = class w5 extends h {
    constructor(t) {
      super(), (this.doableAsTask = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckDoableAsTaskResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doable_as_task", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new w5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w5, t, e)
    }
  },
  w8t = class y5 extends h {
    constructor(t) {
      super(), (this.debuggingOnlyLiveMode = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterfaceAgentInitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: St },
        { no: 2, name: "debugging_only_live_mode", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "interface_agent_client_state",
          kind: "message",
          T: Tat,
        },
      ])
    }
    static fromBinary(t, e) {
      return new y5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y5, t, e)
    }
  },
  y8t = class b5 extends h {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.humanReadableTitle = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterfaceAgentInitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "human_readable_title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new b5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b5, t, e)
    }
  },
  b8t = class T5 extends h {
    constructor(t) {
      super(), (this.taskUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterfaceAgentStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new T5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T5, t, e)
    }
  },
  T8t = class k5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterfaceAgentStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "message", T: kat },
      ])
    }
    static fromBinary(t, e) {
      return new k5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k5, t, e)
    }
  },
  k8t = class S5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskGetInterfaceAgentStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "interface_agent_client_state",
          kind: "message",
          T: Tat,
        },
      ])
    }
    static fromBinary(t, e) {
      return new S5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S5, t, e)
    }
  },
  S8t = class E5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskGetInterfaceAgentStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "message", T: kat },
      ])
    }
    static fromBinary(t, e) {
      return new E5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E5, t, e)
    }
  },
  E8t = class I5 extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskGetInterfaceAgentStatusResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: S8t,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new I5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I5, t, e)
    }
  },
  I8t = class P5 extends h {
    constructor(t) {
      super(), (this.debuggingOnlyLiveMode = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "message", T: Oat },
        { no: 2, name: "model_details", kind: "message", T: St },
        { no: 3, name: "debugging_only_live_mode", kind: "scalar", T: 8 },
        { no: 4, name: "engine_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new P5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P5, t, e)
    }
  },
  P8t = class $5 extends h {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.humanReadableTitle = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "human_readable_title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($5, t, e)
    }
  },
  $8t = class x5 extends h {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.startSequenceNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamLogRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "start_sequence_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new x5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x5, t, e)
    }
  },
  x8t = class N5 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogOutput"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new N5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N5, t, e)
    }
  },
  N8t = class C5 extends h {
    constructor(t) {
      super(),
        (this.userFacingText = ""),
        (this.rawModelOutput = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogToolAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_facing_text", kind: "scalar", T: 9 },
        { no: 3, name: "raw_model_output", kind: "scalar", T: 9 },
        { no: 2, name: "tool_call", kind: "message", T: Wnt },
      ])
    }
    static fromBinary(t, e) {
      return new C5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C5, t, e)
    }
  },
  C8t = class J5 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogThought"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new J5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J5, t, e)
    }
  },
  J8t = class L5 extends h {
    constructor(t) {
      super(), (this.actionSequenceNumber = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_result", kind: "message", T: DW },
        { no: 2, name: "action_sequence_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new L5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L5, t, e)
    }
  },
  L8t = class R5 extends h {
    constructor(t) {
      super(),
        (this.sequenceNumber = 0),
        (this.isNotDone = !1),
        (this.logItem = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "sequence_number", kind: "scalar", T: 5 },
        { no: 2, name: "is_not_done", kind: "scalar", T: 8 },
        { no: 3, name: "output", kind: "message", T: x8t, oneof: "log_item" },
        {
          no: 4,
          name: "tool_action",
          kind: "message",
          T: N8t,
          oneof: "log_item",
        },
        { no: 5, name: "thought", kind: "message", T: C8t, oneof: "log_item" },
        {
          no: 6,
          name: "user_message",
          kind: "message",
          T: Bat,
          oneof: "log_item",
        },
        {
          no: 7,
          name: "instruction",
          kind: "message",
          T: Oat,
          oneof: "log_item",
        },
        {
          no: 8,
          name: "tool_result",
          kind: "message",
          T: J8t,
          oneof: "log_item",
        },
      ])
    }
    static fromBinary(t, e) {
      return new R5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R5, t, e)
    }
  },
  R8t = class D5 extends h {
    constructor(t) {
      super(), (this.taskUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInfoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new D5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D5, t, e)
    }
  },
  D8t = class F5 extends h {
    constructor(t) {
      super(), (this.taskUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskPauseRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new F5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F5, t, e)
    }
  },
  F8t = class A5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskPauseResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new A5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A5, t, e)
    }
  },
  qat = class _5 extends h {
    constructor(t) {
      super(),
        (this.humanReadableTitle = ""),
        (this.taskStatus = jl.UNSPECIFIED),
        (this.lastLogSequenceNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInfoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "human_readable_title", kind: "scalar", T: 9 },
        { no: 2, name: "task_status", kind: "enum", T: n.getEnumType(jl) },
        { no: 3, name: "last_log_sequence_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new _5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_5, t, e)
    }
  },
  A8t = class O5 extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamLogResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "streamed_log_item",
          kind: "message",
          T: L8t,
          oneof: "response",
        },
        {
          no: 2,
          name: "info_update",
          kind: "message",
          T: _8t,
          oneof: "response",
        },
        {
          no: 3,
          name: "initial_task_info",
          kind: "message",
          T: qat,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new O5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O5, t, e)
    }
  },
  _8t = class B5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamLogResponse.InfoUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "human_readable_title", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "task_status",
          kind: "enum",
          T: n.getEnumType(jl),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new B5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B5, t, e)
    }
  },
  O8t = class q5 extends h {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.actionSequenceNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskProvideResultRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "action_sequence_number", kind: "scalar", T: 5 },
        { no: 3, name: "tool_result", kind: "message", T: DW },
      ])
    }
    static fromBinary(t, e) {
      return new q5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q5, t, e)
    }
  },
  B8t = class U5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskProvideResultResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new U5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U5, t, e)
    }
  },
  q8t = class M5 extends h {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.wantsAttentionRightNow = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskSendMessageRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "user_message", kind: "message", T: Bat },
        { no: 3, name: "wants_attention_right_now", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new M5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M5, t, e)
    }
  },
  U8t = class H5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskSendMessageResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new H5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H5, t, e)
    }
  },
  M8t = class W5 extends h {
    constructor(t) {
      super(),
        (this.feedback = ""),
        (this.feedbackType = Sf.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback", kind: "scalar", T: 9 },
        { no: 2, name: "feedback_type", kind: "enum", T: n.getEnumType(Sf) },
      ])
    }
    static fromBinary(t, e) {
      return new W5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W5, t, e)
    }
  },
  Sf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOW_PRIORITY = 1)] = "LOW_PRIORITY"),
    (i[(i.HIGH_PRIORITY = 2)] = "HIGH_PRIORITY")
})(Sf || (Sf = {})),
  n.util.setEnumType(Sf, "aiserver.v1.ReportFeedbackRequest.FeedbackType", [
    { no: 0, name: "FEEDBACK_TYPE_UNSPECIFIED" },
    { no: 1, name: "FEEDBACK_TYPE_LOW_PRIORITY" },
    { no: 2, name: "FEEDBACK_TYPE_HIGH_PRIORITY" },
  ])
var H8t = class j5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new j5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j5, t, e)
    }
  },
  W8t = class V5 extends h {
    constructor(t) {
      super(),
        (this.relativePathToCursorFolder = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path_to_cursor_folder", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new V5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V5, t, e)
    }
  },
  j8t = class G5 extends h {
    constructor(t) {
      super(),
        (this.screenshots = []),
        (this.conversation = []),
        (this.logs = []),
        (this.consoleLogs = ""),
        (this.cursorVersion = ""),
        (this.os = ""),
        (this.protoUrl = ""),
        (this.failingRequstId = ""),
        (this.connectionErrorRaw = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "screenshots", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "current_file", kind: "message", T: Yt },
        { no: 3, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 4, name: "logs", kind: "message", T: W8t, repeated: !0 },
        { no: 5, name: "console_logs", kind: "scalar", T: 9 },
        { no: 6, name: "cursor_version", kind: "scalar", T: 9 },
        { no: 7, name: "os", kind: "scalar", T: 9 },
        { no: 8, name: "proto_url", kind: "scalar", T: 9 },
        { no: 9, name: "failing_requst_id", kind: "scalar", T: 9 },
        { no: 10, name: "connection_error_raw", kind: "scalar", T: 9 },
        { no: 12, name: "debug_info", kind: "message", T: Rs },
        { no: 13, name: "connect_error_code", kind: "scalar", T: 5, opt: !0 },
        {
          no: 14,
          name: "error_detail_code",
          kind: "enum",
          T: n.getEnumType(Sa),
          opt: !0,
        },
        { no: 15, name: "error_detail_title", kind: "scalar", T: 9, opt: !0 },
        { no: 16, name: "error_detail_detail", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new G5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G5, t, e)
    }
  },
  V8t = class z5 extends h {
    constructor(t) {
      super(),
        (this.bug = ""),
        (this.bugType = Ef.UNSPECIFIED),
        (this.contactEmail = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportBugRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "scalar", T: 9 },
        { no: 2, name: "bug_type", kind: "enum", T: n.getEnumType(Ef) },
        { no: 3, name: "context", kind: "message", T: j8t },
        { no: 4, name: "contact_email", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new z5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z5, t, e)
    }
  },
  Ef
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOW = 1)] = "LOW"),
    (i[(i.MEDIUM = 2)] = "MEDIUM"),
    (i[(i.URGENT = 3)] = "URGENT"),
    (i[(i.CRASH = 4)] = "CRASH"),
    (i[(i.CONNECTION_ERROR = 5)] = "CONNECTION_ERROR"),
    (i[(i.IDEA = 6)] = "IDEA"),
    (i[(i.MISC_AUTOMATIC_ERROR = 7)] = "MISC_AUTOMATIC_ERROR")
})(Ef || (Ef = {})),
  n.util.setEnumType(Ef, "aiserver.v1.ReportBugRequest.BugType", [
    { no: 0, name: "BUG_TYPE_UNSPECIFIED" },
    { no: 1, name: "BUG_TYPE_LOW" },
    { no: 2, name: "BUG_TYPE_MEDIUM" },
    { no: 3, name: "BUG_TYPE_URGENT" },
    { no: 4, name: "BUG_TYPE_CRASH" },
    { no: 5, name: "BUG_TYPE_CONNECTION_ERROR" },
    { no: 6, name: "BUG_TYPE_IDEA" },
    { no: 7, name: "BUG_TYPE_MISC_AUTOMATIC_ERROR" },
  ])
var G8t = class Y5 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportBugResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Y5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y5, t, e)
    }
  },
  z8t = class Q5 extends h {
    constructor(t) {
      super(),
        (this.markers = []),
        (this.iterationNumber = 0),
        (this.sequenceId = ""),
        (this.userInstruction = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "markers", kind: "message", T: Y8t, repeated: !0 },
        { no: 2, name: "model_details", kind: "message", T: St },
        { no: 3, name: "iteration_number", kind: "scalar", T: 5 },
        { no: 4, name: "sequence_id", kind: "scalar", T: 9 },
        { no: 5, name: "user_instruction", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Q5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q5, t, e)
    }
  },
  Y8t = class X5 extends h {
    constructor(t) {
      super(),
        (this.lines = []),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        (this.message = ""),
        (this.relativeWorkspacePath = ""),
        (this.relatedInformation = []),
        (this.contextRanges = []),
        (this.ancestorTypeDefinitions = []),
        (this.insertedSymbolTypes = []),
        (this.quickFixes = []),
        (this.startColumn = 0),
        (this.endColumnInclusive = 0),
        (this.classInformation = []),
        (this.functionSignatures = []),
        (this.snapshot = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_inclusive", kind: "scalar", T: 5 },
        { no: 4, name: "message", kind: "scalar", T: 9 },
        { no: 5, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 6,
          name: "related_information",
          kind: "message",
          T: Q8t,
          repeated: !0,
        },
        {
          no: 7,
          name: "context_ranges",
          kind: "message",
          T: X8t,
          repeated: !0,
        },
        {
          no: 8,
          name: "ancestor_type_definitions",
          kind: "message",
          T: K8t,
          repeated: !0,
        },
        {
          no: 9,
          name: "inserted_symbol_types",
          kind: "message",
          T: Z8t,
          repeated: !0,
        },
        { no: 10, name: "quick_fixes", kind: "message", T: tBt, repeated: !0 },
        { no: 11, name: "start_column", kind: "scalar", T: 5 },
        { no: 12, name: "end_column_inclusive", kind: "scalar", T: 5 },
        {
          no: 13,
          name: "class_information",
          kind: "message",
          T: iBt,
          repeated: !0,
        },
        {
          no: 14,
          name: "function_signatures",
          kind: "message",
          T: rBt,
          repeated: !0,
        },
        { no: 15, name: "snapshot", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new X5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X5, t, e)
    }
  },
  Q8t = class K5 extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.relativeWorkspacePath = ""),
        (this.relevantLines = []),
        (this.startLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.RelatedInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "relevant_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "start_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new K5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K5, t, e)
    }
  },
  X8t = class Z5 extends h {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.ContextRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Z5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z5, t, e)
    }
  },
  K8t = class tR extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.FixMarkersRequest.Marker.AncestorTypeDefinition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "start_line", kind: "scalar", T: 5 },
        { no: 4, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tR, t, e)
    }
  },
  Z8t = class eR extends h {
    constructor(t) {
      super(),
        (this.symbolName = ""),
        (this.symbolType = ""),
        (this.relativeWorkspacePath = ""),
        (this.symbolLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.InsertedSymbolType"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol_name", kind: "scalar", T: 9 },
        { no: 2, name: "symbol_type", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "symbol_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new eR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eR, t, e)
    }
  },
  tBt = class iR extends h {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.kind = ""),
        (this.isPreferred = !1),
        (this.edits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.QuickFix"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8 },
        { no: 4, name: "edits", kind: "message", T: eBt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new iR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iR, t, e)
    }
  },
  eBt = class sR extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        (this.deletedLines = []),
        (this.addLines = []),
        (this.snapshot = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.QuickFix.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_inclusive", kind: "scalar", T: 5 },
        { no: 4, name: "deleted_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "add_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 6, name: "snapshot", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new sR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sR, t, e)
    }
  },
  iBt = class rR extends h {
    constructor(t) {
      super(),
        (this.className = ""),
        (this.startLine = 0),
        (this.topLevelLines = []),
        (this.lines = []),
        (this.constructors = []),
        (this.detail = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.ClassInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "class_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "top_level_lines", kind: "scalar", T: 5, repeated: !0 },
        { no: 4, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "constructors", kind: "message", T: sBt, repeated: !0 },
        { no: 6, name: "detail", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rR, t, e)
    }
  },
  sBt = class nR extends h {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.FixMarkersRequest.Marker.ClassInformation.Constructor"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new nR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nR, t, e)
    }
  },
  rBt = class aR extends h {
    constructor(t) {
      super(),
        (this.label = ""),
        (this.documentation = ""),
        (this.parameters = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.FunctionSignature"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "documentation", kind: "scalar", T: 9 },
        { no: 3, name: "parameters", kind: "message", T: nBt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new aR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aR, t, e)
    }
  },
  nBt = class oR extends h {
    constructor(t) {
      super(),
        (this.label = ""),
        (this.documentation = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.FixMarkersRequest.Marker.FunctionSignature.FunctionParameter"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "documentation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new oR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oR, t, e)
    }
  },
  aBt = class cR extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.changes = []),
        (this.success = !1),
        (this.iterationNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "changes", kind: "message", T: oBt, repeated: !0 },
        { no: 3, name: "success", kind: "scalar", T: 8 },
        { no: 4, name: "iteration_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new cR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cR, t, e)
    }
  },
  oBt = class lR extends h {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineExclusive = 0),
        (this.deletedLines = []),
        (this.addLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersResponse.Change"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_exclusive", kind: "scalar", T: 5 },
        { no: 3, name: "deleted_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "add_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lR, t, e)
    }
  },
  cBt = class uR extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.badNotifications = []),
        (this.lintRules = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamLintRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: Ne, repeated: !0 },
        { no: 9, name: "model_details", kind: "message", T: St },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 11,
          name: "bad_notifications",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 12, name: "lint_rules", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new uR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uR, t, e)
    }
  },
  lBt = class hR extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.timeSinceCompletedActionMs = 0),
        (this.featureType = Rd.UNSPECIFIED),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.linesAboveAndBelow = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportGroundTruthCandidateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "time_since_completed_action_ms", kind: "scalar", T: 5 },
        { no: 3, name: "feature_type", kind: "enum", T: n.getEnumType(Rd) },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 5, name: "contents", kind: "scalar", T: 9 },
        { no: 6, name: "selection_in_question", kind: "message", T: Li },
        { no: 7, name: "lines_above_and_below", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new hR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hR, t, e)
    }
  },
  uBt = class dR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportGroundTruthCandidateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new dR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dR, t, e)
    }
  },
  hBt = class mR extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.fate = If.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportCmdKFateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "fate", kind: "enum", T: n.getEnumType(If) },
      ])
    }
    static fromBinary(t, e) {
      return new mR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mR, t, e)
    }
  },
  If
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.CANCELLED = 1)] = "CANCELLED"),
    (i[(i.ACCEPTED = 2)] = "ACCEPTED"),
    (i[(i.REJECTED = 3)] = "REJECTED"),
    (i[(i.FOLLOWED_UP = 4)] = "FOLLOWED_UP"),
    (i[(i.REPROMPTED = 5)] = "REPROMPTED")
})(If || (If = {})),
  n.util.setEnumType(If, "aiserver.v1.ReportCmdKFateRequest.Fate", [
    { no: 0, name: "FATE_UNSPECIFIED" },
    { no: 1, name: "FATE_CANCELLED" },
    { no: 2, name: "FATE_ACCEPTED" },
    { no: 3, name: "FATE_REJECTED" },
    { no: 4, name: "FATE_FOLLOWED_UP" },
    { no: 5, name: "FATE_REPROMPTED" },
  ])
var dBt = class fR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportCmdKFateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new fR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fR, t, e)
    }
  },
  HXt = class pR extends h {
    constructor(t) {
      super(), (this.sshString = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SshConfigPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ssh_string", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new pR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pR, t, e)
    }
  },
  mBt = class gR extends h {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.files = []),
        (this.contextResults = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetFilesForComposerRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 2, name: "files", kind: "message", T: Yt, repeated: !0 },
        { no: 3, name: "rerank_results", kind: "scalar", T: 8, opt: !0 },
        {
          no: 4,
          name: "file_search_results",
          kind: "message",
          T: e3,
          oneof: "context_results",
        },
        {
          no: 5,
          name: "code_search_results",
          kind: "message",
          T: i3,
          oneof: "context_results",
        },
        { no: 6, name: "rerank_results_v2", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "long_context_mode", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "is_eval", kind: "scalar", T: 8, opt: !0 },
        { no: 9, name: "request_id", kind: "scalar", T: 9, opt: !0 },
        { no: 10, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new gR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gR, t, e)
    }
  },
  fBt = class vR extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePaths = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetFilesForComposerResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "relative_workspace_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vR, t, e)
    }
  },
  pBt = class wR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FindBugsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new wR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wR, t, e)
    }
  },
  gBt = class yR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FindBugsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "message", T: vBt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yR, t, e)
    }
  },
  vBt = class bR extends h {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.lineNumber = 0),
        (this.confidence = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FindBugsResponse.Bug"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "confidence", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new bR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bR, t, e)
    }
  },
  wBt = class TR extends h {
    constructor(t) {
      super(),
        (this.diffs = []),
        (this.previousCommitMessages = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WriteGitCommitMessageRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diffs", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 2,
          name: "previous_commit_messages",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new TR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TR, t, e)
    }
  },
  yBt = class kR extends h {
    constructor(t) {
      super(), (this.commitMessage = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WriteGitCommitMessageResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commit_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kR, t, e)
    }
  },
  bBt = class SR extends h {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.isComposerVisible = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.KeepComposerCacheWarmRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: s3 },
        { no: 2, name: "request_id", kind: "scalar", T: 9 },
        { no: 3, name: "is_composer_visible", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new SR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SR, t, e)
    }
  },
  TBt = class ER extends h {
    constructor(t) {
      super(), (this.didKeepWarm = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.KeepComposerCacheWarmResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_keep_warm", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new ER().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ER().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ER().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ER, t, e)
    }
  },
  kBt = class IR extends h {
    constructor(t) {
      super(), (this.diffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDiffReviewRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diffs", kind: "message", T: SBt, repeated: !0 },
        { no: 2, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "use_premium_model", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new IR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IR, t, e)
    }
  },
  SBt = class PR extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDiffReviewRequest.SimpleFileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "chunks", kind: "message", T: EBt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new PR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PR, t, e)
    }
  },
  EBt = class $R extends h {
    constructor(t) {
      super(),
        (this.oldLines = []),
        (this.newLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDiffReviewRequest.SimpleFileDiff.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "old_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "old_range", kind: "message", T: Li },
        { no: 4, name: "new_range", kind: "message", T: Li },
      ])
    }
    static fromBinary(t, e) {
      return new $R().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $R().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $R().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($R, t, e)
    }
  },
  IBt = class xR extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamDiffReviewResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xR, t, e)
    }
  },
  PBt = class NR extends h {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.modelName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CountTokensRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: cat, repeated: !0 },
        { no: 2, name: "model_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new NR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NR, t, e)
    }
  },
  $Bt = class CR extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.count = 0),
        (this.lineCount = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItemTokenDetail"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "count", kind: "scalar", T: 5 },
        { no: 3, name: "line_count", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new CR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CR, t, e)
    }
  },
  xBt = class JR extends h {
    constructor(t) {
      super(),
        (this.count = 0),
        (this.tokenDetails = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CountTokensResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "count", kind: "scalar", T: 5 },
        { no: 2, name: "token_details", kind: "message", T: $Bt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new JR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JR, t, e)
    }
  },
  WXt = class LR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InlineGPT4PromptProtoV1"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
      ])
    }
    static fromBinary(t, e) {
      return new LR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LR, t, e)
    }
  },
  NBt = class RR extends h {
    constructor(t) {
      super(),
        (this.repositories = []),
        (this.contextBlocks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInlineLongCompletionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 6, name: "repositories", kind: "message", T: Mt, repeated: !0 },
        {
          no: 7,
          name: "context_blocks",
          kind: "message",
          T: CBt,
          repeated: !0,
        },
        { no: 13, name: "explicit_context", kind: "message", T: Oe },
        { no: 14, name: "model_details", kind: "message", T: St },
        { no: 15, name: "linter_errors", kind: "message", T: $i },
      ])
    }
    static fromBinary(t, e) {
      return new RR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RR, t, e)
    }
  },
  CBt = class DR extends h {
    constructor(t) {
      super(),
        (this.contextType = Pf.UNSPECIFIED),
        (this.blocks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamInlineLongCompletionRequest.ContextBlock"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_type", kind: "enum", T: n.getEnumType(Pf) },
        { no: 2, name: "blocks", kind: "message", T: Ne, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new DR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DR, t, e)
    }
  },
  Pf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.RECENT_LOCATIONS = 1)] = "RECENT_LOCATIONS")
})(Pf || (Pf = {})),
  n.util.setEnumType(
    Pf,
    "aiserver.v1.StreamInlineLongCompletionRequest.ContextBlock.ContextType",
    [
      { no: 0, name: "CONTEXT_TYPE_UNSPECIFIED" },
      { no: 1, name: "CONTEXT_TYPE_RECENT_LOCATIONS" },
    ],
  )
var JBt = class FR extends h {
    constructor(t) {
      super(),
        (this.mainSymbolsToAnalyzeFromGoToDef = []),
        (this.relatedSymbols = []),
        (this.mainSymbolsToAnalyzeFromImplementations = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiPreviewsIntent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "main_symbols_to_analyze_from_go_to_def",
          kind: "message",
          T: NM,
          repeated: !0,
        },
        { no: 4, name: "main_symbol_hover_details", kind: "message", T: gSt },
        {
          no: 3,
          name: "related_symbols",
          kind: "message",
          T: NM,
          repeated: !0,
        },
        {
          no: 6,
          name: "main_symbols_to_analyze_from_implementations",
          kind: "message",
          T: NM,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new FR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FR, t, e)
    }
  },
  LBt = class AR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiPreviewsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Yt },
        { no: 2, name: "intent", kind: "message", T: JBt },
        { no: 14, name: "model_details", kind: "message", T: St },
        { no: 15, name: "is_detailed", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new AR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AR, t, e)
    }
  },
  RBt = class _R extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiPreviewsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new _R().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _R().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _R().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_R, t, e)
    }
  },
  DBt = class OR extends h {
    constructor(t) {
      super(),
        (this.action = ""),
        (this.generationUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportInlineActionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "action", kind: "scalar", T: 9 },
        { no: 2, name: "generation_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new OR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OR, t, e)
    }
  },
  FBt = class BR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportInlineActionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new BR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BR, t, e)
    }
  },
  r3 = class qR extends h {
    constructor(t) {
      super(), (this.metrics = {}), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportMetricsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "metrics",
          kind: "map",
          K: 9,
          V: { kind: "message", T: ABt },
        },
      ])
    }
    static fromBinary(t, e) {
      return new qR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qR, t, e)
    }
  },
  ABt = class UR extends h {
    constructor(t) {
      super(), (this.tags = {}), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportMetricsRequest.Metric"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 1, opt: !0 },
        { no: 2, name: "tags", kind: "map", K: 9, V: { kind: "scalar", T: 9 } },
      ])
    }
    static fromBinary(t, e) {
      return new UR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UR, t, e)
    }
  },
  n3 = class MR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportMetricsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new MR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MR, t, e)
    }
  },
  _Bt = class HR extends h {
    constructor(t) {
      super(), (this.generateTheWholeThing = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Specedits1Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "generate_the_whole_thing", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new HR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HR, t, e)
    }
  },
  OBt = class WR extends h {
    constructor(t) {
      super(), (this.fullFile = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Specedits1Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "full_file", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new WR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WR, t, e)
    }
  },
  BBt = class jR extends h {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jR, t, e)
    }
  },
  qBt = class VR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new VR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VR, t, e)
    }
  },
  jXt = class GR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmptyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new GR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GR, t, e)
    }
  },
  UBt = class zR extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmptyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new zR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zR, t, e)
    }
  },
  MBt = class YR extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.fileSelections = []),
        (this.fileAttachments = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerPrompt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "file_selections",
          kind: "message",
          T: HBt,
          repeated: !0,
        },
        {
          no: 3,
          name: "file_attachments",
          kind: "message",
          T: WBt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new YR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YR, t, e)
    }
  },
  HBt = class QR extends h {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerPrompt.FileSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new QR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QR, t, e)
    }
  },
  WBt = class XR extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerPrompt.FileAttachment"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XR, t, e)
    }
  },
  jBt = class KR extends h {
    constructor(t) {
      super(), (this.chatModelName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "chat_model_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new KR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KR, t, e)
    }
  },
  VBt = class ZR extends h {
    constructor(t) {
      super(),
        (this.pathEncryptionKey = ""),
        (this.repositoryInfoShouldQueryStaging = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerRepositoryInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository_info", kind: "message", T: Mt },
        { no: 2, name: "path_encryption_key", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "repository_info_should_query_staging",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ZR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZR, t, e)
    }
  },
  GBt = class t4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHeadlessAgenticComposerRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt", kind: "message", T: MBt },
        { no: 2, name: "config", kind: "message", T: jBt },
        { no: 3, name: "repository_info", kind: "message", T: VBt },
      ])
    }
    static fromBinary(t, e) {
      return new t4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t4, t, e)
    }
  },
  zBt = class e4 extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHeadlessAgenticComposerResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "tool_call", kind: "message", T: Lnt, opt: !0 },
        { no: 3, name: "final_tool_result", kind: "message", T: YBt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new e4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e4, t, e)
    }
  },
  YBt = class i4 extends h {
    constructor(t) {
      super(), (this.toolCallId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamHeadlessAgenticComposerResponse.FinalToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 2, name: "result", kind: "message", T: WB },
      ])
    }
    static fromBinary(t, e) {
      return new i4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i4, t, e)
    }
  },
  Uat = {
    typeName: "aiserver.v1.AiService",
    methods: {
      healthCheck: { name: "HealthCheck", I: Nat, O: m6t, kind: I.Unary },
      privacyCheck: { name: "PrivacyCheck", I: f6t, O: p6t, kind: I.Unary },
      timeLeftHealthCheck: {
        name: "TimeLeftHealthCheck",
        I: Nat,
        O: g6t,
        kind: I.Unary,
      },
      throwErrorCheck: {
        name: "ThrowErrorCheck",
        I: c6t,
        O: l6t,
        kind: I.Unary,
      },
      availableModels: {
        name: "AvailableModels",
        I: u6t,
        O: h6t,
        kind: I.Unary,
      },
      streamChatTryReallyHard: {
        name: "StreamChatTryReallyHard",
        I: Ja,
        O: _s,
        kind: I.ServerStreaming,
      },
      rerankDocuments: {
        name: "RerankDocuments",
        I: QRt,
        O: XRt,
        kind: I.Unary,
      },
      streamComposer: {
        name: "StreamComposer",
        I: s3,
        O: _s,
        kind: I.ServerStreaming,
      },
      streamComposerContext: {
        name: "StreamComposerContext",
        I: $at,
        O: xat,
        kind: I.ServerStreaming,
      },
      warmComposerCache: {
        name: "WarmComposerCache",
        I: s3,
        O: AOt,
        kind: I.Unary,
      },
      keepComposerCacheWarm: {
        name: "KeepComposerCacheWarm",
        I: bBt,
        O: TBt,
        kind: I.Unary,
      },
      countTokens: { name: "CountTokens", I: PBt, O: xBt, kind: I.Unary },
      streamPotentialLocs: {
        name: "StreamPotentialLocs",
        I: lOt,
        O: uOt,
        kind: I.ServerStreaming,
      },
      streamPotentialLocsUnderneath: {
        name: "StreamPotentialLocsUnderneath",
        I: oOt,
        O: cOt,
        kind: I.ServerStreaming,
      },
      streamPotentialLocsInitialQueries: {
        name: "StreamPotentialLocsInitialQueries",
        I: nOt,
        O: aOt,
        kind: I.ServerStreaming,
      },
      streamNotepadChat: {
        name: "StreamNotepadChat",
        I: rOt,
        O: _s,
        kind: I.ServerStreaming,
      },
      getChatTitle: { name: "GetChatTitle", I: LOt, O: ROt, kind: I.Unary },
      getCompletion: { name: "GetCompletion", I: qOt, O: UOt, kind: I.Unary },
      getSearch: { name: "GetSearch", I: MOt, O: WOt, kind: I.Unary },
      streamInlineEdits: {
        name: "StreamInlineEdits",
        I: NOt,
        O: COt,
        kind: I.ServerStreaming,
      },
      summarizeConversation: {
        name: "SummarizeConversation",
        I: Ja,
        O: JOt,
        kind: I.Unary,
      },
      isolatedTreesitter: {
        name: "IsolatedTreesitter",
        I: TOt,
        O: kOt,
        kind: I.Unary,
      },
      getSimplePrompt: {
        name: "GetSimplePrompt",
        I: EOt,
        O: IOt,
        kind: I.Unary,
      },
      checkLongFilesFit: {
        name: "CheckLongFilesFit",
        I: Ja,
        O: POt,
        kind: I.Unary,
      },
      getEvaluationPrompt: {
        name: "GetEvaluationPrompt",
        I: $Ot,
        O: xOt,
        kind: I.Unary,
      },
      getUserInfo: { name: "GetUserInfo", I: VOt, O: zOt, kind: I.Unary },
      clearAndRedoEntireBucket: {
        name: "ClearAndRedoEntireBucket",
        I: YOt,
        O: QOt,
        kind: I.Unary,
      },
      streamBranchGemini: {
        name: "StreamBranchGemini",
        I: UAt,
        O: VAt,
        kind: I.ServerStreaming,
      },
      streamBranchFileSelections: {
        name: "StreamBranchFileSelections",
        I: OAt,
        O: BAt,
        kind: I.ServerStreaming,
      },
      streamBackgroundEdit: {
        name: "StreamBackgroundEdit",
        I: K6t,
        O: _s,
        kind: I.ServerStreaming,
      },
      streamGPTFourEdit: {
        name: "StreamGPTFourEdit",
        I: M6t,
        O: _s,
        kind: I.ServerStreaming,
      },
      streamChat: { name: "StreamChat", I: Ja, O: _s, kind: I.ServerStreaming },
      streamChatWeb: {
        name: "StreamChatWeb",
        I: Ja,
        O: _s,
        kind: I.ServerStreaming,
      },
      warmChatCache: { name: "WarmChatCache", I: _Ot, O: OOt, kind: I.Unary },
      streamEdit: {
        name: "StreamEdit",
        I: Lat,
        O: _s,
        kind: I.ServerStreaming,
      },
      preloadEdit: { name: "PreloadEdit", I: J6t, O: L6t, kind: I.Unary },
      streamFastEdit: {
        name: "StreamFastEdit",
        I: N6t,
        O: C6t,
        kind: I.ServerStreaming,
      },
      streamGenerate: {
        name: "StreamGenerate",
        I: v6t,
        O: _s,
        kind: I.ServerStreaming,
      },
      streamInlineLongCompletion: {
        name: "StreamInlineLongCompletion",
        I: NBt,
        O: _s,
        kind: I.ServerStreaming,
      },
      slashEdit: { name: "SlashEdit", I: S6t, O: E6t, kind: I.ServerStreaming },
      slashEditFollowUpWithPreviousEdits: {
        name: "SlashEditFollowUpWithPreviousEdits",
        I: I6t,
        O: P6t,
        kind: I.ServerStreaming,
      },
      streamAiPreviews: {
        name: "StreamAiPreviews",
        I: LBt,
        O: RBt,
        kind: I.ServerStreaming,
      },
      shouldTurnOnCppOnboarding: {
        name: "ShouldTurnOnCppOnboarding",
        I: RSt,
        O: DSt,
        kind: I.Unary,
      },
      streamReview: {
        name: "StreamReview",
        I: w6t,
        O: k6t,
        kind: I.ServerStreaming,
      },
      streamReviewChat: {
        name: "StreamReviewChat",
        I: y6t,
        O: b6t,
        kind: I.ServerStreaming,
      },
      checkQueuePosition: {
        name: "CheckQueuePosition",
        I: wOt,
        O: yOt,
        kind: I.Unary,
      },
      checkUsageBasedPrice: {
        name: "CheckUsageBasedPrice",
        I: gOt,
        O: vOt,
        kind: I.Unary,
      },
      doThisForMeCheck: {
        name: "DoThisForMeCheck",
        I: XOt,
        O: Aat,
        kind: I.Unary,
      },
      streamDoThisForMe: {
        name: "StreamDoThisForMe",
        I: i8t,
        O: n8t,
        kind: I.ServerStreaming,
      },
      streamChatToolformer: {
        name: "StreamChatToolformer",
        I: Ja,
        O: _at,
        kind: I.ServerStreaming,
      },
      streamChatToolformerContinue: {
        name: "StreamChatToolformerContinue",
        I: a8t,
        O: _at,
        kind: I.ServerStreaming,
      },
      pushAiThought: { name: "PushAiThought", I: d8t, O: p8t, kind: I.Unary },
      checkDoableAsTask: {
        name: "CheckDoableAsTask",
        I: g8t,
        O: v8t,
        kind: I.Unary,
      },
      reportGroundTruthCandidate: {
        name: "ReportGroundTruthCandidate",
        I: lBt,
        O: uBt,
        kind: I.Unary,
      },
      reportCmdKFate: { name: "ReportCmdKFate", I: hBt, O: dBt, kind: I.Unary },
      showWelcomeScreen: {
        name: "ShowWelcomeScreen",
        I: n_t,
        O: a_t,
        kind: I.Unary,
      },
      interfaceAgentInit: {
        name: "InterfaceAgentInit",
        I: w8t,
        O: y8t,
        kind: I.Unary,
      },
      streamInterfaceAgentStatus: {
        name: "StreamInterfaceAgentStatus",
        I: b8t,
        O: T8t,
        kind: I.ServerStreaming,
      },
      taskGetInterfaceAgentStatus: {
        name: "TaskGetInterfaceAgentStatus",
        I: k8t,
        O: E8t,
        kind: I.ServerStreaming,
      },
      taskInit: { name: "TaskInit", I: I8t, O: P8t, kind: I.Unary },
      taskPause: { name: "TaskPause", I: D8t, O: F8t, kind: I.Unary },
      taskInfo: { name: "TaskInfo", I: R8t, O: qat, kind: I.Unary },
      taskStreamLog: {
        name: "TaskStreamLog",
        I: $8t,
        O: A8t,
        kind: I.ServerStreaming,
      },
      taskSendMessage: {
        name: "TaskSendMessage",
        I: q8t,
        O: U8t,
        kind: I.Unary,
      },
      taskProvideResult: {
        name: "TaskProvideResult",
        I: O8t,
        O: B8t,
        kind: I.Unary,
      },
      createExperimentalIndex: {
        name: "CreateExperimentalIndex",
        I: b9t,
        O: T9t,
        kind: I.Unary,
      },
      listExperimentalIndexFiles: {
        name: "ListExperimentalIndexFiles",
        I: k9t,
        O: S9t,
        kind: I.Unary,
      },
      listenExperimentalIndex: {
        name: "ListenExperimentalIndex",
        I: bnt,
        O: E9t,
        kind: I.ServerStreaming,
      },
      registerFileToIndex: {
        name: "RegisterFileToIndex",
        I: $W,
        O: CW,
        kind: I.Unary,
      },
      setupIndexDependencies: {
        name: "SetupIndexDependencies",
        I: J9t,
        O: L9t,
        kind: I.Unary,
      },
      computeIndexTopoSort: {
        name: "ComputeIndexTopoSort",
        I: R9t,
        O: D9t,
        kind: I.Unary,
      },
      streamChatDeepContext: {
        name: "StreamChatDeepContext",
        I: s6t,
        O: r6t,
        kind: I.ServerStreaming,
      },
      chooseCodeReferences: {
        name: "ChooseCodeReferences",
        I: xW,
        O: CW,
        kind: I.Unary,
      },
      registerCodeReferences: {
        name: "RegisterCodeReferences",
        I: B9t,
        O: q9t,
        kind: I.Unary,
      },
      extractPaths: { name: "ExtractPaths", I: G9t, O: z9t, kind: I.Unary },
      summarizeWithReferences: {
        name: "SummarizeWithReferences",
        I: NW,
        O: CW,
        kind: I.Unary,
      },
      documentationQuery: {
        name: "DocumentationQuery",
        I: ERt,
        O: IRt,
        kind: I.Unary,
      },
      availableDocs: { name: "AvailableDocs", I: a6t, O: o6t, kind: I.Unary },
      reportFeedback: { name: "ReportFeedback", I: M8t, O: H8t, kind: I.Unary },
      reportBug: { name: "ReportBug", I: V8t, O: G8t, kind: I.Unary },
      streamChatContext: {
        name: "StreamChatContext",
        I: $at,
        O: xat,
        kind: I.ServerStreaming,
      },
      generateTldr: { name: "GenerateTldr", I: q_t, O: U_t, kind: I.Unary },
      taskStreamChatContext: {
        name: "TaskStreamChatContext",
        I: M_t,
        O: K_t,
        kind: I.ServerStreaming,
      },
      rerankResults: { name: "RerankResults", I: O_t, O: B_t, kind: I.Unary },
      modelQuery: { name: "ModelQuery", I: Pat, O: R_t, kind: I.Unary },
      modelQueryV2: {
        name: "ModelQueryV2",
        I: Pat,
        O: F_t,
        kind: I.ServerStreaming,
      },
      intentPrediction: {
        name: "IntentPrediction",
        I: y_t,
        O: b_t,
        kind: I.Unary,
      },
      streamCursorTutor: {
        name: "StreamCursorTutor",
        I: J_t,
        O: L_t,
        kind: I.ServerStreaming,
      },
      checkFeatureStatus: {
        name: "CheckFeatureStatus",
        I: m_t,
        O: g_t,
        kind: I.Unary,
      },
      getEffectiveTokenLimit: {
        name: "GetEffectiveTokenLimit",
        I: f_t,
        O: p_t,
        kind: I.Unary,
      },
      getContextScores: {
        name: "GetContextScores",
        I: e_t,
        O: i_t,
        kind: I.Unary,
      },
      streamCpp: { name: "StreamCpp", I: AM, O: FSt, kind: I.ServerStreaming },
      cppConfig: { name: "CppConfig", I: OSt, O: BSt, kind: I.Unary },
      cppEditHistoryStatus: {
        name: "CppEditHistoryStatus",
        I: CIt,
        O: JIt,
        kind: I.Unary,
      },
      cppAppend: { name: "CppAppend", I: PIt, O: $It, kind: I.Unary },
      checkNumberConfig: {
        name: "CheckNumberConfig",
        I: v_t,
        O: w_t,
        kind: I.Unary,
      },
      streamTerminalAutocomplete: {
        name: "StreamTerminalAutocomplete",
        I: V6t,
        O: X6t,
        kind: I.ServerStreaming,
      },
      streamPseudocodeGenerator: {
        name: "StreamPseudocodeGenerator",
        I: G6t,
        O: z6t,
        kind: I.ServerStreaming,
      },
      streamPseudocodeMapper: {
        name: "StreamPseudocodeMapper",
        I: Y6t,
        O: Q6t,
        kind: I.ServerStreaming,
      },
      streamAiLintBug: {
        name: "StreamAiLintBug",
        I: R6t,
        O: A6t,
        kind: I.ServerStreaming,
      },
      streamAiCursorHelp: {
        name: "StreamAiCursorHelp",
        I: W6t,
        O: j6t,
        kind: I.ServerStreaming,
      },
      logUserLintReply: {
        name: "LogUserLintReply",
        I: _6t,
        O: O6t,
        kind: I.Unary,
      },
      logLinterExplicitUserFeedback: {
        name: "LogLinterExplicitUserFeedback",
        I: B6t,
        O: q6t,
        kind: I.Unary,
      },
      streamFixMarkers: {
        name: "StreamFixMarkers",
        I: z8t,
        O: aBt,
        kind: I.ServerStreaming,
      },
      reportInlineAction: {
        name: "ReportInlineAction",
        I: DBt,
        O: FBt,
        kind: I.Unary,
      },
      streamPriomptPrompt: {
        name: "StreamPriomptPrompt",
        I: h_t,
        O: d_t,
        kind: I.ServerStreaming,
      },
      streamLint: {
        name: "StreamLint",
        I: cBt,
        O: _s,
        kind: I.ServerStreaming,
      },
      streamNewLintRule: {
        name: "StreamNewLintRule",
        I: U6t,
        O: _s,
        kind: I.ServerStreaming,
      },
      aiProject: { name: "AiProject", I: o_t, O: c_t, kind: I.ServerStreaming },
      toCamelCase: { name: "ToCamelCase", I: l_t, O: u_t, kind: I.Unary },
      reportGenerationFeedback: {
        name: "ReportGenerationFeedback",
        I: s_t,
        O: r_t,
        kind: I.Unary,
      },
      getThoughtAnnotation: {
        name: "GetThoughtAnnotation",
        I: xAt,
        O: NAt,
        kind: I.Unary,
      },
      streamWebCmdKV1: {
        name: "StreamWebCmdKV1",
        I: ZAt,
        O: t_t,
        kind: I.ServerStreaming,
      },
      streamNextCursorPrediction: {
        name: "StreamNextCursorPrediction",
        I: YAt,
        O: KAt,
        kind: I.ServerStreaming,
      },
      isCursorPredictionEnabled: {
        name: "IsCursorPredictionEnabled",
        I: GAt,
        O: zAt,
        kind: I.Unary,
      },
      getCppEditClassification: {
        name: "GetCppEditClassification",
        I: WSt,
        O: jSt,
        kind: I.Unary,
      },
      getTerminalCompletion: {
        name: "GetTerminalCompletion",
        I: rAt,
        O: nAt,
        kind: I.Unary,
      },
      takeNotesOnCommitDiff: {
        name: "TakeNotesOnCommitDiff",
        I: DAt,
        O: FAt,
        kind: I.Unary,
      },
      bulkEmbed: { name: "BulkEmbed", I: JAt, O: LAt, kind: I.Unary },
      continueChatRequestWithCommits: {
        name: "ContinueChatRequestWithCommits",
        I: AAt,
        O: UBt,
        kind: I.Unary,
      },
      backgroundCmdKEval: {
        name: "BackgroundCmdKEval",
        I: kAt,
        O: $At,
        kind: I.ServerStreaming,
      },
      backgroundCmdK: {
        name: "BackgroundCmdK",
        I: mAt,
        O: TAt,
        kind: I.ServerStreaming,
      },
      streamCursorMotion: {
        name: "StreamCursorMotion",
        I: hAt,
        O: dAt,
        kind: I.ServerStreaming,
      },
      calculateAutoSelection: {
        name: "CalculateAutoSelection",
        I: oAt,
        O: uAt,
        kind: I.Unary,
      },
      getAtSymbolSuggestions: {
        name: "GetAtSymbolSuggestions",
        I: eAt,
        O: iAt,
        kind: I.Unary,
      },
      getCodebaseQuestions: {
        name: "GetCodebaseQuestions",
        I: Ja,
        O: KFt,
        kind: I.Unary,
      },
      getRankedContextFromContextBank: {
        name: "GetRankedContextFromContextBank",
        I: QFt,
        O: XFt,
        kind: I.ServerStreaming,
      },
      cppEditHistoryAppend: {
        name: "CppEditHistoryAppend",
        I: xIt,
        O: NIt,
        kind: I.Unary,
      },
      devOnlyGetPastRequestIds: {
        name: "DevOnlyGetPastRequestIds",
        I: GFt,
        O: YFt,
        kind: I.Unary,
      },
      getFilesForComposer: {
        name: "GetFilesForComposer",
        I: mBt,
        O: fBt,
        kind: I.Unary,
      },
      tryParseTypeScriptTreeSitter: {
        name: "TryParseTypeScriptTreeSitter",
        I: jFt,
        O: VFt,
        kind: I.Unary,
      },
      nameTab: { name: "NameTab", I: UFt, O: MFt, kind: I.Unary },
      isTerminalFinished: {
        name: "IsTerminalFinished",
        I: Sat,
        O: SFt,
        kind: I.Unary,
      },
      isTerminalFinishedV2: {
        name: "IsTerminalFinishedV2",
        I: Sat,
        O: EFt,
        kind: I.Unary,
      },
      testModelStatus: {
        name: "TestModelStatus",
        I: HFt,
        O: WFt,
        kind: I.Unary,
      },
      findBugs: { name: "FindBugs", I: pBt, O: gBt, kind: I.Unary },
      contextReranking: {
        name: "ContextReranking",
        I: BFt,
        O: qFt,
        kind: I.Unary,
      },
      autoContext: { name: "AutoContext", I: xFt, O: CFt, kind: I.Unary },
      writeGitCommitMessage: {
        name: "WriteGitCommitMessage",
        I: wBt,
        O: yBt,
        kind: I.Unary,
      },
      streamBugBot: {
        name: "StreamBugBot",
        I: FM,
        O: OFt,
        kind: I.ServerStreaming,
      },
      checkBugBotPrice: {
        name: "CheckBugBotPrice",
        I: JFt,
        O: LFt,
        kind: I.Unary,
      },
      checkBugBotTelemetryHealthy: {
        name: "CheckBugBotTelemetryHealthy",
        I: RFt,
        O: DFt,
        kind: I.Unary,
      },
      getSuggestedBugBotIterations: {
        name: "GetSuggestedBugBotIterations",
        I: FFt,
        O: AFt,
        kind: I.Unary,
      },
      testBidi: { name: "TestBidi", I: IFt, O: PFt, kind: I.BiDiStreaming },
      streamDiffReview: {
        name: "StreamDiffReview",
        I: kBt,
        O: IBt,
        kind: I.ServerStreaming,
      },
    },
  },
  Mat = class s4 extends h {
    constructor(t) {
      super(), (this.id = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.User"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "email", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "email_verified", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "first_name", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "last_name", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "created_at", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "updated_at", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new s4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s4, t, e)
    }
  },
  QBt = class r4 extends h {
    constructor(t) {
      super(), (this.destination = $f.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSessionTokenRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user", kind: "message", T: Mat },
        { no: 2, name: "destination", kind: "enum", T: n.getEnumType($f) },
        { no: 3, name: "stub", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "code", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new r4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r4, t, e)
    }
  },
  $f
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.PORTAL = 1)] = "PORTAL"),
    (i[(i.AISERVER = 2)] = "AISERVER"),
    (i[(i.AUTH_PROXY = 3)] = "AUTH_PROXY")
})($f || ($f = {})),
  n.util.setEnumType($f, "aiserver.v1.GetSessionTokenRequest.Destination", [
    { no: 0, name: "DESTINATION_UNSPECIFIED" },
    { no: 1, name: "DESTINATION_PORTAL" },
    { no: 2, name: "DESTINATION_AISERVER" },
    { no: 3, name: "DESTINATION_AUTH_PROXY" },
  ])
var XBt = class n4 extends h {
    constructor(t) {
      super(), (this.sessionToken = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSessionTokenResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_token", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new n4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n4, t, e)
    }
  },
  KBt = class a4 extends h {
    constructor(t) {
      super(), (this.sessionToken = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckSessionTokenRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_token", kind: "scalar", T: 9 },
        { no: 2, name: "user", kind: "message", T: Mat },
      ])
    }
    static fromBinary(t, e) {
      return new a4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a4, t, e)
    }
  },
  ZBt = class o4 extends h {
    constructor(t) {
      super(), (this.valid = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckSessionTokenResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "valid", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new o4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o4, t, e)
    }
  },
  t3t = class c4 extends h {
    constructor(t) {
      super(), (this.email = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomerIdRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "email", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new c4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c4, t, e)
    }
  },
  e3t = class l4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomerIdResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "customer_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new l4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l4, t, e)
    }
  },
  i3t = class u4 extends h {
    constructor(t) {
      super(),
        (this.isUsingCurrentAndOnboardingFormat = !1),
        (this.privacy = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkPrivacyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "current_privacy_mode", kind: "scalar", T: 8, opt: !0 },
        {
          no: 3,
          name: "onboarding_privacy_mode",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 4,
          name: "is_using_current_and_onboarding_format",
          kind: "scalar",
          T: 8,
        },
        { no: 1, name: "privacy", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new u4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u4, t, e)
    }
  },
  s3t = class h4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkPrivacyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new h4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h4, t, e)
    }
  },
  r3t = class d4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmailRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new d4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d4, t, e)
    }
  },
  n3t = class m4 extends h {
    constructor(t) {
      super(),
        (this.email = ""),
        (this.signUpType = xf.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmailResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "email", kind: "scalar", T: 9 },
        { no: 2, name: "sign_up_type", kind: "enum", T: n.getEnumType(xf) },
      ])
    }
    static fromBinary(t, e) {
      return new m4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m4, t, e)
    }
  },
  xf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.AUTH_0 = 1)] = "AUTH_0"),
    (i[(i.GITHUB = 2)] = "GITHUB"),
    (i[(i.GOOGLE = 3)] = "GOOGLE"),
    (i[(i.WORKOS = 4)] = "WORKOS")
})(xf || (xf = {})),
  n.util.setEnumType(xf, "aiserver.v1.GetEmailResponse.SignUpType", [
    { no: 0, name: "SIGN_UP_TYPE_UNSPECIFIED" },
    { no: 1, name: "SIGN_UP_TYPE_AUTH_0" },
    { no: 2, name: "SIGN_UP_TYPE_GITHUB" },
    { no: 3, name: "SIGN_UP_TYPE_GOOGLE" },
    { no: 4, name: "SIGN_UP_TYPE_WORKOS" },
  ])
var a3t = class f4 extends h {
    constructor(t) {
      super(), (this.email = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmailValidRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "email", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new f4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f4, t, e)
    }
  },
  o3t = class p4 extends h {
    constructor(t) {
      super(), (this.valid = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmailValidResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "valid", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new p4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p4, t, e)
    }
  },
  c3t = class g4 extends h {
    constructor(t) {
      super(),
        (this.machineId = ""),
        (this.applicationName = ""),
        (this.version = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DownloadUpdateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "machine_id", kind: "scalar", T: 9 },
        { no: 2, name: "application_name", kind: "scalar", T: 9 },
        { no: 3, name: "version", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new g4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g4, t, e)
    }
  },
  l3t = class v4 extends h {
    constructor(t) {
      super(), (this.canDownload = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DownloadUpdateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "can_download", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new v4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v4, t, e)
    }
  },
  u3t = class w4 extends h {
    constructor(t) {
      super(), (this.useTurbo = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SwitchCmdKFractionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "use_turbo", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new w4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w4, t, e)
    }
  },
  h3t = class y4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SwitchCmdKFractionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new y4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y4, t, e)
    }
  },
  Hat = {
    typeName: "aiserver.v1.AuthService",
    methods: {
      getEmail: { name: "GetEmail", I: r3t, O: n3t, kind: I.Unary },
      emailValid: { name: "EmailValid", I: a3t, O: o3t, kind: I.Unary },
      downloadUpdate: { name: "DownloadUpdate", I: c3t, O: l3t, kind: I.Unary },
      markPrivacy: { name: "MarkPrivacy", I: i3t, O: s3t, kind: I.Unary },
      switchCmdKFraction: {
        name: "SwitchCmdKFraction",
        I: u3t,
        O: h3t,
        kind: I.Unary,
      },
      getCustomerId: { name: "GetCustomerId", I: t3t, O: e3t, kind: I.Unary },
      getSessionToken: {
        name: "GetSessionToken",
        I: QBt,
        O: XBt,
        kind: I.Unary,
      },
      checkSessionToken: {
        name: "CheckSessionToken",
        I: KBt,
        O: ZBt,
        kind: I.Unary,
      },
    },
  },
  Wat = {
    typeName: "aiserver.v1.CmdKService",
    methods: {
      streamCmdK: {
        name: "StreamCmdK",
        I: IDt,
        O: gat,
        kind: I.ServerStreaming,
      },
      streamHypermode: {
        name: "StreamHypermode",
        I: EDt,
        O: gat,
        kind: I.ServerStreaming,
      },
      rerankCmdKContext: {
        name: "RerankCmdKContext",
        I: bDt,
        O: TDt,
        kind: I.Unary,
      },
      streamTerminalCmdK: {
        name: "StreamTerminalCmdK",
        I: xDt,
        O: NDt,
        kind: I.ServerStreaming,
      },
      rerankTerminalCmdKContext: {
        name: "RerankTerminalCmdKContext",
        I: kDt,
        O: SDt,
        kind: I.Unary,
      },
      getRelevantChunks: {
        name: "GetRelevantChunks",
        I: BDt,
        O: qDt,
        kind: I.ServerStreaming,
      },
    },
  },
  jat = {
    typeName: "aiserver.v1.CppService",
    methods: {
      markCppForEval: { name: "MarkCppForEval", I: tEt, O: iEt, kind: I.Unary },
      streamHoldCpp: {
        name: "StreamHoldCpp",
        I: KSt,
        O: ZSt,
        kind: I.ServerStreaming,
      },
      availableModels: {
        name: "AvailableModels",
        I: QSt,
        O: XSt,
        kind: I.Unary,
      },
      recordCppFate: { name: "RecordCppFate", I: zSt, O: YSt, kind: I.Unary },
    },
  },
  vr
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.OWNER = 1)] = "OWNER"),
    (i[(i.MEMBER = 2)] = "MEMBER"),
    (i[(i.FREE_OWNER = 3)] = "FREE_OWNER")
})(vr || (vr = {})),
  n.util.setEnumType(vr, "aiserver.v1.TeamRole", [
    { no: 0, name: "TEAM_ROLE_UNSPECIFIED" },
    { no: 1, name: "TEAM_ROLE_OWNER" },
    { no: 2, name: "TEAM_ROLE_MEMBER" },
    { no: 3, name: "TEAM_ROLE_FREE_OWNER" },
  ])
var d3t = class b4 extends h {
    constructor(t) {
      super(), (this.requestQuota = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateFastRequestsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_quota", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new b4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b4, t, e)
    }
  },
  m3t = class T4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateFastRequestsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new T4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T4, t, e)
    }
  },
  f3t = class k4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetFastRequestsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new k4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k4, t, e)
    }
  },
  p3t = class S4 extends h {
    constructor(t) {
      super(), (this.requestQuota = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetFastRequestsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_quota", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new S4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S4, t, e)
    }
  },
  g3t = class E4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteAccountRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new E4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E4, t, e)
    }
  },
  v3t = class I4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteAccountResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new I4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I4, t, e)
    }
  },
  w3t = class P4 extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.privacyModeForced = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SwitchTeamPrivacyModeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "privacy_mode_forced", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new P4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P4, t, e)
    }
  },
  y3t = class $4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SwitchTeamPrivacyModeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new $4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($4, t, e)
    }
  },
  b3t = class x4 extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamPrivacyModeForcedRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new x4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x4, t, e)
    }
  },
  T3t = class N4 extends h {
    constructor(t) {
      super(), (this.privacyModeForced = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamPrivacyModeForcedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "privacy_mode_forced", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new N4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N4, t, e)
    }
  },
  k3t = class C4 extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamHasValidPaymentMethodRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new C4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C4, t, e)
    }
  },
  S3t = class J4 extends h {
    constructor(t) {
      super(),
        (this.hasValidPaymentMethod = !1),
        (this.trialDaysRemaining = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamHasValidPaymentMethodResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "has_valid_payment_method", kind: "scalar", T: 8 },
        { no: 2, name: "trial_days_remaining", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new J4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J4, t, e)
    }
  },
  E3t = class L4 extends h {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamWithFreeTrialRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "privacy_mode_forced", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new L4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L4, t, e)
    }
  },
  I3t = class R4 extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamWithFreeTrialResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new R4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R4, t, e)
    }
  },
  P3t = class D4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetPricingHistoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new D4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D4, t, e)
    }
  },
  $3t = class F4 extends h {
    constructor(t) {
      super(), (this.pricingHistory = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetPricingHistoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "pricing_history",
          kind: "message",
          T: x3t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new F4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F4, t, e)
    }
  },
  x3t = class A4 extends h {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.id = ""),
        (this.changelog = ""),
        (this.createdAt = _e.zero),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetPricingHistoryResponse.PricingDescription"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "changelog", kind: "scalar", T: 9 },
        { no: 4, name: "created_at", kind: "scalar", T: 3 },
      ])
    }
    static fromBinary(t, e) {
      return new A4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A4, t, e)
    }
  },
  N3t = class _4 extends h {
    constructor(t) {
      super(), (this.month = 0), (this.year = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetMonthlyInvoiceRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "month", kind: "scalar", T: 5 },
        { no: 3, name: "year", kind: "scalar", T: 5 },
        { no: 4, name: "include_usage_events", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_4, t, e)
    }
  },
  C3t = class O4 extends h {
    constructor(t) {
      super(),
        (this.items = []),
        (this.usageEvents = []),
        (this.isUsageEventsMaybeCutoff = !1),
        (this.hasUnpaidMidMonthInvoice = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetMonthlyInvoiceResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "items", kind: "message", T: J3t, repeated: !0 },
        { no: 2, name: "pricing_description", kind: "message", T: L3t },
        { no: 3, name: "usage_events", kind: "message", T: kFt, repeated: !0 },
        { no: 4, name: "is_usage_events_maybe_cutoff", kind: "scalar", T: 8 },
        { no: 5, name: "has_unpaid_mid_month_invoice", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new O4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O4, t, e)
    }
  },
  J3t = class B4 extends h {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.cents = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetMonthlyInvoiceResponse.InvoiceItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "cents", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new B4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B4, t, e)
    }
  },
  L3t = class q4 extends h {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.id = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetMonthlyInvoiceResponse.PricingDescription"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new q4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q4, t, e)
    }
  },
  R3t = class U4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHardLimitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new U4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U4, t, e)
    }
  },
  D3t = class M4 extends h {
    constructor(t) {
      super(),
        (this.hardLimit = 0),
        (this.noUsageBasedAllowed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHardLimitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "hard_limit", kind: "scalar", T: 5 },
        { no: 2, name: "no_usage_based_allowed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new M4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M4, t, e)
    }
  },
  F3t = class H4 extends h {
    constructor(t) {
      super(),
        (this.hardLimit = 0),
        (this.noUsageBasedAllowed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetHardLimitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "hard_limit", kind: "scalar", T: 5 },
        { no: 3, name: "no_usage_based_allowed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new H4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H4, t, e)
    }
  },
  A3t = class W4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetHardLimitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new W4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W4, t, e)
    }
  },
  _3t = class j4 extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.id = 0),
        (this.role = vr.UNSPECIFIED),
        (this.seats = 0),
        (this.hasBilling = !1),
        (this.requestQuotaPerSeat = 0),
        (this.privacyModeForced = !1),
        (this.allowSso = !1),
        (this.adminOnlyUsagePricing = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Team"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 5 },
        { no: 3, name: "role", kind: "enum", T: n.getEnumType(vr) },
        { no: 4, name: "seats", kind: "scalar", T: 5 },
        { no: 5, name: "has_billing", kind: "scalar", T: 8 },
        { no: 6, name: "request_quota_per_seat", kind: "scalar", T: 5 },
        { no: 7, name: "privacy_mode_forced", kind: "scalar", T: 8 },
        { no: 8, name: "allow_sso", kind: "scalar", T: 8 },
        { no: 9, name: "admin_only_usage_pricing", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new j4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j4, t, e)
    }
  },
  O3t = class V4 extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new V4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V4, t, e)
    }
  },
  B3t = class G4 extends h {
    constructor(t) {
      super(), (this.teams = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "teams", kind: "message", T: _3t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new G4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G4, t, e)
    }
  },
  q3t = class z4 extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.seats = 0),
        (this.yearly = !1),
        (this.requestQuotaPerSeat = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetActivationCheckoutUrlRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "seats", kind: "scalar", T: 5 },
        { no: 3, name: "yearly", kind: "scalar", T: 8 },
        { no: 4, name: "request_quota_per_seat", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new z4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z4, t, e)
    }
  },
  U3t = class Y4 extends h {
    constructor(t) {
      super(), (this.checkoutUrl = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetActivationCheckoutUrlResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "checkout_url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Y4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y4, t, e)
    }
  },
  M3t = class Q4 extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamCustomerPortalUrlRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Q4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q4, t, e)
    }
  },
  H3t = class X4 extends h {
    constructor(t) {
      super(), (this.portalUrl = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamCustomerPortalUrlResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "portal_url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new X4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X4, t, e)
    }
  },
  W3t = class K4 extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamMembersRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new K4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K4, t, e)
    }
  },
  j3t = class Z4 extends h {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.email = ""),
        (this.id = 0),
        (this.role = vr.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TeamMember"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 4, name: "email", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 5 },
        { no: 3, name: "role", kind: "enum", T: n.getEnumType(vr) },
      ])
    }
    static fromBinary(t, e) {
      return new Z4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z4, t, e)
    }
  },
  V3t = class tD extends h {
    constructor(t) {
      super(),
        (this.teamMembers = []),
        (this.userId = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamMembersResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_members", kind: "message", T: j3t, repeated: !0 },
        { no: 2, name: "user_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new tD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tD, t, e)
    }
  },
  G3t = class eD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamInviteLinkRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new eD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eD, t, e)
    }
  },
  z3t = class iD extends h {
    constructor(t) {
      super(), (this.inviteLink = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamInviteLinkResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "invite_link", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iD, t, e)
    }
  },
  Y3t = class sD extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.email = ""),
        (this.role = vr.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SendTeamInviteRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "email", kind: "scalar", T: 9 },
        { no: 3, name: "role", kind: "enum", T: n.getEnumType(vr) },
      ])
    }
    static fromBinary(t, e) {
      return new sD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sD, t, e)
    }
  },
  Q3t = class rD extends h {
    constructor(t) {
      super(), (this.validUntil = _e.zero), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SendTeamInviteResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "valid_until", kind: "scalar", T: 3 },
      ])
    }
    static fromBinary(t, e) {
      return new rD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rD, t, e)
    }
  },
  X3t = class nD extends h {
    constructor(t) {
      super(), (this.inviteCode = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AcceptInviteRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "invite_code", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nD, t, e)
    }
  },
  K3t = class aD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AcceptInviteResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new aD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aD, t, e)
    }
  },
  Z3t = class oD extends h {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "privacy_mode_forced", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new oD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oD, t, e)
    }
  },
  t7t = class cD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new cD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cD, t, e)
    }
  },
  e7t = class lD extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.userId = 0),
        (this.role = vr.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateRoleRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "user_id", kind: "scalar", T: 5 },
        { no: 3, name: "role", kind: "enum", T: n.getEnumType(vr) },
      ])
    }
    static fromBinary(t, e) {
      return new lD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lD, t, e)
    }
  },
  i7t = class uD extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateRoleResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new uD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uD, t, e)
    }
  },
  s7t = class hD extends h {
    constructor(t) {
      super(), (this.teamId = 0), (this.userId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveMemberRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "user_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new hD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hD, t, e)
    }
  },
  r7t = class dD extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveMemberResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new dD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dD, t, e)
    }
  },
  n7t = class mD extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.newSeats = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChangeSeatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "new_seats", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new mD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mD, t, e)
    }
  },
  a7t = class fD extends h {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChangeSeatResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new fD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fD, t, e)
    }
  },
  o7t = class pD extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.newNumSeats = 0),
        (this.newRequestQuotaPerSeat = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChangeTeamSubscriptionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "new_num_seats", kind: "scalar", T: 5 },
        { no: 3, name: "new_request_quota_per_seat", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new pD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pD, t, e)
    }
  },
  c7t = class gD extends h {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChangeTeamSubscriptionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new gD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gD, t, e)
    }
  },
  l7t = class vD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamUsageRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new vD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vD, t, e)
    }
  },
  u7t = class wD extends h {
    constructor(t) {
      super(), (this.teamMemberUsage = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamUsageResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "team_member_usage",
          kind: "message",
          T: h7t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new wD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wD, t, e)
    }
  },
  h7t = class yD extends h {
    constructor(t) {
      super(), (this.id = 0), (this.usageData = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TeamMemberUsage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        { no: 2, name: "usage_data", kind: "message", T: d7t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yD, t, e)
    }
  },
  d7t = class bD extends h {
    constructor(t) {
      super(),
        (this.modelType = ""),
        (this.numRequests = 0),
        (this.numTokens = 0),
        (this.maxTokenUsage = 0),
        (this.maxRequestUsage = 0),
        (this.lastUsage = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TeamMemberUsageData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_type", kind: "scalar", T: 9 },
        { no: 2, name: "num_requests", kind: "scalar", T: 5 },
        { no: 3, name: "num_tokens", kind: "scalar", T: 5 },
        { no: 4, name: "max_token_usage", kind: "scalar", T: 5 },
        { no: 5, name: "max_request_usage", kind: "scalar", T: 5 },
        { no: 6, name: "last_usage", kind: "scalar", T: 9 },
        { no: 7, name: "copilot_usage", kind: "scalar", T: 5, opt: !0 },
        { no: 8, name: "docs_count", kind: "scalar", T: 5, opt: !0 },
        {
          no: 9,
          name: "copilot_accepted_usage",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new bD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bD, t, e)
    }
  },
  m7t = class TD extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSignUpTypeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new TD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TD, t, e)
    }
  },
  f7t = class kD extends h {
    constructor(t) {
      super(), (this.signUpType = Nf.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSignUpTypeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "sign_up_type", kind: "enum", T: n.getEnumType(Nf) },
      ])
    }
    static fromBinary(t, e) {
      return new kD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kD, t, e)
    }
  },
  Nf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.AUTH_0 = 1)] = "AUTH_0"),
    (i[(i.GOOGLE = 2)] = "GOOGLE"),
    (i[(i.GITHUB = 3)] = "GITHUB"),
    (i[(i.WORKOS = 4)] = "WORKOS")
})(Nf || (Nf = {})),
  n.util.setEnumType(Nf, "aiserver.v1.GetSignUpTypeResponse.SignUpType", [
    { no: 0, name: "SIGN_UP_TYPE_UNSPECIFIED" },
    { no: 1, name: "SIGN_UP_TYPE_AUTH_0" },
    { no: 2, name: "SIGN_UP_TYPE_GOOGLE" },
    { no: 3, name: "SIGN_UP_TYPE_GITHUB" },
    { no: 4, name: "SIGN_UP_TYPE_WORKOS" },
  ])
var p7t = class SD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDailyTeamUsageRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new SD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SD, t, e)
    }
  },
  g7t = class ED extends h {
    constructor(t) {
      super(), (this.dailyTeamMemberUsage = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDailyTeamUsageResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "daily_team_member_usage",
          kind: "message",
          T: v7t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ED().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ED().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ED().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ED, t, e)
    }
  },
  v7t = class ID extends h {
    constructor(t) {
      super(),
        (this.id = 0),
        (this.dailyUsageData = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DailyTeamMemberUsage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        {
          no: 2,
          name: "daily_usage_data",
          kind: "message",
          T: w7t,
          repeated: !0,
        },
        { no: 3, name: "last_usage", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ID().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ID().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ID().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ID, t, e)
    }
  },
  w7t = class PD extends h {
    constructor(t) {
      super(),
        (this.date = ""),
        (this.modelUsageData = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DailyUsageData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "date", kind: "scalar", T: 9 },
        { no: 4, name: "copilot_usage", kind: "scalar", T: 5, opt: !0 },
        {
          no: 2,
          name: "model_usage_data",
          kind: "message",
          T: y7t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new PD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PD, t, e)
    }
  },
  y7t = class $D extends h {
    constructor(t) {
      super(),
        (this.modelType = ""),
        (this.numRequests = 0),
        (this.numTokens = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelUsageData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_type", kind: "scalar", T: 9 },
        { no: 2, name: "num_requests", kind: "scalar", T: 5 },
        { no: 3, name: "num_tokens", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new $D().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $D().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $D().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($D, t, e)
    }
  },
  b7t = class xD extends h {
    constructor(t) {
      super(), (this.platform = Cf.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDownloadLinkRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "platform", kind: "enum", T: n.getEnumType(Cf) },
      ])
    }
    static fromBinary(t, e) {
      return new xD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xD, t, e)
    }
  },
  Cf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.MAC_APPLE_SILICON = 1)] = "MAC_APPLE_SILICON"),
    (i[(i.MAC_INTEL = 2)] = "MAC_INTEL"),
    (i[(i.MAC_UNIVERSAL = 3)] = "MAC_UNIVERSAL"),
    (i[(i.WINDOWS = 4)] = "WINDOWS"),
    (i[(i.LINUX = 5)] = "LINUX")
})(Cf || (Cf = {})),
  n.util.setEnumType(Cf, "aiserver.v1.GetDownloadLinkRequest.Platform", [
    { no: 0, name: "PLATFORM_UNSPECIFIED" },
    { no: 1, name: "PLATFORM_MAC_APPLE_SILICON" },
    { no: 2, name: "PLATFORM_MAC_INTEL" },
    { no: 3, name: "PLATFORM_MAC_UNIVERSAL" },
    { no: 4, name: "PLATFORM_WINDOWS" },
    { no: 5, name: "PLATFORM_LINUX" },
  ])
var T7t = class ND extends h {
    constructor(t) {
      super(), (this.cachedDownloadLink = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDownloadLinkResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cached_download_link", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ND().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ND().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ND().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ND, t, e)
    }
  },
  k7t = class CD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSsoConfigurationLinksRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new CD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CD, t, e)
    }
  },
  S7t = class JD extends h {
    constructor(t) {
      super(),
        (this.ssoUrl = ""),
        (this.domainVerificationUrl = ""),
        (this.ssoStatus = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSsoConfigurationLinksResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "sso_url", kind: "scalar", T: 9 },
        { no: 2, name: "domain_verification_url", kind: "scalar", T: 9 },
        { no: 3, name: "sso_status", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JD, t, e)
    }
  },
  E7t = class LD extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.adminOnlyUsagePricing = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetAdminOnlyUsagePricingRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "admin_only_usage_pricing", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new LD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LD, t, e)
    }
  },
  I7t = class RD extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetAdminOnlyUsagePricingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new RD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RD, t, e)
    }
  },
  P7t = class DD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetYearlyUpgradeEligibilityRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new DD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DD, t, e)
    }
  },
  $7t = class FD extends h {
    constructor(t) {
      super(), (this.eligible = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetYearlyUpgradeEligibilityResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "eligible", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new FD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FD, t, e)
    }
  },
  x7t = class AD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpgradeToYearlyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new AD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AD, t, e)
    }
  },
  N7t = class _D extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpgradeToYearlyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new _D().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _D().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _D().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_D, t, e)
    }
  },
  C7t = class OD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUsageBasedPremiumRequestsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new OD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OD, t, e)
    }
  },
  J7t = class BD extends h {
    constructor(t) {
      super(),
        (this.usageBasedPremiumRequests = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUsageBasedPremiumRequestsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "usage_based_premium_requests", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new BD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BD, t, e)
    }
  },
  L7t = class qD extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.usageBasedPremiumRequests = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetUsageBasedPremiumRequestsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "usage_based_premium_requests", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new qD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qD, t, e)
    }
  },
  R7t = class UD extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetUsageBasedPremiumRequestsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new UD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UD, t, e)
    }
  },
  D7t = class MD extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetReferralsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new MD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MD, t, e)
    }
  },
  F7t = class HD extends h {
    constructor(t) {
      super(),
        (this.numReferrals = 0),
        (this.referralCode = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetReferralsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_referrals", kind: "scalar", T: 5 },
        { no: 2, name: "referral_code", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new HD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HD, t, e)
    }
  },
  A7t = class WD extends h {
    constructor(t) {
      super(),
        (this.referralCode = ""),
        (this.authId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckReferralCodeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "referral_code", kind: "scalar", T: 9 },
        { no: 2, name: "auth_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new WD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WD, t, e)
    }
  },
  _7t = class jD extends h {
    constructor(t) {
      super(),
        (this.isValid = !1),
        (this.userIsEligible = !1),
        (this.maxRedemptions = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckReferralCodeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_valid", kind: "scalar", T: 8 },
        { no: 2, name: "user_is_eligible", kind: "scalar", T: 8 },
        { no: 3, name: "max_redemptions", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new jD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jD, t, e)
    }
  },
  O7t = class VD extends h {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamReposRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new VD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VD, t, e)
    }
  },
  B7t = class GD extends h {
    constructor(t) {
      super(), (this.repos = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamReposResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repos", kind: "message", T: q7t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new GD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GD, t, e)
    }
  },
  q7t = class zD extends h {
    constructor(t) {
      super(),
        (this.id = 0),
        (this.url = ""),
        (this.patterns = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamReposResponse.Repo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        { no: 2, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "patterns", kind: "message", T: U7t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zD, t, e)
    }
  },
  U7t = class YD extends h {
    constructor(t) {
      super(), (this.id = 0), (this.pattern = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamReposResponse.Pattern"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        { no: 2, name: "pattern", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new YD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YD, t, e)
    }
  },
  M7t = class QD extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.repoUrl = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "repo_url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new QD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QD, t, e)
    }
  },
  H7t = class XD extends h {
    constructor(t) {
      super(), (this.repoId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repo_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new XD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XD, t, e)
    }
  },
  W7t = class KD extends h {
    constructor(t) {
      super(), (this.teamId = 0), (this.repoId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteTeamRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "repo_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new KD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KD, t, e)
    }
  },
  j7t = class ZD extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteTeamRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new ZD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZD, t, e)
    }
  },
  V7t = class tF extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.repoId = 0),
        (this.pattern = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddRepoPatternRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "repo_id", kind: "scalar", T: 5 },
        { no: 3, name: "pattern", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new tF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tF, t, e)
    }
  },
  G7t = class eF extends h {
    constructor(t) {
      super(), (this.patternId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddRepoPatternResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "pattern_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new eF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eF, t, e)
    }
  },
  z7t = class iF extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.repoId = 0),
        (this.patternId = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveRepoPatternRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "repo_id", kind: "scalar", T: 5 },
        { no: 3, name: "pattern_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new iF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iF, t, e)
    }
  },
  Y7t = class sF extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveRepoPatternResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new sF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sF, t, e)
    }
  },
  Vat = {
    typeName: "aiserver.v1.DashboardService",
    methods: {
      getTeams: { name: "GetTeams", I: O3t, O: B3t, kind: I.Unary },
      getActivationCheckoutUrl: {
        name: "GetActivationCheckoutUrl",
        I: q3t,
        O: U3t,
        kind: I.Unary,
      },
      getTeamCustomerPortalUrl: {
        name: "GetTeamCustomerPortalUrl",
        I: M3t,
        O: H3t,
        kind: I.Unary,
      },
      getTeamMembers: { name: "GetTeamMembers", I: W3t, O: V3t, kind: I.Unary },
      sendTeamInvite: { name: "SendTeamInvite", I: Y3t, O: Q3t, kind: I.Unary },
      getTeamInviteLink: {
        name: "GetTeamInviteLink",
        I: G3t,
        O: z3t,
        kind: I.Unary,
      },
      acceptInvite: { name: "AcceptInvite", I: X3t, O: K3t, kind: I.Unary },
      createTeam: { name: "CreateTeam", I: Z3t, O: t7t, kind: I.Unary },
      changeSeat: { name: "ChangeSeat", I: n7t, O: a7t, kind: I.Unary },
      changeTeamSubscription: {
        name: "ChangeTeamSubscription",
        I: o7t,
        O: c7t,
        kind: I.Unary,
      },
      updateRole: { name: "UpdateRole", I: e7t, O: i7t, kind: I.Unary },
      removeMember: { name: "RemoveMember", I: s7t, O: r7t, kind: I.Unary },
      getTeamUsage: { name: "GetTeamUsage", I: l7t, O: u7t, kind: I.Unary },
      getDailyTeamUsage: {
        name: "GetDailyTeamUsage",
        I: p7t,
        O: g7t,
        kind: I.Unary,
      },
      getSignUpType: { name: "GetSignUpType", I: m7t, O: f7t, kind: I.Unary },
      getHardLimit: { name: "GetHardLimit", I: R3t, O: D3t, kind: I.Unary },
      setHardLimit: { name: "SetHardLimit", I: F3t, O: A3t, kind: I.Unary },
      deleteAccount: { name: "DeleteAccount", I: g3t, O: v3t, kind: I.Unary },
      getMonthlyInvoice: {
        name: "GetMonthlyInvoice",
        I: N3t,
        O: C3t,
        kind: I.Unary,
      },
      getPricingHistory: {
        name: "GetPricingHistory",
        I: P3t,
        O: $3t,
        kind: I.Unary,
      },
      createTeamWithFreeTrial: {
        name: "CreateTeamWithFreeTrial",
        I: E3t,
        O: I3t,
        kind: I.Unary,
      },
      getTeamHasValidPaymentMethod: {
        name: "GetTeamHasValidPaymentMethod",
        I: k3t,
        O: S3t,
        kind: I.Unary,
      },
      getTeamPrivacyModeForced: {
        name: "GetTeamPrivacyModeForced",
        I: b3t,
        O: T3t,
        kind: I.Unary,
      },
      switchTeamPrivacyMode: {
        name: "SwitchTeamPrivacyMode",
        I: w3t,
        O: y3t,
        kind: I.Unary,
      },
      updateFastRequests: {
        name: "UpdateFastRequests",
        I: d3t,
        O: m3t,
        kind: I.Unary,
      },
      getFastRequests: {
        name: "GetFastRequests",
        I: f3t,
        O: p3t,
        kind: I.Unary,
      },
      getDownloadLink: {
        name: "GetDownloadLink",
        I: b7t,
        O: T7t,
        kind: I.Unary,
      },
      getSsoConfigurationLinks: {
        name: "GetSsoConfigurationLinks",
        I: k7t,
        O: S7t,
        kind: I.Unary,
      },
      setAdminOnlyUsagePricing: {
        name: "SetAdminOnlyUsagePricing",
        I: E7t,
        O: I7t,
        kind: I.Unary,
      },
      getYearlyUpgradeEligibility: {
        name: "GetYearlyUpgradeEligibility",
        I: P7t,
        O: $7t,
        kind: I.Unary,
      },
      upgradeToYearly: {
        name: "UpgradeToYearly",
        I: x7t,
        O: N7t,
        kind: I.Unary,
      },
      getUsageBasedPremiumRequests: {
        name: "GetUsageBasedPremiumRequests",
        I: C7t,
        O: J7t,
        kind: I.Unary,
      },
      setUsageBasedPremiumRequests: {
        name: "SetUsageBasedPremiumRequests",
        I: L7t,
        O: R7t,
        kind: I.Unary,
      },
      getReferrals: { name: "GetReferrals", I: D7t, O: F7t, kind: I.Unary },
      checkReferralCode: {
        name: "CheckReferralCode",
        I: A7t,
        O: _7t,
        kind: I.Unary,
      },
      getTeamRepos: { name: "GetTeamRepos", I: O7t, O: B7t, kind: I.Unary },
      createTeamRepo: { name: "CreateTeamRepo", I: M7t, O: H7t, kind: I.Unary },
      deleteTeamRepo: { name: "DeleteTeamRepo", I: W7t, O: j7t, kind: I.Unary },
      addRepoPattern: { name: "AddRepoPattern", I: V7t, O: G7t, kind: I.Unary },
      removeRepoPattern: {
        name: "RemoveRepoPattern",
        I: z7t,
        O: Y7t,
        kind: I.Unary,
      },
    },
  },
  Q7t = class rF extends h {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileFilterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: sf, repeated: !0 },
        { no: 2, name: "bug_description", kind: "message", T: he },
      ])
    }
    static fromBinary(t, e) {
      return new rF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rF, t, e)
    }
  },
  X7t = class nF extends h {
    constructor(t) {
      super(),
        (this.filePath = ""),
        (this.fileScore = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileFilterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new nF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nF, t, e)
    }
  },
  K7t = class aF extends h {
    constructor(t) {
      super(), (this.commits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GitFilterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commits", kind: "message", T: Ca, repeated: !0 },
        { no: 2, name: "bug_description", kind: "message", T: he },
      ])
    }
    static fromBinary(t, e) {
      return new aF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aF, t, e)
    }
  },
  Z7t = class oF extends h {
    constructor(t) {
      super(),
        (this.relevantCommit = ""),
        (this.commitScore = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GitFilterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relevant_commit", kind: "scalar", T: 9 },
        { no: 2, name: "commit_score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new oF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oF, t, e)
    }
  },
  tqt = class cF extends h {
    constructor(t) {
      super(), (this.relevantCommits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugAnalysisRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "relevant_commits",
          kind: "message",
          T: Ca,
          repeated: !0,
        },
        {
          no: 2,
          name: "bug_description_and_file_attachments",
          kind: "message",
          T: he,
        },
        { no: 3, name: "model_details", kind: "message", T: St },
      ])
    }
    static fromBinary(t, e) {
      return new cF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cF, t, e)
    }
  },
  eqt = class lF extends h {
    constructor(t) {
      super(),
        (this.reasoning = ""),
        (this.bugDescription = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugAnalysisResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "reasoning", kind: "scalar", T: 9 },
        { no: 2, name: "bug_description", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lF, t, e)
    }
  },
  Gat = {
    typeName: "aiserver.v1.DebuggerService",
    methods: {
      gitFilter: { name: "GitFilter", I: K7t, O: Z7t, kind: I.ServerStreaming },
      fileFilter: {
        name: "FileFilter",
        I: Q7t,
        O: X7t,
        kind: I.ServerStreaming,
      },
      bugAnalysis: {
        name: "BugAnalysis",
        I: tqt,
        O: eqt,
        kind: I.ServerStreaming,
      },
    },
  },
  zat = class uF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.hash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MinimalFileHash"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new uF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uF, t, e)
    }
  },
  iqt = class hF extends h {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.openTabs = []),
        (this.contextGraphFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartFastSearchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "cursor_position", kind: "message", T: ba },
        { no: 3, name: "open_tabs", kind: "message", T: zat, repeated: !0 },
        {
          no: 4,
          name: "context_graph_files",
          kind: "message",
          T: zat,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new hF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hF, t, e)
    }
  },
  sqt = class dF extends h {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartFastSearchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ready", kind: "message", T: rqt, oneof: "response" },
        {
          no: 2,
          name: "missing_files",
          kind: "message",
          T: nqt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new dF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dF, t, e)
    }
  },
  rqt = class mF extends h {
    constructor(t) {
      super(), (this.ready = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartFastSearchResponse.Ready"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ready", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new mF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mF, t, e)
    }
  },
  nqt = class fF extends h {
    constructor(t) {
      super(), (this.file = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartFastSearchResponse.MissingFiles"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fF, t, e)
    }
  },
  aqt = class pF extends h {
    constructor(t) {
      super(), (this.uuid = ""), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastSearchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new pF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pF, t, e)
    }
  },
  oqt = class gF extends h {
    constructor(t) {
      super(), (this.fileChunks = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastSearchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_chunks", kind: "message", T: cqt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gF, t, e)
    }
  },
  cqt = class vF extends h {
    constructor(t) {
      super(),
        (this.chunkScore = 0),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastSearchResponse.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk", kind: "message", T: rSt },
        { no: 2, name: "chunk_score", kind: "scalar", T: 2 },
        { no: 3, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new vF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vF, t, e)
    }
  },
  Yat = {
    typeName: "aiserver.v1.FastSearchService",
    methods: {
      startFastSearch: {
        name: "StartFastSearch",
        I: iqt,
        O: sqt,
        kind: I.Unary,
      },
      fastSearch: { name: "FastSearch", I: aqt, O: oqt, kind: I.Unary },
    },
  },
  GW = class wF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsefulType"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "text", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wF, t, e)
    }
  },
  lqt = class yF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.implementationStartLineInclusive = 0),
        (this.implementationEndLineInclusive = 0),
        (this.applyPlan = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainApplyPlanRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "implementation_start_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "implementation_end_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 5, name: "apply_plan", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new yF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yF, t, e)
    }
  },
  uqt = class bF extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainApplyPlanResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bF, t, e)
    }
  },
  hqt = class TF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.usefulTypes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SortUsefulTypesNaiveRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        { no: 3, name: "query_range", kind: "message", T: dqt },
        { no: 4, name: "useful_types", kind: "message", T: GW, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new TF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TF, t, e)
    }
  },
  dqt = class kF extends h {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SortUsefulTypesNaiveRequest.IRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new kF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kF, t, e)
    }
  },
  mqt = class SF extends h {
    constructor(t) {
      super(), (this.usefulTypes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SortUsefulTypesNaiveResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "useful_types", kind: "message", T: GW, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new SF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SF, t, e)
    }
  },
  fqt = class EF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.oldFileContents = ""),
        (this.implementationStartLineInclusive = 0),
        (this.implementationEndLineInclusive = 0),
        (this.newImplementationLines = []),
        (this.callSiteLines = []),
        (this.functionName = ""),
        (this.branchNotes = ""),
        (this.branchName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainReflectRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "old_file_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "implementation_start_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "implementation_end_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 5,
          name: "new_implementation_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "call_site_lines", kind: "scalar", T: 5, repeated: !0 },
        { no: 7, name: "function_name", kind: "scalar", T: 9 },
        { no: 8, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 9, name: "branch_name", kind: "scalar", T: 9 },
        { no: 10, name: "lints", kind: "message", T: qB },
      ])
    }
    static fromBinary(t, e) {
      return new EF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EF, t, e)
    }
  },
  pqt = class IF extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainReflectResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "decision", kind: "message", T: yqt },
      ])
    }
    static fromBinary(t, e) {
      return new IF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IF, t, e)
    }
  },
  gqt = class PF extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainReflectResponse.AcceptDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new PF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PF, t, e)
    }
  },
  vqt = class $F extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.Opus2ChainReflectResponse.RetryWithoutMoreInformationDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new $F().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $F().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $F().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($F, t, e)
    }
  },
  wqt = class xF extends h {
    constructor(t) {
      super(), (this.codebaseQuestions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.Opus2ChainReflectResponse.RetryWithCodebaseQuestionDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "codebase_questions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new xF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xF, t, e)
    }
  },
  yqt = class NF extends h {
    constructor(t) {
      super(), (this.decision = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainReflectResponse.Decision"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "accept", kind: "message", T: gqt, oneof: "decision" },
        {
          no: 2,
          name: "retry_without_more_information",
          kind: "message",
          T: vqt,
          oneof: "decision",
        },
        {
          no: 3,
          name: "retry_with_codebase_question",
          kind: "message",
          T: wqt,
          oneof: "decision",
        },
      ])
    }
    static fromBinary(t, e) {
      return new NF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NF, t, e)
    }
  },
  bqt = class CF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.implementationStartLineInclusive = 0),
        (this.implementationEndLineInclusive = 0),
        (this.diffHistory = []),
        (this.callSiteLines = []),
        (this.functionName = ""),
        (this.usefulTypes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.V0ChainRunRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "implementation_start_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "implementation_end_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 5, name: "diff_history", kind: "message", T: Xi, repeated: !0 },
        { no: 6, name: "call_site_lines", kind: "scalar", T: 5, repeated: !0 },
        { no: 7, name: "function_name", kind: "scalar", T: 9 },
        { no: 8, name: "useful_types", kind: "message", T: GW, repeated: !0 },
        { no: 10, name: "prompt", kind: "message", T: Qat },
        { no: 9, name: "debug_info", kind: "message", T: Rs },
      ])
    }
    static fromBinary(t, e) {
      return new CF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CF, t, e)
    }
  },
  Tqt = class JF extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.V0ChainRunResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JF, t, e)
    }
  },
  Qat = class LF extends h {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.contextItems = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HallucinatedFunctionsProtoPrompt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "context_items", kind: "message", T: qo, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new LF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LF, t, e)
    }
  },
  Xat = class RF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.implementationStartLineInclusive = 0),
        (this.implementationEndLineInclusive = 0),
        (this.diffHistory = []),
        (this.callSiteLines = []),
        (this.functionName = ""),
        (this.branchNotes = ""),
        (this.branchName = ""),
        (this.scoredCodebaseContext = []),
        (this.branchDiffFiles = []),
        (this.diffHistoryFiles = []),
        (this.planVersion = Jf.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "implementation_start_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "implementation_end_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 5, name: "diff_history", kind: "message", T: Xi, repeated: !0 },
        { no: 6, name: "call_site_lines", kind: "scalar", T: 5, repeated: !0 },
        { no: 7, name: "function_name", kind: "scalar", T: 9 },
        { no: 9, name: "debug_info", kind: "message", T: Rs },
        { no: 20, name: "prompt", kind: "message", T: Qat },
        { no: 10, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 11, name: "branch_name", kind: "scalar", T: 9 },
        {
          no: 12,
          name: "scored_codebase_context",
          kind: "message",
          T: xi,
          repeated: !0,
        },
        { no: 13, name: "diff_to_base_branch", kind: "message", T: kqt },
        {
          no: 16,
          name: "branch_diff_files",
          kind: "message",
          T: Kat,
          repeated: !0,
        },
        {
          no: 14,
          name: "diff_history_files",
          kind: "message",
          T: Kat,
          repeated: !0,
        },
        {
          no: 8,
          name: "codebase_information",
          kind: "message",
          T: Eqt,
          opt: !0,
        },
        { no: 15, name: "plan_version", kind: "enum", T: n.getEnumType(Jf) },
        { no: 17, name: "context_ast", kind: "message", T: wat },
      ])
    }
    static fromBinary(t, e) {
      return new RF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RF, t, e)
    }
  },
  Jf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.V0 = 1)] = "V0"),
    (i[(i.V1_MORE_CONTEXT_AND_GUIDELINES = 2)] =
      "V1_MORE_CONTEXT_AND_GUIDELINES")
})(Jf || (Jf = {})),
  n.util.setEnumType(Jf, "aiserver.v1.Opus2ChainPlanRequest.OpusPlanVersion", [
    { no: 0, name: "OPUS_PLAN_VERSION_UNSPECIFIED" },
    { no: 1, name: "OPUS_PLAN_VERSION_V0" },
    { no: 2, name: "OPUS_PLAN_VERSION_V1_MORE_CONTEXT_AND_GUIDELINES" },
  ])
var kqt = class DF extends h {
    constructor(t) {
      super(),
        (this.fileDiffs = []),
        (this.commits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.BranchDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: Sqt, repeated: !0 },
        { no: 2, name: "commits", kind: "message", T: Ca, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new DF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DF, t, e)
    }
  },
  Sqt = class FF extends h {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diff = ""),
        (this.tooBig = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.BranchDiff.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
        { no: 3, name: "too_big", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new FF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FF, t, e)
    }
  },
  Kat = class AF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new AF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AF, t, e)
    }
  },
  Eqt = class _F extends h {
    constructor(t) {
      super(), (this.files = []), (this.qa = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.CodebaseInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: Iqt, repeated: !0 },
        { no: 2, name: "qa", kind: "message", T: Pqt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _F().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _F().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _F().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_F, t, e)
    }
  },
  Iqt = class OF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.interestingLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.Opus2ChainPlanRequest.CodebaseInformation.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "interesting_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new OF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OF, t, e)
    }
  },
  Pqt = class BF extends h {
    constructor(t) {
      super(),
        (this.question = ""),
        (this.answer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.CodebaseInformation.QA"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "question", kind: "scalar", T: 9 },
        { no: 2, name: "answer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new BF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BF, t, e)
    }
  },
  VXt = class qF extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ExtractFunctionNameFromImplementationPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qF, t, e)
    }
  },
  $qt = class UF extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new UF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UF, t, e)
    }
  },
  GXt = class MF extends h {
    constructor(t) {
      super(),
        (this.examples = []),
        (this.tokenLimit = 0),
        (this.tokenizer = ""),
        (this.chainOfThought = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.CodebaseKnowledgeCmdKInstructionFewShotPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "examples", kind: "message", T: xqt, repeated: !0 },
        { no: 2, name: "current", kind: "message", T: Zat },
        { no: 8, name: "token_limit", kind: "scalar", T: 5 },
        { no: 9, name: "tokenizer", kind: "scalar", T: 9 },
        { no: 10, name: "chain_of_thought", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new MF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MF, t, e)
    }
  },
  xqt = class HF extends h {
    constructor(t) {
      super(),
        (this.instruction = ""),
        (this.reasoning = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.CodebaseKnowledgeCmdKInstructionFewShotPromptProps.Example"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "props", kind: "message", T: Zat },
        { no: 2, name: "instruction", kind: "scalar", T: 9 },
        { no: 3, name: "reasoning", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new HF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HF, t, e)
    }
  },
  Zat = class WF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.currentFileLines = []),
        (this.startLineOneIndexedInclusive = 0),
        (this.endLineOneIndexedExclusive = 0),
        (this.groundTruthLines = []),
        (this.prHistory = []),
        (this.scoredCodebaseContext = []),
        (this.tokenLimit = 0),
        (this.tokenizer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodebaseKnowledgeCmdKInstructionPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "current_file_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 3,
          name: "start_line_one_indexed_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 4, name: "end_line_one_indexed_exclusive", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "ground_truth_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "pr_history", kind: "message", T: tot, repeated: !0 },
        {
          no: 7,
          name: "scored_codebase_context",
          kind: "message",
          T: xi,
          repeated: !0,
        },
        { no: 8, name: "token_limit", kind: "scalar", T: 5 },
        { no: 9, name: "tokenizer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new WF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WF, t, e)
    }
  },
  zXt = class jF extends h {
    constructor(t) {
      super(), (this.codebaseContext = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ScoredCodebaseContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "codebase_context",
          kind: "message",
          T: xi,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new jF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jF, t, e)
    }
  },
  tot = class VF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.originalLines = []),
        (this.newLines = []),
        (this.startLineOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PrHistoryItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "original_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "start_line_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new VF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VF, t, e)
    }
  },
  YXt = class GF extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.currentFileLines = []),
        (this.startLineOneIndexedInclusive = 0),
        (this.endLineOneIndexedExclusive = 0),
        (this.instruction = ""),
        (this.prHistory = []),
        (this.scoredCodebaseContext = []),
        (this.tokenLimit = 0),
        (this.tokenizer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodebaseKnowledgeCmdKPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "current_file_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 3,
          name: "start_line_one_indexed_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 4, name: "end_line_one_indexed_exclusive", kind: "scalar", T: 5 },
        { no: 5, name: "instruction", kind: "scalar", T: 9 },
        { no: 6, name: "pr_history", kind: "message", T: tot, repeated: !0 },
        {
          no: 7,
          name: "scored_codebase_context",
          kind: "message",
          T: xi,
          repeated: !0,
        },
        { no: 8, name: "token_limit", kind: "scalar", T: 5 },
        { no: 9, name: "tokenizer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new GF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GF, t, e)
    }
  },
  QXt = class zF extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: Xat },
        { no: 2, name: "plan", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zF, t, e)
    }
  },
  eot = {
    typeName: "aiserver.v1.HallucinatedFunctionsService",
    methods: {
      v0ChainRun: {
        name: "V0ChainRun",
        I: bqt,
        O: Tqt,
        kind: I.ServerStreaming,
      },
      opus2ChainPlan: {
        name: "Opus2ChainPlan",
        I: Xat,
        O: $qt,
        kind: I.ServerStreaming,
      },
      opus2ChainApplyPlan: {
        name: "Opus2ChainApplyPlan",
        I: lqt,
        O: uqt,
        kind: I.ServerStreaming,
      },
      opus2ChainReflect: {
        name: "Opus2ChainReflect",
        I: fqt,
        O: pqt,
        kind: I.ServerStreaming,
      },
      sortUsefulTypesNaive: {
        name: "SortUsefulTypesNaive",
        I: hqt,
        O: mqt,
        kind: I.Unary,
      },
    },
  },
  zW
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.PYTHON = 1)] = "PYTHON"),
    (i[(i.SHELL = 2)] = "SHELL")
})(zW || (zW = {})),
  n.util.setEnumType(zW, "aiserver.v1.InterpreterTool", [
    { no: 0, name: "INTERPRETER_TOOL_UNSPECIFIED" },
    { no: 1, name: "INTERPRETER_TOOL_PYTHON" },
    { no: 2, name: "INTERPRETER_TOOL_SHELL" },
  ])
var Nqt = class YF extends h {
    constructor(t) {
      super(),
        (this.conversationUuid = ""),
        (this.userFeedback = Lf.UNSPECIFIED),
        (this.userFeedbackDetails = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogInterpreterExplicitUserFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation_uuid", kind: "scalar", T: 9 },
        { no: 3, name: "user_feedback", kind: "enum", T: n.getEnumType(Lf) },
        { no: 4, name: "user_feedback_details", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new YF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YF, t, e)
    }
  },
  Lf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GOOD = 1)] = "GOOD"),
    (i[(i.OKAY = 2)] = "OKAY"),
    (i[(i.BAD = 3)] = "BAD")
})(Lf || (Lf = {})),
  n.util.setEnumType(
    Lf,
    "aiserver.v1.LogInterpreterExplicitUserFeedbackRequest.Feedback",
    [
      { no: 0, name: "FEEDBACK_UNSPECIFIED" },
      { no: 1, name: "FEEDBACK_GOOD" },
      { no: 2, name: "FEEDBACK_OKAY" },
      { no: 3, name: "FEEDBACK_BAD" },
    ],
  )
var Cqt = class QF extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogInterpreterExplicitUserFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new QF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QF, t, e)
    }
  },
  Jqt = class XF extends h {
    constructor(t) {
      super(),
        (this.openFiles = []),
        (this.conversation = []),
        (this.documentationIdentifiers = []),
        (this.scoredCodebaseContext = []),
        (this.conversationUuid = ""),
        (this.quotes = []),
        (this.supportsShellTool = !1),
        (this.globalDescription = ""),
        (this.terminalCwd = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterpreterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "open_files", kind: "message", T: Lqt, repeated: !0 },
        { no: 2, name: "conversation", kind: "message", T: he, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Oe },
        { no: 7, name: "model_details", kind: "message", T: St },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "summary", kind: "scalar", T: 9, opt: !0 },
        {
          no: 12,
          name: "summary_up_until_index",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 13, name: "retry_instructions", kind: "scalar", T: 9, opt: !0 },
        {
          no: 14,
          name: "retry_previous_attempt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 15,
          name: "scored_codebase_context",
          kind: "message",
          T: xi,
          repeated: !0,
        },
        {
          no: 16,
          name: "high_level_folder_description",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 17, name: "conversation_uuid", kind: "scalar", T: 9 },
        { no: 18, name: "cmd_k_debug_info", kind: "message", T: Rs },
        { no: 19, name: "quotes", kind: "message", T: z8, repeated: !0 },
        { no: 20, name: "supports_shell_tool", kind: "scalar", T: 8 },
        { no: 21, name: "global_description", kind: "scalar", T: 9 },
        { no: 22, name: "terminal_cwd", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XF, t, e)
    }
  },
  Lqt = class KF extends h {
    constructor(t) {
      super(), (this.scrollTopLineNumber = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterpreterRequest.FileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: Yt },
        { no: 2, name: "scroll_top_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new KF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KF, t, e)
    }
  },
  Rqt = class ZF extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterpreterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ZF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZF, t, e)
    }
  },
  iot = {
    typeName: "aiserver.v1.InterpreterService",
    methods: {
      streamInterpreter: {
        name: "StreamInterpreter",
        I: Jqt,
        O: Rqt,
        kind: I.ServerStreaming,
      },
      logInterpreterExplicitUserFeedback: {
        name: "LogInterpreterExplicitUserFeedback",
        I: Nqt,
        O: Cqt,
        kind: I.Unary,
      },
    },
  },
  sot = {
    typeName: "aiserver.v1.RepositoryService",
    methods: {
      fastRepoInitHandshake: {
        name: "FastRepoInitHandshake",
        I: sCt,
        O: rCt,
        kind: I.Unary,
      },
      syncMerkleSubtree: {
        name: "SyncMerkleSubtree",
        I: hCt,
        O: dCt,
        kind: I.Unary,
      },
      fastUpdateFile: { name: "FastUpdateFile", I: vCt, O: yCt, kind: I.Unary },
      searchRepositoryV2: {
        name: "SearchRepositoryV2",
        I: Pnt,
        O: $nt,
        kind: I.Unary,
      },
      removeRepositoryV2: {
        name: "RemoveRepositoryV2",
        I: LCt,
        O: RCt,
        kind: I.Unary,
      },
      fastRepoInitHandshakeV2: {
        name: "FastRepoInitHandshakeV2",
        I: nCt,
        O: oCt,
        kind: I.Unary,
      },
      syncMerkleSubtreeV2: {
        name: "SyncMerkleSubtreeV2",
        I: fCt,
        O: pCt,
        kind: I.Unary,
      },
      fastUpdateFileV2: {
        name: "FastUpdateFileV2",
        I: bCt,
        O: kCt,
        kind: I.Unary,
      },
      fastRepoSyncComplete: {
        name: "FastRepoSyncComplete",
        I: lCt,
        O: uCt,
        kind: I.Unary,
      },
      semSearchFast: {
        name: "SemSearchFast",
        I: xnt,
        O: Cnt,
        kind: I.ServerStreaming,
      },
      semSearch: { name: "SemSearch", I: xnt, O: Cnt, kind: I.ServerStreaming },
      ensureIndexCreated: {
        name: "EnsureIndexCreated",
        I: eCt,
        O: iCt,
        kind: I.Unary,
      },
      getHighLevelFolderDescription: {
        name: "GetHighLevelFolderDescription",
        I: K9t,
        O: tCt,
        kind: I.Unary,
      },
      getEmbeddings: { name: "GetEmbeddings", I: NCt, O: CCt, kind: I.Unary },
      getUploadLimits: {
        name: "GetUploadLimits",
        I: SCt,
        O: ECt,
        kind: I.Unary,
      },
      getNumFilesToSend: {
        name: "GetNumFilesToSend",
        I: ICt,
        O: PCt,
        kind: I.Unary,
      },
      getAvailableChunkingStrategies: {
        name: "GetAvailableChunkingStrategies",
        I: $Ct,
        O: xCt,
        kind: I.Unary,
      },
      getLineNumberClassifications: {
        name: "GetLineNumberClassifications",
        I: QCt,
        O: XCt,
        kind: I.ServerStreaming,
      },
    },
  },
  a3
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.IN_PROGRESS = 1)] = "IN_PROGRESS"),
    (i[(i.SUCCEEDED = 2)] = "SUCCEEDED"),
    (i[(i.FAILED = 3)] = "FAILED"),
    (i[(i.NOT_FOUND = 4)] = "NOT_FOUND")
})(a3 || (a3 = {})),
  n.util.setEnumType(a3, "aiserver.v1.UploadStatus", [
    { no: 0, name: "UPLOAD_STATUS_UNSPECIFIED" },
    { no: 1, name: "UPLOAD_STATUS_IN_PROGRESS" },
    { no: 2, name: "UPLOAD_STATUS_SUCCEEDED" },
    { no: 3, name: "UPLOAD_STATUS_FAILED" },
    { no: 4, name: "UPLOAD_STATUS_NOT_FOUND" },
  ])
var Dqt = class tA extends h {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RescrapeDocsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "force_reupload", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tA, t, e)
    }
  },
  Fqt = class eA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RescrapeDocsRequestV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "new_doc_req", kind: "message", T: not },
        { no: 2, name: "force_reupload", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new eA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eA, t, e)
    }
  },
  rot = class iA extends h {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RescrapeDocsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
        { no: 2, name: "new_doc_identifier", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new iA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iA, t, e)
    }
  },
  Aqt = class sA extends h {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadedStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new sA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sA, t, e)
    }
  },
  _qt = class rA extends h {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadDocumentationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rA, t, e)
    }
  },
  Oqt = class nA extends h {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetPagesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nA, t, e)
    }
  },
  Bqt = class aA extends h {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDocRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new aA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aA, t, e)
    }
  },
  qqt = class oA extends h {
    constructor(t) {
      super(),
        (this.id = 0),
        (this.uuid = ""),
        (this.docIdentifier = ""),
        (this.docName = ""),
        (this.docUrlRoot = ""),
        (this.docUrlPrefix = ""),
        (this.isDifferentPrefix = !1),
        (this.createdAt = ""),
        (this.updatedAt = ""),
        (this.lastUploadedAt = ""),
        (this.showToAllUsers = !1),
        (this.teamId = 0),
        (this.customInstructions = ""),
        (this.pages = []),
        (this.publishToTeam = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ProtoDoc"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        { no: 2, name: "uuid", kind: "scalar", T: 9 },
        { no: 3, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 4, name: "doc_name", kind: "scalar", T: 9 },
        { no: 5, name: "doc_url_root", kind: "scalar", T: 9 },
        { no: 6, name: "doc_url_prefix", kind: "scalar", T: 9 },
        { no: 7, name: "is_different_prefix", kind: "scalar", T: 8 },
        { no: 8, name: "created_at", kind: "scalar", T: 9 },
        { no: 9, name: "updated_at", kind: "scalar", T: 9 },
        { no: 10, name: "last_uploaded_at", kind: "scalar", T: 9 },
        { no: 11, name: "upload_status", kind: "message", T: o3 },
        { no: 12, name: "show_to_all_users", kind: "scalar", T: 8 },
        { no: 13, name: "team_id", kind: "scalar", T: 5 },
        { no: 14, name: "custom_instructions", kind: "scalar", T: 9 },
        { no: 15, name: "pages", kind: "message", T: Uqt, repeated: !0 },
        { no: 16, name: "publish_to_team", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new oA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oA, t, e)
    }
  },
  Uqt = class cA extends h {
    constructor(t) {
      super(), (this.url = ""), (this.title = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ProtoDocPage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cA, t, e)
    }
  },
  Mqt = class lA extends h {
    constructor(t) {
      super(),
        (this.pages = []),
        (this.pageUrls = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Pages"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "pages", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "page_urls", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lA, t, e)
    }
  },
  Hqt = class uA extends h {
    constructor(t) {
      super(),
        (this.docIdentifier = ""),
        (this.password = ""),
        (this.docName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkAsPublicRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "password", kind: "scalar", T: 9 },
        { no: 3, name: "doc_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new uA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uA, t, e)
    }
  },
  not = class hA extends h {
    constructor(t) {
      super(),
        (this.docIdentifier = ""),
        (this.ignorePrefixes = []),
        (this.ignoreUrls = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewDocumentationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "message", T: Xnt },
        { no: 4, name: "ignore_prefixes", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "ignore_urls", kind: "scalar", T: 9, repeated: !0 },
        { no: 6, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "publish_to_team", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "client_handles_uuid", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hA, t, e)
    }
  },
  aot = class dA extends h {
    constructor(t) {
      super(),
        (this.status = Rf.UNSPECIFIED),
        (this.progress = 0),
        (this.similarDocIdentifier = ""),
        (this.uploadedPages = []),
        (this.docUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Rf) },
        { no: 2, name: "progress", kind: "scalar", T: 2 },
        { no: 3, name: "similar_doc_identifier", kind: "scalar", T: 9 },
        { no: 4, name: "uploaded_pages", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "doc_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new dA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dA, t, e)
    }
  },
  Rf
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.ALREADY_EXISTS = 3)] = "ALREADY_EXISTS"),
    (i[(i.SIMILAR_ALREADY_EXISTS = 4)] = "SIMILAR_ALREADY_EXISTS")
})(Rf || (Rf = {})),
  n.util.setEnumType(Rf, "aiserver.v1.UploadResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_ALREADY_EXISTS" },
    { no: 4, name: "STATUS_SIMILAR_ALREADY_EXISTS" },
  ])
var o3 = class mA extends h {
    constructor(t) {
      super(),
        (this.status = Df.UNSPECIFIED),
        (this.uploadedPages = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadedStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Df) },
        { no: 2, name: "uploaded_pages", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mA, t, e)
    }
  },
  Df
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.IN_PROGRESS = 1)] = "IN_PROGRESS"),
    (i[(i.SUCCEEDED = 2)] = "SUCCEEDED"),
    (i[(i.FAILED = 3)] = "FAILED"),
    (i[(i.NOT_FOUND = 4)] = "NOT_FOUND")
})(Df || (Df = {})),
  n.util.setEnumType(Df, "aiserver.v1.UploadedStatus.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_IN_PROGRESS" },
    { no: 2, name: "STATUS_SUCCEEDED" },
    { no: 3, name: "STATUS_FAILED" },
    { no: 4, name: "STATUS_NOT_FOUND" },
  ])
var Wqt = class fA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpsertDocsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "upload_status",
          kind: "enum",
          T: n.getEnumType(a3),
          opt: !0,
        },
        { no: 2, name: "ignore_index_prefix", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "doc_id", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fA, t, e)
    }
  },
  jqt = class pA extends h {
    constructor(t) {
      super(), (this.responses = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpsertDocsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "responses", kind: "message", T: aot, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new pA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pA, t, e)
    }
  },
  oot = {
    typeName: "aiserver.v1.UploadService",
    methods: {
      uploadDocumentation: {
        name: "UploadDocumentation",
        I: not,
        O: aot,
        kind: I.Unary,
      },
      uploadDocumentationStatus: {
        name: "UploadDocumentationStatus",
        I: _qt,
        O: o3,
        kind: I.Unary,
      },
      markAsPublic: { name: "MarkAsPublic", I: Hqt, O: o3, kind: I.Unary },
      uploadStatus: { name: "UploadStatus", I: Aqt, O: o3, kind: I.Unary },
      getPages: { name: "GetPages", I: Oqt, O: Mqt, kind: I.Unary },
      getDoc: { name: "GetDoc", I: Bqt, O: qqt, kind: I.Unary },
      rescrapeDocs: { name: "RescrapeDocs", I: Dqt, O: rot, kind: I.Unary },
      rescrapeDocsV2: { name: "RescrapeDocsV2", I: Fqt, O: rot, kind: I.Unary },
      upsertAllDocs: { name: "UpsertAllDocs", I: Wqt, O: jqt, kind: I.Unary },
    },
  },
  cot = {
    typeName: "aiserver.v1.MetricsService",
    methods: {
      reportIncrement: { name: "ReportIncrement", I: r3, O: n3, kind: I.Unary },
      reportDecrement: { name: "ReportDecrement", I: r3, O: n3, kind: I.Unary },
      reportDistribution: {
        name: "ReportDistribution",
        I: r3,
        O: n3,
        kind: I.Unary,
      },
      reportGauge: { name: "ReportGauge", I: r3, O: n3, kind: I.Unary },
    },
  },
  lot = {
    typeName: "aiserver.v1.LinterService",
    methods: {
      lintFile: { name: "LintFile", I: tFt, O: iFt, kind: I.Unary },
      lintChunk: { name: "LintChunk", I: QDt, O: XDt, kind: I.Unary },
      lintFimChunk: { name: "LintFimChunk", I: KDt, O: ZDt, kind: I.Unary },
      lintExplanation: {
        name: "LintExplanation",
        I: vat,
        O: zDt,
        kind: I.ServerStreaming,
      },
      lintExplanation2: {
        name: "LintExplanation2",
        I: vat,
        O: YDt,
        kind: I.Unary,
      },
    },
  },
  uot = {
    typeName: "aiserver.v1.ExperimentService",
    methods: {
      specedits1: { name: "Specedits1", I: _Bt, O: OBt, kind: I.Unary },
      simple: { name: "Simple", I: BBt, O: qBt, kind: I.Unary },
      streamHeadlessAgenticComposer: {
        name: "StreamHeadlessAgenticComposer",
        I: GBt,
        O: zBt,
        kind: I.ServerStreaming,
      },
    },
  },
  Vqt = class gA extends h {
    constructor(t) {
      super(), (this.stackTrace = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogWhenTabTurnsOffRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "stack_trace", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new gA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gA, t, e)
    }
  },
  Gqt = class vA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogWhenTabTurnsOffResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new vA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vA, t, e)
    }
  },
  hot = {
    typeName: "aiserver.v1.ClientLoggerService",
    methods: {
      logWhenTabTurnsOff: {
        name: "LogWhenTabTurnsOff",
        I: Vqt,
        O: Gqt,
        kind: I.Unary,
      },
    },
  },
  zqt = class wA extends h {
    constructor(t) {
      super(), (this.authId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteUserRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "auth_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new wA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wA, t, e)
    }
  },
  Yqt = class yA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteUserResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new yA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yA, t, e)
    }
  },
  Qqt = class bA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTailscaleSSHRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new bA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bA, t, e)
    }
  },
  Xqt = class TA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTailscaleSSHResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new TA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TA, t, e)
    }
  },
  Kqt = class kA extends h {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.authIds = []),
        (this.workosIds = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddAuthIdsToTeamRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "auth_ids", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "workos_ids", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new kA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kA, t, e)
    }
  },
  Zqt = class SA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddAuthIdsToTeamResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new SA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SA, t, e)
    }
  },
  dot = {
    typeName: "aiserver.v1.AdminService",
    methods: {
      deleteUser: { name: "DeleteUser", I: zqt, O: Yqt, kind: I.Unary },
      runTailscaleSSH: {
        name: "RunTailscaleSSH",
        I: Qqt,
        O: Xqt,
        kind: I.Unary,
      },
      addAuthIdsToTeam: {
        name: "AddAuthIdsToTeam",
        I: Kqt,
        O: Zqt,
        kind: I.Unary,
      },
    },
  },
  t2t = class EA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPredictionConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new EA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EA, t, e)
    }
  },
  e2t = class IA extends h {
    constructor(t) {
      super(), (this.name = ""), (this.radius = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPredictionModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "radius", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new IA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IA, t, e)
    }
  },
  i2t = class PA extends h {
    constructor(t) {
      super(),
        (this.models = []),
        (this.defaultModel = ""),
        (this.heuristics = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPredictionConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "models", kind: "message", T: e2t, repeated: !0 },
        { no: 2, name: "default_model", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "heuristics",
          kind: "enum",
          T: n.getEnumType(c3),
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new PA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PA, t, e)
    }
  },
  c3
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DISABLE_IN_LAST_CPP_SUGGESTION = 1)] =
      "DISABLE_IN_LAST_CPP_SUGGESTION")
})(c3 || (c3 = {})),
  n.util.setEnumType(
    c3,
    "aiserver.v1.CursorPredictionConfigResponse.Heuristic",
    [
      { no: 0, name: "HEURISTIC_UNSPECIFIED" },
      { no: 1, name: "HEURISTIC_DISABLE_IN_LAST_CPP_SUGGESTION" },
    ],
  )
var mot = {
    typeName: "aiserver.v1.CursorPredictionService",
    methods: {
      cursorPredictionConfig: {
        name: "CursorPredictionConfig",
        I: t2t,
        O: i2t,
        kind: I.Unary,
      },
    },
  },
  s2t = class $A extends h {
    constructor(t) {
      super(),
        (this.telemEnabled = !1),
        (this.bugBotDismissedNotificationLast10TimesUnixMs = []),
        (this.bugBotViewedNotificationLast10TimesUnixMs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "telem_enabled", kind: "scalar", T: 8 },
        {
          no: 2,
          name: "bug_bot_dismissed_notification_last_10_times_unix_ms",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
        {
          no: 3,
          name: "bug_bot_viewed_notification_last_10_times_unix_ms",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new $A().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $A().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $A().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($A, t, e)
    }
  },
  fot = class xA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "linter_strategy_v1", kind: "message", T: r2t },
        { no: 2, name: "bug_bot_v1", kind: "message", T: a2t },
        { no: 3, name: "linter_strategy_v2", kind: "message", T: n2t },
      ])
    }
    static fromBinary(t, e) {
      return new xA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xA, t, e)
    }
  },
  r2t = class NA extends h {
    constructor(t) {
      super(),
        (this.enabled = !1),
        (this.tryTriggerOnSave = !1),
        (this.waitBetweenTriggersMs = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigResponse.LinterStrategyV1"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
        { no: 2, name: "try_trigger_on_save", kind: "scalar", T: 8 },
        { no: 3, name: "wait_between_triggers_ms", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new NA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NA, t, e)
    }
  },
  n2t = class CA extends h {
    constructor(t) {
      super(),
        (this.enabled = !1),
        (this.waitBetweenTriggersMs = 0),
        (this.debounceTriggersMs = 0),
        (this.keepLinesAroundChunk = 0),
        (this.preventTriggeringForFilesWithThisManyLines = 0),
        (this.preventTriggeringWhenLints = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigResponse.LinterStrategyV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
        { no: 2, name: "wait_between_triggers_ms", kind: "scalar", T: 1 },
        { no: 3, name: "debounce_triggers_ms", kind: "scalar", T: 1 },
        { no: 4, name: "keep_lines_around_chunk", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "prevent_triggering_for_files_with_this_many_lines",
          kind: "scalar",
          T: 5,
        },
        { no: 6, name: "prevent_triggering_when_lints", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new CA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CA, t, e)
    }
  },
  a2t = class JA extends h {
    constructor(t) {
      super(),
        (this.enabled = !1),
        (this.isSubsidized = !1),
        (this.backgroundCallFrequencyMs = 0),
        (this.killSwitch = !1),
        (this.showIntrusiveNotificationOnlyIfLastTimeWasMoreThanMsAgo = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigResponse.BugBotV1"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
        { no: 2, name: "is_subsidized", kind: "scalar", T: 8 },
        { no: 3, name: "background_call_frequency_ms", kind: "scalar", T: 5 },
        { no: 4, name: "kill_switch", kind: "scalar", T: 8 },
        {
          no: 5,
          name: "show_intrusive_notification_only_if_last_time_was_more_than_ms_ago",
          kind: "scalar",
          T: 1,
        },
        {
          no: 6,
          name: "background_diff_absolute_max_tokens",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 7,
          name: "background_diff_min_min_token_threshold",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 8,
          name: "background_diff_min_max_token_threshold",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 9,
          name: "background_diff_last_commit_less_than_this_many_ms_ago",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        {
          no: 15,
          name: "background_unified_context_lines",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 16,
          name: "background_diff_include_uncommitted",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 10,
          name: "default_diff_context_lines",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 11,
          name: "diff_absolute_max_tokens",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 12,
          name: "custom_instructions_max_char_length",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 13,
          name: "default_fallback_iterations",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 14,
          name: "threshold_for_expensive_run_modal_cents",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 17, name: "cheap_model_name", kind: "scalar", T: 9, opt: !0 },
        {
          no: 18,
          name: "cheap_absolute_max_tokens",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 19,
          name: "expensive_absolute_max_tokens",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new JA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JA, t, e)
    }
  },
  o2t = class LA extends h {
    constructor(t) {
      super(),
        (this.activeFile = ""),
        (this.cursorLineNumberOneIndexed = 0),
        (this.telemEnabled = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotLinterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "git_diff", kind: "message", T: V8 },
        { no: 2, name: "active_file", kind: "scalar", T: 9 },
        { no: 3, name: "cursor_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 4, name: "session_id", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "telem_enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new LA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LA, t, e)
    }
  },
  c2t = class RA extends h {
    constructor(t) {
      super(), (this.bugs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotLinterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bugs", kind: "message", T: K8, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new RA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RA, t, e)
    }
  },
  l2t = class DA extends h {
    constructor(t) {
      super(),
        (this.diffString = ""),
        (this.oldStart = 0),
        (this.newStart = 0),
        (this.oldLines = 0),
        (this.newLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChunkDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_string", kind: "scalar", T: 9 },
        { no: 2, name: "old_start", kind: "scalar", T: 5 },
        { no: 3, name: "new_start", kind: "scalar", T: 5 },
        { no: 4, name: "old_lines", kind: "scalar", T: 5 },
        { no: 5, name: "new_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new DA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DA, t, e)
    }
  },
  pot = class FA extends h {
    constructor(t) {
      super(), (this.fileDiffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewRequestV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: u2t, repeated: !0 },
        { no: 2, name: "linter_rules", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "also_find_hard_bugs", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "save_request_as", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new FA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FA, t, e)
    }
  },
  u2t = class AA extends h {
    constructor(t) {
      super(), (this.chunkDiffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewRequestV2.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: ks },
        { no: 2, name: "chunk_diffs", kind: "message", T: l2t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new AA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AA, t, e)
    }
  },
  got = class _A extends h {
    constructor(t) {
      super(),
        (this.id = ""),
        (this.chunkId = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.description = ""),
        (this.severity = 0),
        (this.tldr = ""),
        (this.diff = ""),
        (this.fullChunkStartLine = 0),
        (this.fullChunkEndLine = 0),
        (this.fullChunkTotalLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewBugV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "chunk_id", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "start_line", kind: "scalar", T: 5 },
        { no: 5, name: "end_line", kind: "scalar", T: 5 },
        { no: 6, name: "description", kind: "scalar", T: 9 },
        { no: 7, name: "severity", kind: "scalar", T: 5 },
        { no: 8, name: "tldr", kind: "scalar", T: 9 },
        { no: 9, name: "diff", kind: "scalar", T: 9 },
        { no: 10, name: "full_chunk_start_line", kind: "scalar", T: 5 },
        { no: 11, name: "full_chunk_end_line", kind: "scalar", T: 5 },
        { no: 12, name: "full_chunk_total_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new _A().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _A().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _A().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_A, t, e)
    }
  },
  vot = class OA extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewResponseV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "message", T: got },
      ])
    }
    static fromBinary(t, e) {
      return new OA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OA, t, e)
    }
  },
  h2t = class BA extends h {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatRequestV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: ks },
        { no: 2, name: "bug", kind: "message", T: got },
        { no: 3, name: "linter_rules", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "messages", kind: "message", T: Cat, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new BA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BA, t, e)
    }
  },
  d2t = class qA extends h {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatResponseV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qA, t, e)
    }
  },
  m2t = class UA extends h {
    constructor(t) {
      super(), (this.bugs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bugs", kind: "message", T: f2t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new UA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UA, t, e)
    }
  },
  f2t = class MA extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        (this.codeLines = []),
        (this.severity = 0),
        (this.confidence = 0),
        (this.description = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingResponse.Bug"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_inclusive", kind: "scalar", T: 5 },
        { no: 4, name: "code_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "severity", kind: "scalar", T: 1 },
        { no: 6, name: "confidence", kind: "scalar", T: 1 },
        { no: 7, name: "description", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new MA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MA, t, e)
    }
  },
  p2t = class HA extends h {
    constructor(t) {
      super(), (this.fileDiffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: g2t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new HA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HA, t, e)
    }
  },
  g2t = class WA extends h {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lines = []),
        (this.hunks = []),
        (this.notTruncated = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingRequest.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "message", T: w2t, repeated: !0 },
        { no: 3, name: "hunks", kind: "message", T: v2t, repeated: !0 },
        {
          no: 4,
          name: "old_relative_workspace_path",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 5, name: "not_truncated", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new WA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WA, t, e)
    }
  },
  v2t = class jA extends h {
    constructor(t) {
      super(),
        (this.oldStartOneIndexed = 0),
        (this.newStartOneIndexed = 0),
        (this.oldLines = []),
        (this.newLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingRequest.FileDiff.Hunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "old_start_one_indexed", kind: "scalar", T: 5 },
        { no: 2, name: "new_start_one_indexed", kind: "scalar", T: 5 },
        { no: 3, name: "old_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new jA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jA, t, e)
    }
  },
  w2t = class VA extends h {
    constructor(t) {
      super(),
        (this.oneIndexedLineNumber = 0),
        (this.line = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingRequest.FileDiff.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "one_indexed_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "line", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new VA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VA, t, e)
    }
  },
  wot = {
    typeName: "aiserver.v1.ReviewService",
    methods: {
      streamReview: {
        name: "StreamReview",
        I: pot,
        O: vot,
        kind: I.ServerStreaming,
      },
      streamReviewChat: {
        name: "StreamReviewChat",
        I: h2t,
        O: d2t,
        kind: I.ServerStreaming,
      },
      streamSlowReview: {
        name: "StreamSlowReview",
        I: pot,
        O: vot,
        kind: I.ServerStreaming,
      },
      bugConfig: { name: "BugConfig", I: s2t, O: fot, kind: I.Unary },
      streamBugBotLinter: {
        name: "StreamBugBotLinter",
        I: o2t,
        O: c2t,
        kind: I.ServerStreaming,
      },
      streamBugFinding: {
        name: "StreamBugFinding",
        I: p2t,
        O: m2t,
        kind: I.ServerStreaming,
      },
    },
  },
  yot = {
    typeName: "aiserver.v1.FastApplyService",
    methods: {
      reportEditFate: { name: "ReportEditFate", I: WDt, O: jDt, kind: I.Unary },
      warmApply: { name: "WarmApply", I: VDt, O: GDt, kind: I.Unary },
    },
  },
  y2t = class GA extends h {
    constructor(t) {
      super(),
        (this.maxConcurrentUploads = 0),
        (this.absoluteMaxNumberFiles = 0),
        (this.maxFileRetries = 0),
        (this.syncConcurrency = 0),
        (this.autoIndexingMaxNumFiles = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IndexingConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "max_concurrent_uploads", kind: "scalar", T: 5 },
        { no: 2, name: "absolute_max_number_files", kind: "scalar", T: 5 },
        { no: 3, name: "max_file_retries", kind: "scalar", T: 5 },
        { no: 4, name: "sync_concurrency", kind: "scalar", T: 5 },
        { no: 5, name: "auto_indexing_max_num_files", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new GA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GA, t, e)
    }
  },
  b2t = class zA extends h {
    constructor(t) {
      super(),
        (this.globalSampleRate = 0),
        (this.tracesSampleRate = 0),
        (this.loggerSampleRate = 0),
        (this.minidumpSampleRate = 0),
        (this.errorRateLimit = 0),
        (this.performanceUnitRateLimit = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClientTracingConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "global_sample_rate", kind: "scalar", T: 1 },
        { no: 2, name: "traces_sample_rate", kind: "scalar", T: 1 },
        { no: 3, name: "logger_sample_rate", kind: "scalar", T: 1 },
        { no: 4, name: "minidump_sample_rate", kind: "scalar", T: 1 },
        { no: 5, name: "error_rate_limit", kind: "scalar", T: 1 },
        { no: 6, name: "performance_unit_rate_limit", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new zA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zA, t, e)
    }
  },
  T2t = class YA extends h {
    constructor(t) {
      super(),
        (this.disableUnification = !1),
        (this.fullContextTokenLimit = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "disable_unification", kind: "scalar", T: 8 },
        { no: 2, name: "full_context_token_limit", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new YA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YA, t, e)
    }
  },
  k2t = class QA extends h {
    constructor(t) {
      super(),
        (this.telemEnabled = !1),
        (this.bugBotDismissedNotificationLast10TimesUnixMs = []),
        (this.bugBotViewedNotificationLast10TimesUnixMs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetServerConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "telem_enabled", kind: "scalar", T: 8 },
        {
          no: 2,
          name: "bug_bot_dismissed_notification_last_10_times_unix_ms",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
        {
          no: 3,
          name: "bug_bot_viewed_notification_last_10_times_unix_ms",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new QA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QA, t, e)
    }
  },
  S2t = class XA extends h {
    constructor(t) {
      super(),
        (this.isDevDoNotUseForSecretThingsBecauseCanBeSpoofedByUsers = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetServerConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_config_response", kind: "message", T: fot },
        {
          no: 2,
          name: "is_dev_do_not_use_for_secret_things_because_can_be_spoofed_by_users",
          kind: "scalar",
          T: 8,
        },
        { no: 3, name: "indexing_config", kind: "message", T: y2t },
        { no: 4, name: "client_tracing_config", kind: "message", T: b2t },
        { no: 5, name: "chat_config", kind: "message", T: T2t },
      ])
    }
    static fromBinary(t, e) {
      return new XA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XA, t, e)
    }
  },
  bot = {
    typeName: "aiserver.v1.ServerConfigService",
    methods: {
      getServerConfig: {
        name: "GetServerConfig",
        I: k2t,
        O: S2t,
        kind: I.Unary,
      },
    },
  },
  Tot = {
    typeName: "aiserver.v1.ChatService",
    methods: {
      streamUnifiedChat: {
        name: "StreamUnifiedChat",
        I: BW,
        O: sat,
        kind: I.ServerStreaming,
      },
      streamUnifiedChatWithTools: {
        name: "StreamUnifiedChatWithTools",
        I: VRt,
        O: GRt,
        kind: I.BiDiStreaming,
      },
      streamParallelApply: {
        name: "StreamParallelApply",
        I: WRt,
        O: jRt,
        kind: I.ServerStreaming,
      },
      getConversationSummary: {
        name: "GetConversationSummary",
        I: BW,
        O: Nn,
        kind: I.Unary,
      },
    },
  },
  E2t = class KA extends h {
    constructor(t) {
      super(), (this.data = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EventData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "string_value", kind: "scalar", T: 9, oneof: "data" },
        { no: 2, name: "int_value", kind: "scalar", T: 3, oneof: "data" },
        { no: 3, name: "bool_value", kind: "scalar", T: 8, oneof: "data" },
        { no: 4, name: "double_value", kind: "scalar", T: 1, oneof: "data" },
      ])
    }
    static fromBinary(t, e) {
      return new KA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KA, t, e)
    }
  },
  I2t = class ZA extends h {
    constructor(t) {
      super(),
        (this.eventName = ""),
        (this.eventData = {}),
        (this.timestamp = _e.zero),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AnalyticsEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "event_name", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "event_data",
          kind: "map",
          K: 9,
          V: { kind: "message", T: E2t },
        },
        { no: 3, name: "timestamp", kind: "scalar", T: 3 },
      ])
    }
    static fromBinary(t, e) {
      return new ZA().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZA().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZA().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZA, t, e)
    }
  },
  P2t = class t_ extends h {
    constructor(t) {
      super(), (this.events = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TrackEventsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "events", kind: "message", T: I2t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new t_().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t_().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t_().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t_, t, e)
    }
  },
  $2t = class e_ extends h {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TrackEventsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new e_().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e_().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e_().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e_, t, e)
    }
  },
  kot = {
    typeName: "aiserver.v1.AnalyticsService",
    methods: {
      trackEvents: { name: "TrackEvents", I: P2t, O: $2t, kind: I.Unary },
    },
  },
  Sot = {
    [Uat.typeName]: Uat,
    [Wat.typeName]: Wat,
    [Hat.typeName]: Hat,
    [kot.typeName]: kot,
    [jat.typeName]: jat,
    [Tot.typeName]: Tot,
    [Vat.typeName]: Vat,
    [sot.typeName]: sot,
    [dot.typeName]: dot,
    [Ynt.typeName]: Ynt,
    [Qnt.typeName]: Qnt,
    [Gat.typeName]: Gat,
    [uot.typeName]: uot,
    [Yat.typeName]: Yat,
    [eot.typeName]: eot,
    [iot.typeName]: iot,
    [lot.typeName]: lot,
    [km.typeName]: km,
    [cot.typeName]: cot,
    [oot.typeName]: oot,
    [mot.typeName]: mot,
    [wot.typeName]: wot,
    [yot.typeName]: yot,
    [hot.typeName]: hot,
    [bot.typeName]: bot,
  },
  x2t = class {
    constructor(i) {
      ;(this.g = i),
        (this.a = []),
        (this.c = void 0),
        (this.d = void 0),
        (this.f = !1),
        (this.h = void 0),
        (this.b = new Promise((t, e) => {
          ;(this.c = t), (this.d = e)
        }))
    }
    push(i) {
      this.a.push(i), this.c && this.c()
    }
    end() {
      this.c && this.c(), (this.f = !0)
    }
    error(i) {
      this.d && this.d(i), (this.h = i)
    }
    i() {
      const i = this
      this.b = new Promise((t, e) => {
        ;(this.c = t), (this.d = e)
      }).catch((t) => {
        i.h = t
      })
    }
    [Symbol.asyncIterator]() {
      const i = this.g
      return {
        next: async () => {
          try {
            if (this.h !== void 0) throw this.h
            if (this.a.length > 0) return { done: !1, value: this.a.shift() }
            if (this.f) return { done: !0, value: void 0 }
            const t = await Promise.race([
              this.b.then(() => !1),
              new Promise((e) => setTimeout(() => e(!0), i)),
            ])
            if (this.h !== void 0) throw this.h
            if (this.a.length > 0) return { done: !1, value: this.a.shift() }
            if (t || this.f) return { done: !0, value: void 0 }
            throw new Error("AsyncIterPushable: should not be here")
          } finally {
            this.i()
          }
        },
      }
    }
  },
  N2t = 1e6,
  XXt = Date.now(),
  YW =
    "src.vs.platform.reactivestorage.browser.reactiveStorageServiceImpl.persistentStorage",
  KXt = `${YW}.applicationUser`,
  ZXt = `${YW}.workspaceUser`,
  tKt = `${YW}.applicationUser.subscription`,
  C2t = "workbench.panel.aichat.view",
  eKt = C2t + ".aichat.chatdata"
function J2t(i, t) {
  return t.onProcessConfigUpdate((e) => {
    ;(ds().enabled = e.enabled),
      (ds().loggerSampleRate = e.loggerSampleRate),
      (ds().tracesSampleRate = e.tracesSampleRate)
  })
}
function L2t(i, t, e = Sft(64)) {
  const s = {
      flush: (a) => e.drain(a),
      send: (a) =>
        e
          .add(() => t.sendEnvelope(i, a))
          .then(
            (o) => ({ statusCode: 200 }),
            (o) => {
              if (o instanceof uz) return {}
              throw o
            },
          ),
    },
    r = ds().buffer
  for (const a of r) s.send(a)
  return (ds().buffer = []), (ds().transport = s), at.None
}
function R2t(i, t) {
  if (i === "main") return at.None
  const e = (s) => {
    const r = {}
    s.breadcrumbs.length > 0 && (r.breadcrumbs = s.breadcrumbs),
      Object.keys(r).length > 0 && t.sendScopeUpdate(i, r)
  }
  return (
    yc().addScopeListener((s) => {
      e(s.getScopeData()), yc().clearBreadcrumbs()
    }),
    e(yc().getScopeData()),
    yc().clearBreadcrumbs(),
    at.None
  )
}
function D2t(i, t) {
  const e = new gt()
  return e.add(J2t(i, t)), e.add(L2t(i, t)), e.add(R2t(i, t)), e
}
function l3(i) {
  const t = []
  for (const [s, r] of Object.entries(i)) t.push(new Met({ key: s, value: r }))
  return new RM({ headers: t })
}
var F2t = class {
    async $updateCppSessionId(i) {
      this.R = i
    }
    async $updateCppTelemEnabled(i) {
      this.S = i
    }
    async $changePreferredEmbeddingModel(i) {
      this.w = i
    }
    constructor(i, t, e) {
      ;(this.W = t),
        (this.X = e),
        (this.b = new J()),
        (this.onDidChangeCursorCreds = this.b.event),
        (this.c = new J()),
        (this.onDidChangePrivacyMode = this.c.event),
        (this.d = new J()),
        (this.onDidChangeCursorAuthToken = this.d.event),
        (this.f = new J()),
        (this.onDidRequestRepoIndex = this.f.event),
        (this.g = new J()),
        (this.onDidRequestRepoInterrupt = this.g.event),
        (this.h = new J()),
        (this.onDidChangeFileSyncClientEnabled = this.h.event),
        (this.i = new J()),
        (this.onDidChangeCppEnabled = this.i.event),
        (this.j = new J()),
        (this.onDidChangeCppConfig = this.j.event),
        (this.l = new J()),
        (this.onDidChangeMembershipType = this.l.event),
        (this.n = new J()),
        (this.onProcessConfigUpdate = this.n.event),
        (this.p = !0),
        (this.s = !0),
        (this.t = !0),
        (this.x = !0),
        (this.P = []),
        (this.Q = []),
        (this.Y = void 0),
        (this.bb = N2t),
        (this.cb = new Map()),
        (this.eb = void 0),
        (this.fb = void 0),
        (this.gb = void 0),
        (this.a = i.getProxy(K.MainThreadCursor)),
        D2t("extension", this.W),
        this.a.$getCursorCreds().then((s) => {
          ;(this.o = s), this.b.fire(s)
        }),
        this.a.$getPrivacyMode().then((s) => {
          ;(this.p = s), this.c.fire(s)
        }),
        this.a.$getCursorAuthToken().then((s) => {
          ;(this.r = s), this.d.fire(s)
        }),
        this.a.$isFileSyncClientEnabled().then((s) => {
          this.s = s
        }),
        this.a.$cppEnabled().then((s) => {
          this.t = s
        }),
        this.a.$cppConfig().then((s) => {
          ;(this.u = s), this.j.fire(s)
        }),
        this.a.$membershipType().then((s) => {
          ;(this.v = s), this.l.fire(s)
        }),
        this.a.$preferredEmbeddingModel().then((s) => {
          this.w = s
        }),
        this.a.$getMachineId().then((s) => {
          this.U = s
        }),
        this.a.$getMacMachineId().then((s) => {
          this.V = s
        })
    }
    getCursorCreds() {
      return this.o
    }
    getPrivacyMode() {
      return this.p
    }
    isFileSyncClientEnabled() {
      return this.s
    }
    cppEnabled() {
      return this.t
    }
    cppConfig() {
      return this.u
    }
    membershipType() {
      return this.v
    }
    preferredEmbeddingModel() {
      return this.w
    }
    shouldIndex() {
      return this.x
    }
    getCursorAuthToken() {
      return this.r
    }
    getSemanticSearchResultsFromServer(i) {
      return this.a.$getSemanticSearchResultsFromServer(i)
    }
    getMachineId() {
      return this.U
    }
    getMacMachineId() {
      return this.V
    }
    $shouldIgnoreUri(i) {
      return this.a.$shouldIgnoreUri(i)
    }
    $adminBlocklistPath() {
      return this.a.$adminBlocklistPath()
    }
    $changeCursorCreds(i) {
      return (this.o = i), this.b.fire(i), Promise.resolve()
    }
    $changePrivacyMode(i) {
      const t = this.p
      return (this.p = i), t !== i && this.c.fire(i), Promise.resolve()
    }
    $changeShouldIndex(i) {
      return (this.x = i), Promise.resolve()
    }
    $changeCursorAuthToken(i) {
      return (this.r = i), this.d.fire(i), Promise.resolve()
    }
    $triggerCursorIndex() {
      return this.f.fire(), Promise.resolve()
    }
    $triggerCursorInterrupt(i) {
      return this.g.fire(i), Promise.resolve()
    }
    $changeFileSyncClientEnabled(i) {
      return (this.s = i), this.h.fire(i), Promise.resolve()
    }
    $changeCppEnabled(i) {
      return (this.t = i), this.i.fire(i), Promise.resolve()
    }
    $changeCppConfig(i) {
      return (this.u = i), this.j.fire(i), Promise.resolve()
    }
    $changeMembershipType(i) {
      return (this.v = i), this.l.fire(i), Promise.resolve()
    }
    updateUploadProgress(i, t, e = !1) {
      this.a.$updateUploadProgress(i, t, e)
    }
    showWebCmdKInputBox(i) {
      return this.a.$showWebCmdKInputBox(i)
    }
    processAiReaderMessage(i) {
      return this.a.$processAiReaderMessage(i)
    }
    $getIndexProviderGetGlobalStatus() {
      const i = this.y
      return i ? i() : Promise.resolve(void 0)
    }
    $getIndexProviderGetStatus(i) {
      const t = this.z?.(i)
      return t || Promise.resolve(void 0)
    }
    $getIndexProviderGetRepoInfo() {
      return this.D ? this.D.getRepoInfo() : Promise.resolve(void 0)
    }
    $getIndexProviderGetPathEncryptionKey() {
      return this.D
        ? this.D.getPathEncryptionKey_ONLY_FOR_VM_AGENT()
        : Promise.resolve(void 0)
    }
    $getIndexProviderDecryptPaths(i) {
      return this.D ? this.D.decryptPaths(i) : Promise.resolve(i)
    }
    $getIndexProviderCompileGlobFilter(i) {
      return this.D
        ? this.D.compileGlobFilter(i)
        : Promise.resolve({ globFilter: void 0, notGlobFilter: void 0 })
    }
    $getIndexProviderGetCodebases() {
      return this.D ? this.D.getCodebases() : Promise.resolve(void 0)
    }
    $getIndexProviderGetIndexingProgress(i) {
      const t = this.A
      return t ? t(i) : Promise.resolve(void 0)
    }
    $getIndexProviderGetCurrentJobs(i) {
      const t = this.B
      return t ? t(i) : Promise.resolve(void 0)
    }
    $getIndexProviderGetHighLevelFolderDescription() {
      const i = this.C
      return i ? i() : Promise.resolve(void 0)
    }
    async $forceFlushExtHostEventLogger() {
      return this.Y?.forceFlush()
    }
    async $recordExtHostEvent(i) {
      return this.Y?.recordExtHostEvent(i)
    }
    $getMetricsProviderIncrement(i) {
      const t = this.E
      return t && t(i), Promise.resolve()
    }
    $getMetricsProviderDecrement(i) {
      const t = this.F
      return t && t(i), Promise.resolve()
    }
    $getMetricsProviderDistribution(i) {
      const t = this.G
      return t && t(i), Promise.resolve()
    }
    $getMetricsProviderGauge(i) {
      const t = this.H
      return t && t(i), Promise.resolve()
    }
    $request(i, t) {
      return this.J ? this.J(i, t) : Promise.resolve("")
    }
    $flush(i) {
      return this.L?.(i) ?? Promise.resolve([])
    }
    $cancel(i) {
      this.M?.(i)
    }
    $getDiffingProviderWordDiff(i, t) {
      const e = this.N
      return e
        ? e(i, t)
        : Promise.resolve({
            changes: [
              { value: t, added: !0 },
              { value: i, removed: !0 },
            ],
          })
    }
    async $getEverythingProviderRunCommand(i, t) {
      const e = this.P
      if (e.length > 0) {
        const s = []
        for (const a of e) s.push(a(i, t))
        const r = await Promise.allSettled(s)
        for (const a of r)
          if (a.status === "fulfilled" && a.value !== void 0) return a.value
      }
    }
    async $getEverythingAllLocalProviderRunCommand(i, t) {
      const e = this.Q
      if (e.length > 0) {
        const s = []
        for (const a of e) s.push(a(i, t))
        const r = await Promise.allSettled(s)
        for (const a of r)
          if (a.status === "fulfilled" && a.value !== void 0) return a.value
      }
    }
    getCppSessionId() {
      return this.R
    }
    getCppTelemEnabled() {
      return (this.S ?? !1) && this.getPrivacyMode() !== !0
    }
    onDidChangeIndexingStatus() {
      return (
        this.a.$onDidChangeIndexingStatus(),
        et(() => {
          this.a.$unregisterOnDidChangeIndexingStatus()
        })
      )
    }
    async triggerRefreshCursorAuthToken() {
      await this.a.$triggerRefreshCursorAuthToken(),
        (this.r = await this.a.$getCursorAuthToken())
    }
    registerExtHostEventLogger(i) {
      return (
        (this.Y = i),
        this.a.$registerExtHostEventLogger(),
        et(() => {
          this.a.$unregisterExtHostEventLogger(), (this.Y = void 0)
        })
      )
    }
    registerIndexProvider(i) {
      return (
        (this.B = i.getCurrentJobs),
        (this.A = i.getIndexingProgress),
        (this.z = i.getStatus),
        (this.C = i.getHighLevelFolderDescription),
        (this.y = i.getGlobalStatus),
        (this.D = i),
        this.a.$registerIndexProvider(),
        et(() => {
          this.a.$unregisterIndexProvider(),
            (this.B = void 0),
            (this.A = void 0),
            (this.z = void 0),
            (this.C = void 0),
            (this.y = void 0),
            (this.D = void 0)
        })
      )
    }
    registerRequesterProvider(i) {
      return (
        (this.J = i.request),
        (this.L = i.flush),
        (this.M = i.cancel),
        this.a.$registerRequesterProvider(),
        et(() => {
          this.a.$unregisterRequesterProvider()
        })
      )
    }
    registerShadowClientProvider(i) {
      return (
        (this.$ = i.get),
        this.a.$registerShadowClientProvider(),
        et(() => {
          this.a.$unregisterShadowClientProvider(), (this.$ = void 0)
        })
      )
    }
    registerShadowServerProvider(i) {
      return (
        (this.Z = i.start),
        this.a.$registerShadowServerProvider(),
        et(() => {
          this.a.$unregisterShadowServerProvider(), (this.Z = void 0)
        })
      )
    }
    $getShadowServerProviderStart(i) {
      return (
        this.Z &&
          this.Z(
            i,
            new Proxy(
              {},
              {
                get: (t, e, s) => {
                  if (typeof e == "string") {
                    const r = km.methods[e]?.I
                    if (r === void 0) return
                    const a = km.methods[e]?.O
                    if (a === void 0) return
                    const o = e
                    return async (c) => {
                      const l = new r(c),
                        u = await this.a.$callShadowServer(
                          o,
                          Q.wrap(l.toBinary()),
                        )
                      return a.fromBinary(u.buffer)
                    }
                  }
                },
              },
            ),
          ),
        Promise.resolve()
      )
    }
    async $createShadowClient(i) {
      this.$ && (this.ab = await this.$(i))
    }
    async $callShadowServer(i, t) {
      if (this.ab === void 0) throw new Error("Shadow client not initialized")
      const e = this.ab,
        r = e[i].bind(e),
        o = km.methods[i].I.fromBinary(t.buffer),
        c = await r(o)
      return Q.wrap(c.toBinary())
    }
    async $callAiConnectTransportProviderUnary(i, t, e, s, r, a) {
      if (this.gb) {
        const o = Sot[i],
          c = o.methods[t],
          l = new AbortController()
        a.onCancellationRequested(() => {
          l.abort()
        })
        const u = l.signal
        let d
        try {
          d = c.I.fromBinary(e.buffer)
        } catch (m) {
          throw (
            (console.error(
              "CONCERNING!!! PLEASE REPORT TO SUALEH",
              "ERROR IN THE EXTHOST",
              m,
            ),
            m)
          )
        }
        try {
          const m = await this.gb.unary(o, c, u, s, r, d),
            f = Object.fromEntries(m.header),
            p = Object.fromEntries(m.trailer),
            v = l3(f),
            b = l3(p),
            k = new Y8({
              message: m.message.toBinary(),
              header: v,
              trailer: b,
              isError: !1,
            })
          return Q.wrap(k.toBinary())
        } catch (m) {
          const f = new Y8({
            message: new Uint8Array(0),
            isError: !0,
            connectError: JSON.stringify(m),
          })
          return Q.wrap(f.toBinary())
        }
      }
      throw new Error(
        "BIG PROBLEM. BIG PROBLEM. BIG PROBLEM. BIG PROBLEM. BIG PROBLEM. BIG PROBLEM. Connect transport provider not initialized. BIG PROBLEM.",
      )
    }
    db(i) {
      const t = i ?? this.bb,
        e = new x2t(t),
        s = new AbortController()
      return { promiseQueue: e, canceller: s }
    }
    async $callAiConnectTransportProviderStream(i, t, e, s, r, a, o) {
      if (this.gb) {
        const c = Sot[t],
          l = c.methods[e]
        if (!this.cb.get(i)) {
          const { promiseQueue: k, canceller: E } = this.db(s)
          this.cb.set(i, { promiseQueue: k, canceller: E })
        }
        const d = this.cb.get(i)
        if (d === void 0) throw new Error("Stream ID not found. BIG PROBLEM.")
        const m = d.canceller
        o.onCancellationRequested(() => {
          m.abort()
        })
        const f = m.signal,
          p = d.promiseQueue,
          v = this.cb,
          b = async function* () {
            try {
              for await (const k of p) {
                if (v.get(i)?.canceller.signal.aborted) break
                yield l.I.fromBinary(k.buffer)
              }
            } finally {
            }
          }
        try {
          const k = await this.gb.stream(c, l, f, s, r, b(), a)
          Promise.resolve()
            .then(async () => {
              for await (const V of k.message) {
                if (v.get(i)?.canceller.signal.aborted) break
                const tt = Q.wrap(V.toBinary())
                this.a.$pushAiConnectTransportStreamChunk(tt, i)
              }
              this.a.$endAiConnectTransportStreamChunk(i)
            })
            .catch((V) => {
              this.a.$endAiConnectTransportReportError(i, V)
            })
            .finally(() => {
              v.delete(i)
            })
          const E = Object.fromEntries(k.header),
            P = Object.fromEntries(k.trailer),
            C = l3(E),
            R = l3(P),
            D = new Y8({
              message: new Uint8Array(0),
              header: C,
              trailer: R,
              isError: !1,
            })
          return Q.wrap(D.toBinary())
        } catch (k) {
          const E = new Y8({
            message: new Uint8Array(0),
            isError: !0,
            connectError: JSON.stringify(k),
          })
          return Q.wrap(E.toBinary())
        }
      }
      throw new Error(
        "Connect transport provider not initialized. BIG PROBLEM.",
      )
    }
    async $pushAiConnectTransportStreamChunk(i, t, e) {
      const s = this.cb.get(t)
      if (s) return s.promiseQueue.push(i), { success: !0 }
      {
        const { promiseQueue: r, canceller: a } = this.db(e)
        return (
          this.cb.set(t, { promiseQueue: r, canceller: a }),
          r.push(i),
          { success: !0 }
        )
      }
    }
    $endAiConnectTransportStreamChunk(i) {
      const t = this.cb.get(i)
      if (t) t.promiseQueue.end()
      else {
        const { promiseQueue: e, canceller: s } = this.db(this.bb)
        this.cb.set(i, { promiseQueue: e, canceller: s }), e.end()
      }
    }
    $cancelAiConnectTransportStreamChunk(i) {
      const t = this.cb.get(i)
      if (t) t.canceller.abort()
      else {
        const { promiseQueue: e, canceller: s } = this.db(this.bb)
        this.cb.set(i, { promiseQueue: e, canceller: s }), s.abort()
      }
    }
    registerMetricsProvider(i) {
      return (
        (this.E = i.increment),
        (this.F = i.decrement),
        (this.G = i.distribution),
        (this.H = i.gauge),
        this.a.$registerMetricsProvider(),
        et(() => {
          this.a.$unregisterMetricsProvider(),
            (this.E = void 0),
            (this.F = void 0),
            (this.G = void 0),
            (this.H = void 0)
        })
      )
    }
    registerDiffingProvider(i) {
      return (
        (this.N = i.wordDiff),
        this.a.$registerDiffingProvider(),
        et(() => {
          this.a.$unregisterDiffingProvider()
        })
      )
    }
    registerEverythingProvider(i) {
      return (
        this.P.push(i.runCommand),
        this.a.$registerEverythingProvider(),
        et(() => {
          this.a.$unregisterEverythingProvider()
        })
      )
    }
    registerEverythingProviderAllLocal(i) {
      return (
        this.Q.push(i.runCommand),
        this.a.$registerEverythingProviderAllLocal(),
        et(() => {
          this.a.$unregisterEverythingProviderAllLocal()
        })
      )
    }
    registerEditHistoryProvider(i) {
      return (
        (this.eb = i),
        this.a.$registerEditHistoryProvider(),
        et(() => {
          this.a.$unregisterEditHistoryProvider(), (this.eb = void 0)
        })
      )
    }
    async $getEditHistoryProviderCompileGlobalDiffTrajectories(i) {
      const t = this.eb
      if (t) return t.compileGlobalDiffTrajectories(i)
    }
    async $getEditHistoryProviderHasProcessedTextModelUptilVersion(i) {
      const t = this.eb
      if (t) return t.hasProcessedTextModelUptilVersion(i)
    }
    async $getEditHistoryProviderInitModel(i) {
      const t = this.eb
      if (t) return t.initModel(i)
    }
    registerLspSubgraphProvider(i) {
      return (
        (this.fb = i),
        this.a.$registerLspSubgraphProvider(),
        et(() => {
          this.a.$unregisterLspSubgraphProvider(), (this.fb = void 0)
        })
      )
    }
    registerConnectTransportProvider(i) {
      ;(this.gb = i), this.a.$registerAiConnectTransportProvider()
    }
    $callLspSubgraphProviderActivate() {
      const i = this.fb
      i && i.activate()
    }
    $callLspSubgraphProviderDeactivate() {
      const i = this.fb
      i && i.deactivate()
    }
    $callLspSubgraphProviderDebouncedForceAbort() {
      const i = this.fb
      i && i.debouncedForceAbort()
    }
    $callLspSubgraphProviderRetrieve(i, t, e, s, r, a) {
      const o = this.fb
      return o ? o.retrieve(i, t, e, s, r, a) : Promise.resolve(void 0)
    }
    publicLogCapture(i) {
      this.a.$publicLogCapture(i)
    }
    async $processConfigUpdate(i) {
      await this.W.processConfigUpdate(i)
    }
  },
  u3 = {},
  Vt = { exports: u3 }
;(function (i, t) {
  if (typeof u3 == "object" && typeof Vt == "object") Vt.exports = t()
  else if (typeof define == "function" && define.amd) define([], t)
  else {
    var e = t()
    for (var s in e) (typeof u3 == "object" ? u3 : i)[s] = e[s]
  }
})(typeof self < "u" ? self : void 0, function () {
  return (function (i) {
    var t = {}
    function e(s) {
      if (t[s]) return t[s].exports
      var r = (t[s] = { i: s, l: !1, exports: {} })
      return i[s].call(r.exports, r, r.exports, e), (r.l = !0), r.exports
    }
    return (
      (e.m = i),
      (e.c = t),
      (e.d = function (s, r, a) {
        e.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: a })
      }),
      (e.r = function (s) {
        typeof Symbol < "u" &&
          Symbol.toStringTag &&
          Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(s, "__esModule", { value: !0 })
      }),
      (e.t = function (s, r) {
        if (
          (1 & r && (s = e(s)),
          8 & r || (4 & r && typeof s == "object" && s && s.__esModule))
        )
          return s
        var a = Object.create(null)
        if (
          (e.r(a),
          Object.defineProperty(a, "default", { enumerable: !0, value: s }),
          2 & r && typeof s != "string")
        )
          for (var o in s)
            e.d(
              a,
              o,
              function (c) {
                return s[c]
              }.bind(null, o),
            )
        return a
      }),
      (e.n = function (s) {
        var r =
          s && s.__esModule
            ? function () {
                return s.default
              }
            : function () {
                return s
              }
        return e.d(r, "a", r), r
      }),
      (e.o = function (s, r) {
        return Object.prototype.hasOwnProperty.call(s, r)
      }),
      (e.p = ""),
      e((e.s = 0))
    )
  })([
    function (i, t, e) {
      ;(function (s) {
        var r
        ;(t = i.exports = te),
          (r =
            typeof s == "object" &&
            s.env &&
            s.env.NODE_DEBUG &&
            /\bsemver\b/i.test(s.env.NODE_DEBUG)
              ? function () {
                  var N = Array.prototype.slice.call(arguments, 0)
                  N.unshift("SEMVER"), console.log.apply(console, N)
                }
              : function () {}),
          (t.SEMVER_SPEC_VERSION = "2.0.0")
        var a = 256,
          o = Number.MAX_SAFE_INTEGER || 9007199254740991,
          c = (t.re = []),
          l = (t.src = []),
          u = 0,
          d = u++
        l[d] = "0|[1-9]\\d*"
        var m = u++
        l[m] = "[0-9]+"
        var f = u++
        l[f] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*"
        var p = u++
        l[p] = "(" + l[d] + ")\\.(" + l[d] + ")\\.(" + l[d] + ")"
        var v = u++
        l[v] = "(" + l[m] + ")\\.(" + l[m] + ")\\.(" + l[m] + ")"
        var b = u++
        l[b] = "(?:" + l[d] + "|" + l[f] + ")"
        var k = u++
        l[k] = "(?:" + l[m] + "|" + l[f] + ")"
        var E = u++
        l[E] = "(?:-(" + l[b] + "(?:\\." + l[b] + ")*))"
        var P = u++
        l[P] = "(?:-?(" + l[k] + "(?:\\." + l[k] + ")*))"
        var C = u++
        l[C] = "[0-9A-Za-z-]+"
        var R = u++
        l[R] = "(?:\\+(" + l[C] + "(?:\\." + l[C] + ")*))"
        var D = u++,
          V = "v?" + l[p] + l[E] + "?" + l[R] + "?"
        l[D] = "^" + V + "$"
        var tt = "[v=\\s]*" + l[v] + l[P] + "?" + l[R] + "?",
          Z = u++
        l[Z] = "^" + tt + "$"
        var M = u++
        l[M] = "((?:<|>)?=?)"
        var rt = u++
        l[rt] = l[m] + "|x|X|\\*"
        var Jt = u++
        l[Jt] = l[d] + "|x|X|\\*"
        var ct = u++
        l[ct] =
          "[v=\\s]*(" +
          l[Jt] +
          ")(?:\\.(" +
          l[Jt] +
          ")(?:\\.(" +
          l[Jt] +
          ")(?:" +
          l[E] +
          ")?" +
          l[R] +
          "?)?)?"
        var me = u++
        l[me] =
          "[v=\\s]*(" +
          l[rt] +
          ")(?:\\.(" +
          l[rt] +
          ")(?:\\.(" +
          l[rt] +
          ")(?:" +
          l[P] +
          ")?" +
          l[R] +
          "?)?)?"
        var j = u++
        l[j] = "^" + l[M] + "\\s*" + l[ct] + "$"
        var z = u++
        l[z] = "^" + l[M] + "\\s*" + l[me] + "$"
        var ot = u++
        l[ot] =
          "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])"
        var it = u++
        l[it] = "(?:~>?)"
        var nt = u++
        ;(l[nt] = "(\\s*)" + l[it] + "\\s+"), (c[nt] = new RegExp(l[nt], "g"))
        var $t = u++
        l[$t] = "^" + l[it] + l[ct] + "$"
        var Bt = u++
        l[Bt] = "^" + l[it] + l[me] + "$"
        var xt = u++
        l[xt] = "(?:\\^)"
        var oe = u++
        ;(l[oe] = "(\\s*)" + l[xt] + "\\s+"), (c[oe] = new RegExp(l[oe], "g"))
        var mi = u++
        l[mi] = "^" + l[xt] + l[ct] + "$"
        var Ce = u++
        l[Ce] = "^" + l[xt] + l[me] + "$"
        var wi = u++
        l[wi] = "^" + l[M] + "\\s*(" + tt + ")$|^$"
        var Ri = u++
        l[Ri] = "^" + l[M] + "\\s*(" + V + ")$|^$"
        var ye = u++
        ;(l[ye] = "(\\s*)" + l[M] + "\\s*(" + tt + "|" + l[ct] + ")"),
          (c[ye] = new RegExp(l[ye], "g"))
        var Vr = u++
        l[Vr] = "^\\s*(" + l[ct] + ")\\s+-\\s+(" + l[ct] + ")\\s*$"
        var ec = u++
        l[ec] = "^\\s*(" + l[me] + ")\\s+-\\s+(" + l[me] + ")\\s*$"
        var Fa = u++
        l[Fa] = "(<|>)?=?\\s*\\*"
        for (var Is = 0; Is < 35; Is++)
          r(Is, l[Is]), c[Is] || (c[Is] = new RegExp(l[Is]))
        function Ct(N, A) {
          if (N instanceof te) return N
          if (
            typeof N != "string" ||
            N.length > a ||
            !(A ? c[Z] : c[D]).test(N)
          )
            return null
          try {
            return new te(N, A)
          } catch {
            return null
          }
        }
        function te(N, A) {
          if (N instanceof te) {
            if (N.loose === A) return N
            N = N.version
          } else if (typeof N != "string")
            throw new TypeError("Invalid Version: " + N)
          if (N.length > a)
            throw new TypeError("version is longer than " + a + " characters")
          if (!(this instanceof te)) return new te(N, A)
          r("SemVer", N, A), (this.loose = A)
          var q = N.trim().match(A ? c[Z] : c[D])
          if (!q) throw new TypeError("Invalid Version: " + N)
          if (
            ((this.raw = N),
            (this.major = +q[1]),
            (this.minor = +q[2]),
            (this.patch = +q[3]),
            this.major > o || this.major < 0)
          )
            throw new TypeError("Invalid major version")
          if (this.minor > o || this.minor < 0)
            throw new TypeError("Invalid minor version")
          if (this.patch > o || this.patch < 0)
            throw new TypeError("Invalid patch version")
          q[4]
            ? (this.prerelease = q[4].split(".").map(function (mt) {
                if (/^[0-9]+$/.test(mt)) {
                  var It = +mt
                  if (It >= 0 && It < o) return It
                }
                return mt
              }))
            : (this.prerelease = []),
            (this.build = q[5] ? q[5].split(".") : []),
            this.format()
        }
        ;(t.parse = Ct),
          (t.valid = function (N, A) {
            var q = Ct(N, A)
            return q ? q.version : null
          }),
          (t.clean = function (N, A) {
            var q = Ct(N.trim().replace(/^[=v]+/, ""), A)
            return q ? q.version : null
          }),
          (t.SemVer = te),
          (te.prototype.format = function () {
            return (
              (this.version = this.major + "." + this.minor + "." + this.patch),
              this.prerelease.length &&
                (this.version += "-" + this.prerelease.join(".")),
              this.version
            )
          }),
          (te.prototype.toString = function () {
            return this.version
          }),
          (te.prototype.compare = function (N) {
            return (
              r("SemVer.compare", this.version, this.loose, N),
              N instanceof te || (N = new te(N, this.loose)),
              this.compareMain(N) || this.comparePre(N)
            )
          }),
          (te.prototype.compareMain = function (N) {
            return (
              N instanceof te || (N = new te(N, this.loose)),
              is(this.major, N.major) ||
                is(this.minor, N.minor) ||
                is(this.patch, N.patch)
            )
          }),
          (te.prototype.comparePre = function (N) {
            if (
              (N instanceof te || (N = new te(N, this.loose)),
              this.prerelease.length && !N.prerelease.length)
            )
              return -1
            if (!this.prerelease.length && N.prerelease.length) return 1
            if (!this.prerelease.length && !N.prerelease.length) return 0
            var A = 0
            do {
              var q = this.prerelease[A],
                mt = N.prerelease[A]
              if (
                (r("prerelease compare", A, q, mt),
                q === void 0 && mt === void 0)
              )
                return 0
              if (mt === void 0) return 1
              if (q === void 0) return -1
              if (q !== mt) return is(q, mt)
            } while (++A)
          }),
          (te.prototype.inc = function (N, A) {
            switch (N) {
              case "premajor":
                ;(this.prerelease.length = 0),
                  (this.patch = 0),
                  (this.minor = 0),
                  this.major++,
                  this.inc("pre", A)
                break
              case "preminor":
                ;(this.prerelease.length = 0),
                  (this.patch = 0),
                  this.minor++,
                  this.inc("pre", A)
                break
              case "prepatch":
                ;(this.prerelease.length = 0),
                  this.inc("patch", A),
                  this.inc("pre", A)
                break
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", A),
                  this.inc("pre", A)
                break
              case "major":
                ;(this.minor === 0 &&
                  this.patch === 0 &&
                  this.prerelease.length !== 0) ||
                  this.major++,
                  (this.minor = 0),
                  (this.patch = 0),
                  (this.prerelease = [])
                break
              case "minor":
                ;(this.patch === 0 && this.prerelease.length !== 0) ||
                  this.minor++,
                  (this.patch = 0),
                  (this.prerelease = [])
                break
              case "patch":
                this.prerelease.length === 0 && this.patch++,
                  (this.prerelease = [])
                break
              case "pre":
                if (this.prerelease.length === 0) this.prerelease = [0]
                else {
                  for (var q = this.prerelease.length; --q >= 0; )
                    typeof this.prerelease[q] == "number" &&
                      (this.prerelease[q]++, (q = -2))
                  q === -1 && this.prerelease.push(0)
                }
                A &&
                  (this.prerelease[0] === A
                    ? isNaN(this.prerelease[1]) && (this.prerelease = [A, 0])
                    : (this.prerelease = [A, 0]))
                break
              default:
                throw new Error("invalid increment argument: " + N)
            }
            return this.format(), (this.raw = this.version), this
          }),
          (t.inc = function (N, A, q, mt) {
            typeof q == "string" && ((mt = q), (q = void 0))
            try {
              return new te(N, q).inc(A, mt).version
            } catch {
              return null
            }
          }),
          (t.diff = function (N, A) {
            if (Eu(N, A)) return null
            var q = Ct(N),
              mt = Ct(A)
            if (q.prerelease.length || mt.prerelease.length) {
              for (var It in q)
                if (
                  (It === "major" || It === "minor" || It === "patch") &&
                  q[It] !== mt[It]
                )
                  return "pre" + It
              return "prerelease"
            }
            for (var It in q)
              if (
                (It === "major" || It === "minor" || It === "patch") &&
                q[It] !== mt[It]
              )
                return It
          }),
          (t.compareIdentifiers = is)
        var n_ = /^[0-9]+$/
        function is(N, A) {
          var q = n_.test(N),
            mt = n_.test(A)
          return (
            q && mt && ((N = +N), (A = +A)),
            q && !mt ? -1 : mt && !q ? 1 : N < A ? -1 : N > A ? 1 : 0
          )
        }
        function qi(N, A, q) {
          return new te(N, q).compare(new te(A, q))
        }
        function Gr(N, A, q) {
          return qi(N, A, q) > 0
        }
        function ic(N, A, q) {
          return qi(N, A, q) < 0
        }
        function Eu(N, A, q) {
          return qi(N, A, q) === 0
        }
        function a_(N, A, q) {
          return qi(N, A, q) !== 0
        }
        function sc(N, A, q) {
          return qi(N, A, q) >= 0
        }
        function Iu(N, A, q) {
          return qi(N, A, q) <= 0
        }
        function Aa(N, A, q, mt) {
          var It
          switch (A) {
            case "===":
              typeof N == "object" && (N = N.version),
                typeof q == "object" && (q = q.version),
                (It = N === q)
              break
            case "!==":
              typeof N == "object" && (N = N.version),
                typeof q == "object" && (q = q.version),
                (It = N !== q)
              break
            case "":
            case "=":
            case "==":
              It = Eu(N, q, mt)
              break
            case "!=":
              It = a_(N, q, mt)
              break
            case ">":
              It = Gr(N, q, mt)
              break
            case ">=":
              It = sc(N, q, mt)
              break
            case "<":
              It = ic(N, q, mt)
              break
            case "<=":
              It = Iu(N, q, mt)
              break
            default:
              throw new TypeError("Invalid operator: " + A)
          }
          return It
        }
        function bt(N, A) {
          if (N instanceof bt) {
            if (N.loose === A) return N
            N = N.value
          }
          if (!(this instanceof bt)) return new bt(N, A)
          r("comparator", N, A),
            (this.loose = A),
            this.parse(N),
            this.semver === _a
              ? (this.value = "")
              : (this.value = this.operator + this.semver.version),
            r("comp", this)
        }
        ;(t.rcompareIdentifiers = function (N, A) {
          return is(A, N)
        }),
          (t.major = function (N, A) {
            return new te(N, A).major
          }),
          (t.minor = function (N, A) {
            return new te(N, A).minor
          }),
          (t.patch = function (N, A) {
            return new te(N, A).patch
          }),
          (t.compare = qi),
          (t.compareLoose = function (N, A) {
            return qi(N, A, !0)
          }),
          (t.rcompare = function (N, A, q) {
            return qi(A, N, q)
          }),
          (t.sort = function (N, A) {
            return N.sort(function (q, mt) {
              return t.compare(q, mt, A)
            })
          }),
          (t.rsort = function (N, A) {
            return N.sort(function (q, mt) {
              return t.rcompare(q, mt, A)
            })
          }),
          (t.gt = Gr),
          (t.lt = ic),
          (t.eq = Eu),
          (t.neq = a_),
          (t.gte = sc),
          (t.lte = Iu),
          (t.cmp = Aa),
          (t.Comparator = bt)
        var _a = {}
        function Pe(N, A) {
          if (N instanceof Pe) return N.loose === A ? N : new Pe(N.raw, A)
          if (N instanceof bt) return new Pe(N.value, A)
          if (!(this instanceof Pe)) return new Pe(N, A)
          if (
            ((this.loose = A),
            (this.raw = N),
            (this.set = N.split(/\s*\|\|\s*/)
              .map(function (q) {
                return this.parseRange(q.trim())
              }, this)
              .filter(function (q) {
                return q.length
              })),
            !this.set.length)
          )
            throw new TypeError("Invalid SemVer Range: " + N)
          this.format()
        }
        function fi(N) {
          return !N || N.toLowerCase() === "x" || N === "*"
        }
        function s7(N, A, q, mt, It, ai, Zt, Di, Te, yi, Ps, Be, Qe) {
          return (
            (A = fi(q)
              ? ""
              : fi(mt)
                ? ">=" + q + ".0.0"
                : fi(It)
                  ? ">=" + q + "." + mt + ".0"
                  : ">=" + A) +
            " " +
            (Di = fi(Te)
              ? ""
              : fi(yi)
                ? "<" + (+Te + 1) + ".0.0"
                : fi(Ps)
                  ? "<" + Te + "." + (+yi + 1) + ".0"
                  : Be
                    ? "<=" + Te + "." + yi + "." + Ps + "-" + Be
                    : "<=" + Di)
          ).trim()
        }
        function r7(N, A) {
          for (var q = 0; q < N.length; q++) if (!N[q].test(A)) return !1
          if (A.prerelease.length) {
            for (q = 0; q < N.length; q++)
              if (
                (r(N[q].semver),
                N[q].semver !== _a && N[q].semver.prerelease.length > 0)
              ) {
                var mt = N[q].semver
                if (
                  mt.major === A.major &&
                  mt.minor === A.minor &&
                  mt.patch === A.patch
                )
                  return !0
              }
            return !1
          }
          return !0
        }
        function Us(N, A, q) {
          try {
            A = new Pe(A, q)
          } catch {
            return !1
          }
          return A.test(N)
        }
        function Pu(N, A, q, mt) {
          var It, ai, Zt, Di, Te
          switch (((N = new te(N, mt)), (A = new Pe(A, mt)), q)) {
            case ">":
              ;(It = Gr), (ai = Iu), (Zt = ic), (Di = ">"), (Te = ">=")
              break
            case "<":
              ;(It = ic), (ai = sc), (Zt = Gr), (Di = "<"), (Te = "<=")
              break
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"')
          }
          if (Us(N, A, mt)) return !1
          for (var yi = 0; yi < A.set.length; ++yi) {
            var Ps = A.set[yi],
              Be = null,
              Qe = null
            if (
              (Ps.forEach(function (Ni) {
                Ni.semver === _a && (Ni = new bt(">=0.0.0")),
                  (Be = Be || Ni),
                  (Qe = Qe || Ni),
                  It(Ni.semver, Be.semver, mt)
                    ? (Be = Ni)
                    : Zt(Ni.semver, Qe.semver, mt) && (Qe = Ni)
              }),
              Be.operator === Di ||
                Be.operator === Te ||
                ((!Qe.operator || Qe.operator === Di) && ai(N, Qe.semver)) ||
                (Qe.operator === Te && Zt(N, Qe.semver)))
            )
              return !1
          }
          return !0
        }
        ;(bt.prototype.parse = function (N) {
          var A = this.loose ? c[wi] : c[Ri],
            q = N.match(A)
          if (!q) throw new TypeError("Invalid comparator: " + N)
          ;(this.operator = q[1]),
            this.operator === "=" && (this.operator = ""),
            q[2] ? (this.semver = new te(q[2], this.loose)) : (this.semver = _a)
        }),
          (bt.prototype.toString = function () {
            return this.value
          }),
          (bt.prototype.test = function (N) {
            return (
              r("Comparator.test", N, this.loose),
              this.semver === _a ||
                (typeof N == "string" && (N = new te(N, this.loose)),
                Aa(N, this.operator, this.semver, this.loose))
            )
          }),
          (bt.prototype.intersects = function (N, A) {
            if (!(N instanceof bt))
              throw new TypeError("a Comparator is required")
            var q
            if (this.operator === "")
              return (q = new Pe(N.value, A)), Us(this.value, q, A)
            if (N.operator === "")
              return (q = new Pe(this.value, A)), Us(N.semver, q, A)
            var mt = !(
                (this.operator !== ">=" && this.operator !== ">") ||
                (N.operator !== ">=" && N.operator !== ">")
              ),
              It = !(
                (this.operator !== "<=" && this.operator !== "<") ||
                (N.operator !== "<=" && N.operator !== "<")
              ),
              ai = this.semver.version === N.semver.version,
              Zt = !(
                (this.operator !== ">=" && this.operator !== "<=") ||
                (N.operator !== ">=" && N.operator !== "<=")
              ),
              Di =
                Aa(this.semver, "<", N.semver, A) &&
                (this.operator === ">=" || this.operator === ">") &&
                (N.operator === "<=" || N.operator === "<"),
              Te =
                Aa(this.semver, ">", N.semver, A) &&
                (this.operator === "<=" || this.operator === "<") &&
                (N.operator === ">=" || N.operator === ">")
            return mt || It || (ai && Zt) || Di || Te
          }),
          (t.Range = Pe),
          (Pe.prototype.format = function () {
            return (
              (this.range = this.set
                .map(function (N) {
                  return N.join(" ").trim()
                })
                .join("||")
                .trim()),
              this.range
            )
          }),
          (Pe.prototype.toString = function () {
            return this.range
          }),
          (Pe.prototype.parseRange = function (N) {
            var A = this.loose
            ;(N = N.trim()), r("range", N, A)
            var q = A ? c[ec] : c[Vr]
            ;(N = N.replace(q, s7)),
              r("hyphen replace", N),
              (N = N.replace(c[ye], "$1$2$3")),
              r("comparator trim", N, c[ye]),
              (N = (N = (N = N.replace(c[nt], "$1~")).replace(c[oe], "$1^"))
                .split(/\s+/)
                .join(" "))
            var mt = A ? c[wi] : c[Ri],
              It = N.split(" ")
                .map(function (ai) {
                  return (function (Zt, Di) {
                    return (
                      r("comp", Zt),
                      (Zt = (function (Te, yi) {
                        return Te.trim()
                          .split(/\s+/)
                          .map(function (Ps) {
                            return (function (Be, Qe) {
                              r("caret", Be, Qe)
                              var Ni = Qe ? c[Ce] : c[mi]
                              return Be.replace(
                                Ni,
                                function ($, Et, At, Y, kt) {
                                  var Xe
                                  return (
                                    r("caret", Be, $, Et, At, Y, kt),
                                    fi(Et)
                                      ? (Xe = "")
                                      : fi(At)
                                        ? (Xe =
                                            ">=" +
                                            Et +
                                            ".0.0 <" +
                                            (+Et + 1) +
                                            ".0.0")
                                        : fi(Y)
                                          ? (Xe =
                                              Et === "0"
                                                ? ">=" +
                                                  Et +
                                                  "." +
                                                  At +
                                                  ".0 <" +
                                                  Et +
                                                  "." +
                                                  (+At + 1) +
                                                  ".0"
                                                : ">=" +
                                                  Et +
                                                  "." +
                                                  At +
                                                  ".0 <" +
                                                  (+Et + 1) +
                                                  ".0.0")
                                          : kt
                                            ? (r("replaceCaret pr", kt),
                                              kt.charAt(0) !== "-" &&
                                                (kt = "-" + kt),
                                              (Xe =
                                                Et === "0"
                                                  ? At === "0"
                                                    ? ">=" +
                                                      Et +
                                                      "." +
                                                      At +
                                                      "." +
                                                      Y +
                                                      kt +
                                                      " <" +
                                                      Et +
                                                      "." +
                                                      At +
                                                      "." +
                                                      (+Y + 1)
                                                    : ">=" +
                                                      Et +
                                                      "." +
                                                      At +
                                                      "." +
                                                      Y +
                                                      kt +
                                                      " <" +
                                                      Et +
                                                      "." +
                                                      (+At + 1) +
                                                      ".0"
                                                  : ">=" +
                                                    Et +
                                                    "." +
                                                    At +
                                                    "." +
                                                    Y +
                                                    kt +
                                                    " <" +
                                                    (+Et + 1) +
                                                    ".0.0"))
                                            : (r("no pr"),
                                              (Xe =
                                                Et === "0"
                                                  ? At === "0"
                                                    ? ">=" +
                                                      Et +
                                                      "." +
                                                      At +
                                                      "." +
                                                      Y +
                                                      " <" +
                                                      Et +
                                                      "." +
                                                      At +
                                                      "." +
                                                      (+Y + 1)
                                                    : ">=" +
                                                      Et +
                                                      "." +
                                                      At +
                                                      "." +
                                                      Y +
                                                      " <" +
                                                      Et +
                                                      "." +
                                                      (+At + 1) +
                                                      ".0"
                                                  : ">=" +
                                                    Et +
                                                    "." +
                                                    At +
                                                    "." +
                                                    Y +
                                                    " <" +
                                                    (+Et + 1) +
                                                    ".0.0")),
                                    r("caret return", Xe),
                                    Xe
                                  )
                                },
                              )
                            })(Ps, yi)
                          })
                          .join(" ")
                      })(Zt, Di)),
                      r("caret", Zt),
                      (Zt = (function (Te, yi) {
                        return Te.trim()
                          .split(/\s+/)
                          .map(function (Ps) {
                            return (function (Be, Qe) {
                              var Ni = Qe ? c[Bt] : c[$t]
                              return Be.replace(
                                Ni,
                                function ($, Et, At, Y, kt) {
                                  var Xe
                                  return (
                                    r("tilde", Be, $, Et, At, Y, kt),
                                    fi(Et)
                                      ? (Xe = "")
                                      : fi(At)
                                        ? (Xe =
                                            ">=" +
                                            Et +
                                            ".0.0 <" +
                                            (+Et + 1) +
                                            ".0.0")
                                        : fi(Y)
                                          ? (Xe =
                                              ">=" +
                                              Et +
                                              "." +
                                              At +
                                              ".0 <" +
                                              Et +
                                              "." +
                                              (+At + 1) +
                                              ".0")
                                          : kt
                                            ? (r("replaceTilde pr", kt),
                                              kt.charAt(0) !== "-" &&
                                                (kt = "-" + kt),
                                              (Xe =
                                                ">=" +
                                                Et +
                                                "." +
                                                At +
                                                "." +
                                                Y +
                                                kt +
                                                " <" +
                                                Et +
                                                "." +
                                                (+At + 1) +
                                                ".0"))
                                            : (Xe =
                                                ">=" +
                                                Et +
                                                "." +
                                                At +
                                                "." +
                                                Y +
                                                " <" +
                                                Et +
                                                "." +
                                                (+At + 1) +
                                                ".0"),
                                    r("tilde return", Xe),
                                    Xe
                                  )
                                },
                              )
                            })(Ps, yi)
                          })
                          .join(" ")
                      })(Zt, Di)),
                      r("tildes", Zt),
                      (Zt = (function (Te, yi) {
                        return (
                          r("replaceXRanges", Te, yi),
                          Te.split(/\s+/)
                            .map(function (Ps) {
                              return (function (Be, Qe) {
                                Be = Be.trim()
                                var Ni = Qe ? c[z] : c[j]
                                return Be.replace(
                                  Ni,
                                  function ($, Et, At, Y, kt, Xe) {
                                    r("xRange", Be, $, Et, At, Y, kt, Xe)
                                    var $s = fi(At),
                                      Sr = $s || fi(Y),
                                      Oa = Sr || fi(kt)
                                    return (
                                      Et === "=" && Oa && (Et = ""),
                                      $s
                                        ? ($ =
                                            Et === ">" || Et === "<"
                                              ? "<0.0.0"
                                              : "*")
                                        : Et && Oa
                                          ? (Sr && (Y = 0),
                                            Oa && (kt = 0),
                                            Et === ">"
                                              ? ((Et = ">="),
                                                Sr
                                                  ? ((At = +At + 1),
                                                    (Y = 0),
                                                    (kt = 0))
                                                  : Oa &&
                                                    ((Y = +Y + 1), (kt = 0)))
                                              : Et === "<=" &&
                                                ((Et = "<"),
                                                Sr
                                                  ? (At = +At + 1)
                                                  : (Y = +Y + 1)),
                                            ($ = Et + At + "." + Y + "." + kt))
                                          : Sr
                                            ? ($ =
                                                ">=" +
                                                At +
                                                ".0.0 <" +
                                                (+At + 1) +
                                                ".0.0")
                                            : Oa &&
                                              ($ =
                                                ">=" +
                                                At +
                                                "." +
                                                Y +
                                                ".0 <" +
                                                At +
                                                "." +
                                                (+Y + 1) +
                                                ".0"),
                                      r("xRange return", $),
                                      $
                                    )
                                  },
                                )
                              })(Ps, yi)
                            })
                            .join(" ")
                        )
                      })(Zt, Di)),
                      r("xrange", Zt),
                      (Zt = (function (Te, yi) {
                        return (
                          r("replaceStars", Te, yi),
                          Te.trim().replace(c[Fa], "")
                        )
                      })(Zt, Di)),
                      r("stars", Zt),
                      Zt
                    )
                  })(ai, A)
                })
                .join(" ")
                .split(/\s+/)
            return (
              this.loose &&
                (It = It.filter(function (ai) {
                  return !!ai.match(mt)
                })),
              (It = It.map(function (ai) {
                return new bt(ai, A)
              }))
            )
          }),
          (Pe.prototype.intersects = function (N, A) {
            if (!(N instanceof Pe)) throw new TypeError("a Range is required")
            return this.set.some(function (q) {
              return q.every(function (mt) {
                return N.set.some(function (It) {
                  return It.every(function (ai) {
                    return mt.intersects(ai, A)
                  })
                })
              })
            })
          }),
          (t.toComparators = function (N, A) {
            return new Pe(N, A).set.map(function (q) {
              return q
                .map(function (mt) {
                  return mt.value
                })
                .join(" ")
                .trim()
                .split(" ")
            })
          }),
          (Pe.prototype.test = function (N) {
            if (!N) return !1
            typeof N == "string" && (N = new te(N, this.loose))
            for (var A = 0; A < this.set.length; A++)
              if (r7(this.set[A], N)) return !0
            return !1
          }),
          (t.satisfies = Us),
          (t.maxSatisfying = function (N, A, q) {
            var mt = null,
              It = null
            try {
              var ai = new Pe(A, q)
            } catch {
              return null
            }
            return (
              N.forEach(function (Zt) {
                ai.test(Zt) &&
                  ((mt && It.compare(Zt) !== -1) || (It = new te((mt = Zt), q)))
              }),
              mt
            )
          }),
          (t.minSatisfying = function (N, A, q) {
            var mt = null,
              It = null
            try {
              var ai = new Pe(A, q)
            } catch {
              return null
            }
            return (
              N.forEach(function (Zt) {
                ai.test(Zt) &&
                  ((mt && It.compare(Zt) !== 1) || (It = new te((mt = Zt), q)))
              }),
              mt
            )
          }),
          (t.validRange = function (N, A) {
            try {
              return new Pe(N, A).range || "*"
            } catch {
              return null
            }
          }),
          (t.ltr = function (N, A, q) {
            return Pu(N, A, "<", q)
          }),
          (t.gtr = function (N, A, q) {
            return Pu(N, A, ">", q)
          }),
          (t.outside = Pu),
          (t.prerelease = function (N, A) {
            var q = Ct(N, A)
            return q && q.prerelease.length ? q.prerelease : null
          }),
          (t.intersects = function (N, A, q) {
            return (N = new Pe(N, q)), (A = new Pe(A, q)), N.intersects(A)
          }),
          (t.coerce = function (N) {
            if (N instanceof te) return N
            if (typeof N != "string") return null
            var A = N.match(c[ot])
            return A == null
              ? null
              : Ct((A[1] || "0") + "." + (A[2] || "0") + "." + (A[3] || "0"))
          })
      }).call(this, e(1))
    },
    function (i, t) {
      var e,
        s,
        r = (i.exports = {})
      function a() {
        throw new Error("setTimeout has not been defined")
      }
      function o() {
        throw new Error("clearTimeout has not been defined")
      }
      function c(k) {
        if (e === setTimeout) return setTimeout(k, 0)
        if ((e === a || !e) && setTimeout)
          return (e = setTimeout), setTimeout(k, 0)
        try {
          return e(k, 0)
        } catch {
          try {
            return e.call(null, k, 0)
          } catch {
            return e.call(this, k, 0)
          }
        }
      }
      ;(function () {
        try {
          e = typeof setTimeout == "function" ? setTimeout : a
        } catch {
          e = a
        }
        try {
          s = typeof clearTimeout == "function" ? clearTimeout : o
        } catch {
          s = o
        }
      })()
      var l,
        u = [],
        d = !1,
        m = -1
      function f() {
        d &&
          l &&
          ((d = !1), l.length ? (u = l.concat(u)) : (m = -1), u.length && p())
      }
      function p() {
        if (!d) {
          var k = c(f)
          d = !0
          for (var E = u.length; E; ) {
            for (l = u, u = []; ++m < E; ) l && l[m].run()
            ;(m = -1), (E = u.length)
          }
          ;(l = null),
            (d = !1),
            (function (P) {
              if (s === clearTimeout) return clearTimeout(P)
              if ((s === o || !s) && clearTimeout)
                return (s = clearTimeout), clearTimeout(P)
              try {
                s(P)
              } catch {
                try {
                  return s.call(null, P)
                } catch {
                  return s.call(this, P)
                }
              }
            })(k)
        }
      }
      function v(k, E) {
        ;(this.fun = k), (this.array = E)
      }
      function b() {}
      ;(r.nextTick = function (k) {
        var E = new Array(arguments.length - 1)
        if (arguments.length > 1)
          for (var P = 1; P < arguments.length; P++) E[P - 1] = arguments[P]
        u.push(new v(k, E)), u.length !== 1 || d || c(p)
      }),
        (v.prototype.run = function () {
          this.fun.apply(null, this.array)
        }),
        (r.title = "browser"),
        (r.browser = !0),
        (r.env = {}),
        (r.argv = []),
        (r.version = ""),
        (r.versions = {}),
        (r.on = b),
        (r.addListener = b),
        (r.once = b),
        (r.off = b),
        (r.removeListener = b),
        (r.removeAllListeners = b),
        (r.emit = b),
        (r.prependListener = b),
        (r.prependOnceListener = b),
        (r.listeners = function (k) {
          return []
        }),
        (r.binding = function (k) {
          throw new Error("process.binding is not supported")
        }),
        (r.cwd = function () {
          return "/"
        }),
        (r.chdir = function (k) {
          throw new Error("process.chdir is not supported")
        }),
        (r.umask = function () {
          return 0
        })
    },
  ])
})
var iKt = Vt.exports.SEMVER_SPEC_VERSION,
  sKt = Vt.exports.parse,
  rKt = Vt.exports.valid,
  nKt = Vt.exports.coerce,
  aKt = Vt.exports.clean,
  oKt = Vt.exports.inc,
  cKt = Vt.exports.major,
  lKt = Vt.exports.minor,
  uKt = Vt.exports.patch,
  hKt = Vt.exports.prerelease,
  dKt = Vt.exports.gt,
  mKt = Vt.exports.gte,
  fKt = Vt.exports.lt,
  pKt = Vt.exports.lte,
  gKt = Vt.exports.eq,
  vKt = Vt.exports.neq,
  wKt = Vt.exports.cmp,
  yKt = Vt.exports.compare,
  bKt = Vt.exports.rcompare,
  TKt = Vt.exports.compareIdentifiers,
  kKt = Vt.exports.rcompareIdentifiers,
  SKt = Vt.exports.compareBuild,
  EKt = Vt.exports.sort,
  IKt = Vt.exports.rsort,
  PKt = Vt.exports.diff,
  $Kt = Vt.exports.validRange,
  xKt = Vt.exports.satisfies,
  NKt = Vt.exports.maxSatisfying,
  CKt = Vt.exports.minSatisfying,
  JKt = Vt.exports.minVersion,
  LKt = Vt.exports.gtr,
  RKt = Vt.exports.ltr,
  DKt = Vt.exports.outside,
  FKt = Vt.exports.intersects,
  AKt = Vt.exports.SemVer,
  _Kt = Vt.exports.Comparator,
  OKt = Vt.exports.Range,
  Eot = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/,
  A2t = /^-(\d{4})(\d{2})(\d{2})$/
function _2t(i) {
  return (i = i.trim()), i === "*" || Eot.test(i)
}
function Iot(i) {
  if (!_2t(i)) return null
  if (((i = i.trim()), i === "*"))
    return {
      hasCaret: !1,
      hasGreaterEquals: !1,
      majorBase: 0,
      majorMustEqual: !1,
      minorBase: 0,
      minorMustEqual: !1,
      patchBase: 0,
      patchMustEqual: !1,
      preRelease: null,
    }
  const t = i.match(Eot)
  return t
    ? {
        hasCaret: t[1] === "^",
        hasGreaterEquals: t[1] === ">=",
        majorBase: t[2] === "x" ? 0 : parseInt(t[2], 10),
        majorMustEqual: t[2] !== "x",
        minorBase: t[4] === "x" ? 0 : parseInt(t[4], 10),
        minorMustEqual: t[4] !== "x",
        patchBase: t[6] === "x" ? 0 : parseInt(t[6], 10),
        patchMustEqual: t[6] !== "x",
        preRelease: t[8] || null,
      }
    : null
}
function Pot(i) {
  if (!i) return null
  const t = i.majorBase,
    e = i.majorMustEqual,
    s = i.minorBase
  let r = i.minorMustEqual
  const a = i.patchBase
  let o = i.patchMustEqual
  i.hasCaret && (t === 0 || (r = !1), (o = !1))
  let c = 0
  if (i.preRelease) {
    const l = A2t.exec(i.preRelease)
    if (l) {
      const [, u, d, m] = l
      c = Date.UTC(Number(u), Number(d) - 1, Number(m))
    }
  }
  return {
    majorBase: t,
    majorMustEqual: e,
    minorBase: s,
    minorMustEqual: r,
    patchBase: a,
    patchMustEqual: o,
    isMinimum: i.hasGreaterEquals,
    notBefore: c,
  }
}
var O2t = class {
  constructor() {
    this.buffers = []
  }
  add(i) {
    let t = this.buffers.indexOf(i)
    return t < 0 && ((t = this.buffers.length), this.buffers.push(i)), t
  }
}
function B2t(i, t) {
  if (t.serializeBuffersForPostMessage) {
    const e = new O2t(),
      r = JSON.stringify(i, (o, c) => {
        if (c instanceof ArrayBuffer)
          return { $$vscode_array_buffer_reference$$: !0, index: e.add(c) }
        if (ArrayBuffer.isView(c)) {
          const l = q2t(c)
          if (l)
            return {
              $$vscode_array_buffer_reference$$: !0,
              index: e.add(c.buffer),
              view: {
                type: l,
                byteLength: c.byteLength,
                byteOffset: c.byteOffset,
              },
            }
        }
        return c
      }),
      a = e.buffers.map((o) => {
        const c = new Uint8Array(o)
        return Q.wrap(c)
      })
    return { message: r, buffers: a }
  } else return { message: JSON.stringify(i), buffers: [] }
}
function q2t(i) {
  switch (i.constructor.name) {
    case "Int8Array":
      return 1
    case "Uint8Array":
      return 2
    case "Uint8ClampedArray":
      return 3
    case "Int16Array":
      return 4
    case "Uint16Array":
      return 5
    case "Int32Array":
      return 6
    case "Uint32Array":
      return 7
    case "Float32Array":
      return 8
    case "Float64Array":
      return 9
    case "BigInt64Array":
      return 10
    case "BigUint64Array":
      return 11
  }
}
function U2t(i, t) {
  const e = t.map((a) => {
      const o = new ArrayBuffer(a.byteLength)
      return new Uint8Array(o).set(a.buffer), o
    }),
    s = t.length
      ? (a, o) => {
          if (
            o &&
            typeof o == "object" &&
            o.$$vscode_array_buffer_reference$$
          ) {
            const c = o,
              { index: l } = c,
              u = e[l]
            if (c.view)
              switch (c.view.type) {
                case 1:
                  return new Int8Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / Int8Array.BYTES_PER_ELEMENT,
                  )
                case 2:
                  return new Uint8Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / Uint8Array.BYTES_PER_ELEMENT,
                  )
                case 3:
                  return new Uint8ClampedArray(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT,
                  )
                case 4:
                  return new Int16Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / Int16Array.BYTES_PER_ELEMENT,
                  )
                case 5:
                  return new Uint16Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / Uint16Array.BYTES_PER_ELEMENT,
                  )
                case 6:
                  return new Int32Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / Int32Array.BYTES_PER_ELEMENT,
                  )
                case 7:
                  return new Uint32Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / Uint32Array.BYTES_PER_ELEMENT,
                  )
                case 8:
                  return new Float32Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / Float32Array.BYTES_PER_ELEMENT,
                  )
                case 9:
                  return new Float64Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / Float64Array.BYTES_PER_ELEMENT,
                  )
                case 10:
                  return new BigInt64Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT,
                  )
                case 11:
                  return new BigUint64Array(
                    u,
                    c.view.byteOffset,
                    c.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT,
                  )
                default:
                  throw new Error("Unknown array buffer view type")
              }
            return u
          }
          return o
        }
      : void 0
  return { message: JSON.parse(i, s), arrayBuffers: e }
}
var M2t = class {
  #t
  #e
  #i
  #s
  #n
  #r
  #o
  #a
  #c
  #l
  #u
  #d
  constructor(i, t, e, s, r, a, o) {
    ;(this.#o = ""),
      (this.#c = !1),
      (this.#l = !1),
      (this._onMessageEmitter = new J()),
      (this.onDidReceiveMessage = this._onMessageEmitter.event),
      (this.#h = new J()),
      (this._onDidDispose = this.#h.event),
      (this.#t = i),
      (this.#e = t),
      (this.#a = e),
      (this.#s = s),
      (this.#n = r),
      (this.#r = a),
      (this.#u = Vl(a)),
      (this.#d = H2t(a)),
      (this.#i = o)
  }
  #h
  dispose() {
    ;(this.#c = !0),
      this.#h.fire(),
      this.#h.dispose(),
      this._onMessageEmitter.dispose()
  }
  asWebviewUri(i) {
    return (this.#l = !0), Tm(i, this.#s)
  }
  get cspSource() {
    const i = this.#r.extensionLocation
    if (i.scheme === G.https || i.scheme === G.http) {
      let t = i.toString()
      return t.endsWith("/") || (t += "/"), t + " " + PW
    }
    return PW
  }
  get html() {
    return this.a(), this.#o
  }
  set html(i) {
    this.a(),
      this.#o !== i &&
        ((this.#o = i),
        this.#d &&
          !this.#l &&
          /(["'])vscode-resource:([^\s'"]+?)(["'])/i.test(i) &&
          ((this.#l = !0),
          this.#i.report(
            "Webview vscode-resource: uris",
            this.#r,
            "Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri",
          )),
        this.#e.$setHtml(this.#t, this.b(i)))
  }
  get options() {
    return this.a(), this.#a
  }
  set options(i) {
    this.a(),
      Qs(this.#a, i) || this.#e.$setOptions(this.#t, $ot(this.#r, this.#n, i)),
      (this.#a = i)
  }
  async postMessage(i) {
    if (this.#c) return !1
    const t = B2t(i, { serializeBuffersForPostMessage: this.#u })
    return this.#e.$postMessage(this.#t, t.message, ...t.buffers)
  }
  a() {
    if (this.#c) throw new Error("Webview is disposed")
  }
  b(i) {
    if (!this.#d) return i
    const t = this.#r.extensionLocation?.scheme === G.vscodeRemote,
      e =
        this.#r.extensionLocation.scheme === G.vscodeRemote
          ? this.#r.extensionLocation.authority
          : void 0
    return i
      .replace(
        /(["'])(?:vscode-resource):(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi,
        (s, r, a, o, c, l) => {
          const u = S.from({
              scheme: o || "file",
              path: decodeURIComponent(c),
            }),
            d = Tm(u, { isRemote: t, authority: e }).toString()
          return `${r}${d}${l}`
        },
      )
      .replace(
        /(["'])(?:vscode-webview-resource):(\/\/[^\s\/'"]+\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi,
        (s, r, a, o, c, l) => {
          const u = S.from({
              scheme: o || "file",
              path: decodeURIComponent(c),
            }),
            d = Tm(u, { isRemote: t, authority: e }).toString()
          return `${r}${d}${l}`
        },
      )
  }
}
function Vl(i) {
  try {
    const t = Pot(Iot(i.engines.vscode))
    return !!t && t.majorBase >= 1 && t.minorBase >= 57
  } catch {
    return !1
  }
}
function H2t(i) {
  try {
    const t = Pot(Iot(i.engines.vscode))
    return t ? t.majorBase < 1 || (t.majorBase === 1 && t.minorBase < 60) : !1
  } catch {
    return !1
  }
}
var W2t = class extends at {
  constructor(i, t, e, s, r) {
    super(),
      (this.c = t),
      (this.f = e),
      (this.g = s),
      (this.h = r),
      (this.b = new Map()),
      (this.a = i.getProxy(K.MainThreadWebviews))
  }
  dispose() {
    super.dispose()
    for (const i of this.b.values()) i.dispose()
    this.b.clear()
  }
  $onMessage(i, t, e) {
    const s = this.j(i)
    if (s) {
      const { message: r } = U2t(t, e.value)
      s._onMessageEmitter.fire(r)
    }
  }
  $onMissingCsp(i, t) {
    this.g.warn(
      `${t} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`,
    )
  }
  createNewWebview(i, t, e) {
    const s = new M2t(i, this.a, j2t(t), this.c, this.f, e, this.h)
    this.b.set(i, s)
    const r = s._onDidDispose(() => {
      r.dispose(), this.deleteWebview(i)
    })
    return s
  }
  deleteWebview(i) {
    this.b.delete(i)
  }
  j(i) {
    return this.b.get(i)
  }
}
function h3(i) {
  return { id: i.identifier, location: i.extensionLocation }
}
function $ot(i, t, e) {
  return {
    enableCommandUris: e.enableCommandUris,
    enableScripts: e.enableScripts,
    enableForms: e.enableForms,
    portMapping: e.portMapping,
    localResourceRoots: e.localResourceRoots || V2t(i, t),
  }
}
function j2t(i) {
  return {
    enableCommandUris: i.enableCommandUris,
    enableScripts: i.enableScripts,
    enableForms: i.enableForms,
    portMapping: i.portMapping,
    localResourceRoots: i.localResourceRoots?.map((t) => S.from(t)),
  }
}
function V2t(i, t) {
  return [
    ...(t?.getWorkspaceFolders() || []).map((e) => e.uri),
    i.extensionLocation,
  ]
}
var wr = class kut {
    static {
      this.a = !1
    }
    constructor(t) {
      ;(this.d = t), (this.b = new Map()), (this.c = 1)
    }
    add(t) {
      const e = this.c++
      return this.b.set(e, t), this.e(), e
    }
    get(t, e) {
      return this.b.has(t) ? this.b.get(t)[e] : void 0
    }
    delete(t) {
      this.b.delete(t), this.e()
    }
    e() {
      kut.a && console.log(`${this.d} cache size - ${this.b.size}`)
    }
  },
  G2t = class {
    constructor(i, t) {
      ;(this.document = i),
        (this.b = t),
        (this.a = 1),
        (this.c = new wr("custom documents"))
    }
    addEdit(i) {
      return this.c.add([i])
    }
    async undo(i, t) {
      await this.f(i).undo(), t || this.disposeBackup()
    }
    async redo(i, t) {
      await this.f(i).redo(), t || this.disposeBackup()
    }
    disposeEdits(i) {
      for (const t of i) this.c.delete(t)
    }
    getNewBackupUri() {
      if (!this.b) throw new Error("Backup requires a valid storage path")
      const i = Z2t(this.document.uri) + this.a++
      return He(this.b, i)
    }
    updateBackup(i) {
      this.d?.delete(), (this.d = i)
    }
    disposeBackup() {
      this.d?.delete(), (this.d = void 0)
    }
    f(i) {
      const t = this.c.get(i, 0)
      if (!t) throw new Error("No edit found")
      return t
    }
  },
  z2t = class {
    constructor() {
      this.a = new Map()
    }
    get(i, t) {
      return this.a.get(this.b(i, t))
    }
    add(i, t, e) {
      const s = this.b(i, t.uri)
      if (this.a.has(s))
        throw new Error(
          `Document already exists for viewType:${i} resource:${t.uri}`,
        )
      const r = new G2t(t, e)
      return this.a.set(s, r), r
    }
    delete(i, t) {
      const e = this.b(i, t.uri)
      this.a.delete(e)
    }
    b(i, t) {
      return `${i}@@@${t}`
    }
  },
  xot
;(function (i) {
  ;(i[(i.Text = 0)] = "Text"), (i[(i.Custom = 1)] = "Custom")
})(xot || (xot = {}))
var Y2t = class {
    constructor() {
      this.a = new Map()
    }
    addTextProvider(i, t, e) {
      return this.b(i, { type: 0, extension: t, provider: e })
    }
    addCustomProvider(i, t, e) {
      return this.b(i, { type: 1, extension: t, provider: e })
    }
    get(i) {
      return this.a.get(i)
    }
    b(i, t) {
      if (this.a.has(i))
        throw new Error(`Provider for viewType:${i} already registered`)
      return this.a.set(i, t), new Ht(() => this.a.delete(i))
    }
  },
  Q2t = class {
    constructor(i, t, e, s, r) {
      ;(this.d = t),
        (this.f = e),
        (this.g = s),
        (this.h = r),
        (this.b = new Y2t()),
        (this.c = new z2t()),
        (this.a = i.getProxy(K.MainThreadCustomEditors))
    }
    registerCustomEditorProvider(i, t, e, s) {
      const r = new gt()
      return (
        X2t(e)
          ? (r.add(this.b.addTextProvider(t, i, e)),
            this.a.$registerTextEditorProvider(
              h3(i),
              t,
              s.webviewOptions || {},
              { supportsMove: !!e.moveCustomTextEditor },
              Vl(i),
            ))
          : (r.add(this.b.addCustomProvider(t, i, e)),
            d3(e) &&
              r.add(
                e.onDidChangeCustomDocument((a) => {
                  const o = this.i(t, a.document.uri)
                  if (K2t(a)) {
                    const c = o.addEdit(a)
                    this.a.$onDidEdit(a.document.uri, t, c, a.label)
                  } else this.a.$onContentChange(a.document.uri, t)
                }),
              ),
            this.a.$registerCustomEditorProvider(
              h3(i),
              t,
              s.webviewOptions || {},
              !!s.supportsMultipleEditorsPerDocument,
              Vl(i),
            )),
        Ht.from(
          r,
          new Ht(() => {
            this.a.$unregisterEditorProvider(t)
          }),
        )
      )
    }
    async $createCustomDocument(i, t, e, s, r) {
      const a = this.b.get(t)
      if (!a) throw new Error(`No provider found for '${t}'`)
      if (a.type !== 1) throw new Error(`Invalid provide type for '${t}'`)
      const o = S.revive(i),
        c = await a.provider.openCustomDocument(
          o,
          { backupId: e, untitledDocumentData: s?.buffer },
          r,
        )
      let l
      return (
        d3(a.provider) &&
          this.f &&
          (l =
            this.f.workspaceValue(a.extension) ??
            this.f.globalValue(a.extension)),
        this.c.add(t, c, l),
        { editable: d3(a.provider) }
      )
    }
    async $disposeCustomDocument(i, t) {
      const e = this.b.get(t)
      if (!e) throw new Error(`No provider found for '${t}'`)
      if (e.type !== 1) throw new Error(`Invalid provider type for '${t}'`)
      const s = S.revive(i),
        { document: r } = this.i(t, s)
      this.c.delete(t, r), r.dispose()
    }
    async $resolveCustomEditor(i, t, e, s, r, a) {
      const o = this.b.get(e)
      if (!o) throw new Error(`No provider found for '${e}'`)
      const c = ii.to(r),
        l = this.g.createNewWebview(t, s.contentOptions, o.extension),
        u = this.h.createNewWebviewPanel(
          t,
          e,
          s.title,
          c,
          s.options,
          l,
          s.active,
        ),
        d = S.revive(i)
      switch (o.type) {
        case 1: {
          const { document: m } = this.i(e, d)
          return o.provider.resolveCustomEditor(m, u, a)
        }
        case 0: {
          const m = this.d.getDocument(d)
          return o.provider.resolveCustomTextEditor(m, u, a)
        }
        default:
          throw new Error("Unknown webview provider type")
      }
    }
    $disposeEdits(i, t, e) {
      this.i(t, i).disposeEdits(e)
    }
    async $onMoveCustomEditor(i, t, e) {
      const s = this.b.get(e)
      if (!s) throw new Error(`No provider found for '${e}'`)
      if (!s.provider.moveCustomTextEditor)
        throw new Error(`Provider does not implement move '${e}'`)
      const r = this.h.getWebviewPanel(i)
      if (!r) throw new Error("No webview found")
      const a = S.revive(t),
        o = this.d.getDocument(a)
      await s.provider.moveCustomTextEditor(o, r, ce.None)
    }
    async $undo(i, t, e, s) {
      return this.i(t, i).undo(e, s)
    }
    async $redo(i, t, e, s) {
      return this.i(t, i).redo(e, s)
    }
    async $revert(i, t, e) {
      const s = this.i(t, i)
      await this.j(t).revertCustomDocument(s.document, e), s.disposeBackup()
    }
    async $onSave(i, t, e) {
      const s = this.i(t, i)
      await this.j(t).saveCustomDocument(s.document, e), s.disposeBackup()
    }
    async $onSaveAs(i, t, e, s) {
      const r = this.i(t, i)
      return this.j(t).saveCustomDocumentAs(r.document, S.revive(e), s)
    }
    async $backup(i, t, e) {
      const s = this.i(t, i),
        a = await this.j(t).backupCustomDocument(
          s.document,
          { destination: s.getNewBackupUri() },
          e,
        )
      return s.updateBackup(a), a.id
    }
    i(i, t) {
      const e = this.c.get(i, S.revive(t))
      if (!e) throw new Error("No custom document found")
      return e
    }
    j(i) {
      const e = this.b.get(i)?.provider
      if (!e || !d3(e)) throw new Error("Custom document is not editable")
      return e
    }
  }
function d3(i) {
  return !!i.onDidChangeCustomDocument
}
function X2t(i) {
  return typeof i.resolveCustomTextEditor == "function"
}
function K2t(i) {
  return typeof i.undo == "function" && typeof i.redo == "function"
}
function Z2t(i) {
  const t =
    i.scheme === G.file || i.scheme === G.untitled ? i.fsPath : i.toString()
  return nn(t) + ""
}
var Ho,
  Not = class Sut {
    #t
    #e
    #i
    constructor(t, e, s, r, a, o, c, l) {
      ;(this.d = t),
        (this.e = e),
        (this.f = s),
        (this.g = r),
        (this.h = a),
        (this.c = !1),
        (this.f = Math.max(r, s)),
        (this.#i = new oi((u) => o.getComparisonKey(u))),
        (this.#t = c),
        (this.#e = l)
    }
    dispose() {
      this.c ||
        (this.#e.fire([...this.#i.keys()]),
        this.#t?.$clear(this.e),
        this.#i.clear(),
        (this.c = !0))
    }
    get name() {
      return this.j(), this.d
    }
    set(t, e) {
      if (!t) {
        this.clear()
        return
      }
      this.j()
      let s = []
      if (S.isUri(t)) {
        if (!e) {
          this.delete(t)
          return
        }
        this.#i.set(t, e.slice()), (s = [t])
      } else if (Array.isArray(t)) {
        s = []
        let o
        t = [...t].sort(Sut.k)
        for (const c of t) {
          const [l, u] = c
          if (
            ((!o || l.toString() !== o.toString()) &&
              (o && this.#i.get(o).length === 0 && this.#i.delete(o),
              (o = l),
              s.push(l),
              this.#i.set(l, [])),
            u)
          )
            this.#i.get(l)?.push(...u)
          else {
            const d = this.#i.get(l)
            d && (d.length = 0)
          }
        }
      }
      if ((this.#e.fire(s), !this.#t)) return
      const r = []
      let a = 0
      for (const o of s) {
        let c = []
        const l = this.#i.get(o)
        if (l)
          if (l.length > this.g) {
            c = []
            const u = [Ii.Error, Ii.Warning, Ii.Information, Ii.Hint]
            t: for (let d = 0; d < 4; d++)
              for (const m of l)
                if (
                  m.severity === u[d] &&
                  c.push({ ...ml.from(m), modelVersionId: this.h(o) }) ===
                    this.g
                )
                  break t
            c.push({
              severity: ji.Info,
              message: g(2757, null, l.length - this.g),
              startLineNumber: c[c.length - 1].startLineNumber,
              startColumn: c[c.length - 1].startColumn,
              endLineNumber: c[c.length - 1].endLineNumber,
              endColumn: c[c.length - 1].endColumn,
            })
          } else
            c = l.map((u) => ({ ...ml.from(u), modelVersionId: this.h(o) }))
        if ((r.push([o, c]), (a += c.length), a > this.f)) break
      }
      this.#t.$changeMany(this.e, r)
    }
    delete(t) {
      this.j(),
        this.#e.fire([t]),
        this.#i.delete(t),
        this.#t?.$changeMany(this.e, [[t, void 0]])
    }
    clear() {
      this.j(),
        this.#e.fire([...this.#i.keys()]),
        this.#i.clear(),
        this.#t?.$clear(this.e)
    }
    forEach(t, e) {
      this.j()
      for (const [s, r] of this) t.call(e, s, r, this)
    }
    *[Symbol.iterator]() {
      this.j()
      for (const t of this.#i.keys()) yield [t, this.get(t)]
    }
    get(t) {
      this.j()
      const e = this.#i.get(t)
      return Array.isArray(e) ? Object.freeze(e.slice(0)) : []
    }
    has(t) {
      return this.j(), Array.isArray(this.#i.get(t))
    }
    j() {
      if (this.c) throw new Error("illegal state - object is disposed")
    }
    static k(t, e) {
      return t[0].toString() < e[0].toString()
        ? -1
        : t[0].toString() > e[0].toString()
          ? 1
          : 0
    }
  },
  QW = class {
    static {
      Ho = this
    }
    static {
      this.c = 0
    }
    static {
      this.d = 1e3
    }
    static {
      this.e = 1.1 * this.d
    }
    static _mapper(t) {
      const e = new oi()
      for (const s of t) e.set(s, s)
      return { uris: Object.freeze(Array.from(e.values())) }
    }
    constructor(t, e, s, r) {
      ;(this.j = e),
        (this.k = s),
        (this.l = r),
        (this.g = new Map()),
        (this.h = new rdt({ merge: (a) => a.flat(), delay: 50 })),
        (this.onDidChangeDiagnostics = Qt.map(this.h.event, Ho._mapper)),
        (this.f = t.getProxy(K.MainThreadDiagnostics))
    }
    createDiagnosticCollection(t, e) {
      const { g: s, f: r, h: a, j: o, k: c, l } = this,
        u = new (class {
          $changeMany(f, p) {
            r.$changeMany(f, p),
              o.trace(
                "[DiagnosticCollection] change many (extension, owner, uris)",
                t.value,
                f,
                p.length === 0 ? "CLEARING" : p,
              )
          }
          $clear(f) {
            r.$clear(f),
              o.trace(
                "[DiagnosticCollection] remove all (extension, owner)",
                t.value,
                f,
              )
          }
          dispose() {
            r.dispose()
          }
        })()
      let d
      if (!e) (e = "_generated_diagnostic_collection_name_#" + Ho.c++), (d = e)
      else if (!s.has(e)) d = e
      else {
        this.j.warn(`DiagnosticCollection with name '${e}' does already exist.`)
        do d = e + Ho.c++
        while (s.has(d))
      }
      return new (class extends Not {
        constructor() {
          super(
            e,
            d,
            Ho.e,
            Ho.d,
            (f) => l.getDocument(f)?.version,
            c.extUri,
            u,
            a,
          ),
            s.set(d, this)
        }
        dispose() {
          super.dispose(), s.delete(d)
        }
      })()
    }
    getDiagnostics(t) {
      if (t) return this.m(t)
      {
        const e = new Map(),
          s = []
        for (const r of this.g.values())
          r.forEach((a, o) => {
            let c = e.get(a.toString())
            typeof c > "u" &&
              ((c = s.length), e.set(a.toString(), c), s.push([a, []])),
              (s[c][1] = s[c][1].concat(...o))
          })
        return s
      }
    }
    m(t) {
      let e = []
      for (const s of this.g.values()) s.has(t) && (e = e.concat(s.get(t)))
      return e
    }
    $acceptMarkersChange(t) {
      if (!this.n) {
        const e = "_generated_mirror",
          s = new Not(
            e,
            e,
            Number.MAX_SAFE_INTEGER,
            Number.MAX_SAFE_INTEGER,
            (r) => {},
            this.k.extUri,
            void 0,
            this.h,
          )
        this.g.set(e, s), (this.n = s)
      }
      for (const [e, s] of t) this.n.set(S.revive(e), s.map(ml.to))
    }
  }
QW = Ho = __decorate([__param(1, Rt), __param(2, Nc)], QW)
var tUt = class {
    constructor(i) {
      this.a = i.getProxy(K.MainThreadDialogs)
    }
    showOpenDialog(i, t) {
      return (
        t?.allowUIResources && _(i, "showLocal"),
        this.a
          .$showOpenDialog(t)
          .then((e) => (e ? e.map((s) => S.revive(s)) : void 0))
      )
    }
    showSaveDialog(i) {
      return this.a.$showSaveDialog(i).then((t) => (t ? S.revive(t) : void 0))
    }
  },
  eUt = class Eut {
    static {
      this.a = 0
    }
    constructor(t, e, s) {
      ;(this.d = e),
        (this.e = s),
        (this.b = new Map()),
        (this.c = t.getProxy(K.MainThreadDocumentContentProviders))
    }
    registerTextDocumentContentProvider(t, e) {
      if (Object.keys(G).indexOf(t) >= 0)
        throw new Error(`scheme '${t}' already registered`)
      const s = Eut.a++
      this.b.set(s, e), this.c.$registerTextContentProvider(s, t)
      let r
      if (typeof e.onDidChange == "function") {
        let a
        r = e.onDidChange(async (o) => {
          if (o.scheme !== t) {
            this.e.warn(
              `Provider for scheme '${t}' is firing event for schema '${o.scheme}' which will be IGNORED`,
            )
            return
          }
          if (!this.d.getDocument(o)) return
          a && (await a)
          const c = this.$provideTextDocumentContent(s, o)
            .then(async (l) => {
              if (!l && typeof l != "string") return
              const u = this.d.getDocument(o)
              if (!u) return
              const d = mG(l)
              if (!u.equalLines(d)) return this.c.$onVirtualDocumentChange(o, l)
            })
            .catch($e)
            .finally(() => {
              a === c && (a = void 0)
            })
          a = c
        })
      }
      return new Ht(() => {
        this.b.delete(s) && this.c.$unregisterTextContentProvider(s),
          r && (r.dispose(), (r = void 0))
      })
    }
    $provideTextDocumentContent(t, e) {
      const s = this.b.get(t)
      return s
        ? Promise.resolve(s.provideTextDocumentContent(S.revive(e), ce.None))
        : Promise.reject(new Error(`unsupported uri-scheme: ${e.scheme}`))
    }
  },
  iUt = class {
    constructor(i, t, e, s = { timeout: 1500, errors: 3 }) {
      ;(this.c = i),
        (this.d = t),
        (this.f = e),
        (this.g = s),
        (this.a = new Ru()),
        (this.b = new WeakMap())
    }
    dispose() {
      this.a.clear()
    }
    getOnWillSaveTextDocumentEvent(i) {
      return (t, e, s) => {
        const a = { dispose: this.a.push([t, e, i]) }
        return Array.isArray(s) && s.push(a), a
      }
    }
    async $participateInSave(i, t) {
      const e = S.revive(i)
      let s = !1
      const r = setTimeout(() => (s = !0), this.g.timeout),
        a = []
      try {
        for (const o of [...this.a]) {
          if (s) break
          const c = this.d.getDocument(e),
            l = await this.h(o, { document: c, reason: e8.to(t) })
          a.push(l)
        }
      } finally {
        clearTimeout(r)
      }
      return a
    }
    h([i, t, e], s) {
      const r = this.b.get(i)
      return typeof r == "number" && r > this.g.errors
        ? Promise.resolve(!1)
        : this.i(e, i, t, s).then(
            () => !0,
            (a) => {
              if (
                (this.c.error(
                  `onWillSaveTextDocument-listener from extension '${e.identifier.value}' threw ERROR`,
                ),
                this.c.error(a),
                !(a instanceof Error) || a.message !== "concurrent_edits")
              ) {
                const o = this.b.get(i)
                this.b.set(i, o ? o + 1 : 1),
                  typeof o == "number" &&
                    o > this.g.errors &&
                    this.c.info(
                      `onWillSaveTextDocument-listener from extension '${e.identifier.value}' will now be IGNORED because of timeouts and/or errors`,
                    )
              }
              return !1
            },
          )
    }
    i(i, t, e, s) {
      const r = [],
        a = Date.now(),
        { document: o, reason: c } = s,
        { version: l } = o,
        u = Object.freeze({
          document: o,
          reason: c,
          waitUntil(d) {
            if (Object.isFrozen(r))
              throw u7("waitUntil can not be called async")
            r.push(Promise.resolve(d))
          },
        })
      try {
        t.apply(e, [u])
      } catch (d) {
        return Promise.reject(d)
      }
      return (
        Object.freeze(r),
        new Promise((d, m) => {
          const f = setTimeout(() => m(new Error("timeout")), this.g.timeout)
          return Promise.all(r)
            .then((p) => {
              this.c.debug(
                `onWillSaveTextDocument-listener from extension '${i.identifier.value}' finished after ${Date.now() - a}ms`,
              ),
                clearTimeout(f),
                d(p)
            })
            .catch((p) => {
              clearTimeout(f), m(p)
            })
        }).then((d) => {
          const m = { edits: [] }
          for (const f of d)
            if (Array.isArray(f) && f.every((p) => p instanceof aa))
              for (const { newText: p, newEol: v, range: b } of f)
                m.edits.push({
                  resource: o.uri,
                  versionId: void 0,
                  textEdit: {
                    range: b && U.from(b),
                    text: p,
                    eol: v && wl.from(v),
                  },
                })
          if (m.edits.length !== 0)
            return l === o.version
              ? this.f.$tryApplyWorkspaceEdit(new gs(m))
              : Promise.reject(new Error("concurrent_edits"))
        })
      )
    }
  },
  sUt = class {
    constructor(i, t) {
      ;(this.a = new J()),
        (this.b = new J()),
        (this.c = new J()),
        (this.d = new J()),
        (this.onDidAddDocument = this.a.event),
        (this.onDidRemoveDocument = this.b.event),
        (this.onDidChangeDocument = this.c.event),
        (this.onDidSaveDocument = this.d.event),
        (this.e = new gt()),
        (this.h = new Map()),
        (this.f = i.getProxy(K.MainThreadDocuments)),
        (this.g = t),
        this.g.onDidRemoveDocuments(
          (e) => {
            for (const s of e) this.b.fire(s.document)
          },
          void 0,
          this.e,
        ),
        this.g.onDidAddDocuments(
          (e) => {
            for (const s of e) this.a.fire(s.document)
          },
          void 0,
          this.e,
        )
    }
    dispose() {
      this.e.dispose()
    }
    getAllDocumentData() {
      return [...this.g.allDocuments()]
    }
    getDocumentData(i) {
      if (!i) return
      const t = this.g.getDocument(i)
      if (t) return t
    }
    getDocument(i) {
      const t = this.getDocumentData(i)
      if (!t?.document)
        throw new Error(`Unable to retrieve document from URI '${i}'`)
      return t.document
    }
    ensureDocumentData(i) {
      const t = this.g.getDocument(i)
      if (t) return Promise.resolve(t)
      let e = this.h.get(i.toString())
      return (
        e ||
          ((e = this.f.$tryOpenDocument(i).then(
            (s) => {
              this.h.delete(i.toString())
              const r = S.revive(s)
              return hc(this.g.getDocument(r))
            },
            (s) => (this.h.delete(i.toString()), Promise.reject(s)),
          )),
          this.h.set(i.toString(), e)),
        e
      )
    }
    createDocumentData(i) {
      return this.f.$tryCreateDocument(i).then((t) => S.revive(t))
    }
    $acceptModelLanguageChanged(i, t) {
      const e = S.revive(i),
        s = this.g.getDocument(e)
      if (!s) throw new Error("unknown document")
      this.b.fire(s.document), s._acceptLanguageId(t), this.a.fire(s.document)
    }
    $acceptModelSaved(i) {
      const t = S.revive(i),
        e = this.g.getDocument(t)
      if (!e) throw new Error("unknown document")
      this.$acceptDirtyStateChanged(i, !1), this.d.fire(e.document)
    }
    $acceptDirtyStateChanged(i, t) {
      const e = S.revive(i),
        s = this.g.getDocument(e)
      if (!s) throw new Error("unknown document")
      s._acceptIsDirty(t),
        this.c.fire({
          document: s.document,
          contentChanges: [],
          reason: void 0,
        })
    }
    $acceptModelChanged(i, t, e) {
      const s = S.revive(i),
        r = this.g.getDocument(s)
      if (!r) throw new Error("unknown document")
      r._acceptIsDirty(e), r.onEvents(t)
      let a
      t.isUndoing ? (a = Bh.Undo) : t.isRedoing && (a = Bh.Redo),
        this.c.fire(
          MY({
            document: r.document,
            contentChanges: t.changes.map((o) => ({
              range: U.to(o.range),
              rangeOffset: o.rangeOffset,
              rangeLength: o.rangeLength,
              text: o.text,
            })),
            reason: a,
          }),
        )
    }
    setWordDefinitionFor(i, t) {
      k$t(i, t)
    }
  },
  rUt = class {
    constructor(i) {
      ;(this.b = new Map()),
        (this.c = new J()),
        (this.onDidChange = this.c.event),
        (this.d = new Set()),
        (this.e = 0),
        (this.a = i.getProxy(K.MainThreadEmbeddings))
    }
    registerEmbeddingsProvider(i, t, e) {
      if (this.d.has(t))
        throw new Error(
          "An embeddings provider for this model is already registered",
        )
      const s = this.e++
      return (
        this.a.$registerEmbeddingProvider(s, t),
        this.b.set(s, { id: t, provider: e }),
        et(() => {
          this.d.delete(t),
            this.a.$unregisterEmbeddingProvider(s),
            this.b.delete(s)
        })
      )
    }
    async computeEmbeddings(i, t, e) {
      e ??= ce.None
      let s = !1
      typeof t == "string" && ((t = [t]), (s = !0))
      const r = await this.a.$computeEmbeddings(i, t, e)
      if (r.length !== t.length) throw new Error()
      if (s) {
        if (r.length !== 1) throw new Error()
        return r[0]
      }
      return r
    }
    async $provideEmbeddings(i, t, e) {
      const s = this.b.get(i)
      if (!s) return []
      const r = await s.provider.provideEmbeddings(t, e)
      return r || []
    }
    get embeddingsModels() {
      return Array.from(this.d)
    }
    $acceptEmbeddingModels(i) {
      ;(this.d = new Set(i)), this.c.fire()
    }
  },
  nUt = class {
    constructor(i) {
      ;(this.a = new Map()),
        (this.b = 0),
        (this.c = i.getProxy(K.MainThreadAiEmbeddingVector))
    }
    async $provideAiEmbeddingVector(i, t, e) {
      if (this.a.size === 0)
        throw new Error("No embedding vector providers registered")
      const s = this.a.get(i)
      if (!s) throw new Error("Embedding vector provider not found")
      const r = await s.provideEmbeddingVector(t, e)
      if (!r) throw new Error("Embedding vector provider returned undefined")
      return r
    }
    registerEmbeddingVectorProvider(i, t, e) {
      const s = this.b
      return (
        this.b++,
        this.a.set(s, e),
        this.c.$registerAiEmbeddingVectorProvider(t, s),
        new Ht(() => {
          this.c.$unregisterAiEmbeddingVectorProvider(s), this.a.delete(s)
        })
      )
    }
  },
  Cot
;(function (i) {
  ;(i[(i.Invalid = 0)] = "Invalid"),
    (i[(i.Start = 1)] = "Start"),
    (i[(i.H = 2)] = "H"),
    (i[(i.HT = 3)] = "HT"),
    (i[(i.HTT = 4)] = "HTT"),
    (i[(i.HTTP = 5)] = "HTTP"),
    (i[(i.F = 6)] = "F"),
    (i[(i.FI = 7)] = "FI"),
    (i[(i.FIL = 8)] = "FIL"),
    (i[(i.BeforeColon = 9)] = "BeforeColon"),
    (i[(i.AfterColon = 10)] = "AfterColon"),
    (i[(i.AlmostThere = 11)] = "AlmostThere"),
    (i[(i.End = 12)] = "End"),
    (i[(i.Accept = 13)] = "Accept"),
    (i[(i.LastKnownState = 14)] = "LastKnownState")
})(Cot || (Cot = {}))
var aUt = class {
    constructor(i, t, e) {
      const s = new Uint8Array(i * t)
      for (let r = 0, a = i * t; r < a; r++) s[r] = e
      ;(this.a = s), (this.rows = i), (this.cols = t)
    }
    get(i, t) {
      return this.a[i * this.cols + t]
    }
    set(i, t, e) {
      this.a[i * this.cols + t] = e
    }
  },
  Jot = class {
    constructor(i) {
      let t = 0,
        e = 0
      for (let r = 0, a = i.length; r < a; r++) {
        const [o, c, l] = i[r]
        c > t && (t = c), o > e && (e = o), l > e && (e = l)
      }
      t++, e++
      const s = new aUt(e, t, 0)
      for (let r = 0, a = i.length; r < a; r++) {
        const [o, c, l] = i[r]
        s.set(o, c, l)
      }
      ;(this.a = s), (this.b = t)
    }
    nextState(i, t) {
      return t < 0 || t >= this.b ? 0 : this.a.get(i, t)
    }
  },
  XW = null
function oUt() {
  return (
    XW === null &&
      (XW = new Jot([
        [1, 104, 2],
        [1, 72, 2],
        [1, 102, 6],
        [1, 70, 6],
        [2, 116, 3],
        [2, 84, 3],
        [3, 116, 4],
        [3, 84, 4],
        [4, 112, 5],
        [4, 80, 5],
        [5, 115, 9],
        [5, 83, 9],
        [5, 58, 10],
        [6, 105, 7],
        [6, 73, 7],
        [7, 108, 8],
        [7, 76, 8],
        [8, 101, 9],
        [8, 69, 9],
        [9, 58, 10],
        [10, 47, 11],
        [11, 47, 12],
      ])),
    XW
  )
}
var Lot
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.ForceTermination = 1)] = "ForceTermination"),
    (i[(i.CannotEndIn = 2)] = "CannotEndIn")
})(Lot || (Lot = {}))
var Ff = null
function cUt() {
  if (Ff === null) {
    Ff = new Wit(0)
    const i = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`
    for (let e = 0; e < i.length; e++) Ff.set(i.charCodeAt(e), 1)
    const t = ".,;:"
    for (let e = 0; e < t.length; e++) Ff.set(t.charCodeAt(e), 2)
  }
  return Ff
}
var lUt = class bV {
    static a(t, e, s, r, a) {
      let o = a - 1
      do {
        const c = e.charCodeAt(o)
        if (t.get(c) !== 2) break
        o--
      } while (o > r)
      if (r > 0) {
        const c = e.charCodeAt(r - 1),
          l = e.charCodeAt(o)
        ;((c === 40 && l === 41) ||
          (c === 91 && l === 93) ||
          (c === 123 && l === 125)) &&
          o--
      }
      return {
        range: {
          startLineNumber: s,
          startColumn: r + 1,
          endLineNumber: s,
          endColumn: o + 2,
        },
        url: e.substring(r, o + 1),
      }
    }
    static computeLinks(t, e = oUt()) {
      const s = cUt(),
        r = []
      for (let a = 1, o = t.getLineCount(); a <= o; a++) {
        const c = t.getLineContent(a),
          l = c.length
        let u = 0,
          d = 0,
          m = 0,
          f = 1,
          p = !1,
          v = !1,
          b = !1,
          k = !1
        for (; u < l; ) {
          let E = !1
          const P = c.charCodeAt(u)
          if (f === 13) {
            let C
            switch (P) {
              case 40:
                ;(p = !0), (C = 0)
                break
              case 41:
                C = p ? 0 : 1
                break
              case 91:
                ;(b = !0), (v = !0), (C = 0)
                break
              case 93:
                ;(b = !1), (C = v ? 0 : 1)
                break
              case 123:
                ;(k = !0), (C = 0)
                break
              case 125:
                C = k ? 0 : 1
                break
              case 39:
              case 34:
              case 96:
                m === P
                  ? (C = 1)
                  : m === 39 || m === 34 || m === 96
                    ? (C = 0)
                    : (C = 1)
                break
              case 42:
                C = m === 42 ? 1 : 0
                break
              case 124:
                C = m === 124 ? 1 : 0
                break
              case 32:
                C = b ? 0 : 1
                break
              default:
                C = s.get(P)
            }
            C === 1 && (r.push(bV.a(s, c, a, d, u)), (E = !0))
          } else if (f === 12) {
            let C
            P === 91 ? ((v = !0), (C = 0)) : (C = s.get(P)),
              C === 1 ? (E = !0) : (f = 13)
          } else (f = e.nextState(f, P)), f === 0 && (E = !0)
          E && ((f = 1), (p = !1), (v = !1), (k = !1), (d = u + 1), (m = P)),
            u++
        }
        f === 13 && r.push(bV.a(s, c, a, d, l))
      }
      return r
    }
  },
  uUt = class {
    constructor() {
      this.a = []
    }
    add(i) {
      ;(this.b = void 0), this.a.push(i)
    }
    delete(i) {
      const t = this.a.indexOf(i)
      t >= 0 && (this.a.splice(t, 1), (this.b = void 0))
    }
    c() {
      if (!this.b) {
        const i = this.a.sort(),
          t = []
        let e,
          s,
          r = 14,
          a = 14
        for (const o of i) {
          let c = e ? Odt(e, o) : 0
          for (c === 0 ? (s = 1) : (s = a); c < o.length; c++)
            c + 1 === o.length ? ((r = a), (a = 9)) : (a += 1),
              t.push([s, o.toUpperCase().charCodeAt(c), a]),
              t.push([s, o.toLowerCase().charCodeAt(c), a]),
              (s = a)
          ;(e = o), (a = r)
        }
        t.push([9, 58, 10]), t.push([10, 47, 12]), (this.b = new Jot(t))
      }
    }
    provideDocumentLinks(i) {
      this.c()
      const t = [],
        e = lUt.computeLinks(
          {
            getLineContent(s) {
              return i.lineAt(s - 1).text
            },
            getLineCount() {
              return i.lineCount
            },
          },
          this.b,
        )
      for (const s of e) {
        const r = xo.to(s)
        r.target && t.push(r)
      }
      return t
    }
  },
  hUt = class TV {
    constructor(t, e) {
      ;(this.i = e),
        (this.b = new uUt()),
        (this.c = new Map()),
        (this.d = new Set()),
        (this.f = new Map()),
        (this.h = 0),
        (this.a = t.getProxy(K.MainThreadFileSystem))
    }
    dispose() {
      this.g?.dispose()
    }
    registerFileSystemProvider(t, e, s, r = {}) {
      if ((TV.j(s), this.d.has(e)))
        throw new Error(
          `a provider for the scheme '${e}' is already registered`,
        )
      this.g || (this.g = this.i.registerDocumentLinkProvider(t, "*", this.b))
      const a = this.h++
      this.b.add(e), this.d.add(e), this.c.set(a, s)
      let o = 2
      r.isCaseSensitive && (o += 1024),
        r.isReadonly && (o += 2048),
        typeof s.copy == "function" && (o += 8),
        typeof s.open == "function" &&
          typeof s.close == "function" &&
          typeof s.read == "function" &&
          typeof s.write == "function" &&
          (_(t, "fsChunks"), (o += 4))
      let c
      r.isReadonly &&
        to(r.isReadonly) &&
        r.isReadonly.value !== "" &&
        (c = {
          value: r.isReadonly.value,
          isTrusted: r.isReadonly.isTrusted,
          supportThemeIcons: r.isReadonly.supportThemeIcons,
          supportHtml: r.isReadonly.supportHtml,
          baseUri: r.isReadonly.baseUri,
          uris: r.isReadonly.uris,
        }),
        this.a.$registerFileSystemProvider(a, e, o, c).catch((u) => {
          console.error(
            `FAILED to register filesystem provider of ${t.identifier.value}-extension for the scheme ${e}`,
          ),
            console.error(u)
        })
      const l = s.onDidChangeFile((u) => {
        const d = []
        for (const m of u) {
          const { uri: f, type: p } = m
          if (f.scheme !== e) continue
          let v
          switch (p) {
            case nl.Changed:
              v = 0
              break
            case nl.Created:
              v = 1
              break
            case nl.Deleted:
              v = 2
              break
            default:
              throw new Error("Unknown FileChangeType")
          }
          d.push({ resource: f, type: v })
        }
        this.a.$onFileSystemChange(a, d)
      })
      return et(() => {
        l.dispose(),
          this.b.delete(e),
          this.d.delete(e),
          this.c.delete(a),
          this.a.$unregisterProvider(a)
      })
    }
    static j(t) {
      if (!t) throw new Error("MISSING provider")
      if (typeof t.watch != "function")
        throw new Error("Provider does NOT implement watch")
      if (typeof t.stat != "function")
        throw new Error("Provider does NOT implement stat")
      if (typeof t.readDirectory != "function")
        throw new Error("Provider does NOT implement readDirectory")
      if (typeof t.createDirectory != "function")
        throw new Error("Provider does NOT implement createDirectory")
      if (typeof t.readFile != "function")
        throw new Error("Provider does NOT implement readFile")
      if (typeof t.writeFile != "function")
        throw new Error("Provider does NOT implement writeFile")
      if (typeof t.delete != "function")
        throw new Error("Provider does NOT implement delete")
      if (typeof t.rename != "function")
        throw new Error("Provider does NOT implement rename")
    }
    static k(t) {
      const { type: e, ctime: s, mtime: r, size: a, permissions: o } = t
      return { type: e, ctime: s, mtime: r, size: a, permissions: o }
    }
    $stat(t, e) {
      return Promise.resolve(this.l(t).stat(S.revive(e))).then((s) => TV.k(s))
    }
    $readdir(t, e) {
      return Promise.resolve(this.l(t).readDirectory(S.revive(e)))
    }
    $readFile(t, e) {
      return Promise.resolve(this.l(t).readFile(S.revive(e))).then((s) =>
        Q.wrap(s),
      )
    }
    $writeFile(t, e, s, r) {
      return Promise.resolve(this.l(t).writeFile(S.revive(e), s.buffer, r))
    }
    $delete(t, e, s) {
      return Promise.resolve(this.l(t).delete(S.revive(e), s))
    }
    $rename(t, e, s, r) {
      return Promise.resolve(this.l(t).rename(S.revive(e), S.revive(s), r))
    }
    $copy(t, e, s, r) {
      const a = this.l(t)
      if (!a.copy)
        throw new Error('FileSystemProvider does not implement "copy"')
      return Promise.resolve(a.copy(S.revive(e), S.revive(s), r))
    }
    $mkdir(t, e) {
      return Promise.resolve(this.l(t).createDirectory(S.revive(e)))
    }
    $watch(t, e, s, r) {
      const a = this.l(t).watch(S.revive(s), r)
      this.f.set(e, a)
    }
    $unwatch(t, e) {
      const s = this.f.get(e)
      s && (s.dispose(), this.f.delete(e))
    }
    $open(t, e, s) {
      const r = this.l(t)
      if (!r.open)
        throw new Error('FileSystemProvider does not implement "open"')
      return Promise.resolve(r.open(S.revive(e), s))
    }
    $close(t, e) {
      const s = this.l(t)
      if (!s.close)
        throw new Error('FileSystemProvider does not implement "close"')
      return Promise.resolve(s.close(e))
    }
    $read(t, e, s, r) {
      const a = this.l(t)
      if (!a.read)
        throw new Error('FileSystemProvider does not implement "read"')
      const o = Q.alloc(r)
      return Promise.resolve(a.read(e, s, o.buffer, 0, r)).then((c) =>
        o.slice(0, c),
      )
    }
    $write(t, e, s, r) {
      const a = this.l(t)
      if (!a.write)
        throw new Error('FileSystemProvider does not implement "write"')
      return Promise.resolve(a.write(e, s, r.buffer, 0, r.byteLength))
    }
    l(t) {
      const e = this.c.get(t)
      if (!e) {
        const s = new Error()
        throw ((s.name = "ENOPRO"), (s.message = "no provider"), s)
      }
      return e
    }
  }
function Rot(i) {
  return typeof i.correlationId == "number"
}
function dUt(i) {
  return i.recursive === !0
}
var Dot = class Iut extends at {
    static {
      this.a = 5
    }
    constructor(t, e, s, r) {
      super(),
        (this.h = t),
        (this.j = e),
        (this.m = s),
        (this.n = r),
        (this.c = this.D(new zr())),
        (this.f = void 0),
        (this.g = 0)
    }
    r() {
      const t = new gt()
      ;(this.c.value = t),
        (this.b = this.q(t)),
        this.b.setVerboseLogging(this.m),
        t.add(this.b.onDidChangeFile((e) => this.h(e))),
        t.add(this.b.onDidLogMessage((e) => this.j(e))),
        t.add(this.b.onDidError((e) => this.s(e.error, e.request)))
    }
    s(t, e) {
      this.t(t, e)
        ? this.g < Iut.a && this.f
          ? (this.w(`restarting watcher after unexpected error: ${t}`),
            this.u(this.f))
          : this.w(
              `gave up attempting to restart watcher after unexpected error: ${t}`,
            )
        : this.w(t)
    }
    t(t, e) {
      return !(
        !this.n.restartOnError ||
        e ||
        t.indexOf("No space left on device") !== -1 ||
        t.indexOf("EMFILE") !== -1
      )
    }
    u(t) {
      this.g++, this.r(), this.watch(t)
    }
    async watch(t) {
      ;(this.f = t), await this.b?.watch(t)
    }
    async setVerboseLogging(t) {
      ;(this.m = t), await this.b?.setVerboseLogging(t)
    }
    w(t) {
      this.j({ type: "error", message: `[File Watcher (${this.n.type})] ${t}` })
    }
    y(t) {
      this.j({ type: "trace", message: `[File Watcher (${this.n.type})] ${t}` })
    }
    dispose() {
      return (this.b = void 0), super.dispose()
    }
  },
  mUt = class extends Dot {
    constructor(i, t, e) {
      super(i, t, e, { type: "node.js", restartOnError: !1 })
    }
  },
  fUt = class extends Dot {
    constructor(i, t, e) {
      super(i, t, e, { type: "universal", restartOnError: !0 })
    }
  }
function Fot(i) {
  return i.map((t) => ({
    type: t.type,
    resource: S.revive(t.resource),
    cId: t.cId,
  }))
}
function pUt(i) {
  const t = new gUt()
  for (const e of i) t.processEvent(e)
  return t.coalesce()
}
function Aot(i, t) {
  return typeof t == "string" && !t.startsWith(co) && !$r(t)
    ? { base: i, pattern: t }
    : t
}
function _ot(i, t) {
  const e = []
  for (const s of t) e.push(sr(Aot(i, s)))
  return e
}
var gUt = class {
  constructor() {
    ;(this.a = new Set()), (this.b = new Map())
  }
  c(i) {
    return De ? i.resource.fsPath : i.resource.fsPath.toLowerCase()
  }
  processEvent(i) {
    const t = this.b.get(this.c(i))
    let e = !1
    if (t) {
      const s = t.type,
        r = i.type
      t.resource.fsPath !== i.resource.fsPath && (i.type === 2 || i.type === 1)
        ? (e = !0)
        : s === 1 && r === 2
          ? (this.b.delete(this.c(i)), this.a.delete(t))
          : s === 2 && r === 1
            ? (t.type = 0)
            : (s === 1 && r === 0) || (t.type = r)
    } else e = !0
    e && (this.a.add(i), this.b.set(this.c(i), i))
  }
  coalesce() {
    const i = [],
      t = []
    return Array.from(this.a)
      .filter((e) => (e.type !== 2 ? (i.push(e), !1) : !0))
      .sort((e, s) => e.resource.fsPath.length - s.resource.fsPath.length)
      .filter((e) =>
        t.some((s) => a0t(e.resource.fsPath, s, !De))
          ? !1
          : (t.push(e.resource.fsPath), !0),
      )
      .concat(i)
  }
}
function vUt(i, t) {
  if (typeof t == "number")
    switch (i.type) {
      case 1:
        return (t & 4) === 0
      case 2:
        return (t & 8) === 0
      case 0:
        return (t & 2) === 0
    }
  return !1
}
function wUt(i) {
  if (typeof i == "number") {
    const t = []
    return (
      i & 4 && t.push("Added"),
      i & 8 && t.push("Deleted"),
      i & 2 && t.push("Updated"),
      t.length === 0 ? "<all>" : `[${t.join(", ")}]`
    )
  }
  return "<none>"
}
var yUt = class {
    get ignoreCreateEvents() {
      return !!(this.h & 1)
    }
    get ignoreChangeEvents() {
      return !!(this.h & 2)
    }
    get ignoreDeleteEvents() {
      return !!(this.h & 4)
    }
    constructor(i, t, e, s, r, a, o) {
      ;(this.a = Math.random()),
        (this.b = new J()),
        (this.c = new J()),
        (this.d = new J()),
        (this.h = 0),
        o.ignoreCreateEvents && (this.h += 1),
        o.ignoreChangeEvents && (this.h += 2),
        o.ignoreDeleteEvents && (this.h += 4)
      const c = sr(a),
        l = typeof a == "string",
        u = o.correlate,
        d = r((m) => {
          if (
            !(typeof m.session == "number" && m.session !== this.a) &&
            !(u && typeof m.session > "u")
          ) {
            if (!o.ignoreCreateEvents)
              for (const f of m.created) {
                const p = S.revive(f)
                c(p.fsPath) && (!l || e.getWorkspaceFolder(p)) && this.b.fire(p)
              }
            if (!o.ignoreChangeEvents)
              for (const f of m.changed) {
                const p = S.revive(f)
                c(p.fsPath) && (!l || e.getWorkspaceFolder(p)) && this.c.fire(p)
              }
            if (!o.ignoreDeleteEvents)
              for (const f of m.deleted) {
                const p = S.revive(f)
                c(p.fsPath) && (!l || e.getWorkspaceFolder(p)) && this.d.fire(p)
              }
          }
        })
      this.g = Ht.from(
        this.i(i, e, t, s, a, o, o.correlate),
        this.b,
        this.c,
        this.d,
        d,
      )
    }
    i(i, t, e, s, r, a, o) {
      const c = Ht.from()
      if (
        typeof r == "string" ||
        (a.ignoreChangeEvents && a.ignoreCreateEvents && a.ignoreDeleteEvents)
      )
        return c
      const l = i.getProxy(K.MainThreadFileSystemEventService)
      let u = !1
      ;(r.pattern.includes(co) || r.pattern.includes(v2)) && (u = !0)
      const d = a.excludes ?? []
      let m, f
      if (o)
        (a.ignoreChangeEvents ||
          a.ignoreCreateEvents ||
          a.ignoreDeleteEvents) &&
          ((f = 14),
          a.ignoreChangeEvents && (f &= -3),
          a.ignoreCreateEvents && (f &= -5),
          a.ignoreDeleteEvents && (f &= -9))
      else if (u && d.length === 0) {
        const p = t.getWorkspaceFolder(S.revive(r.baseUri)),
          v = e.getConfiguration("files", p).get("watcherExclude")
        if (v) for (const b in v) b && v[b] === !0 && d.push(b)
      } else if (!u) {
        const p = t.getWorkspaceFolder(S.revive(r.baseUri))
        if (p) {
          const v = e.getConfiguration("files", p).get("watcherExclude")
          if (v) {
            for (const b in v)
              if (b && v[b] === !0) {
                const k = `${Gn(b, "/")}/${co}`
                m || (m = []), m.push(Aot(p.uri.fsPath, k))
              }
          }
          if (!m || m.length === 0) return c
        }
      }
      return (
        l.$watch(
          s.identifier.value,
          this.a,
          r.baseUri,
          { recursive: u, excludes: d, includes: m, filter: f },
          !!o,
        ),
        Ht.from({ dispose: () => l.$unwatch(this.a) })
      )
    }
    dispose() {
      this.g.dispose()
    }
    get onDidCreate() {
      return this.b.event
    }
    get onDidChange() {
      return this.c.event
    }
    get onDidDelete() {
      return this.d.event
    }
  },
  bUt = class {
    constructor(i) {
      ;(this.a = i),
        (this.session = this.a.session),
        (this.b = new as(() => this.a.created.map(S.revive))),
        (this.c = new as(() => this.a.changed.map(S.revive))),
        (this.d = new as(() => this.a.deleted.map(S.revive)))
    }
    get created() {
      return this.b.value
    }
    get changed() {
      return this.c.value
    }
    get deleted() {
      return this.d.value
    }
  },
  TUt = class {
    constructor(i, t, e) {
      ;(this.j = i),
        (this.k = t),
        (this.l = e),
        (this.a = new J()),
        (this.b = new J()),
        (this.c = new J()),
        (this.d = new J()),
        (this.g = new Du()),
        (this.h = new Du()),
        (this.i = new Du()),
        (this.onDidRenameFile = this.b.event),
        (this.onDidCreateFile = this.c.event),
        (this.onDidDeleteFile = this.d.event)
    }
    createFileSystemWatcher(i, t, e, s, r) {
      return new yUt(this.j, t, i, e, this.a.event, us.from(s), r)
    }
    $onFileEvent(i) {
      this.a.fire(new bUt(i))
    }
    $onDidRunFileOperation(i, t) {
      switch (i) {
        case 2:
          this.b.fire(
            Object.freeze({
              files: t.map((e) => ({
                oldUri: S.revive(e.source),
                newUri: S.revive(e.target),
              })),
            }),
          )
          break
        case 1:
          this.d.fire(
            Object.freeze({ files: t.map((e) => S.revive(e.target)) }),
          )
          break
        case 0:
        case 3:
          this.c.fire(
            Object.freeze({ files: t.map((e) => S.revive(e.target)) }),
          )
          break
        default:
      }
    }
    getOnWillRenameFileEvent(i) {
      return this.m(i, this.g)
    }
    getOnWillCreateFileEvent(i) {
      return this.m(i, this.h)
    }
    getOnWillDeleteFileEvent(i) {
      return this.m(i, this.i)
    }
    m(i, t) {
      return (e, s, r) => {
        const a = function (c) {
          e.call(s, c)
        }
        return (a.extension = i), t.event(a, void 0, r)
      }
    }
    async $onWillRunFileOperation(i, t, e, s) {
      switch (i) {
        case 2:
          return await this.n(
            this.g,
            {
              files: t.map((r) => ({
                oldUri: S.revive(r.source),
                newUri: S.revive(r.target),
              })),
            },
            e,
            s,
          )
        case 1:
          return await this.n(
            this.i,
            { files: t.map((r) => S.revive(r.target)) },
            e,
            s,
          )
        case 0:
        case 3:
          return await this.n(
            this.h,
            { files: t.map((r) => S.revive(r.target)) },
            e,
            s,
          )
      }
    }
    async n(i, t, e, s) {
      const r = new Set(),
        a = []
      if (
        (await i.fireAsync(t, s, async (c, l) => {
          const u = Date.now(),
            d = await Promise.resolve(c)
          d instanceof mo &&
            (a.push([l.extension, d]),
            r.add(l.extension.displayName ?? l.extension.identifier.value)),
            Date.now() - u > e &&
              this.k.warn("SLOW file-participant", l.extension.identifier)
        }),
        s.isCancellationRequested || a.length === 0)
      )
        return
      const o = { edits: [] }
      for (const [, c] of a) {
        const { edits: l } = Oi.from(c, {
          getTextDocumentVersion: (u) => this.l.getDocument(u)?.version,
          getNotebookDocumentVersion: () => {},
        })
        o.edits = o.edits.concat(l)
      }
      return { edit: o, extensionNames: Array.from(r) }
    }
  },
  kUt = class {
    constructor(i, t, e, s, r) {
      ;(this.a = t), (this.b = e), (this.c = s)
      const a = new Tt(
        "interactive.open",
        "_interactive.open",
        "Open interactive window and return notebook editor and input URI",
        [
          new H(
            "showOptions",
            "Show Options",
            (o) => !0,
            (o) => o,
          ),
          new H(
            "resource",
            "Interactive resource Uri",
            (o) => !0,
            (o) => o,
          ),
          new H(
            "controllerId",
            "Notebook controller Id",
            (o) => !0,
            (o) => o,
          ),
          new H(
            "title",
            "Interactive editor title",
            (o) => !0,
            (o) => o,
          ),
        ],
        new yt("Notebook and input URI", (o) => {
          if (
            (r.debug(
              "[ExtHostInteractive] open iw with notebook editor id",
              o.notebookEditorId,
            ),
            o.notebookEditorId !== void 0)
          ) {
            const c = this.a.getEditorById(o.notebookEditorId)
            return (
              r.debug("[ExtHostInteractive] notebook editor found", c.id),
              {
                notebookUri: S.revive(o.notebookUri),
                inputUri: S.revive(o.inputUri),
                notebookEditor: c.apiEditor,
              }
            )
          }
          return (
            r.debug(
              "[ExtHostInteractive] notebook editor not found, uris for the interactive document",
              o.notebookUri,
              o.inputUri,
            ),
            {
              notebookUri: S.revive(o.notebookUri),
              inputUri: S.revive(o.inputUri),
            }
          )
        }),
      )
      this.c.registerApiCommand(a)
    }
    $willAddInteractiveDocument(i, t, e, s) {
      this.b.acceptDocumentsAndEditorsDelta({
        addedDocuments: [
          {
            EOL: t,
            lines: [""],
            languageId: e,
            uri: i,
            isDirty: !1,
            versionId: 1,
          },
        ],
      })
    }
    $willRemoveInteractiveDocument(i, t) {
      this.b.acceptDocumentsAndEditorsDelta({ removedDocuments: [i] })
    }
  },
  SUt = class {
    constructor(i) {
      ;(this.b = 0), (this.a = i.getProxy(K.MainThreadLabelService))
    }
    $registerResourceLabelFormatter(i) {
      const t = this.b++
      return (
        this.a.$registerResourceLabelFormatter(t, i),
        et(() => {
          this.a.$unregisterResourceLabelFormatter(t)
        })
      )
    }
  },
  Oot
;(function (i) {
  ;(i[(i.LTR = 0)] = "LTR"), (i[(i.RTL = 1)] = "RTL")
})(Oot || (Oot = {}))
var EUt = class qs extends ue {
    constructor(t, e, s, r) {
      super(t, e, s, r),
        (this.selectionStartLineNumber = t),
        (this.selectionStartColumn = e),
        (this.positionLineNumber = s),
        (this.positionColumn = r)
    }
    toString() {
      return (
        "[" +
        this.selectionStartLineNumber +
        "," +
        this.selectionStartColumn +
        " -> " +
        this.positionLineNumber +
        "," +
        this.positionColumn +
        "]"
      )
    }
    equalsSelection(t) {
      return qs.selectionsEqual(this, t)
    }
    static selectionsEqual(t, e) {
      return (
        t.selectionStartLineNumber === e.selectionStartLineNumber &&
        t.selectionStartColumn === e.selectionStartColumn &&
        t.positionLineNumber === e.positionLineNumber &&
        t.positionColumn === e.positionColumn
      )
    }
    getDirection() {
      return this.selectionStartLineNumber === this.startLineNumber &&
        this.selectionStartColumn === this.startColumn
        ? 0
        : 1
    }
    setEndPosition(t, e) {
      return this.getDirection() === 0
        ? new qs(this.startLineNumber, this.startColumn, t, e)
        : new qs(t, e, this.startLineNumber, this.startColumn)
    }
    getPosition() {
      return new ws(this.positionLineNumber, this.positionColumn)
    }
    getSelectionStart() {
      return new ws(this.selectionStartLineNumber, this.selectionStartColumn)
    }
    setStartPosition(t, e) {
      return this.getDirection() === 0
        ? new qs(t, e, this.endLineNumber, this.endColumn)
        : new qs(this.endLineNumber, this.endColumn, t, e)
    }
    static fromPositions(t, e = t) {
      return new qs(t.lineNumber, t.column, e.lineNumber, e.column)
    }
    static fromRange(t, e) {
      return e === 0
        ? new qs(t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn)
        : new qs(t.endLineNumber, t.endColumn, t.startLineNumber, t.startColumn)
    }
    static liftSelection(t) {
      return new qs(
        t.selectionStartLineNumber,
        t.selectionStartColumn,
        t.positionLineNumber,
        t.positionColumn,
      )
    }
    static selectionsArrEqual(t, e) {
      if ((t && !e) || (!t && e)) return !1
      if (!t && !e) return !0
      if (t.length !== e.length) return !1
      for (let s = 0, r = t.length; s < r; s++)
        if (!this.selectionsEqual(t[s], e[s])) return !1
      return !0
    }
    static isISelection(t) {
      return (
        t &&
        typeof t.selectionStartLineNumber == "number" &&
        typeof t.selectionStartColumn == "number" &&
        typeof t.positionLineNumber == "number" &&
        typeof t.positionColumn == "number"
      )
    }
    static createWithDirection(t, e, s, r, a) {
      return a === 0 ? new qs(t, e, s, r) : new qs(s, r, t, e)
    }
  },
  Bot = class Put {
    constructor(t, e) {
      ;(this.d = t), (this.e = e)
    }
    async provideDocumentSymbols(t, e) {
      const s = this.d.getDocument(t),
        r = await this.e.provideDocumentSymbols(s, e)
      if (!d7(r)) return r[0] instanceof Dh ? r.map(AU.from) : Put.f(r)
    }
    static f(t) {
      t = t.slice(0).sort((r, a) => {
        let o = r.location.range.start.compareTo(a.location.range.start)
        return (
          o === 0 && (o = a.location.range.end.compareTo(r.location.range.end)),
          o
        )
      })
      const e = [],
        s = []
      for (const r of t) {
        const a = {
          name: r.name || "!!MISSING: name!!",
          kind: Ls.from(r.kind),
          tags: r.tags?.map(yn.from) || [],
          detail: "",
          containerName: r.containerName,
          range: U.from(r.location.range),
          selectionRange: U.from(r.location.range),
          children: [],
        }
        for (;;) {
          if (s.length === 0) {
            s.push(a), e.push(a)
            break
          }
          const o = s[s.length - 1]
          if (
            ue.containsRange(o.range, a.range) &&
            !ue.equalsRange(o.range, a.range)
          ) {
            o.children?.push(a), s.push(a)
            break
          }
          s.pop()
        }
      }
      return e
    }
  },
  m3 = class {
    constructor(i, t, e, s, r, a) {
      ;(this.f = i),
        (this.g = t),
        (this.h = e),
        (this.j = s),
        (this.k = r),
        (this.l = a),
        (this.d = new wr("CodeLens")),
        (this.e = new Map())
    }
    async provideCodeLenses(i, t) {
      const e = this.f.getDocument(i),
        s = await this.h.provideCodeLenses(e, t)
      if (!s || t.isCancellationRequested) return
      const r = this.d.add(s),
        a = new gt()
      this.e.set(r, a)
      const o = { cacheId: r, lenses: [] }
      for (let c = 0; c < s.length; c++)
        o.lenses.push({
          cacheId: [r, c],
          range: U.from(s[c].range),
          command: this.g.toInternal(s[c].command, a),
        })
      return o
    }
    async resolveCodeLens(i, t) {
      const e = i.cacheId && this.d.get(...i.cacheId)
      if (!e) return
      let s
      if (
        (typeof this.h.resolveCodeLens != "function" || e.isResolved
          ? (s = e)
          : (s = await this.h.resolveCodeLens(e, t)),
        s || (s = e),
        t.isCancellationRequested)
      )
        return
      const r = i.cacheId && this.e.get(i.cacheId[0])
      if (r) {
        if (!s.command) {
          const a = new Error(
            "INVALID code lens resolved, lacks command: " +
              this.j.identifier.value,
          )
          this.k.onExtensionError(this.j.identifier, a), this.l.error(a)
          return
        }
        return (i.command = this.g.toInternal(s.command, r)), i
      }
    }
    releaseCodeLenses(i) {
      this.e.get(i)?.dispose(), this.e.delete(i), this.d.delete(i)
    }
  }
function f3(i) {
  return Array.isArray(i) ? i.map(ud.from) : i ? [ud.from(i)] : []
}
var qot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDefinition(i, t, e) {
      const s = this.d.getDocument(i),
        r = Kt.to(t),
        a = await this.e.provideDefinition(s, r, e)
      return f3(a)
    }
  },
  Uot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDeclaration(i, t, e) {
      const s = this.d.getDocument(i),
        r = Kt.to(t),
        a = await this.e.provideDeclaration(s, r, e)
      return f3(a)
    }
  },
  Mot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideImplementation(i, t, e) {
      const s = this.d.getDocument(i),
        r = Kt.to(t),
        a = await this.e.provideImplementation(s, r, e)
      return f3(a)
    }
  },
  Hot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideTypeDefinition(i, t, e) {
      const s = this.d.getDocument(i),
        r = Kt.to(t),
        a = await this.e.provideTypeDefinition(s, r, e)
      return f3(a)
    }
  },
  KW = class $ut {
    static {
      this.f = 10
    }
    constructor(t, e) {
      ;(this.g = t), (this.h = e), (this.d = 0), (this.e = new Map())
    }
    async provideHover(t, e, s, r) {
      const a = this.g.getDocument(t),
        o = Kt.to(e)
      let c
      if (s && s.verbosityRequest) {
        const m = s.verbosityRequest.previousHover.id,
          f = this.e.get(m)
        if (!f) throw new Error(`Hover with id ${m} not found`)
        const p = {
          verbosityDelta: s.verbosityRequest.verbosityDelta,
          previousHover: f,
        }
        c = await this.h.provideHover(a, o, r, p)
      } else c = await this.h.provideHover(a, o, r)
      if (!c || d7(c.contents)) return
      c.range || (c.range = a.getWordRangeAtPosition(o)),
        c.range || (c.range = new Nt(o, o))
      const l = hd.from(c),
        u = this.d
      if (this.e.size === $ut.f) {
        const m = Math.min(...this.e.keys())
        this.e.delete(m)
      }
      return this.e.set(u, c), (this.d += 1), { ...l, id: u }
    }
    releaseHover(t) {
      this.e.delete(t)
    }
  },
  Wot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideEvaluatableExpression(i, t, e) {
      const s = this.d.getDocument(i),
        r = Kt.to(t),
        a = await this.e.provideEvaluatableExpression(s, r, e)
      if (a) return BU.from(a)
    }
  },
  jot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideInlineValues(i, t, e, s) {
      const r = this.d.getDocument(i),
        a = await this.e.provideInlineValues(r, U.to(t), zO.to(e), s)
      if (Array.isArray(a)) return a.map((o) => GO.from(o))
    }
  },
  Vot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDocumentHighlights(i, t, e) {
      const s = this.d.getDocument(i),
        r = Kt.to(t),
        a = await this.e.provideDocumentHighlights(s, r, e)
      if (Array.isArray(a)) return a.map(pl.from)
    }
  },
  Got = class {
    constructor(i, t, e) {
      ;(this.d = i), (this.e = t), (this.f = e)
    }
    async provideMultiDocumentHighlights(i, t, e, s) {
      const r = this.d.getDocument(i),
        a = e
          .map((l) => {
            try {
              return this.d.getDocument(l)
            } catch (u) {
              this.f.error(
                "Error: Unable to retrieve document from URI: " +
                  l +
                  ". Error message: " +
                  u,
              )
              return
            }
          })
          .filter((l) => l !== void 0),
        o = Kt.to(t),
        c = await this.e.provideMultiDocumentHighlights(r, o, a, s)
      if (Array.isArray(c)) return c.map(qU.from)
    }
  },
  zot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideLinkedEditingRanges(i, t, e) {
      const s = this.d.getDocument(i),
        r = Kt.to(t),
        a = await this.e.provideLinkedEditingRanges(s, r, e)
      if (a && Array.isArray(a.ranges))
        return { ranges: Ue(a.ranges.map(U.from)), wordPattern: a.wordPattern }
    }
  },
  Yot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideReferences(i, t, e, s) {
      const r = this.d.getDocument(i),
        a = Kt.to(t),
        o = await this.e.provideReferences(r, a, e, s)
      if (Array.isArray(o)) return o.map(Qi.from)
    }
  },
  p3 = class Z3 {
    static {
      this.d = 1e3
    }
    constructor(t, e, s, r, a, o, c) {
      ;(this.g = t),
        (this.h = e),
        (this.j = s),
        (this.k = r),
        (this.l = a),
        (this.m = o),
        (this.n = c),
        (this.e = new wr("CodeAction")),
        (this.f = new Map())
    }
    async provideCodeActions(t, e, s, r) {
      const a = this.g.getDocument(t),
        o = EUt.isISelection(e) ? or.to(e) : U.to(e),
        c = []
      for (const p of this.j.getDiagnostics(t))
        if (o.intersection(p.range) && c.push(p) > Z3.d) break
      const l = {
          diagnostics: c,
          only: s.only ? new Ie(s.only) : void 0,
          triggerKind: eM.to(s.trigger),
        },
        u = await this.k.provideCodeActions(a, o, l, r)
      if (!Cu(u) || r.isCancellationRequested) return
      const d = this.e.add(u),
        m = new gt()
      this.f.set(d, m)
      const f = []
      for (let p = 0; p < u.length; p++) {
        const v = u[p]
        if (v)
          if (Z3.o(v))
            this.n.report(
              "CodeActionProvider.provideCodeActions - return commands",
              this.m,
              "Return 'CodeAction' instances instead.",
            ),
              f.push({
                _isSynthetic: !0,
                title: v.title,
                command: this.h.toInternal(v, m),
              })
          else {
            l.only &&
              (v.kind
                ? l.only.contains(v.kind) ||
                  this.l.warn(
                    `${this.m.identifier.value} - Code actions of kind '${l.only.value}' requested but returned code action is of kind '${v.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`,
                  )
                : this.l.warn(
                    `${this.m.identifier.value} - Code actions of kind '${l.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`,
                  ))
            const b = v.ranges ?? []
            f.push({
              cacheId: [d, p],
              title: v.title,
              command: v.command && this.h.toInternal(v.command, m),
              diagnostics: v.diagnostics && v.diagnostics.map(ml.from),
              edit: v.edit && Oi.from(v.edit, void 0),
              kind: v.kind && v.kind.value,
              isPreferred: v.isPreferred,
              isAI: hi(this.m, "codeActionAI") ? v.isAI : !1,
              ranges: hi(this.m, "codeActionRanges")
                ? Ue(b.map(U.from))
                : void 0,
              disabled: v.disabled?.reason,
            })
          }
      }
      return { cacheId: d, actions: f }
    }
    async resolveCodeAction(t, e) {
      const [s, r] = t,
        a = this.e.get(s, r)
      if (!a || Z3.o(a)) return {}
      if (!this.k.resolveCodeAction) return {}
      const o = (await this.k.resolveCodeAction(a, e)) ?? a
      let c
      o.edit && (c = Oi.from(o.edit, void 0))
      let l
      if (o.command) {
        const u = this.f.get(s)
        u && (l = this.h.toInternal(o.command, u))
      }
      return { edit: c, command: l }
    }
    releaseCodeActions(t) {
      this.f.get(t)?.dispose(), this.f.delete(t), this.e.delete(t)
    }
    static o(t) {
      return typeof t.command == "string" && typeof t.title == "string"
    }
  },
  Af = class {
    constructor(i, t, e, s, r) {
      ;(this.e = i),
        (this.f = t),
        (this.g = e),
        (this.h = s),
        (this.j = r),
        (this.d = new wr("DocumentPasteEdit"))
    }
    async prepareDocumentPaste(i, t, e, s) {
      if (!this.g.prepareDocumentPaste) return
      const r = this.f.getDocument(i),
        a = t.map((l) => U.to(l)),
        o = pa.toDataTransfer(e, () => {
          throw new Pht()
        })
      if (
        (await this.g.prepareDocumentPaste(r, a, o, s),
        s.isCancellationRequested)
      )
        return
      const c = Array.from(o).filter(([, l]) => !(l instanceof mO))
      return pa.from(c)
    }
    async providePasteEdits(i, t, e, s, r, a) {
      if (!this.g.provideDocumentPasteEdits) return []
      const o = this.f.getDocument(t),
        c = e.map((m) => U.to(m)),
        l = pa.toDataTransfer(
          s,
          async (m) =>
            (await this.e.$resolvePasteFileData(this.h, i, m)).buffer,
        ),
        u = await this.g.provideDocumentPasteEdits(
          o,
          c,
          l,
          {
            only: r.only ? new Zc(r.only) : void 0,
            triggerKind: r.triggerKind,
          },
          a,
        )
      if (!u || a.isCancellationRequested) return []
      const d = this.d.add(u)
      return u.map((m, f) => ({
        _cacheId: [d, f],
        title: m.title ?? g(2760, null, this.j.displayName || this.j.name),
        kind: m.kind,
        yieldTo: m.yieldTo?.map((p) => p.value),
        insertText:
          typeof m.insertText == "string"
            ? m.insertText
            : { snippet: m.insertText.value },
        additionalEdit: m.additionalEdit
          ? Oi.from(m.additionalEdit, void 0)
          : void 0,
      }))
    }
    async resolvePasteEdit(i, t) {
      const [e, s] = i,
        r = this.d.get(e, s)
      if (!r || !this.g.resolveDocumentPasteEdit) return {}
      const a = (await this.g.resolveDocumentPasteEdit(r, t)) ?? r
      return {
        additionalEdit: a.additionalEdit
          ? Oi.from(a.additionalEdit, void 0)
          : void 0,
      }
    }
    releasePasteEdits(i) {
      this.d.delete(i)
    }
  },
  Qot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDocumentFormattingEdits(i, t, e) {
      const s = this.d.getDocument(i),
        r = await this.e.provideDocumentFormattingEdits(s, t, e)
      if (Array.isArray(r)) return r.map(si.from)
    }
  },
  ZW = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDocumentRangeFormattingEdits(i, t, e, s) {
      const r = this.d.getDocument(i),
        a = U.to(t),
        o = await this.e.provideDocumentRangeFormattingEdits(r, a, e, s)
      if (Array.isArray(o)) return o.map(si.from)
    }
    async provideDocumentRangesFormattingEdits(i, t, e, s) {
      $G(
        typeof this.e.provideDocumentRangesFormattingEdits == "function",
        "INVALID invocation of `provideDocumentRangesFormattingEdits`",
      )
      const r = this.d.getDocument(i),
        a = t.map(U.to),
        o = await this.e.provideDocumentRangesFormattingEdits(r, a, e, s)
      if (Array.isArray(o)) return o.map(si.from)
    }
  },
  Xot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t), (this.autoFormatTriggerCharacters = [])
    }
    async provideOnTypeFormattingEdits(i, t, e, s, r) {
      const a = this.d.getDocument(i),
        o = Kt.to(t),
        c = await this.e.provideOnTypeFormattingEdits(a, o, e, s, r)
      if (Array.isArray(c)) return c.map(si.from)
    }
  },
  g3 = class {
    constructor(i, t) {
      ;(this.e = i), (this.f = t), (this.d = new wr("WorkspaceSymbols"))
    }
    async provideWorkspaceSymbols(i, t) {
      const e = await this.e.provideWorkspaceSymbols(i, t)
      if (!Cu(e)) return { symbols: [] }
      const s = this.d.add(e),
        r = { cacheId: s, symbols: [] }
      for (let a = 0; a < e.length; a++) {
        const o = e[a]
        if (!o || !o.name) {
          this.f.warn("INVALID SymbolInformation", o)
          continue
        }
        r.symbols.push({ ...Po.from(o), cacheId: [s, a] })
      }
      return r
    }
    async resolveWorkspaceSymbol(i, t) {
      if (typeof this.e.resolveWorkspaceSymbol != "function" || !i.cacheId)
        return i
      const e = this.d.get(...i.cacheId)
      if (e) {
        const s = await this.e.resolveWorkspaceSymbol(e, t)
        return s && en(i, Po.from(s), !0)
      }
    }
    releaseWorkspaceSymbols(i) {
      this.d.delete(i)
    }
  },
  v3 = class kV {
    static supportsResolving(t) {
      return typeof t.prepareRename == "function"
    }
    constructor(t, e, s) {
      ;(this.d = t), (this.e = e), (this.f = s)
    }
    async provideRenameEdits(t, e, s, r) {
      const a = this.d.getDocument(t),
        o = Kt.to(e)
      try {
        const c = await this.e.provideRenameEdits(a, o, s, r)
        return c ? Oi.from(c) : void 0
      } catch (c) {
        const l = kV.g(c)
        return l ? { rejectReason: l, edits: void 0 } : Promise.reject(c)
      }
    }
    async resolveRenameLocation(t, e, s) {
      if (typeof this.e.prepareRename != "function")
        return Promise.resolve(void 0)
      const r = this.d.getDocument(t),
        a = Kt.to(e)
      try {
        const o = await this.e.prepareRename(r, a, s)
        let c, l
        if (
          (Nt.isRange(o)
            ? ((c = o), (l = r.getText(o)))
            : Je(o) && ((c = o.range), (l = o.placeholder)),
          !c || !l)
        )
          return
        if (c.start.line > a.line || c.end.line < a.line) {
          this.f.warn(
            "INVALID rename location: position line must be within range start/end lines",
          )
          return
        }
        return { range: U.from(c), text: l }
      } catch (o) {
        const c = kV.g(o)
        return c
          ? { rejectReason: c, range: void 0, text: void 0 }
          : Promise.reject(o)
      }
    }
    static g(t) {
      return typeof t == "string"
        ? t
        : t instanceof Error && typeof t.message == "string"
          ? t.message
          : void 0
    }
  },
  tj = class SV {
    static {
      this.d = { [d6.Invoke]: Vh.Invoke, [d6.Automatic]: Vh.Automatic }
    }
    constructor(t, e, s) {
      ;(this.e = t), (this.f = e), (this.g = s)
    }
    async supportsAutomaticNewSymbolNamesTriggerKind() {
      return this.f.supportsAutomaticTriggerKind
    }
    async provideNewSymbolNames(t, e, s, r) {
      const a = this.e.getDocument(t),
        o = U.to(e)
      try {
        const c = SV.d[s],
          l = await this.f.provideNewSymbolNames(a, o, c, r)
        return l
          ? l.map((u) =>
              typeof u == "string"
                ? { newSymbolName: u }
                : { newSymbolName: u.newSymbolName, tags: u.tags },
            )
          : void 0
      } catch (c) {
        this.g.error(SV.h(c) ?? JSON.stringify(c, null, "	"))
        return
      }
    }
    static h(t) {
      return typeof t == "string"
        ? t
        : t instanceof Error && typeof t.message == "string"
          ? t.message
          : void 0
    }
  },
  ej = class {
    constructor(i, t) {
      ;(this.resultId = i), (this.tokens = t)
    }
  },
  ij = class br {
    constructor(t, e) {
      ;(this.f = t), (this.g = e), (this.e = 1), (this.d = new Map())
    }
    async provideDocumentSemanticTokens(t, e, s) {
      const r = this.f.getDocument(t),
        a = e !== 0 ? this.d.get(e) : null
      let o =
        typeof a?.resultId == "string" &&
        typeof this.g.provideDocumentSemanticTokensEdits == "function"
          ? await this.g.provideDocumentSemanticTokensEdits(r, a.resultId, s)
          : await this.g.provideDocumentSemanticTokens(r, s)
      return (
        a && this.d.delete(e), o ? ((o = br.h(o)), this.o(br.n(a, o), o)) : null
      )
    }
    async releaseDocumentSemanticColoring(t) {
      this.d.delete(t)
    }
    static h(t) {
      return br.j(t)
        ? br.k(t)
          ? t
          : new al(new Uint32Array(t.data), t.resultId)
        : br.l(t)
          ? br.m(t)
            ? t
            : new yO(
                t.edits.map(
                  (e) =>
                    new dtt(
                      e.start,
                      e.deleteCount,
                      e.data ? new Uint32Array(e.data) : e.data,
                    ),
                ),
                t.resultId,
              )
          : t
    }
    static j(t) {
      return t && !!t.data
    }
    static k(t) {
      return t.data instanceof Uint32Array
    }
    static l(t) {
      return t && Array.isArray(t.edits)
    }
    static m(t) {
      for (const e of t.edits) if (!(e.data instanceof Uint32Array)) return !1
      return !0
    }
    static n(t, e) {
      if (!br.j(e) || !t || !t.tokens) return e
      const s = t.tokens,
        r = s.length,
        a = e.data,
        o = a.length
      let c = 0
      const l = Math.min(r, o)
      for (; c < l && s[c] === a[c]; ) c++
      if (c === r && c === o) return new yO([], e.resultId)
      let u = 0
      const d = l - c
      for (; u < d && s[r - u - 1] === a[o - u - 1]; ) u++
      return new yO(
        [{ start: c, deleteCount: r - c - u, data: a.subarray(c, o - u) }],
        e.resultId,
      )
    }
    o(t, e) {
      if (br.j(t)) {
        const s = this.e++
        return (
          this.d.set(s, new ej(t.resultId, t.data)),
          EW({ id: s, type: "full", data: t.data })
        )
      }
      if (br.l(t)) {
        const s = this.e++
        return (
          br.j(e)
            ? this.d.set(s, new ej(e.resultId, e.data))
            : this.d.set(s, new ej(t.resultId)),
          EW({
            id: s,
            type: "delta",
            deltas: (t.edits || []).map((r) => ({
              start: r.start,
              deleteCount: r.deleteCount,
              data: r.data,
            })),
          })
        )
      }
      return null
    }
  },
  Kot = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDocumentRangeSemanticTokens(i, t, e) {
      const s = this.d.getDocument(i),
        r = await this.e.provideDocumentRangeSemanticTokens(s, U.to(t), e)
      return r ? this.f(r) : null
    }
    f(i) {
      return EW({ id: 0, type: "full", data: i.data })
    }
  },
  _f = class xut {
    static supportsResolving(t) {
      return typeof t.resolveCompletionItem == "function"
    }
    constructor(t, e, s, r, a) {
      ;(this.f = t),
        (this.g = e),
        (this.h = s),
        (this.j = r),
        (this.k = a),
        (this.d = new wr("CompletionItem")),
        (this.e = new Map())
    }
    async provideCompletionItems(t, e, s, r) {
      const a = this.f.getDocument(t),
        o = Kt.to(e),
        c = a.getWordRangeAtPosition(o) || new Nt(o, o),
        l = c.with({ end: o }),
        u = new ss(),
        d = await this.h.provideCompletionItems(a, o, r, MU.to(s))
      if (!d || r.isCancellationRequested) return
      const m = Array.isArray(d) ? new Vc(d) : d,
        f = xut.supportsResolving(this.h)
          ? this.d.add(m.items)
          : this.d.add([]),
        p = new gt()
      this.e.set(f, p)
      const v = [],
        b = {
          x: f,
          b: v,
          a: { replace: U.from(c), insert: U.from(l) },
          c: m.isIncomplete || void 0,
          d: u.elapsed(),
        }
      for (let k = 0; k < m.items.length; k++) {
        const E = m.items[k],
          P = this.l(E, [f, k], l, c)
        v.push(P)
      }
      return b
    }
    async resolveCompletionItem(t, e) {
      if (typeof this.h.resolveCompletionItem != "function") return
      const s = this.d.get(...t)
      if (!s) return
      const r = this.l(s, t),
        a = await this.h.resolveCompletionItem(s, e)
      if (!a) return
      const o = this.l(a, t)
      return (
        (r.h !== o.h || r.i !== o.i) &&
          this.j.report(
            "CompletionItem.insertText",
            this.k,
            "extension MAY NOT change 'insertText' of a CompletionItem during resolve",
          ),
        (r.n !== o.n || r.o !== o.o || !Qs(r.p, o.p)) &&
          this.j.report(
            "CompletionItem.command",
            this.k,
            "extension MAY NOT change 'command' of a CompletionItem during resolve",
          ),
        { ...r, d: o.d, c: o.c, l: o.l, h: o.h, i: o.i, n: o.n, o: o.o, p: o.p }
      )
    }
    releaseCompletionItems(t) {
      this.e.get(t)?.dispose(), this.e.delete(t), this.d.delete(t)
    }
    l(t, e, s, r) {
      const a = this.e.get(e[0])
      if (!a) throw Error("DisposableStore is missing...")
      const o = this.g.toInternal(t.command, a),
        c = {
          x: e,
          a: t.label,
          b: t.kind !== void 0 ? QO.from(t.kind) : void 0,
          m: t.tags && t.tags.map(YO.from),
          c: t.detail,
          d:
            typeof t.documentation > "u"
              ? void 0
              : Dt.fromStrict(t.documentation),
          e: t.sortText !== t.label ? t.sortText : void 0,
          f: t.filterText !== t.label ? t.filterText : void 0,
          g: t.preselect || void 0,
          i: t.keepWhitespace ? 1 : 0,
          k: t.commitCharacters?.join(""),
          l: t.additionalTextEdits && t.additionalTextEdits.map(si.from),
          n: o?.$ident,
          o: o?.id,
          p: o?.$ident ? void 0 : o?.arguments,
        }
      t.textEdit
        ? (this.j.report(
            "CompletionItem.textEdit",
            this.k,
            "Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.",
          ),
          (c.h = t.textEdit.newText))
        : typeof t.insertText == "string"
          ? (c.h = t.insertText)
          : t.insertText instanceof fo &&
            ((c.h = t.insertText.value), (c.i |= 4))
      let l
      return (
        t.textEdit ? (l = t.textEdit.range) : t.range && (l = t.range),
        Nt.isRange(l)
          ? (c.j = U.from(l))
          : l &&
            (!s?.isEqual(l.inserting) || !r?.isEqual(l.replacing)) &&
            (c.j = {
              insert: U.from(l.inserting),
              replace: U.from(l.replacing),
            }),
        c
      )
    }
  },
  Gl = class {
    async provideInlineCompletions(i, t, e, s) {}
    async provideInlineEditsForRange(i, t, e, s) {}
    disposeCompletions(i) {}
    handleDidShowCompletionItem(i, t, e) {}
    handlePartialAccept(i, t, e, s) {}
  },
  IUt = class extends Gl {
    constructor(i, t, e, s) {
      super(),
        (this.f = i),
        (this.g = t),
        (this.h = e),
        (this.j = s),
        (this.d = new Zot()),
        (this.e = hi(this.f, "inlineCompletionsAdditions")),
        (this.k = { [h6.Automatic]: jh.Automatic, [h6.Explicit]: jh.Invoke })
    }
    get supportsHandleEvents() {
      return (
        hi(this.f, "inlineCompletionsAdditions") &&
        (typeof this.h.handleDidShowCompletionItem == "function" ||
          typeof this.h.handleDidPartiallyAcceptCompletionItem == "function")
      )
    }
    async provideInlineCompletions(i, t, e, s) {
      const r = this.g.getDocument(i),
        a = Kt.to(t),
        o = await this.h.provideInlineCompletionItems(
          r,
          a,
          {
            selectedCompletionInfo: e.selectedSuggestionInfo
              ? {
                  range: U.to(e.selectedSuggestionInfo.range),
                  text: e.selectedSuggestionInfo.text,
                }
              : void 0,
            triggerKind: this.k[e.triggerKind],
          },
          s,
        )
      if (!o || s.isCancellationRequested) return
      const c = Array.isArray(o) ? o : o.items,
        l = this.e ? (Array.isArray(o) ? [] : o.commands || []) : [],
        u = this.e && !Array.isArray(o) ? o.enableForwardStability : void 0
      let d
      return {
        pid: this.d.createReferenceId({
          dispose() {
            d?.dispose()
          },
          items: c,
        }),
        items: c.map((f, p) => {
          let v
          f.command &&
            (d || (d = new gt()), (v = this.j.toInternal(f.command, d)))
          const b = f.insertText
          return {
            insertText: typeof b == "string" ? b : { snippet: b.value },
            filterText: f.filterText,
            range: f.range ? U.from(f.range) : void 0,
            command: v,
            idx: p,
            completeBracketPairs: this.e ? f.completeBracketPairs : !1,
          }
        }),
        commands: l.map((f) => (d || (d = new gt()), this.j.toInternal(f, d))),
        suppressSuggestions: !1,
        enableForwardStability: u,
      }
    }
    async provideInlineEditsForRange(i, t, e, s) {
      if (!this.h.provideInlineEditsForRange) return
      _(this.f, "inlineCompletionsAdditions")
      const r = this.g.getDocument(i),
        a = U.to(t),
        o = await this.h.provideInlineEditsForRange(
          r,
          a,
          {
            selectedCompletionInfo: e.selectedSuggestionInfo
              ? {
                  range: U.to(e.selectedSuggestionInfo.range),
                  text: e.selectedSuggestionInfo.text,
                }
              : void 0,
            triggerKind: this.k[e.triggerKind],
            userPrompt: e.userPrompt,
          },
          s,
        )
      if (!o || s.isCancellationRequested) return
      const c = Array.isArray(o) ? o : o.items,
        l = this.e ? (Array.isArray(o) ? [] : o.commands || []) : [],
        u = this.e && !Array.isArray(o) ? o.enableForwardStability : void 0
      let d
      return {
        pid: this.d.createReferenceId({
          dispose() {
            d?.dispose()
          },
          items: c,
        }),
        items: c.map((f, p) => {
          let v
          f.command &&
            (d || (d = new gt()), (v = this.j.toInternal(f.command, d)))
          const b = f.insertText
          return {
            insertText: typeof b == "string" ? b : { snippet: b.value },
            filterText: f.filterText,
            range: f.range ? U.from(f.range) : void 0,
            command: v,
            idx: p,
            completeBracketPairs: this.e ? f.completeBracketPairs : !1,
          }
        }),
        commands: l.map((f) => (d || (d = new gt()), this.j.toInternal(f, d))),
        suppressSuggestions: !1,
        enableForwardStability: u,
      }
    }
    disposeCompletions(i) {
      this.d.disposeReferenceId(i)?.dispose()
    }
    handleDidShowCompletionItem(i, t, e) {
      const s = this.d.get(i)?.items[t]
      s &&
        this.h.handleDidShowCompletionItem &&
        this.e &&
        this.h.handleDidShowCompletionItem(s, e)
    }
    handlePartialAccept(i, t, e, s) {
      const r = this.d.get(i)?.items[t]
      r &&
        this.h.handleDidPartiallyAcceptCompletionItem &&
        this.e &&
        (this.h.handleDidPartiallyAcceptCompletionItem(r, e),
        this.h.handleDidPartiallyAcceptCompletionItem(r, oM.to(s)))
    }
  },
  sj = class {
    async provideInlineEdits(i, t, e) {
      const s = this.f.getDocument(i),
        r = await this.g.provideInlineEdit(
          s,
          { triggerKind: this.e[t.triggerKind] },
          e,
        )
      if (!r || e.isCancellationRequested) return
      let a
      const o = this.d.createReferenceId({
        dispose() {
          a?.dispose()
        },
        item: r,
      })
      let c
      r.accepted &&
        (a || (a = new gt()), (c = this.h.toInternal(r.accepted, a)))
      let l
      r.rejected &&
        (a || (a = new gt()), (l = this.h.toInternal(r.rejected, a)))
      let u
      return (
        r.shown && (a || (a = new gt()), (u = this.h.toInternal(r.shown, a))),
        a || (a = new gt()),
        {
          pid: o,
          text: r.text,
          range: U.from(r.range),
          accepted: c,
          rejected: l,
          shown: u,
          commands: r.commands?.map((m) => this.h.toInternal(m, a)),
        }
      )
    }
    disposeEdit(i) {
      this.d.disposeReferenceId(i)?.dispose()
    }
    constructor(i, t, e, s) {
      ;(this.f = t),
        (this.g = e),
        (this.h = s),
        (this.d = new Zot()),
        (this.e = { [m6.Automatic]: ld.Automatic, [m6.Invoke]: ld.Invoke })
    }
  },
  Zot = class {
    constructor() {
      ;(this.d = new Map()), (this.e = 1)
    }
    createReferenceId(i) {
      const t = this.e++
      return this.d.set(t, i), t
    }
    disposeReferenceId(i) {
      const t = this.d.get(i)
      return this.d.delete(i), t
    }
    get(i) {
      return this.d.get(i)
    }
  },
  rj = class {
    constructor(i, t) {
      ;(this.e = i), (this.f = t), (this.d = new wr("SignatureHelp"))
    }
    async provideSignatureHelp(i, t, e, s) {
      const r = this.e.getDocument(i),
        a = Kt.to(t),
        o = this.g(e),
        c = await this.f.provideSignatureHelp(r, a, s, o)
      if (c) {
        const l = this.d.add([c])
        return { ...dd.from(c), id: l }
      }
    }
    g(i) {
      let t
      if (i.activeSignatureHelp) {
        const e = dd.to(i.activeSignatureHelp),
          s = this.d.get(i.activeSignatureHelp.id, 0)
        s
          ? ((t = s),
            (t.activeSignature = e.activeSignature),
            (t.activeParameter = e.activeParameter))
          : (t = e)
      }
      return { ...i, activeSignatureHelp: t }
    }
    releaseSignatureHelp(i) {
      this.d.delete(i)
    }
  },
  w3 = class {
    constructor(i, t, e, s, r) {
      ;(this.f = i),
        (this.g = t),
        (this.h = e),
        (this.j = s),
        (this.k = r),
        (this.d = new wr("InlayHints")),
        (this.e = new Map())
    }
    async provideInlayHints(i, t, e) {
      const s = this.f.getDocument(i),
        r = U.to(t),
        a = await this.h.provideInlayHints(s, r, e)
      if (!Array.isArray(a) || a.length === 0) {
        this.j.trace(
          `[InlayHints] NO inlay hints from '${this.k.identifier.value}' for range ${JSON.stringify(t)}`,
        )
        return
      }
      if (e.isCancellationRequested) return
      const o = this.d.add(a)
      this.e.set(o, new gt())
      const c = { hints: [], cacheId: o }
      for (let l = 0; l < a.length; l++)
        this.l(a[l], r) && c.hints.push(this.m(a[l], [o, l]))
      return (
        this.j.trace(
          `[InlayHints] ${c.hints.length} inlay hints from '${this.k.identifier.value}' for range ${JSON.stringify(t)}`,
        ),
        c
      )
    }
    async resolveInlayHint(i, t) {
      if (typeof this.h.resolveInlayHint != "function") return
      const e = this.d.get(...i)
      if (!e) return
      const s = await this.h.resolveInlayHint(e, t)
      if (s && this.l(s)) return this.m(s, i)
    }
    releaseHints(i) {
      this.e.get(i)?.dispose(), this.e.delete(i), this.d.delete(i)
    }
    l(i, t) {
      return i.label.length === 0 ||
        (Array.isArray(i.label) && i.label.every((e) => e.value.length === 0))
        ? (console.log("INVALID inlay hint, empty label", i), !1)
        : !(t && !t.contains(i.position))
    }
    m(i, t) {
      const e = this.e.get(t[0])
      if (!e) throw Error("DisposableStore is missing...")
      const s = {
        label: "",
        cacheId: t,
        tooltip: Dt.fromStrict(i.tooltip),
        position: Kt.from(i.position),
        textEdits: i.textEdits && i.textEdits.map(si.from),
        kind: i.kind && ZO.from(i.kind),
        paddingLeft: i.paddingLeft,
        paddingRight: i.paddingRight,
      }
      if (typeof i.label == "string") s.label = i.label
      else {
        const r = []
        s.label = r
        for (const a of i.label) {
          if (!a.value) {
            console.warn(
              "INVALID inlay hint, empty label part",
              this.k.identifier.value,
            )
            continue
          }
          const o = { label: a.value, tooltip: Dt.fromStrict(a.tooltip) }
          ys.isLocation(a.location) && (o.location = Qi.from(a.location)),
            a.command && (o.command = this.g.toInternal(a.command, e)),
            r.push(o)
        }
      }
      return s
    }
  },
  y3 = class t7 {
    constructor(t, e) {
      ;(this.e = t), (this.f = e), (this.d = new wr("DocumentLink"))
    }
    async provideLinks(t, e) {
      const s = this.e.getDocument(t),
        r = await this.f.provideDocumentLinks(s, e)
      if (
        !(!Array.isArray(r) || r.length === 0) &&
        !e.isCancellationRequested
      ) {
        if (typeof this.f.resolveDocumentLink != "function")
          return { links: r.filter(t7.g).map(xo.from) }
        {
          const a = this.d.add(r),
            o = { links: [], cacheId: a }
          for (let c = 0; c < r.length; c++) {
            if (!t7.g(r[c])) continue
            const l = xo.from(r[c])
            ;(l.cacheId = [a, c]), o.links.push(l)
          }
          return o
        }
      }
    }
    static g(t) {
      return t.target && t.target.path.length > 5e4
        ? (console.warn("DROPPING link because it is too long"), !1)
        : !0
    }
    async resolveLink(t, e) {
      if (typeof this.f.resolveDocumentLink != "function") return
      const s = this.d.get(...t)
      if (!s) return
      const r = await this.f.resolveDocumentLink(s, e)
      if (!(!r || !t7.g(r))) return xo.from(r)
    }
    releaseLinks(t) {
      this.d.delete(t)
    }
  },
  nj = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideColors(i, t) {
      const e = this.d.getDocument(i),
        s = await this.e.provideDocumentColors(e, t)
      return Array.isArray(s)
        ? s.map((a) => ({ color: gl.from(a.color), range: U.from(a.range) }))
        : []
    }
    async provideColorPresentations(i, t, e) {
      const s = this.d.getDocument(i),
        r = U.to(t.range),
        a = gl.to(t.color),
        o = await this.e.provideColorPresentations(
          a,
          { document: s, range: r },
          e,
        )
      if (Array.isArray(o)) return o.map(t8.from)
    }
  },
  tct = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideFoldingRanges(i, t, e) {
      const s = this.d.getDocument(i),
        r = await this.e.provideFoldingRanges(s, t, e)
      if (Array.isArray(r)) return r.map(i8.from)
    }
  },
  ect = class {
    constructor(i, t, e) {
      ;(this.d = i), (this.e = t), (this.f = e)
    }
    async provideSelectionRanges(i, t, e) {
      const s = this.d.getDocument(i),
        r = t.map(Kt.to),
        a = await this.e.provideSelectionRanges(s, r, e)
      if (!Cu(a)) return []
      if (a.length !== r.length)
        return (
          this.f.warn(
            "BAD selection ranges, provider must return ranges for each position",
          ),
          []
        )
      const o = []
      for (let c = 0; c < r.length; c++) {
        const l = []
        o.push(l)
        let u = r[c],
          d = a[c]
        for (;;) {
          if (!d.range.contains(u))
            throw new Error(
              "INVALID selection range, must contain the previous range",
            )
          if ((l.push(VU.from(d)), !d.parent)) break
          ;(u = d.range), (d = d.parent)
        }
      }
      return o
    }
  },
  Of = class {
    constructor(i, t) {
      ;(this.f = i), (this.g = t), (this.d = new vB("")), (this.e = new Map())
    }
    async prepareSession(i, t, e) {
      const s = this.f.getDocument(i),
        r = Kt.to(t),
        a = await this.g.prepareCallHierarchy(s, r, e)
      if (!a) return
      const o = this.d.nextId()
      return (
        this.e.set(o, new Map()),
        Array.isArray(a) ? a.map((c) => this.h(o, c)) : [this.h(o, a)]
      )
    }
    async provideCallsTo(i, t, e) {
      const s = this.j(i, t)
      if (!s) throw new Error("missing call hierarchy item")
      const r = await this.g.provideCallHierarchyIncomingCalls(s, e)
      if (r)
        return r.map((a) => ({
          from: this.h(i, a.from),
          fromRanges: a.fromRanges.map((o) => U.from(o)),
        }))
    }
    async provideCallsFrom(i, t, e) {
      const s = this.j(i, t)
      if (!s) throw new Error("missing call hierarchy item")
      const r = await this.g.provideCallHierarchyOutgoingCalls(s, e)
      if (r)
        return r.map((a) => ({
          to: this.h(i, a.to),
          fromRanges: a.fromRanges.map((o) => U.from(o)),
        }))
    }
    releaseSession(i) {
      this.e.delete(i)
    }
    h(i, t) {
      const e = this.e.get(i),
        s = $o.from(t, i, e.size.toString(36))
      return e.set(s._itemId, t), s
    }
    j(i, t) {
      return this.e.get(i)?.get(t)
    }
  },
  Bf = class {
    constructor(i, t) {
      ;(this.f = i), (this.g = t), (this.d = new vB("")), (this.e = new Map())
    }
    async prepareSession(i, t, e) {
      const s = this.f.getDocument(i),
        r = Kt.to(t),
        a = await this.g.prepareTypeHierarchy(s, r, e)
      if (!a) return
      const o = this.d.nextId()
      return (
        this.e.set(o, new Map()),
        Array.isArray(a) ? a.map((c) => this.h(o, c)) : [this.h(o, a)]
      )
    }
    async provideSupertypes(i, t, e) {
      const s = this.j(i, t)
      if (!s) throw new Error("missing type hierarchy item")
      const r = await this.g.provideTypeHierarchySupertypes(s, e)
      if (r) return r.map((a) => this.h(i, a))
    }
    async provideSubtypes(i, t, e) {
      const s = this.j(i, t)
      if (!s) throw new Error("missing type hierarchy item")
      const r = await this.g.provideTypeHierarchySubtypes(s, e)
      if (r) return r.map((a) => this.h(i, a))
    }
    releaseSession(i) {
      this.e.delete(i)
    }
    h(i, t) {
      const e = this.e.get(i),
        s = No.from(t, i, e.size.toString(36))
      return e.set(s._itemId, t), s
    }
    j(i, t) {
      return this.e.get(i)?.get(t)
    }
  },
  b3 = class {
    constructor(i, t, e, s, r) {
      ;(this.e = i),
        (this.f = t),
        (this.g = e),
        (this.h = s),
        (this.j = r),
        (this.d = new wr("DocumentDropEdit"))
    }
    async provideDocumentOnDropEdits(i, t, e, s, r) {
      const a = this.f.getDocument(t),
        o = Kt.to(e),
        c = pa.toDataTransfer(
          s,
          async (m) =>
            (await this.e.$resolveDocumentOnDropFileData(this.h, i, m)).buffer,
        ),
        l = await this.g.provideDocumentDropEdits(a, o, c, r)
      if (!l) return
      const u = Ir(l),
        d = this.d.add(u)
      return u.map((m, f) => ({
        _cacheId: [d, f],
        title: m.title ?? g(2761, null, this.j.displayName || this.j.name),
        kind: m.kind?.value,
        yieldTo: m.yieldTo?.map((p) => p.value),
        insertText:
          typeof m.insertText == "string"
            ? m.insertText
            : { snippet: m.insertText.value },
        additionalEdit: m.additionalEdit
          ? Oi.from(m.additionalEdit, void 0)
          : void 0,
      }))
    }
    async resolveDropEdit(i, t) {
      const [e, s] = i,
        r = this.d.get(e, s)
      if (!r || !this.g.resolveDocumentDropEdit) return {}
      const a = (await this.g.resolveDocumentDropEdit(r, t)) ?? r
      return {
        additionalEdit: a.additionalEdit
          ? Oi.from(a.additionalEdit, void 0)
          : void 0,
      }
    }
    releaseDropEdits(i) {
      this.d.delete(i)
    }
  },
  ict = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideMappedEdits(i, t, e, s) {
      const r = S.revive(i),
        a = this.d.getDocument(r),
        o = (d) => ({
          uri: S.revive(d.uri),
          version: d.version,
          ranges: d.ranges.map((m) => U.to(m)),
        }),
        c = e.documents.map((d) => d.map(o)),
        l = {
          documents: c,
          selections: c[0]?.[0]?.ranges ?? [],
          conversation: e.conversation?.map((d) =>
            d.type === "response"
              ? {
                  type: "response",
                  message: d.message,
                  references: d.references?.map(o),
                }
              : { type: "request", message: d.message },
          ),
        },
        u = await this.e.provideMappedEdits(a, t, l, s)
      return u ? Oi.from(u) : null
    }
  },
  qf = class {
    constructor(i, t) {
      ;(this.adapter = i), (this.extension = t)
    }
  },
  PUt = class di {
    static {
      this.d = 0
    }
    constructor(t, e, s, r, a, o, c, l) {
      ;(this.g = e),
        (this.h = s),
        (this.j = r),
        (this.k = a),
        (this.l = o),
        (this.m = c),
        (this.n = l),
        (this.f = new Map()),
        (this.e = t.getProxy(K.MainThreadLanguageFeatures))
    }
    o(t, e) {
      return dl.from(t, this.g, e)
    }
    p(t) {
      return new Ht(() => {
        this.f.delete(t), this.e.$unregister(t)
      })
    }
    q() {
      return di.d++
    }
    async s(t, e, s, r, a, o = !1) {
      const c = this.f.get(t)
      if (!c || !(c.adapter instanceof e)) return r
      const l = Date.now()
      o ||
        this.l.trace(
          `[${c.extension.identifier.value}] INVOKE provider '${s.toString().replace(/[\r\n]/g, "")}'`,
        )
      const u = s(c.adapter, c.extension)
      return (
        Promise.resolve(u)
          .catch((d) => {
            Ms(d) ||
              (this.l.error(
                `[${c.extension.identifier.value}] provider FAILED`,
              ),
              this.l.error(d),
              this.n.onExtensionError(c.extension.identifier, d))
          })
          .finally(() => {
            o ||
              this.l.trace(
                `[${c.extension.identifier.value}] provider DONE after ${Date.now() - l}ms`,
              )
          }),
        ce.isCancellationToken(a) ? Nmt(u, a) : u
      )
    }
    t(t, e) {
      const s = this.q()
      return this.f.set(s, new qf(t, e)), s
    }
    static u(t) {
      return t.displayName || t.name
    }
    static w(t) {
      return t.identifier.value
    }
    registerDocumentSymbolProvider(t, e, s, r) {
      const a = this.t(new Bot(this.h, s), t),
        o = (r && r.label) || di.u(t)
      return (
        this.e.$registerDocumentSymbolProvider(a, this.o(e, t), o), this.p(a)
      )
    }
    $provideDocumentSymbols(t, e, s) {
      return this.s(
        t,
        Bot,
        (r) => r.provideDocumentSymbols(S.revive(e), s),
        void 0,
        s,
      )
    }
    registerCodeLensProvider(t, e, s) {
      const r = this.q(),
        a = typeof s.onDidChangeCodeLenses == "function" ? this.q() : void 0
      this.f.set(
        r,
        new qf(new m3(this.h, this.j.converter, s, t, this.n, this.l), t),
      ),
        this.e.$registerCodeLensSupport(r, this.o(e, t), a)
      let o = this.p(r)
      if (a !== void 0) {
        const c = s.onDidChangeCodeLenses((l) => this.e.$emitCodeLensEvent(a))
        o = Ht.from(o, c)
      }
      return o
    }
    $provideCodeLenses(t, e, s) {
      return this.s(
        t,
        m3,
        (r) => r.provideCodeLenses(S.revive(e), s),
        void 0,
        s,
        e.scheme === "output",
      )
    }
    $resolveCodeLens(t, e, s) {
      return this.s(t, m3, (r) => r.resolveCodeLens(e, s), void 0, void 0, !0)
    }
    $releaseCodeLenses(t, e) {
      this.s(
        t,
        m3,
        (s) => Promise.resolve(s.releaseCodeLenses(e)),
        void 0,
        void 0,
        !0,
      )
    }
    registerDefinitionProvider(t, e, s) {
      const r = this.t(new qot(this.h, s), t)
      return this.e.$registerDefinitionSupport(r, this.o(e, t)), this.p(r)
    }
    $provideDefinition(t, e, s, r) {
      return this.s(
        t,
        qot,
        (a) => a.provideDefinition(S.revive(e), s, r),
        [],
        r,
      )
    }
    registerDeclarationProvider(t, e, s) {
      const r = this.t(new Uot(this.h, s), t)
      return this.e.$registerDeclarationSupport(r, this.o(e, t)), this.p(r)
    }
    $provideDeclaration(t, e, s, r) {
      return this.s(
        t,
        Uot,
        (a) => a.provideDeclaration(S.revive(e), s, r),
        [],
        r,
      )
    }
    registerImplementationProvider(t, e, s) {
      const r = this.t(new Mot(this.h, s), t)
      return this.e.$registerImplementationSupport(r, this.o(e, t)), this.p(r)
    }
    $provideImplementation(t, e, s, r) {
      return this.s(
        t,
        Mot,
        (a) => a.provideImplementation(S.revive(e), s, r),
        [],
        r,
      )
    }
    registerTypeDefinitionProvider(t, e, s) {
      const r = this.t(new Hot(this.h, s), t)
      return this.e.$registerTypeDefinitionSupport(r, this.o(e, t)), this.p(r)
    }
    $provideTypeDefinition(t, e, s, r) {
      return this.s(
        t,
        Hot,
        (a) => a.provideTypeDefinition(S.revive(e), s, r),
        [],
        r,
      )
    }
    registerHoverProvider(t, e, s, r) {
      const a = this.t(new KW(this.h, s), t)
      return this.e.$registerHoverProvider(a, this.o(e, t)), this.p(a)
    }
    $provideHover(t, e, s, r, a) {
      return this.s(
        t,
        KW,
        (o) => o.provideHover(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    $releaseHover(t, e) {
      this.s(t, KW, (s) => Promise.resolve(s.releaseHover(e)), void 0, void 0)
    }
    registerEvaluatableExpressionProvider(t, e, s, r) {
      const a = this.t(new Wot(this.h, s), t)
      return (
        this.e.$registerEvaluatableExpressionProvider(a, this.o(e, t)),
        this.p(a)
      )
    }
    $provideEvaluatableExpression(t, e, s, r) {
      return this.s(
        t,
        Wot,
        (a) => a.provideEvaluatableExpression(S.revive(e), s, r),
        void 0,
        r,
      )
    }
    registerInlineValuesProvider(t, e, s, r) {
      const a =
          typeof s.onDidChangeInlineValues == "function" ? this.q() : void 0,
        o = this.t(new jot(this.h, s), t)
      this.e.$registerInlineValuesProvider(o, this.o(e, t), a)
      let c = this.p(o)
      if (a !== void 0) {
        const l = s.onDidChangeInlineValues((u) =>
          this.e.$emitInlineValuesEvent(a),
        )
        c = Ht.from(c, l)
      }
      return c
    }
    $provideInlineValues(t, e, s, r, a) {
      return this.s(
        t,
        jot,
        (o) => o.provideInlineValues(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    registerDocumentHighlightProvider(t, e, s) {
      const r = this.t(new Vot(this.h, s), t)
      return (
        this.e.$registerDocumentHighlightProvider(r, this.o(e, t)), this.p(r)
      )
    }
    registerMultiDocumentHighlightProvider(t, e, s) {
      const r = this.t(new Got(this.h, s, this.l), t)
      return (
        this.e.$registerMultiDocumentHighlightProvider(r, this.o(e, t)),
        this.p(r)
      )
    }
    $provideDocumentHighlights(t, e, s, r) {
      return this.s(
        t,
        Vot,
        (a) => a.provideDocumentHighlights(S.revive(e), s, r),
        void 0,
        r,
      )
    }
    $provideMultiDocumentHighlights(t, e, s, r, a) {
      return this.s(
        t,
        Got,
        (o) =>
          o.provideMultiDocumentHighlights(
            S.revive(e),
            s,
            r.map((c) => S.revive(c)),
            a,
          ),
        void 0,
        a,
      )
    }
    registerLinkedEditingRangeProvider(t, e, s) {
      const r = this.t(new zot(this.h, s), t)
      return (
        this.e.$registerLinkedEditingRangeProvider(r, this.o(e, t)), this.p(r)
      )
    }
    $provideLinkedEditingRanges(t, e, s, r) {
      return this.s(
        t,
        zot,
        async (a) => {
          const o = await a.provideLinkedEditingRanges(S.revive(e), s, r)
          if (o)
            return {
              ranges: o.ranges,
              wordPattern: o.wordPattern ? di.y(o.wordPattern) : void 0,
            }
        },
        void 0,
        r,
      )
    }
    registerReferenceProvider(t, e, s) {
      const r = this.t(new Yot(this.h, s), t)
      return this.e.$registerReferenceSupport(r, this.o(e, t)), this.p(r)
    }
    $provideReferences(t, e, s, r, a) {
      return this.s(
        t,
        Yot,
        (o) => o.provideReferences(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    registerCodeActionProvider(t, e, s, r) {
      const a = new gt(),
        o = this.t(
          new p3(this.h, this.j.converter, this.k, s, this.l, t, this.m),
          t,
        )
      return (
        this.e.$registerCodeActionSupport(
          o,
          this.o(e, t),
          {
            providedKinds: r?.providedCodeActionKinds?.map((c) => c.value),
            documentation: r?.documentation?.map((c) => ({
              kind: c.kind.value,
              command: this.j.converter.toInternal(c.command, a),
            })),
          },
          di.u(t),
          di.w(t),
          !!s.resolveCodeAction,
        ),
        a.add(this.p(o)),
        a
      )
    }
    $provideCodeActions(t, e, s, r, a) {
      return this.s(
        t,
        p3,
        (o) => o.provideCodeActions(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    $resolveCodeAction(t, e, s) {
      return this.s(t, p3, (r) => r.resolveCodeAction(e, s), {}, void 0)
    }
    $releaseCodeActions(t, e) {
      this.s(
        t,
        p3,
        (s) => Promise.resolve(s.releaseCodeActions(e)),
        void 0,
        void 0,
      )
    }
    registerDocumentFormattingEditProvider(t, e, s) {
      const r = this.t(new Qot(this.h, s), t)
      return (
        this.e.$registerDocumentFormattingSupport(
          r,
          this.o(e, t),
          t.identifier,
          t.displayName || t.name,
        ),
        this.p(r)
      )
    }
    $provideDocumentFormattingEdits(t, e, s, r) {
      return this.s(
        t,
        Qot,
        (a) => a.provideDocumentFormattingEdits(S.revive(e), s, r),
        void 0,
        r,
      )
    }
    registerDocumentRangeFormattingEditProvider(t, e, s) {
      const r = typeof s.provideDocumentRangesFormattingEdits == "function",
        a = this.t(new ZW(this.h, s), t)
      return (
        this.e.$registerRangeFormattingSupport(
          a,
          this.o(e, t),
          t.identifier,
          t.displayName || t.name,
          r,
        ),
        this.p(a)
      )
    }
    $provideDocumentRangeFormattingEdits(t, e, s, r, a) {
      return this.s(
        t,
        ZW,
        (o) => o.provideDocumentRangeFormattingEdits(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    $provideDocumentRangesFormattingEdits(t, e, s, r, a) {
      return this.s(
        t,
        ZW,
        (o) => o.provideDocumentRangesFormattingEdits(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    registerOnTypeFormattingEditProvider(t, e, s, r) {
      const a = this.t(new Xot(this.h, s), t)
      return (
        this.e.$registerOnTypeFormattingSupport(
          a,
          this.o(e, t),
          r,
          t.identifier,
        ),
        this.p(a)
      )
    }
    $provideOnTypeFormattingEdits(t, e, s, r, a, o) {
      return this.s(
        t,
        Xot,
        (c) => c.provideOnTypeFormattingEdits(S.revive(e), s, r, a, o),
        void 0,
        o,
      )
    }
    registerWorkspaceSymbolProvider(t, e) {
      const s = this.t(new g3(e, this.l), t)
      return (
        this.e.$registerNavigateTypeSupport(
          s,
          typeof e.resolveWorkspaceSymbol == "function",
        ),
        this.p(s)
      )
    }
    $provideWorkspaceSymbols(t, e, s) {
      return this.s(
        t,
        g3,
        (r) => r.provideWorkspaceSymbols(e, s),
        { symbols: [] },
        s,
      )
    }
    $resolveWorkspaceSymbol(t, e, s) {
      return this.s(
        t,
        g3,
        (r) => r.resolveWorkspaceSymbol(e, s),
        void 0,
        void 0,
      )
    }
    $releaseWorkspaceSymbols(t, e) {
      this.s(t, g3, (s) => s.releaseWorkspaceSymbols(e), void 0, void 0)
    }
    registerRenameProvider(t, e, s) {
      const r = this.t(new v3(this.h, s, this.l), t)
      return (
        this.e.$registerRenameSupport(r, this.o(e, t), v3.supportsResolving(s)),
        this.p(r)
      )
    }
    $provideRenameEdits(t, e, s, r, a) {
      return this.s(
        t,
        v3,
        (o) => o.provideRenameEdits(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    $resolveRenameLocation(t, e, s, r) {
      return this.s(
        t,
        v3,
        (a) => a.resolveRenameLocation(S.revive(e), s, r),
        void 0,
        r,
      )
    }
    registerNewSymbolNamesProvider(t, e, s) {
      const r = this.t(new tj(this.h, s, this.l), t)
      return this.e.$registerNewSymbolNamesProvider(r, this.o(e, t)), this.p(r)
    }
    $supportsAutomaticNewSymbolNamesTriggerKind(t) {
      return this.s(
        t,
        tj,
        (e) => e.supportsAutomaticNewSymbolNamesTriggerKind(),
        !1,
        void 0,
      )
    }
    $provideNewSymbolNames(t, e, s, r, a) {
      return this.s(
        t,
        tj,
        (o) => o.provideNewSymbolNames(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    registerDocumentSemanticTokensProvider(t, e, s, r) {
      const a = this.t(new ij(this.h, s), t),
        o = typeof s.onDidChangeSemanticTokens == "function" ? this.q() : void 0
      this.e.$registerDocumentSemanticTokensProvider(a, this.o(e, t), r, o)
      let c = this.p(a)
      if (o) {
        const l = s.onDidChangeSemanticTokens((u) =>
          this.e.$emitDocumentSemanticTokensEvent(o),
        )
        c = Ht.from(c, l)
      }
      return c
    }
    $provideDocumentSemanticTokens(t, e, s, r) {
      return this.s(
        t,
        ij,
        (a) => a.provideDocumentSemanticTokens(S.revive(e), s, r),
        null,
        r,
      )
    }
    $releaseDocumentSemanticTokens(t, e) {
      this.s(t, ij, (s) => s.releaseDocumentSemanticColoring(e), void 0, void 0)
    }
    registerDocumentRangeSemanticTokensProvider(t, e, s, r) {
      const a = this.t(new Kot(this.h, s), t)
      return (
        this.e.$registerDocumentRangeSemanticTokensProvider(a, this.o(e, t), r),
        this.p(a)
      )
    }
    $provideDocumentRangeSemanticTokens(t, e, s, r) {
      return this.s(
        t,
        Kot,
        (a) => a.provideDocumentRangeSemanticTokens(S.revive(e), s, r),
        null,
        r,
      )
    }
    registerCompletionItemProvider(t, e, s, r) {
      const a = this.t(new _f(this.h, this.j.converter, s, this.m, t), t)
      return (
        this.e.$registerCompletionsProvider(
          a,
          this.o(e, t),
          r,
          _f.supportsResolving(s),
          t.identifier,
        ),
        this.p(a)
      )
    }
    $provideCompletionItems(t, e, s, r, a) {
      return this.s(
        t,
        _f,
        (o) => o.provideCompletionItems(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    $resolveCompletionItem(t, e, s) {
      return this.s(t, _f, (r) => r.resolveCompletionItem(e, s), void 0, s)
    }
    $releaseCompletionItems(t, e) {
      this.s(t, _f, (s) => s.releaseCompletionItems(e), void 0, void 0)
    }
    registerInlineCompletionsProvider(t, e, s, r) {
      const a = new IUt(t, this.h, s, this.j.converter),
        o = this.t(a, t)
      return (
        this.e.$registerInlineCompletionsSupport(
          o,
          this.o(e, t),
          a.supportsHandleEvents,
          ae.toKey(t.identifier.value),
          r?.yieldTo?.map((c) => ae.toKey(c)) || [],
        ),
        this.p(o)
      )
    }
    $provideInlineCompletions(t, e, s, r, a) {
      return this.s(
        t,
        Gl,
        (o) => o.provideInlineCompletions(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    $provideInlineEditsForRange(t, e, s, r, a) {
      return this.s(
        t,
        Gl,
        (o) => o.provideInlineEditsForRange(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    $handleInlineCompletionDidShow(t, e, s, r) {
      this.s(
        t,
        Gl,
        async (a) => {
          a.handleDidShowCompletionItem(e, s, r)
        },
        void 0,
        void 0,
      )
    }
    $handleInlineCompletionPartialAccept(t, e, s, r, a) {
      this.s(
        t,
        Gl,
        async (o) => {
          o.handlePartialAccept(e, s, r, a)
        },
        void 0,
        void 0,
      )
    }
    $freeInlineCompletionsList(t, e) {
      this.s(
        t,
        Gl,
        async (s) => {
          s.disposeCompletions(e)
        },
        void 0,
        void 0,
      )
    }
    registerInlineEditProvider(t, e, s) {
      const r = new sj(t, this.h, s, this.j.converter),
        a = this.t(r, t)
      return (
        this.e.$registerInlineEditProvider(a, this.o(e, t), t.identifier),
        this.p(a)
      )
    }
    $provideInlineEdit(t, e, s, r) {
      return this.s(
        t,
        sj,
        (a) => a.provideInlineEdits(S.revive(e), s, r),
        void 0,
        r,
      )
    }
    $freeInlineEdit(t, e) {
      this.s(
        t,
        sj,
        async (s) => {
          s.disposeEdit(e)
        },
        void 0,
        void 0,
      )
    }
    registerSignatureHelpProvider(t, e, s, r) {
      const a = Array.isArray(r)
          ? { triggerCharacters: r, retriggerCharacters: [] }
          : r,
        o = this.t(new rj(this.h, s), t)
      return (
        this.e.$registerSignatureHelpProvider(o, this.o(e, t), a), this.p(o)
      )
    }
    $provideSignatureHelp(t, e, s, r, a) {
      return this.s(
        t,
        rj,
        (o) => o.provideSignatureHelp(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    $releaseSignatureHelp(t, e) {
      this.s(t, rj, (s) => s.releaseSignatureHelp(e), void 0, void 0)
    }
    registerInlayHintsProvider(t, e, s) {
      const r =
          typeof s.onDidChangeInlayHints == "function" ? this.q() : void 0,
        a = this.t(new w3(this.h, this.j.converter, s, this.l, t), t)
      this.e.$registerInlayHintsProvider(
        a,
        this.o(e, t),
        typeof s.resolveInlayHint == "function",
        r,
        di.u(t),
      )
      let o = this.p(a)
      if (r !== void 0) {
        const c = s.onDidChangeInlayHints((l) => this.e.$emitInlayHintsEvent(r))
        o = Ht.from(o, c)
      }
      return o
    }
    $provideInlayHints(t, e, s, r) {
      return this.s(
        t,
        w3,
        (a) => a.provideInlayHints(S.revive(e), s, r),
        void 0,
        r,
      )
    }
    $resolveInlayHint(t, e, s) {
      return this.s(t, w3, (r) => r.resolveInlayHint(e, s), void 0, s)
    }
    $releaseInlayHints(t, e) {
      this.s(t, w3, (s) => s.releaseHints(e), void 0, void 0)
    }
    registerDocumentLinkProvider(t, e, s) {
      const r = this.t(new y3(this.h, s), t)
      return (
        this.e.$registerDocumentLinkProvider(
          r,
          this.o(e, t),
          typeof s.resolveDocumentLink == "function",
        ),
        this.p(r)
      )
    }
    $provideDocumentLinks(t, e, s) {
      return this.s(
        t,
        y3,
        (r) => r.provideLinks(S.revive(e), s),
        void 0,
        s,
        e.scheme === "output",
      )
    }
    $resolveDocumentLink(t, e, s) {
      return this.s(t, y3, (r) => r.resolveLink(e, s), void 0, void 0, !0)
    }
    $releaseDocumentLinks(t, e) {
      this.s(t, y3, (s) => s.releaseLinks(e), void 0, void 0, !0)
    }
    registerColorProvider(t, e, s) {
      const r = this.t(new nj(this.h, s), t)
      return this.e.$registerDocumentColorProvider(r, this.o(e, t)), this.p(r)
    }
    $provideDocumentColors(t, e, s) {
      return this.s(t, nj, (r) => r.provideColors(S.revive(e), s), [], s)
    }
    $provideColorPresentations(t, e, s, r) {
      return this.s(
        t,
        nj,
        (a) => a.provideColorPresentations(S.revive(e), s, r),
        void 0,
        r,
      )
    }
    registerFoldingRangeProvider(t, e, s) {
      const r = this.q(),
        a = typeof s.onDidChangeFoldingRanges == "function" ? this.q() : void 0
      this.f.set(r, new qf(new tct(this.h, s), t)),
        this.e.$registerFoldingRangeProvider(r, this.o(e, t), t.identifier, a)
      let o = this.p(r)
      if (a !== void 0) {
        const c = s.onDidChangeFoldingRanges(() =>
          this.e.$emitFoldingRangeEvent(a),
        )
        o = Ht.from(o, c)
      }
      return o
    }
    $provideFoldingRanges(t, e, s, r) {
      return this.s(
        t,
        tct,
        (a) => a.provideFoldingRanges(S.revive(e), s, r),
        void 0,
        r,
      )
    }
    registerSelectionRangeProvider(t, e, s) {
      const r = this.t(new ect(this.h, s, this.l), t)
      return this.e.$registerSelectionRangeProvider(r, this.o(e, t)), this.p(r)
    }
    $provideSelectionRanges(t, e, s, r) {
      return this.s(
        t,
        ect,
        (a) => a.provideSelectionRanges(S.revive(e), s, r),
        [],
        r,
      )
    }
    registerCallHierarchyProvider(t, e, s) {
      const r = this.t(new Of(this.h, s), t)
      return this.e.$registerCallHierarchyProvider(r, this.o(e, t)), this.p(r)
    }
    $prepareCallHierarchy(t, e, s, r) {
      return this.s(
        t,
        Of,
        (a) => Promise.resolve(a.prepareSession(S.revive(e), s, r)),
        void 0,
        r,
      )
    }
    $provideCallHierarchyIncomingCalls(t, e, s, r) {
      return this.s(t, Of, (a) => a.provideCallsTo(e, s, r), void 0, r)
    }
    $provideCallHierarchyOutgoingCalls(t, e, s, r) {
      return this.s(t, Of, (a) => a.provideCallsFrom(e, s, r), void 0, r)
    }
    $releaseCallHierarchy(t, e) {
      this.s(t, Of, (s) => Promise.resolve(s.releaseSession(e)), void 0, void 0)
    }
    registerTypeHierarchyProvider(t, e, s) {
      const r = this.t(new Bf(this.h, s), t)
      return this.e.$registerTypeHierarchyProvider(r, this.o(e, t)), this.p(r)
    }
    $prepareTypeHierarchy(t, e, s, r) {
      return this.s(
        t,
        Bf,
        (a) => Promise.resolve(a.prepareSession(S.revive(e), s, r)),
        void 0,
        r,
      )
    }
    $provideTypeHierarchySupertypes(t, e, s, r) {
      return this.s(t, Bf, (a) => a.provideSupertypes(e, s, r), void 0, r)
    }
    $provideTypeHierarchySubtypes(t, e, s, r) {
      return this.s(t, Bf, (a) => a.provideSubtypes(e, s, r), void 0, r)
    }
    $releaseTypeHierarchy(t, e) {
      this.s(t, Bf, (s) => Promise.resolve(s.releaseSession(e)), void 0, void 0)
    }
    registerDocumentOnDropEditProvider(t, e, s, r) {
      const a = this.q()
      return (
        this.f.set(a, new qf(new b3(this.e, this.h, s, a, t), t)),
        this.e.$registerDocumentOnDropEditProvider(
          a,
          this.o(e, t),
          hi(t, "documentPaste") && r
            ? {
                supportsResolve: !!s.resolveDocumentDropEdit,
                dropMimeTypes: r.dropMimeTypes,
                providedDropKinds: r.providedDropEditKinds?.map((o) => o.value),
              }
            : void 0,
        ),
        this.p(a)
      )
    }
    $provideDocumentOnDropEdits(t, e, s, r, a, o) {
      return this.s(
        t,
        b3,
        (c) =>
          Promise.resolve(
            c.provideDocumentOnDropEdits(e, S.revive(s), r, a, o),
          ),
        void 0,
        void 0,
      )
    }
    $resolveDropEdit(t, e, s) {
      return this.s(t, b3, (r) => r.resolveDropEdit(e, s), {}, void 0)
    }
    $releaseDocumentOnDropEdits(t, e) {
      this.s(
        t,
        b3,
        (s) => Promise.resolve(s.releaseDropEdits(e)),
        void 0,
        void 0,
      )
    }
    registerMappedEditsProvider(t, e, s) {
      const r = this.t(new ict(this.h, s), t)
      return (
        this.e.$registerMappedEditsProvider(
          r,
          this.o(e, t),
          t.displayName ?? t.name,
        ),
        this.p(r)
      )
    }
    $provideMappedEdits(t, e, s, r, a) {
      return this.s(
        t,
        ict,
        (o) => Promise.resolve(o.provideMappedEdits(e, s, r, a)),
        null,
        a,
      )
    }
    registerDocumentPasteEditProvider(t, e, s, r) {
      const a = this.q()
      return (
        this.f.set(a, new qf(new Af(this.e, this.h, s, a, t), t)),
        this.e.$registerPasteEditProvider(a, this.o(e, t), {
          supportsCopy: !!s.prepareDocumentPaste,
          supportsPaste: !!s.provideDocumentPasteEdits,
          supportsResolve: !!s.resolveDocumentPasteEdit,
          providedPasteEditKinds: r.providedPasteEditKinds?.map((o) => o.value),
          copyMimeTypes: r.copyMimeTypes,
          pasteMimeTypes: r.pasteMimeTypes,
        }),
        this.p(a)
      )
    }
    $prepareDocumentPaste(t, e, s, r, a) {
      return this.s(
        t,
        Af,
        (o) => o.prepareDocumentPaste(S.revive(e), s, r, a),
        void 0,
        a,
      )
    }
    $providePasteEdits(t, e, s, r, a, o, c) {
      return this.s(
        t,
        Af,
        (l) => l.providePasteEdits(e, S.revive(s), r, a, o, c),
        void 0,
        c,
      )
    }
    $resolvePasteEdit(t, e, s) {
      return this.s(t, Af, (r) => r.resolvePasteEdit(e, s), {}, void 0)
    }
    $releasePasteEdits(t, e) {
      this.s(
        t,
        Af,
        (s) => Promise.resolve(s.releasePasteEdits(e)),
        void 0,
        void 0,
      )
    }
    static y(t) {
      return { pattern: t.source, flags: t.flags }
    }
    static z(t) {
      return {
        decreaseIndentPattern: di.y(t.decreaseIndentPattern),
        increaseIndentPattern: di.y(t.increaseIndentPattern),
        indentNextLinePattern: t.indentNextLinePattern
          ? di.y(t.indentNextLinePattern)
          : void 0,
        unIndentedLinePattern: t.unIndentedLinePattern
          ? di.y(t.unIndentedLinePattern)
          : void 0,
      }
    }
    static B(t) {
      return {
        beforeText: di.y(t.beforeText),
        afterText: t.afterText ? di.y(t.afterText) : void 0,
        previousLineText: t.previousLineText
          ? di.y(t.previousLineText)
          : void 0,
        action: t.action,
      }
    }
    static C(t) {
      return t.map(di.B)
    }
    static D(t) {
      return {
        open: t.open,
        close: t.close,
        notIn: t.notIn ? t.notIn.map((e) => Qc.toString(e)) : void 0,
      }
    }
    static E(t) {
      return t.map(di.D)
    }
    setLanguageConfiguration(t, e, s) {
      const { wordPattern: r } = s
      if (r && dG(r))
        throw new Error(
          `Invalid language configuration: wordPattern '${r}' is not allowed to match the empty string.`,
        )
      r
        ? this.h.setWordDefinitionFor(e, r)
        : this.h.setWordDefinitionFor(e, void 0),
        s.__electricCharacterSupport &&
          this.m.report(
            "LanguageConfiguration.__electricCharacterSupport",
            t,
            "Do not use.",
          ),
        s.__characterPairSupport &&
          this.m.report(
            "LanguageConfiguration.__characterPairSupport",
            t,
            "Do not use.",
          )
      const a = this.q(),
        o = {
          comments: s.comments,
          brackets: s.brackets,
          wordPattern: s.wordPattern ? di.y(s.wordPattern) : void 0,
          indentationRules: s.indentationRules
            ? di.z(s.indentationRules)
            : void 0,
          onEnterRules: s.onEnterRules ? di.C(s.onEnterRules) : void 0,
          __electricCharacterSupport: s.__electricCharacterSupport,
          __characterPairSupport: s.__characterPairSupport,
          autoClosingPairs: s.autoClosingPairs
            ? di.E(s.autoClosingPairs)
            : void 0,
        }
      return this.e.$setLanguageConfiguration(a, e, o), this.p(a)
    }
    $setWordDefinitions(t) {
      for (const e of t)
        this.h.setWordDefinitionFor(
          e.languageId,
          new RegExp(e.regexSource, e.regexFlags),
        )
    }
  }
function $Ut(i) {
  return typeof i == "object" && typeof i.sessionId == "string"
}
var qKt = X("ILanguageModelToolsService"),
  xUt = class {
    constructor(i) {
      ;(this.a = new Map()),
        (this.c = new Map()),
        (this.d = new Map()),
        (this.b = i.getProxy(K.MainThreadLanguageModelTools)),
        this.b.$getTools().then((t) => {
          for (const e of t) this.d.set(e.id, ki(e))
        })
    }
    async $countTokensForInvocation(i, t, e) {
      const s = this.c.get(i)
      if (!s) throw new Error(`Tool invocation call ${i} not found`)
      return await s(t, e)
    }
    async invokeTool(i, t, e) {
      const s = Ze()
      if (
        (t.tokenizationOptions &&
          this.c.set(s, t.tokenizationOptions.countTokens),
        t.toolInvocationToken && !$Ut(t.toolInvocationToken))
      )
        throw new Error("Invalid tool invocation token")
      try {
        return await this.b.$invokeTool(
          {
            toolId: i,
            callId: s,
            parameters: t.input,
            tokenBudget: t.tokenizationOptions?.tokenBudget,
            context: t.toolInvocationToken,
          },
          e,
        )
      } finally {
        this.c.delete(s)
      }
    }
    $onDidChangeTools(i) {
      this.d.clear()
      for (const t of i) this.d.set(t.id, t)
    }
    get tools() {
      return Array.from(this.d.values()).map((i) => uM.to(i))
    }
    async $invokeTool(i, t) {
      const e = this.a.get(i.toolId)
      if (!e) throw new Error(`Unknown tool ${i.toolId}`)
      const s = { input: i.parameters, toolInvocationToken: i.context }
      i.tokenBudget !== void 0 &&
        (s.tokenizationOptions = {
          tokenBudget: i.tokenBudget,
          countTokens:
            this.c.get(i.callId) ||
            ((a, o = ce.None) =>
              this.b.$countTokensForInvocation(i.callId, a, o)),
        })
      const r = await zG(Promise.resolve(e.tool.invoke(s, t)), t)
      if (!r) throw new bi()
      return hM.from(r)
    }
    async $prepareToolInvocation(i, t, e) {
      const s = this.a.get(i)
      if (!s) throw new Error(`Unknown tool ${i}`)
      if (!s.tool.prepareInvocation) return
      const r = { input: t },
        a = await s.tool.prepareInvocation(r, e)
      if (a)
        return {
          confirmationMessages: a.confirmationMessages
            ? {
                title: a.confirmationMessages.title,
                message:
                  typeof a.confirmationMessages.message == "string"
                    ? a.confirmationMessages.message
                    : Dt.from(a.confirmationMessages.message),
              }
            : void 0,
          invocationMessage:
            typeof a.invocationMessage == "string"
              ? a.invocationMessage
              : a.invocationMessage
                ? Dt.from(a.invocationMessage)
                : void 0,
        }
    }
    registerTool(i, t, e) {
      return (
        this.a.set(t, { extension: i, tool: e }),
        this.b.$registerTool(t),
        et(() => {
          this.a.delete(t), this.b.$unregisterTool(t)
        })
      )
    }
  },
  NUt = class {
    constructor(i, t, e, s) {
      ;(this.c = t),
        (this.d = e),
        (this.e = s),
        (this.b = []),
        (this.f = 0),
        (this.g = new Set()),
        (this.a = i.getProxy(K.MainThreadLanguages))
    }
    $acceptLanguageIds(i) {
      this.b = i
    }
    async getLanguages() {
      return this.b.slice(0)
    }
    async changeLanguage(i, t) {
      await this.a.$changeLanguage(i, t)
      const e = this.c.getDocumentData(i)
      if (!e) throw new Error(`document '${i.toString()}' NOT found`)
      return e.document
    }
    async tokenAtPosition(i, t) {
      const e = i.version,
        s = Kt.from(t),
        r = await this.a.$tokensAtPosition(i.uri, s),
        a = {
          type: ua.Other,
          range:
            i.getWordRangeAtPosition(t) ??
            new Nt(t.line, t.character, t.line, t.character),
        }
      if (!r) return a
      const o = { range: U.to(r.range), type: RU.to(r.type) }
      return !o.range.contains(t) || e !== i.version ? a : o
    }
    createLanguageStatusItem(i, t, e) {
      const s = this.f++,
        r = this.a,
        a = this.g,
        o = `${i.identifier.value}/${t}`
      if (a.has(o))
        throw new Error(`LanguageStatusItem with id '${t}' ALREADY exists`)
      a.add(o)
      const c = {
        selector: e,
        id: t,
        name: i.displayName ?? i.name,
        severity: Wc.Information,
        command: void 0,
        text: "",
        detail: "",
        busy: !1,
      }
      let l
      const u = new gt(),
        d = () => {
          if ((l?.dispose(), !a.has(o))) {
            console.warn(
              `LanguageStatusItem (${t}) from ${i.identifier.value} has been disposed and CANNOT be updated anymore`,
            )
            return
          }
          l = XG(() => {
            u.clear(),
              this.a.$setLanguageStatus(s, {
                id: o,
                name: c.name ?? i.displayName ?? i.name,
                source: i.displayName ?? i.name,
                selector: dl.from(c.selector, this.e),
                label: c.text,
                detail: c.detail ?? "",
                severity:
                  c.severity === Wc.Error
                    ? Le.Error
                    : c.severity === Wc.Warning
                      ? Le.Warning
                      : Le.Info,
                command: c.command && this.d.toInternal(c.command, u),
                accessibilityInfo: c.accessibilityInformation,
                busy: c.busy,
              })
          }, 0)
        },
        m = {
          dispose() {
            u.dispose(), l?.dispose(), r.$removeLanguageStatus(s), a.delete(o)
          },
          get id() {
            return c.id
          },
          get name() {
            return c.name
          },
          set name(f) {
            ;(c.name = f), d()
          },
          get selector() {
            return c.selector
          },
          set selector(f) {
            ;(c.selector = f), d()
          },
          get text() {
            return c.text
          },
          set text(f) {
            ;(c.text = f), d()
          },
          set text2(f) {
            _(i, "languageStatusText"), (c.text = f), d()
          },
          get text2() {
            return _(i, "languageStatusText"), c.text
          },
          get detail() {
            return c.detail
          },
          set detail(f) {
            ;(c.detail = f), d()
          },
          get severity() {
            return c.severity
          },
          set severity(f) {
            ;(c.severity = f), d()
          },
          get accessibilityInformation() {
            return c.accessibilityInformation
          },
          set accessibilityInformation(f) {
            ;(c.accessibilityInformation = f), d()
          },
          get command() {
            return c.command
          },
          set command(f) {
            ;(c.command = f), d()
          },
          get busy() {
            return c.busy
          },
          set busy(f) {
            ;(c.busy = f), d()
          },
        }
      return d(), m
    }
  }
function CUt(i) {
  return i && i.title
}
var aj = class {
  constructor(t, e) {
    ;(this.b = e), (this.a = t.getProxy(K.MainThreadMessageService))
  }
  showMessage(t, e, s, r, a) {
    const o = {
      source: { identifier: t.identifier, label: t.displayName || t.name },
    }
    let c
    typeof r == "string" || CUt(r)
      ? (c = [r, ...a])
      : ((o.modal = r?.modal),
        (o.useCustom = r?.useCustom),
        (o.detail = r?.detail),
        (c = a)),
      o.useCustom && _(t, "resolvers")
    const l = []
    let u = !1
    for (let d = 0; d < c.length; d++) {
      const m = c[d]
      if (typeof m == "string")
        l.push({ title: m, handle: d, isCloseAffordance: !1 })
      else if (typeof m == "object") {
        const { title: f, isCloseAffordance: p } = m
        l.push({ title: f, isCloseAffordance: !!p, handle: d }),
          p &&
            (u
              ? this.b.warn(
                  `[${t.identifier}] Only one message item can have 'isCloseAffordance':`,
                  m,
                )
              : (u = !0))
      } else this.b.warn(`[${t.identifier}] Invalid message item:`, m)
    }
    return this.a.$showMessage(e, s, o, l).then((d) => {
      if (typeof d == "number") return c[d]
    })
  }
}
aj = __decorate([__param(1, Rt)], aj)
var oj = class {
    constructor(i, t, e, s) {
      ;(this.start = i),
        (this.deletedCount = t),
        (this.deletedItems = e),
        (this.items = s)
    }
    asApiEvent() {
      return {
        range: new gn(this.start, this.start + this.deletedCount),
        addedCells: this.items.map((i) => i.apiCell),
        removedCells: this.deletedItems,
      }
    }
  },
  cj = class {
    static asModelAddData(i) {
      return {
        EOL: i.eol,
        lines: i.source,
        languageId: i.language,
        uri: i.uri,
        isDirty: !1,
        versionId: 1,
      }
    }
    constructor(i, t, e) {
      ;(this.notebook = i),
        (this.h = t),
        (this.j = e),
        (this.handle = e.handle),
        (this.uri = S.revive(e.uri)),
        (this.cellKind = e.cellKind),
        (this.a = e.outputs.map(ma.to)),
        (this.e = e.internalMetadata ?? {}),
        (this.b = Object.freeze(e.metadata ?? {})),
        (this.d = Object.freeze(bl.to(e.internalMetadata ?? {})))
    }
    get internalMetadata() {
      return this.e
    }
    get apiCell() {
      if (!this.f) {
        const i = this,
          t = this.h.getDocument(this.uri)
        if (!t)
          throw new Error(
            `MISSING extHostDocument for notebook cell: ${this.uri}`,
          )
        const e = {
          get index() {
            return i.notebook.getCellIndex(i)
          },
          notebook: i.notebook.apiNotebook,
          kind: fd.to(this.j.cellKind),
          document: t.document,
          get mime() {
            return i.g
          },
          set mime(s) {
            i.g = s
          },
          get outputs() {
            return i.a.slice(0)
          },
          get metadata() {
            return i.b
          },
          get executionSummary() {
            return i.d
          },
        }
        this.f = Object.freeze(e)
      }
      return this.f
    }
    setOutputs(i) {
      this.a = i.map(ma.to)
    }
    setOutputItems(i, t, e) {
      const s = e.map(Tl.to),
        r = this.a.find((a) => a.id === i)
      if (
        r &&
        (t || (r.items.length = 0),
        r.items.push(...s),
        r.items.length > 1 && r.items.every((a) => $Z(a.mime)))
      ) {
        const a = new Map(),
          o = []
        r.items.forEach((c) => {
          let l
          a.has(c.mime)
            ? (l = a.get(c.mime))
            : ((l = []), a.set(c.mime, l), o.push(c.mime)),
            l.push(c.data)
        }),
          (r.items.length = 0),
          o.forEach((c) => {
            const l = Abt(a.get(c))
            r.items.push({ mime: c, data: l.data.buffer })
          })
      }
    }
    setMetadata(i) {
      this.b = Object.freeze(i)
    }
    setInternalMetadata(i) {
      ;(this.e = i), (this.d = Object.freeze(bl.to(i)))
    }
    setMime(i) {}
  },
  JUt = class Nut {
    static {
      this.a = 0
    }
    constructor(t, e, s, r, a) {
      ;(this.k = t),
        (this.l = e),
        (this.m = s),
        (this.uri = r),
        (this.handle = Nut.a++),
        (this.b = []),
        (this.g = 0),
        (this.h = !1),
        (this.j = !1),
        (this.d = a.viewType),
        (this.f = Object.freeze(a.metadata ?? Object.create(null))),
        this.r([[0, 0, a.cells]], !0, void 0),
        (this.g = a.versionId)
    }
    dispose() {
      this.j = !0
    }
    get versionId() {
      return this.g
    }
    get apiNotebook() {
      if (!this.e) {
        const t = this,
          e = {
            get uri() {
              return t.uri
            },
            get version() {
              return t.g
            },
            get notebookType() {
              return t.d
            },
            get isDirty() {
              return t.h
            },
            get isUntitled() {
              return t.uri.scheme === G.untitled
            },
            get isClosed() {
              return t.j
            },
            get metadata() {
              return t.f
            },
            get cellCount() {
              return t.b.length
            },
            cellAt(s) {
              return (s = t.n(s)), t.b[s].apiCell
            },
            getCells(s) {
              return (s ? t.p(s) : t.b).map((a) => a.apiCell)
            },
            save() {
              return t.q()
            },
            [Symbol.for("debug.description")]() {
              return `NotebookDocument(${this.uri.toString()})`
            },
          }
        this.e = Object.freeze(e)
      }
      return this.e
    }
    acceptDocumentPropertiesChanged(t) {
      t.metadata && (this.f = Object.freeze({ ...this.f, ...t.metadata }))
    }
    acceptDirty(t) {
      this.h = t
    }
    acceptModelChanged(t, e, s) {
      ;(this.g = t.versionId),
        (this.h = e),
        this.acceptDocumentPropertiesChanged({ metadata: s })
      const r = {
          notebook: this.apiNotebook,
          metadata: s,
          cellChanges: [],
          contentChanges: [],
        },
        a = []
      for (const c of t.rawEvents)
        c.kind === rr.ModelChange
          ? this.r(c.changes, !1, r.contentChanges)
          : c.kind === rr.Move
            ? this.s(c.index, c.length, c.newIdx, r.contentChanges)
            : c.kind === rr.Output
              ? (this.t(c.index, c.outputs),
                a.push({
                  cell: this.b[c.index].apiCell,
                  outputs: this.b[c.index].apiCell.outputs,
                }))
              : c.kind === rr.OutputItem
                ? (this.u(c.index, c.outputId, c.append, c.outputItems),
                  a.push({
                    cell: this.b[c.index].apiCell,
                    outputs: this.b[c.index].apiCell.outputs,
                  }))
                : c.kind === rr.ChangeCellLanguage
                  ? (this.v(c.index, c.language),
                    a.push({
                      cell: this.b[c.index].apiCell,
                      document: this.b[c.index].apiCell.document,
                    }))
                  : c.kind === rr.ChangeCellContent
                    ? a.push({
                        cell: this.b[c.index].apiCell,
                        document: this.b[c.index].apiCell.document,
                      })
                    : c.kind === rr.ChangeCellMime
                      ? this.w(c.index, c.mime)
                      : c.kind === rr.ChangeCellMetadata
                        ? (this.x(c.index, c.metadata),
                          a.push({
                            cell: this.b[c.index].apiCell,
                            metadata: this.b[c.index].apiCell.metadata,
                          }))
                        : c.kind === rr.ChangeCellInternalMetadata &&
                          (this.y(c.index, c.internalMetadata),
                          a.push({
                            cell: this.b[c.index].apiCell,
                            executionSummary:
                              this.b[c.index].apiCell.executionSummary,
                          }))
      const o = new Map()
      for (let c = 0; c < a.length; c++) {
        const l = a[c],
          u = o.get(l.cell)
        if (u === void 0) {
          const d = r.cellChanges.push({
            document: void 0,
            executionSummary: void 0,
            metadata: void 0,
            outputs: void 0,
            ...l,
          })
          o.set(l.cell, d - 1)
        } else r.cellChanges[u] = { ...r.cellChanges[u], ...l }
      }
      return (
        Object.freeze(r),
        Object.freeze(r.cellChanges),
        Object.freeze(r.contentChanges),
        r
      )
    }
    n(t) {
      return (t = t | 0), t < 0 ? 0 : t >= this.b.length ? this.b.length - 1 : t
    }
    o(t) {
      let e = t.start | 0,
        s = t.end | 0
      return (
        e < 0 && (e = 0),
        s > this.b.length && (s = this.b.length),
        t.with({ start: e, end: s })
      )
    }
    p(t) {
      t = this.o(t)
      const e = []
      for (let s = t.start; s < t.end; s++) e.push(this.b[s])
      return e
    }
    async q() {
      return this.j
        ? Promise.reject(new Error("Notebook has been closed"))
        : this.k.$trySaveNotebook(this.uri)
    }
    r(t, e, s) {
      if (this.j) return
      const r = [],
        a = [],
        o = []
      if (
        (t.reverse().forEach((c) => {
          const u = c[2].map((f) => {
              const p = new cj(this, this.l, f)
              return e || a.push(cj.asModelAddData(f)), p
            }),
            d = new oj(c[0], c[1], [], u),
            m = this.b.splice(c[0], c[1], ...u)
          for (const f of m) o.push(f.uri), d.deletedItems.push(f.apiCell)
          r.push(d)
        }),
        this.l.acceptDocumentsAndEditorsDelta({
          addedDocuments: a,
          removedDocuments: o,
        }),
        s)
      )
        for (const c of r) s.push(c.asApiEvent())
    }
    s(t, e, s, r) {
      const a = this.b.splice(t, e)
      this.b.splice(s, 0, ...a)
      const o = [
        new oj(
          t,
          e,
          a.map((c) => c.apiCell),
          [],
        ),
        new oj(s, 0, [], a),
      ]
      for (const c of o) r.push(c.asApiEvent())
    }
    t(t, e) {
      this.b[t].setOutputs(e)
    }
    u(t, e, s, r) {
      this.b[t].setOutputItems(e, s, r)
    }
    v(t, e) {
      const s = this.b[t]
      s.apiCell.document.languageId !== e &&
        this.m.$acceptModelLanguageChanged(s.uri, e)
    }
    w(t, e) {
      const s = this.b[t]
      s.apiCell.mime = e
    }
    x(t, e) {
      this.b[t].setMetadata(e)
    }
    y(t, e) {
      this.b[t].setInternalMetadata(e)
    }
    getCellFromApiCell(t) {
      return this.b.find((e) => e.apiCell === t)
    }
    getCellFromIndex(t) {
      return this.b[t]
    }
    getCell(t) {
      return this.b.find((e) => e.handle === t)
    }
    getCellIndex(t) {
      return this.b.indexOf(t)
    }
  },
  lj = class Cut {
    static {
      this.apiEditorsToExtHost = new WeakMap()
    }
    constructor(t, e, s, r, a, o, c) {
      ;(this.id = t),
        (this.c = e),
        (this.notebookData = s),
        (this.d = r),
        (this.e = a),
        (this.f = o),
        (this.g = c),
        (this.a = !1)
    }
    get apiEditor() {
      if (!this.b) {
        const t = this
        ;(this.b = {
          get notebook() {
            return t.notebookData.apiNotebook
          },
          get selection() {
            return t.e[0]
          },
          set selection(e) {
            this.selections = [e]
          },
          get selections() {
            return t.e
          },
          set selections(e) {
            if (!Array.isArray(e) || !e.every(gn.isNotebookRange))
              throw Lt("selections")
            ;(t.e = e), t.h(e)
          },
          get visibleRanges() {
            return t.d
          },
          revealRange(e, s) {
            t.c.$tryRevealRange(t.id, Or.from(e), s ?? IO.Default)
          },
          get viewColumn() {
            return t.f
          },
          get replOptions() {
            if (t.g === "repl")
              return { appendIndex: this.notebook.cellCount - 1 }
          },
          [Symbol.for("debug.description")]() {
            return `NotebookEditor(${this.notebook.uri.toString()})`
          },
        }),
          Cut.apiEditorsToExtHost.set(this.b, this)
      }
      return this.b
    }
    get visible() {
      return this.a
    }
    _acceptVisibility(t) {
      this.a = t
    }
    _acceptVisibleRanges(t) {
      this.d = t
    }
    _acceptSelections(t) {
      this.e = t
    }
    h(t) {
      this.c.$trySetSelections(this.id, t.map(Or.from))
    }
    _acceptViewColumn(t) {
      this.f = t
    }
  },
  uj = class {
    constructor(i, t) {
      ;(this.piece = i),
        (this.color = t),
        (this.size_left = 0),
        (this.lf_left = 0),
        (this.parent = this),
        (this.left = this),
        (this.right = this)
    }
    next() {
      if (this.right !== ut) return hj(this.right)
      let i = this
      for (; i.parent !== ut && i.parent.left !== i; ) i = i.parent
      return i.parent === ut ? ut : i.parent
    }
    prev() {
      if (this.left !== ut) return rct(this.left)
      let i = this
      for (; i.parent !== ut && i.parent.right !== i; ) i = i.parent
      return i.parent === ut ? ut : i.parent
    }
    detach() {
      ;(this.parent = null), (this.left = null), (this.right = null)
    }
  },
  sct
;(function (i) {
  ;(i[(i.Black = 0)] = "Black"), (i[(i.Red = 1)] = "Red")
})(sct || (sct = {}))
var ut = new uj(null, 0)
;(ut.parent = ut), (ut.left = ut), (ut.right = ut), (ut.color = 0)
function hj(i) {
  for (; i.left !== ut; ) i = i.left
  return i
}
function rct(i) {
  for (; i.right !== ut; ) i = i.right
  return i
}
function dj(i) {
  return i === ut ? 0 : i.size_left + i.piece.length + dj(i.right)
}
function mj(i) {
  return i === ut ? 0 : i.lf_left + i.piece.lineFeedCnt + mj(i.right)
}
function fj() {
  ut.parent = ut
}
function Uf(i, t) {
  const e = t.right
  ;(e.size_left += t.size_left + (t.piece ? t.piece.length : 0)),
    (e.lf_left += t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0)),
    (t.right = e.left),
    e.left !== ut && (e.left.parent = t),
    (e.parent = t.parent),
    t.parent === ut
      ? (i.root = e)
      : t.parent.left === t
        ? (t.parent.left = e)
        : (t.parent.right = e),
    (e.left = t),
    (t.parent = e)
}
function Mf(i, t) {
  const e = t.left
  ;(t.left = e.right),
    e.right !== ut && (e.right.parent = t),
    (e.parent = t.parent),
    (t.size_left -= e.size_left + (e.piece ? e.piece.length : 0)),
    (t.lf_left -= e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0)),
    t.parent === ut
      ? (i.root = e)
      : t === t.parent.right
        ? (t.parent.right = e)
        : (t.parent.left = e),
    (e.right = t),
    (t.parent = e)
}
function T3(i, t) {
  let e, s
  if (
    (t.left === ut
      ? ((s = t), (e = s.right))
      : t.right === ut
        ? ((s = t), (e = s.left))
        : ((s = hj(t.right)), (e = s.right)),
    s === i.root)
  ) {
    ;(i.root = e), (e.color = 0), t.detach(), fj(), (i.root.parent = ut)
    return
  }
  const r = s.color === 1
  if (
    (s === s.parent.left ? (s.parent.left = e) : (s.parent.right = e),
    s === t
      ? ((e.parent = s.parent), Hf(i, e))
      : (s.parent === t ? (e.parent = s) : (e.parent = s.parent),
        Hf(i, e),
        (s.left = t.left),
        (s.right = t.right),
        (s.parent = t.parent),
        (s.color = t.color),
        t === i.root
          ? (i.root = s)
          : t === t.parent.left
            ? (t.parent.left = s)
            : (t.parent.right = s),
        s.left !== ut && (s.left.parent = s),
        s.right !== ut && (s.right.parent = s),
        (s.size_left = t.size_left),
        (s.lf_left = t.lf_left),
        Hf(i, s)),
    t.detach(),
    e.parent.left === e)
  ) {
    const o = dj(e),
      c = mj(e)
    if (o !== e.parent.size_left || c !== e.parent.lf_left) {
      const l = o - e.parent.size_left,
        u = c - e.parent.lf_left
      ;(e.parent.size_left = o), (e.parent.lf_left = c), Cn(i, e.parent, l, u)
    }
  }
  if ((Hf(i, e.parent), r)) {
    fj()
    return
  }
  let a
  for (; e !== i.root && e.color === 0; )
    e === e.parent.left
      ? ((a = e.parent.right),
        a.color === 1 &&
          ((a.color = 0),
          (e.parent.color = 1),
          Uf(i, e.parent),
          (a = e.parent.right)),
        a.left.color === 0 && a.right.color === 0
          ? ((a.color = 1), (e = e.parent))
          : (a.right.color === 0 &&
              ((a.left.color = 0),
              (a.color = 1),
              Mf(i, a),
              (a = e.parent.right)),
            (a.color = e.parent.color),
            (e.parent.color = 0),
            (a.right.color = 0),
            Uf(i, e.parent),
            (e = i.root)))
      : ((a = e.parent.left),
        a.color === 1 &&
          ((a.color = 0),
          (e.parent.color = 1),
          Mf(i, e.parent),
          (a = e.parent.left)),
        a.left.color === 0 && a.right.color === 0
          ? ((a.color = 1), (e = e.parent))
          : (a.left.color === 0 &&
              ((a.right.color = 0),
              (a.color = 1),
              Uf(i, a),
              (a = e.parent.left)),
            (a.color = e.parent.color),
            (e.parent.color = 0),
            (a.left.color = 0),
            Mf(i, e.parent),
            (e = i.root)))
  ;(e.color = 0), fj()
}
function nct(i, t) {
  for (Hf(i, t); t !== i.root && t.parent.color === 1; )
    if (t.parent === t.parent.parent.left) {
      const e = t.parent.parent.right
      e.color === 1
        ? ((t.parent.color = 0),
          (e.color = 0),
          (t.parent.parent.color = 1),
          (t = t.parent.parent))
        : (t === t.parent.right && ((t = t.parent), Uf(i, t)),
          (t.parent.color = 0),
          (t.parent.parent.color = 1),
          Mf(i, t.parent.parent))
    } else {
      const e = t.parent.parent.left
      e.color === 1
        ? ((t.parent.color = 0),
          (e.color = 0),
          (t.parent.parent.color = 1),
          (t = t.parent.parent))
        : (t === t.parent.left && ((t = t.parent), Mf(i, t)),
          (t.parent.color = 0),
          (t.parent.parent.color = 1),
          Uf(i, t.parent.parent))
    }
  i.root.color = 0
}
function Cn(i, t, e, s) {
  for (; t !== i.root && t !== ut; )
    t.parent.left === t && ((t.parent.size_left += e), (t.parent.lf_left += s)),
      (t = t.parent)
}
function Hf(i, t) {
  let e = 0,
    s = 0
  if (t !== i.root) {
    for (; t !== i.root && t === t.parent.right; ) t = t.parent
    if (t !== i.root)
      for (
        t = t.parent,
          e = dj(t.left) - t.size_left,
          s = mj(t.left) - t.lf_left,
          t.size_left += e,
          t.lf_left += s;
        t !== i.root && (e !== 0 || s !== 0);

      )
        t.parent.left === t &&
          ((t.parent.size_left += e), (t.parent.lf_left += s)),
          (t = t.parent)
  }
}
var Jn = 65535
function act(i) {
  let t
  return (
    i[i.length - 1] < 65536
      ? (t = new Uint16Array(i.length))
      : (t = new Uint32Array(i.length)),
    t.set(i, 0),
    t
  )
}
var LUt = class {
  constructor(i, t, e, s, r) {
    ;(this.lineStarts = i),
      (this.cr = t),
      (this.lf = e),
      (this.crlf = s),
      (this.isBasicASCII = r)
  }
}
function Ln(i, t = !0) {
  const e = [0]
  let s = 1
  for (let r = 0, a = i.length; r < a; r++) {
    const o = i.charCodeAt(r)
    o === 13
      ? r + 1 < a && i.charCodeAt(r + 1) === 10
        ? ((e[s++] = r + 2), r++)
        : (e[s++] = r + 1)
      : o === 10 && (e[s++] = r + 1)
  }
  return t ? act(e) : e
}
function RUt(i, t) {
  ;(i.length = 0), (i[0] = 0)
  let e = 1,
    s = 0,
    r = 0,
    a = 0,
    o = !0
  for (let l = 0, u = t.length; l < u; l++) {
    const d = t.charCodeAt(l)
    d === 13
      ? l + 1 < u && t.charCodeAt(l + 1) === 10
        ? (a++, (i[e++] = l + 2), l++)
        : (s++, (i[e++] = l + 1))
      : d === 10
        ? (r++, (i[e++] = l + 1))
        : o && d !== 9 && (d < 32 || d > 126) && (o = !1)
  }
  const c = new LUt(act(i), s, r, a, o)
  return (i.length = 0), c
}
var Zi = class {
    constructor(i, t, e, s, r) {
      ;(this.bufferIndex = i),
        (this.start = t),
        (this.end = e),
        (this.lineFeedCnt = s),
        (this.length = r)
    }
  },
  Wo = class {
    constructor(i, t) {
      ;(this.buffer = i), (this.lineStarts = t)
    }
  },
  DUt = class {
    constructor(i, t) {
      ;(this.a = []),
        (this.c = i),
        (this.d = t),
        (this.b = 0),
        i.root !== ut &&
          i.iterate(i.root, (e) => (e !== ut && this.a.push(e.piece), !0))
    }
    read() {
      return this.a.length === 0
        ? this.b === 0
          ? (this.b++, this.d)
          : null
        : this.b > this.a.length - 1
          ? null
          : this.b === 0
            ? this.d + this.c.getPieceContent(this.a[this.b++])
            : this.c.getPieceContent(this.a[this.b++])
    }
  },
  FUt = class {
    constructor(i) {
      ;(this.a = i), (this.b = [])
    }
    get(i) {
      for (let t = this.b.length - 1; t >= 0; t--) {
        const e = this.b[t]
        if (
          e.nodeStartOffset <= i &&
          e.nodeStartOffset + e.node.piece.length >= i
        )
          return e
      }
      return null
    }
    get2(i) {
      for (let t = this.b.length - 1; t >= 0; t--) {
        const e = this.b[t]
        if (
          e.nodeStartLineNumber &&
          e.nodeStartLineNumber < i &&
          e.nodeStartLineNumber + e.node.piece.lineFeedCnt >= i
        )
          return e
      }
      return null
    }
    set(i) {
      this.b.length >= this.a && this.b.shift(), this.b.push(i)
    }
    validate(i) {
      let t = !1
      const e = this.b
      for (let s = 0; s < e.length; s++) {
        const r = e[s]
        if (r.node.parent === null || r.nodeStartOffset >= i) {
          ;(e[s] = null), (t = !0)
          continue
        }
      }
      if (t) {
        const s = []
        for (const r of e) r !== null && s.push(r)
        this.b = s
      }
    }
  },
  AUt = class {
    constructor(i, t, e) {
      this.create(i, t, e)
    }
    create(i, t, e) {
      ;(this.a = [new Wo("", [0])]),
        (this.g = { line: 0, column: 0 }),
        (this.root = ut),
        (this.b = 1),
        (this.c = 0),
        (this.d = t),
        (this.e = t.length),
        (this.f = e)
      let s = null
      for (let r = 0, a = i.length; r < a; r++)
        if (i[r].buffer.length > 0) {
          i[r].lineStarts || (i[r].lineStarts = Ln(i[r].buffer))
          const o = new Zi(
            r + 1,
            { line: 0, column: 0 },
            {
              line: i[r].lineStarts.length - 1,
              column:
                i[r].buffer.length -
                i[r].lineStarts[i[r].lineStarts.length - 1],
            },
            i[r].lineStarts.length - 1,
            i[r].buffer.length,
          )
          this.a.push(i[r]), (s = this.S(s, o))
        }
      ;(this.h = new FUt(1)), (this.j = { lineNumber: 0, value: "" }), this.y()
    }
    normalizeEOL(i) {
      const t = Jn,
        e = t - Math.floor(t / 3),
        s = e * 2
      let r = "",
        a = 0
      const o = []
      if (
        (this.iterate(this.root, (c) => {
          const l = this.R(c),
            u = l.length
          if (a <= e || a + u < s) return (r += l), (a += u), !0
          const d = r.replace(/\r\n|\r|\n/g, i)
          return o.push(new Wo(d, Ln(d))), (r = l), (a = u), !0
        }),
        a > 0)
      ) {
        const c = r.replace(/\r\n|\r|\n/g, i)
        o.push(new Wo(c, Ln(c)))
      }
      this.create(o, i, !0)
    }
    getEOL() {
      return this.d
    }
    setEOL(i) {
      ;(this.d = i), (this.e = this.d.length), this.normalizeEOL(i)
    }
    createSnapshot(i) {
      return new DUt(this, i)
    }
    equal(i) {
      if (
        this.getLength() !== i.getLength() ||
        this.getLineCount() !== i.getLineCount()
      )
        return !1
      let t = 0
      return this.iterate(this.root, (s) => {
        if (s === ut) return !0
        const r = this.R(s),
          a = r.length,
          o = i.G(t),
          c = i.G(t + a),
          l = i.getValueInRange2(o, c)
        return (t += a), r === l
      })
    }
    getOffsetAt(i, t) {
      let e = 0,
        s = this.root
      for (; s !== ut; )
        if (s.left !== ut && s.lf_left + 1 >= i) s = s.left
        else if (s.lf_left + s.piece.lineFeedCnt + 1 >= i) {
          e += s.size_left
          const r = this.B(s, i - s.lf_left - 2)
          return (e += r + t - 1)
        } else
          (i -= s.lf_left + s.piece.lineFeedCnt),
            (e += s.size_left + s.piece.length),
            (s = s.right)
      return e
    }
    getPositionAt(i) {
      ;(i = Math.floor(i)), (i = Math.max(0, i))
      let t = this.root,
        e = 0
      const s = i
      for (; t !== ut; )
        if (t.size_left !== 0 && t.size_left >= i) t = t.left
        else if (t.size_left + t.piece.length >= i) {
          const r = this.A(t, i - t.size_left)
          if (((e += t.lf_left + r.index), r.index === 0)) {
            const a = this.getOffsetAt(e + 1, 1),
              o = s - a
            return new ws(e + 1, o + 1)
          }
          return new ws(e + 1, r.remainder + 1)
        } else if (
          ((i -= t.size_left + t.piece.length),
          (e += t.lf_left + t.piece.lineFeedCnt),
          t.right === ut)
        ) {
          const r = this.getOffsetAt(e + 1, 1),
            a = s - i - r
          return new ws(e + 1, a + 1)
        } else t = t.right
      return new ws(1, 1)
    }
    getValueInRange(i, t) {
      if (
        i.startLineNumber === i.endLineNumber &&
        i.startColumn === i.endColumn
      )
        return ""
      const e = this.H(i.startLineNumber, i.startColumn),
        s = this.H(i.endLineNumber, i.endColumn),
        r = this.getValueInRange2(e, s)
      return t
        ? t !== this.d || !this.f
          ? r.replace(/\r\n|\r|\n/g, t)
          : t === this.getEOL() && this.f
            ? r
            : r.replace(/\r\n|\r|\n/g, t)
        : r
    }
    getValueInRange2(i, t) {
      if (i.node === t.node) {
        const o = i.node,
          c = this.a[o.piece.bufferIndex].buffer,
          l = this.u(o.piece.bufferIndex, o.piece.start)
        return c.substring(l + i.remainder, l + t.remainder)
      }
      let e = i.node
      const s = this.a[e.piece.bufferIndex].buffer,
        r = this.u(e.piece.bufferIndex, e.piece.start)
      let a = s.substring(r + i.remainder, r + e.piece.length)
      for (e = e.next(); e !== ut; ) {
        const o = this.a[e.piece.bufferIndex].buffer,
          c = this.u(e.piece.bufferIndex, e.piece.start)
        if (e === t.node) {
          a += o.substring(c, c + t.remainder)
          break
        } else a += o.substr(c, e.piece.length)
        e = e.next()
      }
      return a
    }
    getLinesContent() {
      const i = []
      let t = 0,
        e = "",
        s = !1
      return (
        this.iterate(this.root, (r) => {
          if (r === ut) return !0
          const a = r.piece
          let o = a.length
          if (o === 0) return !0
          const c = this.a[a.bufferIndex].buffer,
            l = this.a[a.bufferIndex].lineStarts,
            u = a.start.line,
            d = a.end.line
          let m = l[u] + a.start.column
          if (
            s &&
            (c.charCodeAt(m) === 10 && (m++, o--),
            (i[t++] = e),
            (e = ""),
            (s = !1),
            o === 0)
          )
            return !0
          if (u === d)
            return (
              !this.f && c.charCodeAt(m + o - 1) === 13
                ? ((s = !0), (e += c.substr(m, o - 1)))
                : (e += c.substr(m, o)),
              !0
            )
          ;(e += this.f
            ? c.substring(m, Math.max(m, l[u + 1] - this.e))
            : c.substring(m, l[u + 1]).replace(/(\r\n|\r|\n)$/, "")),
            (i[t++] = e)
          for (let f = u + 1; f < d; f++)
            (e = this.f
              ? c.substring(l[f], l[f + 1] - this.e)
              : c.substring(l[f], l[f + 1]).replace(/(\r\n|\r|\n)$/, "")),
              (i[t++] = e)
          return (
            !this.f && c.charCodeAt(l[d] + a.end.column - 1) === 13
              ? ((s = !0),
                a.end.column === 0
                  ? t--
                  : (e = c.substr(l[d], a.end.column - 1)))
              : (e = c.substr(l[d], a.end.column)),
            !0
          )
        }),
        s && ((i[t++] = e), (e = "")),
        (i[t++] = e),
        i
      )
    }
    getLength() {
      return this.c
    }
    getLineCount() {
      return this.b
    }
    getLineContent(i) {
      return this.j.lineNumber === i
        ? this.j.value
        : ((this.j.lineNumber = i),
          i === this.b
            ? (this.j.value = this.getLineRawContent(i))
            : this.f
              ? (this.j.value = this.getLineRawContent(i, this.e))
              : (this.j.value = this.getLineRawContent(i).replace(
                  /(\r\n|\r|\n)$/,
                  "",
                )),
          this.j.value)
    }
    l(i) {
      if (i.remainder === i.node.piece.length) {
        const t = i.node.next()
        if (!t) return 0
        const e = this.a[t.piece.bufferIndex],
          s = this.u(t.piece.bufferIndex, t.piece.start)
        return e.buffer.charCodeAt(s)
      } else {
        const t = this.a[i.node.piece.bufferIndex],
          s = this.u(i.node.piece.bufferIndex, i.node.piece.start) + i.remainder
        return t.buffer.charCodeAt(s)
      }
    }
    getLineCharCode(i, t) {
      const e = this.H(i, t + 1)
      return this.l(e)
    }
    getLineLength(i) {
      if (i === this.getLineCount()) {
        const t = this.getOffsetAt(i, 1)
        return this.getLength() - t
      }
      return this.getOffsetAt(i + 1, 1) - this.getOffsetAt(i, 1) - this.e
    }
    getCharCode(i) {
      const t = this.G(i)
      return this.l(t)
    }
    getNearestChunk(i) {
      const t = this.G(i)
      if (t.remainder === t.node.piece.length) {
        const e = t.node.next()
        if (!e || e === ut) return ""
        const s = this.a[e.piece.bufferIndex],
          r = this.u(e.piece.bufferIndex, e.piece.start)
        return s.buffer.substring(r, r + e.piece.length)
      } else {
        const e = this.a[t.node.piece.bufferIndex],
          s = this.u(t.node.piece.bufferIndex, t.node.piece.start),
          r = s + t.remainder,
          a = s + t.node.piece.length
        return e.buffer.substring(r, a)
      }
    }
    findMatchesInNode(i, t, e, s, r, a, o, c, l, u, d) {
      const m = this.a[i.piece.bufferIndex],
        f = this.u(i.piece.bufferIndex, i.piece.start),
        p = this.u(i.piece.bufferIndex, r),
        v = this.u(i.piece.bufferIndex, a)
      let b
      const k = { line: 0, column: 0 }
      let E, P
      t._wordSeparators
        ? ((E = m.buffer.substring(p, v)), (P = (C) => C + p), t.reset(0))
        : ((E = m.buffer), (P = (C) => C), t.reset(p))
      do
        if (((b = t.next(E)), b)) {
          if (P(b.index) >= v) return u
          this.s(i, P(b.index) - f, k)
          const C = this.t(i.piece.bufferIndex, r, k),
            R = k.line === r.line ? k.column - r.column + s : k.column + 1,
            D = R + b[0].length
          if (
            ((d[u++] = ast(new ue(e + C, R, e + C, D), b, c)),
            P(b.index) + b[0].length >= v || u >= l)
          )
            return u
        }
      while (b)
      return u
    }
    findMatchesLineByLine(i, t, e, s) {
      const r = []
      let a = 0
      const o = new zPt(t.wordSeparators, t.regex)
      let c = this.H(i.startLineNumber, i.startColumn)
      if (c === null) return []
      const l = this.H(i.endLineNumber, i.endColumn)
      if (l === null) return []
      let u = this.s(c.node, c.remainder)
      const d = this.s(l.node, l.remainder)
      if (c.node === l.node)
        return (
          this.findMatchesInNode(
            c.node,
            o,
            i.startLineNumber,
            i.startColumn,
            u,
            d,
            t,
            e,
            s,
            a,
            r,
          ),
          r
        )
      let m = i.startLineNumber,
        f = c.node
      for (; f !== l.node; ) {
        const v = this.t(f.piece.bufferIndex, u, f.piece.end)
        if (v >= 1) {
          const k = this.a[f.piece.bufferIndex].lineStarts,
            E = this.u(f.piece.bufferIndex, f.piece.start),
            P = k[u.line + v],
            C = m === i.startLineNumber ? i.startColumn : 1
          if (
            ((a = this.findMatchesInNode(
              f,
              o,
              m,
              C,
              u,
              this.s(f, P - E),
              t,
              e,
              s,
              a,
              r,
            )),
            a >= s)
          )
            return r
          m += v
        }
        const b = m === i.startLineNumber ? i.startColumn - 1 : 0
        if (m === i.endLineNumber) {
          const k = this.getLineContent(m).substring(b, i.endColumn - 1)
          return (a = this.n(t, o, k, i.endLineNumber, b, a, r, e, s)), r
        }
        if (
          ((a = this.n(
            t,
            o,
            this.getLineContent(m).substr(b),
            m,
            b,
            a,
            r,
            e,
            s,
          )),
          a >= s)
        )
          return r
        m++, (c = this.H(m, 1)), (f = c.node), (u = this.s(c.node, c.remainder))
      }
      if (m === i.endLineNumber) {
        const v = m === i.startLineNumber ? i.startColumn - 1 : 0,
          b = this.getLineContent(m).substring(v, i.endColumn - 1)
        return (a = this.n(t, o, b, i.endLineNumber, v, a, r, e, s)), r
      }
      const p = m === i.startLineNumber ? i.startColumn : 1
      return (
        (a = this.findMatchesInNode(l.node, o, m, p, u, d, t, e, s, a, r)), r
      )
    }
    n(i, t, e, s, r, a, o, c, l) {
      const u = i.wordSeparators
      if (!c && i.simpleSearch) {
        const m = i.simpleSearch,
          f = m.length,
          p = e.length
        let v = -f
        for (; (v = e.indexOf(m, v + f)) !== -1; )
          if (
            (!u || ost(u, e, p, v, f)) &&
            ((o[a++] = new yH(new ue(s, v + 1 + r, s, v + 1 + f + r), null)),
            a >= l)
          )
            return a
        return a
      }
      let d
      t.reset(0)
      do
        if (
          ((d = t.next(e)),
          d &&
            ((o[a++] = ast(
              new ue(s, d.index + 1 + r, s, d.index + 1 + d[0].length + r),
              d,
              c,
            )),
            a >= l))
        )
          return a
      while (d)
      return a
    }
    insert(i, t, e = !1) {
      if (
        ((this.f = this.f && e),
        (this.j.lineNumber = 0),
        (this.j.value = ""),
        this.root !== ut)
      ) {
        const { node: s, remainder: r, nodeStartOffset: a } = this.G(i),
          o = s.piece,
          c = o.bufferIndex,
          l = this.s(s, r)
        if (
          s.piece.bufferIndex === 0 &&
          o.end.line === this.g.line &&
          o.end.column === this.g.column &&
          a + o.length === i &&
          t.length < Jn
        ) {
          this.F(s, t), this.y()
          return
        }
        if (a === i) this.o(t, s), this.h.validate(i)
        else if (a + s.piece.length > i) {
          const u = []
          let d = new Zi(
            o.bufferIndex,
            l,
            o.end,
            this.t(o.bufferIndex, l, o.end),
            this.u(c, o.end) - this.u(c, l),
          )
          if (this.K() && this.M(t) && this.I(s, r) === 10) {
            const v = { line: d.start.line + 1, column: 0 }
            ;(d = new Zi(
              d.bufferIndex,
              v,
              d.end,
              this.t(d.bufferIndex, v, d.end),
              d.length - 1,
            )),
              (t += `
`)
          }
          if (this.K() && this.L(t))
            if (this.I(s, r - 1) === 13) {
              const v = this.s(s, r - 1)
              this.C(s, v), (t = "\r" + t), s.piece.length === 0 && u.push(s)
            } else this.C(s, l)
          else this.C(s, l)
          const m = this.w(t)
          d.length > 0 && this.S(s, d)
          let f = s
          for (let p = 0; p < m.length; p++) f = this.S(f, m[p])
          this.v(u)
        } else this.q(t, s)
      } else {
        const s = this.w(t)
        let r = this.T(null, s[0])
        for (let a = 1; a < s.length; a++) r = this.S(r, s[a])
      }
      this.y()
    }
    delete(i, t) {
      if (
        ((this.j.lineNumber = 0),
        (this.j.value = ""),
        t <= 0 || this.root === ut)
      )
        return
      const e = this.G(i),
        s = this.G(i + t),
        r = e.node,
        a = s.node
      if (r === a) {
        const m = this.s(r, e.remainder),
          f = this.s(r, s.remainder)
        if (e.nodeStartOffset === i) {
          if (t === r.piece.length) {
            const p = r.next()
            T3(this, r), this.N(p), this.y()
            return
          }
          this.D(r, f), this.h.validate(i), this.N(r), this.y()
          return
        }
        if (e.nodeStartOffset + r.piece.length === i + t) {
          this.C(r, m), this.O(r), this.y()
          return
        }
        this.E(r, m, f), this.y()
        return
      }
      const o = [],
        c = this.s(r, e.remainder)
      this.C(r, c), this.h.validate(i), r.piece.length === 0 && o.push(r)
      const l = this.s(a, s.remainder)
      this.D(a, l), a.piece.length === 0 && o.push(a)
      const u = r.next()
      for (let m = u; m !== ut && m !== a; m = m.next()) o.push(m)
      const d = r.piece.length === 0 ? r.prev() : r
      this.v(o), this.O(d), this.y()
    }
    o(i, t) {
      const e = []
      if (this.K() && this.M(i) && this.L(t)) {
        const a = t.piece,
          o = { line: a.start.line + 1, column: 0 },
          c = new Zi(
            a.bufferIndex,
            o,
            a.end,
            this.t(a.bufferIndex, o, a.end),
            a.length - 1,
          )
        ;(t.piece = c),
          (i += `
`),
          Cn(this, t, -1, -1),
          t.piece.length === 0 && e.push(t)
      }
      const s = this.w(i)
      let r = this.T(t, s[s.length - 1])
      for (let a = s.length - 2; a >= 0; a--) r = this.T(r, s[a])
      this.N(r), this.v(e)
    }
    q(i, t) {
      this.Q(i, t) &&
        (i += `
`)
      const e = this.w(i),
        s = this.S(t, e[0])
      let r = s
      for (let a = 1; a < e.length; a++) r = this.S(r, e[a])
      this.N(s)
    }
    s(i, t, e) {
      const s = i.piece,
        r = i.piece.bufferIndex,
        a = this.a[r].lineStarts,
        c = a[s.start.line] + s.start.column + t
      let l = s.start.line,
        u = s.end.line,
        d = 0,
        m = 0,
        f = 0
      for (; l <= u && ((d = (l + (u - l) / 2) | 0), (f = a[d]), d !== u); )
        if (((m = a[d + 1]), c < f)) u = d - 1
        else if (c >= m) l = d + 1
        else break
      return e
        ? ((e.line = d), (e.column = c - f), null)
        : { line: d, column: c - f }
    }
    t(i, t, e) {
      if (e.column === 0) return e.line - t.line
      const s = this.a[i].lineStarts
      if (e.line === s.length - 1) return e.line - t.line
      const r = s[e.line + 1],
        a = s[e.line] + e.column
      if (r > a + 1) return e.line - t.line
      const o = a - 1
      return this.a[i].buffer.charCodeAt(o) === 13
        ? e.line - t.line + 1
        : e.line - t.line
    }
    u(i, t) {
      return this.a[i].lineStarts[t.line] + t.column
    }
    v(i) {
      for (let t = 0; t < i.length; t++) T3(this, i[t])
    }
    w(i) {
      if (i.length > Jn) {
        const u = []
        for (; i.length > Jn; ) {
          const m = i.charCodeAt(Jn - 1)
          let f
          m === 13 || (m >= 55296 && m <= 56319)
            ? ((f = i.substring(0, Jn - 1)), (i = i.substring(Jn - 1)))
            : ((f = i.substring(0, Jn)), (i = i.substring(Jn)))
          const p = Ln(f)
          u.push(
            new Zi(
              this.a.length,
              { line: 0, column: 0 },
              { line: p.length - 1, column: f.length - p[p.length - 1] },
              p.length - 1,
              f.length,
            ),
          ),
            this.a.push(new Wo(f, p))
        }
        const d = Ln(i)
        return (
          u.push(
            new Zi(
              this.a.length,
              { line: 0, column: 0 },
              { line: d.length - 1, column: i.length - d[d.length - 1] },
              d.length - 1,
              i.length,
            ),
          ),
          this.a.push(new Wo(i, d)),
          u
        )
      }
      let t = this.a[0].buffer.length
      const e = Ln(i, !1)
      let s = this.g
      if (
        this.a[0].lineStarts[this.a[0].lineStarts.length - 1] === t &&
        t !== 0 &&
        this.L(i) &&
        this.M(this.a[0].buffer)
      ) {
        ;(this.g = { line: this.g.line, column: this.g.column + 1 }),
          (s = this.g)
        for (let u = 0; u < e.length; u++) e[u] += t + 1
        ;(this.a[0].lineStarts = this.a[0].lineStarts.concat(e.slice(1))),
          (this.a[0].buffer += "_" + i),
          (t += 1)
      } else {
        if (t !== 0) for (let u = 0; u < e.length; u++) e[u] += t
        ;(this.a[0].lineStarts = this.a[0].lineStarts.concat(e.slice(1))),
          (this.a[0].buffer += i)
      }
      const r = this.a[0].buffer.length,
        a = this.a[0].lineStarts.length - 1,
        o = r - this.a[0].lineStarts[a],
        c = { line: a, column: o },
        l = new Zi(0, s, c, this.t(0, s, c), r - t)
      return (this.g = c), [l]
    }
    getLinesRawContent() {
      return this.U(this.root)
    }
    getLineRawContent(i, t = 0) {
      let e = this.root,
        s = ""
      const r = this.h.get2(i)
      if (r) {
        e = r.node
        const a = this.B(e, i - r.nodeStartLineNumber - 1),
          o = this.a[e.piece.bufferIndex].buffer,
          c = this.u(e.piece.bufferIndex, e.piece.start)
        if (r.nodeStartLineNumber + e.piece.lineFeedCnt === i)
          s = o.substring(c + a, c + e.piece.length)
        else {
          const l = this.B(e, i - r.nodeStartLineNumber)
          return o.substring(c + a, c + l - t)
        }
      } else {
        let a = 0
        const o = i
        for (; e !== ut; )
          if (e.left !== ut && e.lf_left >= i - 1) e = e.left
          else if (e.lf_left + e.piece.lineFeedCnt > i - 1) {
            const c = this.B(e, i - e.lf_left - 2),
              l = this.B(e, i - e.lf_left - 1),
              u = this.a[e.piece.bufferIndex].buffer,
              d = this.u(e.piece.bufferIndex, e.piece.start)
            return (
              (a += e.size_left),
              this.h.set({
                node: e,
                nodeStartOffset: a,
                nodeStartLineNumber: o - (i - 1 - e.lf_left),
              }),
              u.substring(d + c, d + l - t)
            )
          } else if (e.lf_left + e.piece.lineFeedCnt === i - 1) {
            const c = this.B(e, i - e.lf_left - 2),
              l = this.a[e.piece.bufferIndex].buffer,
              u = this.u(e.piece.bufferIndex, e.piece.start)
            s = l.substring(u + c, u + e.piece.length)
            break
          } else
            (i -= e.lf_left + e.piece.lineFeedCnt),
              (a += e.size_left + e.piece.length),
              (e = e.right)
      }
      for (e = e.next(); e !== ut; ) {
        const a = this.a[e.piece.bufferIndex].buffer
        if (e.piece.lineFeedCnt > 0) {
          const o = this.B(e, 0),
            c = this.u(e.piece.bufferIndex, e.piece.start)
          return (s += a.substring(c, c + o - t)), s
        } else {
          const o = this.u(e.piece.bufferIndex, e.piece.start)
          s += a.substr(o, e.piece.length)
        }
        e = e.next()
      }
      return s
    }
    y() {
      let i = this.root,
        t = 1,
        e = 0
      for (; i !== ut; )
        (t += i.lf_left + i.piece.lineFeedCnt),
          (e += i.size_left + i.piece.length),
          (i = i.right)
      ;(this.b = t), (this.c = e), this.h.validate(this.c)
    }
    A(i, t) {
      const e = i.piece,
        s = this.s(i, t),
        r = s.line - e.start.line
      if (this.u(e.bufferIndex, e.end) - this.u(e.bufferIndex, e.start) === t) {
        const a = this.t(i.piece.bufferIndex, e.start, s)
        if (a !== r) return { index: a, remainder: 0 }
      }
      return { index: r, remainder: s.column }
    }
    B(i, t) {
      if (t < 0) return 0
      const e = i.piece,
        s = this.a[e.bufferIndex].lineStarts,
        r = e.start.line + t + 1
      return r > e.end.line
        ? s[e.end.line] + e.end.column - s[e.start.line] - e.start.column
        : s[r] - s[e.start.line] - e.start.column
    }
    C(i, t) {
      const e = i.piece,
        s = e.lineFeedCnt,
        r = this.u(e.bufferIndex, e.end),
        a = t,
        o = this.u(e.bufferIndex, a),
        c = this.t(e.bufferIndex, e.start, a),
        l = c - s,
        u = o - r,
        d = e.length + u
      ;(i.piece = new Zi(e.bufferIndex, e.start, a, c, d)), Cn(this, i, u, l)
    }
    D(i, t) {
      const e = i.piece,
        s = e.lineFeedCnt,
        r = this.u(e.bufferIndex, e.start),
        a = t,
        o = this.t(e.bufferIndex, a, e.end),
        c = this.u(e.bufferIndex, a),
        l = o - s,
        u = r - c,
        d = e.length + u
      ;(i.piece = new Zi(e.bufferIndex, a, e.end, o, d)), Cn(this, i, u, l)
    }
    E(i, t, e) {
      const s = i.piece,
        r = s.start,
        a = s.end,
        o = s.length,
        c = s.lineFeedCnt,
        l = t,
        u = this.t(s.bufferIndex, s.start, l),
        d = this.u(s.bufferIndex, t) - this.u(s.bufferIndex, r)
      ;(i.piece = new Zi(s.bufferIndex, s.start, l, u, d)),
        Cn(this, i, d - o, u - c)
      const m = new Zi(
          s.bufferIndex,
          e,
          a,
          this.t(s.bufferIndex, e, a),
          this.u(s.bufferIndex, a) - this.u(s.bufferIndex, e),
        ),
        f = this.S(i, m)
      this.N(f)
    }
    F(i, t) {
      this.Q(t, i) &&
        (t += `
`)
      const e = this.K() && this.L(t) && this.M(i),
        s = this.a[0].buffer.length
      this.a[0].buffer += t
      const r = Ln(t, !1)
      for (let f = 0; f < r.length; f++) r[f] += s
      if (e) {
        const f = this.a[0].lineStarts[this.a[0].lineStarts.length - 2]
        this.a[0].lineStarts.pop(),
          (this.g = { line: this.g.line - 1, column: s - f })
      }
      this.a[0].lineStarts = this.a[0].lineStarts.concat(r.slice(1))
      const a = this.a[0].lineStarts.length - 1,
        o = this.a[0].buffer.length - this.a[0].lineStarts[a],
        c = { line: a, column: o },
        l = i.piece.length + t.length,
        u = i.piece.lineFeedCnt,
        d = this.t(0, i.piece.start, c),
        m = d - u
      ;(i.piece = new Zi(i.piece.bufferIndex, i.piece.start, c, d, l)),
        (this.g = c),
        Cn(this, i, t.length, m)
    }
    G(i) {
      let t = this.root
      const e = this.h.get(i)
      if (e)
        return {
          node: e.node,
          nodeStartOffset: e.nodeStartOffset,
          remainder: i - e.nodeStartOffset,
        }
      let s = 0
      for (; t !== ut; )
        if (t.size_left > i) t = t.left
        else if (t.size_left + t.piece.length >= i) {
          s += t.size_left
          const r = { node: t, remainder: i - t.size_left, nodeStartOffset: s }
          return this.h.set(r), r
        } else
          (i -= t.size_left + t.piece.length),
            (s += t.size_left + t.piece.length),
            (t = t.right)
      return null
    }
    H(i, t) {
      let e = this.root,
        s = 0
      for (; e !== ut; )
        if (e.left !== ut && e.lf_left >= i - 1) e = e.left
        else if (e.lf_left + e.piece.lineFeedCnt > i - 1) {
          const r = this.B(e, i - e.lf_left - 2),
            a = this.B(e, i - e.lf_left - 1)
          return (
            (s += e.size_left),
            { node: e, remainder: Math.min(r + t - 1, a), nodeStartOffset: s }
          )
        } else if (e.lf_left + e.piece.lineFeedCnt === i - 1) {
          const r = this.B(e, i - e.lf_left - 2)
          if (r + t - 1 <= e.piece.length)
            return { node: e, remainder: r + t - 1, nodeStartOffset: s }
          t -= e.piece.length - r
          break
        } else
          (i -= e.lf_left + e.piece.lineFeedCnt),
            (s += e.size_left + e.piece.length),
            (e = e.right)
      for (e = e.next(); e !== ut; ) {
        if (e.piece.lineFeedCnt > 0) {
          const r = this.B(e, 0),
            a = this.J(e)
          return { node: e, remainder: Math.min(t - 1, r), nodeStartOffset: a }
        } else if (e.piece.length >= t - 1) {
          const r = this.J(e)
          return { node: e, remainder: t - 1, nodeStartOffset: r }
        } else t -= e.piece.length
        e = e.next()
      }
      return null
    }
    I(i, t) {
      if (i.piece.lineFeedCnt < 1) return -1
      const e = this.a[i.piece.bufferIndex],
        s = this.u(i.piece.bufferIndex, i.piece.start) + t
      return e.buffer.charCodeAt(s)
    }
    J(i) {
      if (!i) return 0
      let t = i.size_left
      for (; i !== this.root; )
        i.parent.right === i &&
          (t += i.parent.size_left + i.parent.piece.length),
          (i = i.parent)
      return t
    }
    K() {
      return !(
        this.f &&
        this.d ===
          `
`
      )
    }
    L(i) {
      if (typeof i == "string") return i.charCodeAt(0) === 10
      if (i === ut || i.piece.lineFeedCnt === 0) return !1
      const t = i.piece,
        e = this.a[t.bufferIndex].lineStarts,
        s = t.start.line,
        r = e[s] + t.start.column
      return s === e.length - 1 || e[s + 1] > r + 1
        ? !1
        : this.a[t.bufferIndex].buffer.charCodeAt(r) === 10
    }
    M(i) {
      return typeof i == "string"
        ? i.charCodeAt(i.length - 1) === 13
        : i === ut || i.piece.lineFeedCnt === 0
          ? !1
          : this.I(i, i.piece.length - 1) === 13
    }
    N(i) {
      if (this.K() && this.L(i)) {
        const t = i.prev()
        this.M(t) && this.P(t, i)
      }
    }
    O(i) {
      if (this.K() && this.M(i)) {
        const t = i.next()
        this.L(t) && this.P(i, t)
      }
    }
    P(i, t) {
      const e = [],
        s = this.a[i.piece.bufferIndex].lineStarts
      let r
      i.piece.end.column === 0
        ? (r = {
            line: i.piece.end.line - 1,
            column: s[i.piece.end.line] - s[i.piece.end.line - 1] - 1,
          })
        : (r = { line: i.piece.end.line, column: i.piece.end.column - 1 })
      const a = i.piece.length - 1,
        o = i.piece.lineFeedCnt - 1
      ;(i.piece = new Zi(i.piece.bufferIndex, i.piece.start, r, o, a)),
        Cn(this, i, -1, -1),
        i.piece.length === 0 && e.push(i)
      const c = { line: t.piece.start.line + 1, column: 0 },
        l = t.piece.length - 1,
        u = this.t(t.piece.bufferIndex, c, t.piece.end)
      ;(t.piece = new Zi(t.piece.bufferIndex, c, t.piece.end, u, l)),
        Cn(this, t, -1, -1),
        t.piece.length === 0 && e.push(t)
      const d = this.w(`\r
`)
      this.S(i, d[0])
      for (let m = 0; m < e.length; m++) T3(this, e[m])
    }
    Q(i, t) {
      if (this.K() && this.M(i)) {
        const e = t.next()
        if (this.L(e)) {
          if (
            ((i += `
`),
            e.piece.length === 1)
          )
            T3(this, e)
          else {
            const s = e.piece,
              r = { line: s.start.line + 1, column: 0 },
              a = s.length - 1,
              o = this.t(s.bufferIndex, r, s.end)
            ;(e.piece = new Zi(s.bufferIndex, r, s.end, o, a)),
              Cn(this, e, -1, -1)
          }
          return !0
        }
      }
      return !1
    }
    iterate(i, t) {
      if (i === ut) return t(ut)
      const e = this.iterate(i.left, t)
      return e && t(i) && this.iterate(i.right, t)
    }
    R(i) {
      if (i === ut) return ""
      const t = this.a[i.piece.bufferIndex],
        e = i.piece,
        s = this.u(e.bufferIndex, e.start),
        r = this.u(e.bufferIndex, e.end)
      return t.buffer.substring(s, r)
    }
    getPieceContent(i) {
      const t = this.a[i.bufferIndex],
        e = this.u(i.bufferIndex, i.start),
        s = this.u(i.bufferIndex, i.end)
      return t.buffer.substring(e, s)
    }
    S(i, t) {
      const e = new uj(t, 1)
      if (
        ((e.left = ut),
        (e.right = ut),
        (e.parent = ut),
        (e.size_left = 0),
        (e.lf_left = 0),
        this.root === ut)
      )
        (this.root = e), (e.color = 0)
      else if (i.right === ut) (i.right = e), (e.parent = i)
      else {
        const r = hj(i.right)
        ;(r.left = e), (e.parent = r)
      }
      return nct(this, e), e
    }
    T(i, t) {
      const e = new uj(t, 1)
      if (
        ((e.left = ut),
        (e.right = ut),
        (e.parent = ut),
        (e.size_left = 0),
        (e.lf_left = 0),
        this.root === ut)
      )
        (this.root = e), (e.color = 0)
      else if (i.left === ut) (i.left = e), (e.parent = i)
      else {
        const s = rct(i.left)
        ;(s.right = e), (e.parent = s)
      }
      return nct(this, e), e
    }
    U(i) {
      let t = ""
      return this.iterate(i, (e) => ((t += this.R(e)), !0)), t
    }
  },
  oct
;(function (i) {
  ;(i[(i.Unknown = 0)] = "Unknown"),
    (i[(i.Invalid = 3)] = "Invalid"),
    (i[(i.LF = 1)] = "LF"),
    (i[(i.CRLF = 2)] = "CRLF")
})(oct || (oct = {}))
function pj(i) {
  let t = 0,
    e = 0,
    s = 0,
    r = 0
  for (let a = 0, o = i.length; a < o; a++) {
    const c = i.charCodeAt(a)
    c === 13
      ? (t === 0 && (e = a),
        t++,
        a + 1 < o && i.charCodeAt(a + 1) === 10 ? ((r |= 2), a++) : (r |= 3),
        (s = a + 1))
      : c === 10 && ((r |= 1), t === 0 && (e = a), t++, (s = a + 1))
  }
  return t === 0 && (e = i.length), [t, e, i.length - s, r]
}
var gj
function _Ut() {
  return gj || (gj = new TextDecoder("UTF-16LE")), gj
}
function OUt(i, t, e) {
  const s = new Uint16Array(i.buffer, t, e)
  return e > 0 && (s[0] === 65279 || s[0] === 65534)
    ? BUt(i, t, e)
    : _Ut().decode(s)
}
function BUt(i, t, e) {
  const s = []
  let r = 0
  for (let a = 0; a < e; a++) {
    const o = evt(i, t)
    ;(t += 2), (s[r++] = String.fromCharCode(o))
  }
  return s.join("")
}
function k3(i) {
  return i.replace(/\n/g, "\\n").replace(/\r/g, "\\r")
}
var qUt = class Tr {
    get oldLength() {
      return this.oldText.length
    }
    get oldEnd() {
      return this.oldPosition + this.oldText.length
    }
    get newLength() {
      return this.newText.length
    }
    get newEnd() {
      return this.newPosition + this.newText.length
    }
    constructor(t, e, s, r) {
      ;(this.oldPosition = t),
        (this.oldText = e),
        (this.newPosition = s),
        (this.newText = r)
    }
    shift(t) {
      return new Tr(
        this.oldPosition + t,
        this.oldText,
        this.newPosition + t,
        this.newText,
      )
    }
    toString() {
      return this.oldText.length === 0
        ? `(insert@${this.oldPosition} "${k3(this.newText)}")`
        : this.newText.length === 0
          ? `(delete@${this.oldPosition} "${k3(this.oldText)}")`
          : `(replace@${this.oldPosition} "${k3(this.oldText)}" with "${k3(this.newText)}")`
    }
    static a(t) {
      return 4 + 2 * t.length
    }
    static c(t, e, s) {
      const r = e.length
      H_(t, r, s), (s += 4)
      for (let a = 0; a < r; a++) ivt(t, e.charCodeAt(a), s), (s += 2)
      return s
    }
    static d(t, e) {
      const s = M_(t, e)
      return (e += 4), OUt(t, e, s)
    }
    writeSize() {
      return 8 + Tr.a(this.oldText) + Tr.a(this.newText)
    }
    write(t, e) {
      return (
        H_(t, this.oldPosition, e),
        (e += 4),
        H_(t, this.newPosition, e),
        (e += 4),
        (e = Tr.c(t, this.oldText, e)),
        (e = Tr.c(t, this.newText, e)),
        e
      )
    }
    static read(t, e, s) {
      const r = M_(t, e)
      e += 4
      const a = M_(t, e)
      e += 4
      const o = Tr.d(t, e)
      e += Tr.a(o)
      const c = Tr.d(t, e)
      return (e += Tr.a(c)), s.push(new Tr(r, o, a, c)), e
    }
  },
  UUt = class i_ extends at {
    constructor(t, e, s, r, a, o, c) {
      super(),
        (this.m = this.D(new J())),
        (this.onDidChangeContent = this.m.event),
        (this.f = e),
        (this.j = !o),
        (this.g = r),
        (this.h = a),
        (this.c = new AUt(t, s, c))
    }
    equals(t) {
      return !(t instanceof i_) ||
        this.f !== t.f ||
        this.getEOL() !== t.getEOL()
        ? !1
        : this.c.equal(t.c)
    }
    mightContainRTL() {
      return this.g
    }
    mightContainUnusualLineTerminators() {
      return this.h
    }
    resetMightContainUnusualLineTerminators() {
      this.h = !1
    }
    mightContainNonBasicASCII() {
      return this.j
    }
    getBOM() {
      return this.f
    }
    getEOL() {
      return this.c.getEOL()
    }
    createSnapshot(t) {
      return this.c.createSnapshot(t ? this.f : "")
    }
    getOffsetAt(t, e) {
      return this.c.getOffsetAt(t, e)
    }
    getPositionAt(t) {
      return this.c.getPositionAt(t)
    }
    getRangeAt(t, e) {
      const s = t + e,
        r = this.getPositionAt(t),
        a = this.getPositionAt(s)
      return new ue(r.lineNumber, r.column, a.lineNumber, a.column)
    }
    getValueInRange(t, e = 0) {
      if (t.isEmpty()) return ""
      const s = this.n(e)
      return this.c.getValueInRange(t, s)
    }
    getValueLengthInRange(t, e = 0) {
      if (t.isEmpty()) return 0
      if (t.startLineNumber === t.endLineNumber)
        return t.endColumn - t.startColumn
      const s = this.getOffsetAt(t.startLineNumber, t.startColumn),
        r = this.getOffsetAt(t.endLineNumber, t.endColumn)
      let a = 0
      const o = this.n(e),
        c = this.getEOL()
      if (o.length !== c.length) {
        const l = o.length - c.length,
          u = t.endLineNumber - t.startLineNumber
        a = l * u
      }
      return r - s + a
    }
    getCharacterCountInRange(t, e = 0) {
      if (this.j) {
        let s = 0
        const r = t.startLineNumber,
          a = t.endLineNumber
        for (let o = r; o <= a; o++) {
          const c = this.getLineContent(o),
            l = o === r ? t.startColumn - 1 : 0,
            u = o === a ? t.endColumn - 1 : c.length
          for (let d = l; d < u; d++)
            P_(c.charCodeAt(d)) ? ((s = s + 1), (d = d + 1)) : (s = s + 1)
        }
        return (s += this.n(e).length * (a - r)), s
      }
      return this.getValueLengthInRange(t, e)
    }
    getNearestChunk(t) {
      return this.c.getNearestChunk(t)
    }
    getLength() {
      return this.c.getLength()
    }
    getLineCount() {
      return this.c.getLineCount()
    }
    getLinesContent() {
      return this.c.getLinesContent()
    }
    getLineContent(t) {
      return this.c.getLineContent(t)
    }
    getLineCharCode(t, e) {
      return this.c.getLineCharCode(t, e)
    }
    getCharCode(t) {
      return this.c.getCharCode(t)
    }
    getLineLength(t) {
      return this.c.getLineLength(t)
    }
    getLineMinColumn(t) {
      return 1
    }
    getLineMaxColumn(t) {
      return this.getLineLength(t) + 1
    }
    getLineFirstNonWhitespaceColumn(t) {
      const e = k7(this.getLineContent(t))
      return e === -1 ? 0 : e + 1
    }
    getLineLastNonWhitespaceColumn(t) {
      const e = Adt(this.getLineContent(t))
      return e === -1 ? 0 : e + 2
    }
    n(t) {
      switch (t) {
        case 1:
          return `
`
        case 2:
          return `\r
`
        case 0:
          return this.getEOL()
        default:
          throw new Error("Unknown EOL preference")
      }
    }
    setEOL(t) {
      this.c.setEOL(t)
    }
    applyEdits(t, e, s) {
      let r = this.g,
        a = this.h,
        o = this.j,
        c = !0,
        l = []
      for (let b = 0; b < t.length; b++) {
        const k = t[b]
        c && k._isTracked && (c = !1)
        const E = k.range
        if (k.text) {
          let V = !0
          o || ((V = !Wdt(k.text)), (o = V)),
            !r && V && (r = yG(k.text)),
            !a && V && (a = bG(k.text))
        }
        let P = "",
          C = 0,
          R = 0,
          D = 0
        if (k.text) {
          let V
          ;[C, R, D, V] = pj(k.text)
          const tt = this.getEOL()
          V === 0 ||
          V ===
            (tt ===
            `\r
`
              ? 2
              : 1)
            ? (P = k.text)
            : (P = k.text.replace(/\r\n|\r|\n/g, tt))
        }
        l[b] = {
          sortIndex: b,
          identifier: k.identifier || null,
          range: E,
          rangeOffset: this.getOffsetAt(E.startLineNumber, E.startColumn),
          rangeLength: this.getValueLengthInRange(E),
          text: P,
          eolCount: C,
          firstLineLength: R,
          lastLineLength: D,
          forceMoveMarkers: !!k.forceMoveMarkers,
          isAutoWhitespaceEdit: k.isAutoWhitespaceEdit || !1,
        }
      }
      l.sort(i_.t)
      let u = !1
      for (let b = 0, k = l.length - 1; b < k; b++) {
        const E = l[b].range.getEndPosition(),
          P = l[b + 1].range.getStartPosition()
        if (P.isBeforeOrEqual(E)) {
          if (P.isBefore(E))
            throw new Error("Overlapping ranges are not allowed!")
          u = !0
        }
      }
      c && (l = this.q(l))
      const d = s || e ? i_._getInverseEditRanges(l) : [],
        m = []
      if (e)
        for (let b = 0; b < l.length; b++) {
          const k = l[b],
            E = d[b]
          if (k.isAutoWhitespaceEdit && k.range.isEmpty())
            for (let P = E.startLineNumber; P <= E.endLineNumber; P++) {
              let C = ""
              ;(P === E.startLineNumber &&
                ((C = this.getLineContent(k.range.startLineNumber)),
                k7(C) !== -1)) ||
                m.push({ lineNumber: P, oldContent: C })
            }
        }
      let f = null
      if (s) {
        let b = 0
        f = []
        for (let k = 0; k < l.length; k++) {
          const E = l[k],
            P = d[k],
            C = this.getValueInRange(E.range),
            R = E.rangeOffset + b
          ;(b += E.text.length - C.length),
            (f[k] = {
              sortIndex: E.sortIndex,
              identifier: E.identifier,
              range: P,
              text: C,
              textChange: new qUt(E.rangeOffset, C, R, E.text),
            })
        }
        u || f.sort((k, E) => k.sortIndex - E.sortIndex)
      }
      ;(this.g = r), (this.h = a), (this.j = o)
      const p = this.s(l)
      let v = null
      if (e && m.length > 0) {
        m.sort((b, k) => k.lineNumber - b.lineNumber), (v = [])
        for (let b = 0, k = m.length; b < k; b++) {
          const E = m[b].lineNumber
          if (b > 0 && m[b - 1].lineNumber === E) continue
          const P = m[b].oldContent,
            C = this.getLineContent(E)
          C.length === 0 || C === P || k7(C) !== -1 || v.push(E)
        }
      }
      return this.m.fire(), new jPt(f, p, v)
    }
    q(t) {
      return t.length < 1e3 ? t : [this._toSingleEditOperation(t)]
    }
    _toSingleEditOperation(t) {
      let e = !1
      const s = t[0].range,
        r = t[t.length - 1].range,
        a = new ue(
          s.startLineNumber,
          s.startColumn,
          r.endLineNumber,
          r.endColumn,
        )
      let o = s.startLineNumber,
        c = s.startColumn
      const l = []
      for (let p = 0, v = t.length; p < v; p++) {
        const b = t[p],
          k = b.range
        ;(e = e || b.forceMoveMarkers),
          l.push(
            this.getValueInRange(
              new ue(o, c, k.startLineNumber, k.startColumn),
            ),
          ),
          b.text.length > 0 && l.push(b.text),
          (o = k.endLineNumber),
          (c = k.endColumn)
      }
      const u = l.join(""),
        [d, m, f] = pj(u)
      return {
        sortIndex: 0,
        identifier: t[0].identifier,
        range: a,
        rangeOffset: this.getOffsetAt(a.startLineNumber, a.startColumn),
        rangeLength: this.getValueLengthInRange(a, 0),
        text: u,
        eolCount: d,
        firstLineLength: m,
        lastLineLength: f,
        forceMoveMarkers: e,
        isAutoWhitespaceEdit: !1,
      }
    }
    s(t) {
      t.sort(i_.u)
      const e = []
      for (let s = 0; s < t.length; s++) {
        const r = t[s],
          a = r.range.startLineNumber,
          o = r.range.startColumn,
          c = r.range.endLineNumber,
          l = r.range.endColumn
        if (a === c && o === l && r.text.length === 0) continue
        r.text
          ? (this.c.delete(r.rangeOffset, r.rangeLength),
            this.c.insert(r.rangeOffset, r.text, !0))
          : this.c.delete(r.rangeOffset, r.rangeLength)
        const u = new ue(a, o, c, l)
        e.push({
          range: u,
          rangeLength: r.rangeLength,
          text: r.text,
          rangeOffset: r.rangeOffset,
          forceMoveMarkers: r.forceMoveMarkers,
        })
      }
      return e
    }
    findMatchesLineByLine(t, e, s, r) {
      return this.c.findMatchesLineByLine(t, e, s, r)
    }
    getPieceTree() {
      return this.c
    }
    static _getInverseEditRange(t, e) {
      const s = t.startLineNumber,
        r = t.startColumn,
        [a, o, c] = pj(e)
      let l
      if (e.length > 0) {
        const u = a + 1
        u === 1
          ? (l = new ue(s, r, s, r + o))
          : (l = new ue(s, r, s + u - 1, c + 1))
      } else l = new ue(s, r, s, r)
      return l
    }
    static _getInverseEditRanges(t) {
      const e = []
      let s = 0,
        r = 0,
        a = null
      for (let o = 0, c = t.length; o < c; o++) {
        const l = t[o]
        let u, d
        a
          ? a.range.endLineNumber === l.range.startLineNumber
            ? ((u = s), (d = r + (l.range.startColumn - a.range.endColumn)))
            : ((u = s + (l.range.startLineNumber - a.range.endLineNumber)),
              (d = l.range.startColumn))
          : ((u = l.range.startLineNumber), (d = l.range.startColumn))
        let m
        if (l.text.length > 0) {
          const f = l.eolCount + 1
          f === 1
            ? (m = new ue(u, d, u, d + l.firstLineLength))
            : (m = new ue(u, d, u + f - 1, l.lastLineLength + 1))
        } else m = new ue(u, d, u, d)
        ;(s = m.endLineNumber), (r = m.endColumn), e.push(m), (a = l)
      }
      return e
    }
    static t(t, e) {
      const s = ue.compareRangesUsingEnds(t.range, e.range)
      return s === 0 ? t.sortIndex - e.sortIndex : s
    }
    static u(t, e) {
      const s = ue.compareRangesUsingEnds(t.range, e.range)
      return s === 0 ? e.sortIndex - t.sortIndex : -s
    }
  },
  MUt = class {
    constructor(i, t, e, s, r, a, o, c, l) {
      ;(this.a = i),
        (this.b = t),
        (this.c = e),
        (this.d = s),
        (this.e = r),
        (this.f = a),
        (this.g = o),
        (this.h = c),
        (this.j = l)
    }
    k(i) {
      const t = this.c + this.d + this.e,
        e = this.c + this.e
      return t === 0
        ? i === 1
          ? `
`
          : `\r
`
        : e > t / 2
          ? `\r
`
          : `
`
    }
    create(i) {
      const t = this.k(i),
        e = this.a
      if (
        this.j &&
        ((t ===
          `\r
` &&
          (this.c > 0 || this.d > 0)) ||
          (t ===
            `
` &&
            (this.c > 0 || this.e > 0)))
      )
        for (let r = 0, a = e.length; r < a; r++) {
          const o = e[r].buffer.replace(/\r\n|\r|\n/g, t),
            c = Ln(o)
          e[r] = new Wo(o, c)
        }
      const s = new UUt(e, this.b, t, this.f, this.g, this.h, this.j)
      return { textBuffer: s, disposable: s }
    }
    getFirstLineText(i) {
      return this.a[0].buffer.substr(0, i).split(/\r\n|\r|\n/)[0]
    }
  },
  cct = class {
    constructor() {
      ;(this.a = []),
        (this.b = ""),
        (this.c = !1),
        (this.d = 0),
        (this.e = []),
        (this.f = 0),
        (this.g = 0),
        (this.h = 0),
        (this.j = !1),
        (this.k = !1),
        (this.l = !0)
    }
    acceptChunk(i) {
      if (i.length === 0) return
      this.a.length === 0 && Gdt(i) && ((this.b = Vdt), (i = i.substr(1)))
      const t = i.charCodeAt(i.length - 1)
      t === 13 || (t >= 55296 && t <= 56319)
        ? (this.m(i.substr(0, i.length - 1), !1), (this.c = !0), (this.d = t))
        : (this.m(i, !1), (this.c = !1), (this.d = t))
    }
    m(i, t) {
      ;(!t && i.length === 0) ||
        (this.c ? this.n(String.fromCharCode(this.d) + i) : this.n(i))
    }
    n(i) {
      const t = RUt(this.e, i)
      this.a.push(new Wo(i, t.lineStarts)),
        (this.f += t.cr),
        (this.g += t.lf),
        (this.h += t.crlf),
        t.isBasicASCII ||
          ((this.l = !1),
          this.j || (this.j = yG(i)),
          this.k || (this.k = bG(i)))
    }
    finish(i = !0) {
      return (
        this.o(),
        new MUt(
          this.a,
          this.b,
          this.f,
          this.g,
          this.h,
          this.j,
          this.k,
          this.l,
          i,
        )
      )
    }
    o() {
      if ((this.a.length === 0 && this.m("", !0), this.c)) {
        this.c = !1
        const i = this.a[this.a.length - 1]
        i.buffer += String.fromCharCode(this.d)
        const t = Ln(i.buffer)
        ;(i.lineStarts = t), this.d === 13 && this.f++
      }
    }
  },
  HUt = class extends at {
    constructor(i, t, e) {
      super(), (this._source = i), (this.b = t), (this.c = e), (this.a = void 0)
    }
    f(i) {
      const t = i.getLineCount()
      return new ue(1, 1, t, this.g(i, t))
    }
    g(i, t) {
      if (t < 1 || t > i.getLineCount())
        throw new Error("Illegal value for lineNumber")
      return i.getLineLength(t) + 1
    }
    get inputTextBuffer() {
      if (!this.b) {
        const i = new cct()
        i.acceptChunk(this._source)
        const t = i.finish(!0),
          { textBuffer: e, disposable: s } = t.create(1)
        ;(this.b = e), this.D(s)
      }
      return this.b
    }
    get outputTextBuffers() {
      return (
        this.a ||
          (this.a = this.c.map((i) => {
            const t = new cct()
            t.acceptChunk(i)
            const e = t.finish(!0),
              { textBuffer: s, disposable: r } = e.create(1)
            return this.D(r), s
          })),
        this.a
      )
    }
    findInInputs(i) {
      const e = new rst(i, !1, !1, null).parseSearchRequest()
      if (!e) return []
      const s = this.f(this.inputTextBuffer)
      return this.inputTextBuffer.findMatchesLineByLine(s, e, !0, 5e3)
    }
    findInOutputs(i) {
      const e = new rst(i, !1, !1, null).parseSearchRequest()
      return e
        ? this.outputTextBuffers
            .map((s) => {
              const r = s.findMatchesLineByLine(this.f(s), e, !0, 5e3)
              if (r.length !== 0) return { textBuffer: s, matches: r }
            })
            .filter((s) => !!s)
        : []
    }
  }
function lct(i, t) {
  let e = -1
  const s = []
  let r = []
  return (
    i.forEach((o) => {
      o.range.startLineNumber !== e &&
        r.length > 0 &&
        (s.push([...r]), (r = [])),
        r.push(o),
        (e = o.range.endLineNumber)
    }),
    r.length > 0 && s.push([...r]),
    s.map((o) => {
      const c = [],
        l = o[0].range.startLineNumber,
        u = o[o.length - 1].range.endLineNumber
      for (let d = l; d <= u; d++) c.push(t.getLineContent(d))
      return new qtt(
        c.join(`
`) +
          `
`,
        o.map(
          (d) =>
            new ue(
              d.range.startLineNumber - 1,
              d.range.startColumn - 1,
              d.range.endLineNumber - 1,
              d.range.endColumn - 1,
            ),
        ),
      )
    })
  )
}
var MKt = Object.freeze({
    id: "application",
    order: 100,
    title: g(4069, null),
    type: "object",
  }),
  WUt = Object.freeze({
    id: "workbench",
    order: 7,
    title: g(4070, null),
    type: "object",
  }),
  jUt = Object.freeze({
    id: "security",
    scope: 1,
    title: g(4071, null),
    type: "object",
    order: 7,
  }),
  HKt = Object.freeze({
    id: "problems",
    title: g(4072, null),
    type: "object",
    order: 101,
  }),
  VUt = Object.freeze({
    id: "window",
    order: 8,
    title: g(4073, null),
    type: "object",
  }),
  GUt = {
    ConfigurationMigration: "base.contributions.configuration.migration",
  },
  zUt = class {
    constructor() {
      ;(this.migrations = []),
        (this.a = new J()),
        (this.onDidRegisterConfigurationMigration = this.a.event)
    }
    registerConfigurationMigrations(i) {
      this.migrations.push(...i)
    }
  },
  S3 = new zUt()
Si.add(GUt.ConfigurationMigration, S3)
var uct = class extends at {
  static {
    this.ID = "workbench.contrib.configurationMigration"
  }
  constructor(t, e) {
    super(),
      (this.a = t),
      (this.b = e),
      this.D(
        this.b.onDidChangeWorkspaceFolders(async (s) => {
          for (const r of s.added) await this.f(r, S3.migrations)
        }),
      ),
      this.c(S3.migrations),
      this.D(S3.onDidRegisterConfigurationMigration((s) => this.c(s)))
  }
  async c(t) {
    await this.f(void 0, t)
    for (const e of this.b.getWorkspace().folders) await this.f(e, t)
  }
  async f(t, e) {
    await Promise.all([e.map((s) => this.g(s, t?.uri))])
  }
  async g(t, e) {
    const s = this.a.inspect(t.key, { resource: e }),
      r =
        this.b.getWorkbenchState() === 3
          ? [
              ["user", 2],
              ["userLocal", 3],
              ["userRemote", 4],
              ["workspace", 5],
              ["workspaceFolder", 6],
            ]
          : [
              ["user", 2],
              ["userLocal", 3],
              ["userRemote", 4],
              ["workspace", 5],
            ]
    for (const [a, o] of r) {
      const c = s[a]
      if (!c) continue
      const l = []
      if (c.value !== void 0) {
        const u = await this.h(t, a, c.value, e, void 0)
        for (const d of u ?? []) l.push([d, []])
      }
      for (const { identifiers: u, value: d } of c.overrides ?? [])
        if (d !== void 0) {
          const m = await this.h(t, a, d, e, u)
          for (const f of m ?? []) l.push([f, u])
        }
      l.length &&
        (await Promise.allSettled(
          l.map(async ([[u, d], m]) =>
            this.a.updateValue(
              u,
              d.value,
              { resource: e, overrideIdentifiers: m },
              o,
            ),
          ),
        ))
    }
  }
  async h(t, e, s, r, a) {
    const o = (l) => {
        const d = this.a.inspect(l, { resource: r })[e]
        if (d)
          return a
            ? d.overrides?.find(({ identifiers: m }) => Qs(m, a))?.value
            : d.value
      },
      c = await t.migrateFn(s, o)
    return Array.isArray(c) ? c : [[t.key, c]]
  }
}
uct = __decorate([__param(0, dn), __param(1, s6)], uct)
var hct = class extends at {
  static {
    this.ID = "workbench.contrib.dynamicWorkbenchSecurityConfiguration"
  }
  constructor(t) {
    super(),
      (this.b = t),
      (this.a = new Yn()),
      (this.ready = this.a.p),
      this.c()
  }
  async c() {
    try {
      await this.f()
    } finally {
      this.a.complete()
    }
  }
  async f() {
    if (!ie && (await this.b.getEnvironment())?.os !== 1) return
    Si.as(_c.Configuration).registerConfiguration({
      ...jUt,
      properties: {
        "security.allowedUNCHosts": {
          type: "array",
          items: {
            type: "string",
            pattern: "^[^\\\\]+$",
            patternErrorMessage: g(4074, null),
          },
          default: [],
          markdownDescription: g(4075, null),
          scope: 2,
        },
        "security.restrictUNCAccess": {
          type: "boolean",
          default: !0,
          markdownDescription: g(4076, null),
          scope: 2,
        },
      },
    })
  }
}
hct = __decorate([__param(0, ust)], hct)
var Wf = "window.newWindowProfile",
  dct = class extends at {
    static {
      this.ID = "workbench.contrib.dynamicWindowConfiguration"
    }
    constructor(t, e) {
      super(),
        (this.c = t),
        (this.f = e),
        this.g(),
        this.D(this.c.onDidChangeProfiles((s) => this.g())),
        this.h(),
        this.j(),
        this.D(
          e.onDidChangeConfiguration((s) => {
            s.source !== 7 && s.affectsConfiguration(Wf) && this.h()
          }),
        ),
        this.D(this.c.onDidChangeProfiles(() => this.j()))
    }
    g() {
      const t = Si.as(_c.Configuration),
        e = {
          ...VUt,
          properties: {
            [Wf]: {
              type: ["string", "null"],
              default: null,
              enum: [...this.c.profiles.map((s) => s.name), null],
              enumItemLabels: [
                ...this.c.profiles.map((s) => ""),
                g(4077, null),
              ],
              description: g(4078, null),
              scope: 1,
            },
          },
        }
      this.a
        ? t.updateConfigurations({ add: [e], remove: [this.a] })
        : t.registerConfiguration(e),
        (this.a = e)
    }
    h() {
      const t = this.f.getValue(Wf)
      this.b = t ? this.c.profiles.find((e) => e.name === t) : void 0
    }
    j() {
      const t = this.f.getValue(Wf)
      if (!t) return
      const e = this.b
        ? this.c.profiles.find((s) => s.id === this.b.id)
        : void 0
      t !== e?.name && this.f.updateValue(Wf, e?.name)
    }
  }
dct = __decorate([__param(0, ubt), __param(1, dn)], dct)
var GKt = X("editorResolverService"),
  YUt = Si.as(_c.Configuration),
  QUt = {
    ...WUt,
    properties: {
      "workbench.editorAssociations": {
        type: "object",
        markdownDescription: g(12787, null),
        additionalProperties: { type: "string" },
      },
    },
  }
YUt.registerConfiguration(QUt)
var vj
;(function (i) {
  ;(i.builtin = "builtin"),
    (i.option = "option"),
    (i.exclusive = "exclusive"),
    (i.default = "default")
})(vj || (vj = {}))
var mct
;(function (i) {
  ;(i[(i.ABORT = 1)] = "ABORT"), (i[(i.NONE = 2)] = "NONE")
})(mct || (mct = {}))
function XUt(i, t) {
  if (
    new Set([
      G.extension,
      G.webviewPanel,
      G.vscodeWorkspaceTrust,
      G.walkThrough,
      G.vscodeSettings,
      G.aiSettings,
      G.aiChat,
    ]).has(t.scheme)
  )
    return !1
  const r =
    typeof i == "string" && i.indexOf(Wt.sep) >= 0
      ? `${t.scheme}:${t.path}`
      : xr(t)
  return Bc(typeof i == "string" ? i.toLowerCase() : i, r.toLowerCase())
}
var KUt = class s_ {
    static {
      this.a = 0
    }
    get activeNotebookEditor() {
      return this.k?.apiEditor
    }
    get visibleNotebookEditors() {
      return this.l.map((t) => t.apiEditor)
    }
    constructor(t, e, s, r, a, o, c) {
      ;(this.q = s),
        (this.r = r),
        (this.s = a),
        (this.t = o),
        (this.u = c),
        (this.f = new Map()),
        (this.g = new oi()),
        (this.h = new Map()),
        (this.j = new J()),
        (this.onDidChangeActiveNotebookEditor = this.j.event),
        (this.l = []),
        (this.m = new J()),
        (this.onDidOpenNotebookDocument = this.m.event),
        (this.n = new J()),
        (this.onDidCloseNotebookDocument = this.n.event),
        (this.o = new J()),
        (this.onDidChangeVisibleNotebookEditors = this.o.event),
        (this.p = new wr("NotebookCellStatusBarCache")),
        (this.x = 0),
        (this.y = new Map()),
        (this.b = t.getProxy(K.MainThreadNotebook)),
        (this.c = t.getProxy(K.MainThreadNotebookDocuments)),
        (this.d = t.getProxy(K.MainThreadNotebookEditors)),
        (this.i = e.converter),
        e.registerArgumentProcessor({
          processArgument: (l) => {
            if (l && l.$mid === 13) {
              const u = l.notebookEditor?.notebookUri,
                d = l.cell.handle,
                f = this.g.get(u)?.getCell(d)
              if (f) return f.apiCell
            }
            if (l && l.$mid === 14) {
              const u = l.uri,
                d = this.g.get(u)
              if (d) return d.apiNotebook
            }
            return l
          },
        }),
        s_.C(e)
    }
    getEditorById(t) {
      const e = this.h.get(t)
      if (!e)
        throw new Error(
          `unknown text editor: ${t}. known editors: ${[...this.h.keys()]} `,
        )
      return e
    }
    getIdByEditor(t) {
      for (const [e, s] of this.h) if (s.apiEditor === t) return e
    }
    get notebookDocuments() {
      return [...this.g.values()]
    }
    getNotebookDocument(t, e) {
      const s = this.g.get(t)
      if (!s && !e) throw new Error(`NO notebook document for '${t}'`)
      return s
    }
    static w(t, e) {
      if (!e) return
      const s = e.filenamePattern
        .map((r) => n8.from(r))
        .filter((r) => r !== void 0)
      if (e.filenamePattern && !s) {
        console.warn(
          `Notebook content provider view options file name pattern is invalid ${e.filenamePattern}`,
        )
        return
      }
      return {
        extension: t.identifier,
        providerDisplayName: t.displayName || t.name,
        displayName: e.displayName,
        filenamePattern: s,
        priority: e.exclusive ? vj.exclusive : void 0,
      }
    }
    registerNotebookCellStatusBarItemProvider(t, e, s) {
      const r = s_.a++,
        a =
          typeof s.onDidChangeCellStatusBarItems == "function" ? s_.a++ : void 0
      this.f.set(r, s),
        this.b.$registerNotebookCellStatusBarItemProvider(r, a, e)
      let o
      return (
        a !== void 0 &&
          (o = s.onDidChangeCellStatusBarItems((c) =>
            this.b.$emitCellStatusBarEvent(a),
          )),
        new Ht(() => {
          this.f.delete(r),
            this.b.$unregisterNotebookCellStatusBarItemProvider(r, a),
            o?.dispose()
        })
      )
    }
    async createNotebookDocument(t) {
      const e = await this.c.$tryCreateNotebook({
        viewType: t.viewType,
        content: t.content && da.from(t.content),
      })
      return S.revive(e)
    }
    async openNotebookDocument(t) {
      const e = this.g.get(t)
      if (e) return e.apiNotebook
      const s = await this.c.$tryOpenNotebook(t),
        r = this.g.get(S.revive(s))
      return hc(r?.apiNotebook)
    }
    async showNotebookDocument(t, e) {
      let s
      typeof e == "object"
        ? (s = {
            position: ii.from(e.viewColumn),
            preserveFocus: e.preserveFocus,
            selections: e.selections && e.selections.map(Or.from),
            pinned: typeof e.preview == "boolean" ? !e.preview : void 0,
            label:
              typeof e.asRepl == "string"
                ? e.asRepl
                : typeof e.asRepl == "object"
                  ? e.asRepl.label
                  : void 0,
          })
        : (s = { preserveFocus: !1, pinned: !0 })
      const r = e?.asRepl ? "repl" : t.notebookType,
        a = await this.d.$tryShowNotebookDocument(t.uri, r, s),
        o = a && this.h.get(a)?.apiEditor
      if (o) return o
      throw a
        ? new Error(
            `Could NOT open editor for "${t.uri.toString()}" because another editor opened in the meantime.`,
          )
        : new Error(`Could NOT open editor for "${t.uri.toString()}".`)
    }
    async $provideNotebookCellStatusBarItems(t, e, s, r) {
      const a = this.f.get(t),
        o = S.revive(e),
        c = this.g.get(o)
      if (!c || !a) return
      const l = c.getCellFromIndex(s)
      if (!l) return
      const u = await a.provideCellStatusBarItems(l.apiCell, r)
      if (!u) return
      const d = new gt(),
        m = this.p.add([d]),
        p = (Array.isArray(u) ? u : [u]).map((v) => QU.from(v, this.i, d))
      return { cacheId: m, items: p }
    }
    $releaseNotebookCellStatusBarItems(t) {
      this.p.delete(t)
    }
    registerNotebookSerializer(t, e, s, r, a) {
      if (E_(e)) throw new Error("viewType cannot be empty or just whitespace")
      const o = this.x++
      return (
        this.y.set(o, { viewType: e, serializer: s, options: r }),
        this.b.$registerNotebookSerializer(
          o,
          { id: t.identifier, location: t.extensionLocation },
          e,
          KU.from(r),
          s_.w(t, a),
        ),
        et(() => {
          this.b.$unregisterNotebookSerializer(o)
        })
      )
    }
    async $dataToNotebook(t, e, s) {
      const r = this.y.get(t)
      if (!r) throw new Error("NO serializer found")
      const a = await r.serializer.deserializeNotebook(e.buffer, s)
      return new gs(da.from(a))
    }
    async $notebookToData(t, e, s) {
      const r = this.y.get(t)
      if (!r) throw new Error("NO serializer found")
      const a = await r.serializer.serializeNotebook(da.to(e.value), s)
      return Q.wrap(a)
    }
    async $saveNotebook(t, e, s, r, a) {
      const o = S.revive(e),
        c = this.y.get(t)
      if ((this.D(`enter saveNotebook(versionId: ${s}, ${o.toString()})`), !c))
        throw new Error("NO serializer found")
      const l = this.g.get(o)
      if (!l) throw new Error("Document NOT found")
      if (l.versionId !== s) throw new Error("Document version mismatch")
      if (!this.s.value.isWritableFileSystem(o.scheme))
        throw new n2(g(2766, null, this.A(o)), 6)
      const u = {
        metadata: WY(
          l.apiNotebook.metadata,
          (v) => !(c.options?.transientDocumentMetadata ?? {})[v],
        ),
        cells: [],
      }
      for (const v of l.apiNotebook.getCells()) {
        const b = new kO(
          v.kind,
          v.document.getText(),
          v.document.languageId,
          v.mime,
          c.options?.transientOutputs ? [] : [...v.outputs],
          v.metadata,
          v.executionSummary,
        )
        ;(b.metadata = WY(
          v.metadata,
          (k) => !(c.options?.transientCellMetadata ?? {})[k],
        )),
          u.cells.push(b)
      }
      if ((await this.z(o, r), a.isCancellationRequested))
        throw new Error("canceled")
      const d = await c.serializer.serializeNotebook(u, a)
      if (a.isCancellationRequested) throw new Error("canceled")
      this.D(`serialized versionId: ${s} ${o.toString()}`),
        await this.s.value.writeFile(o, d),
        this.D(`Finished write versionId: ${s} ${o.toString()}`)
      const m = this.s.getFileSystemProviderExtUri(o.scheme),
        f = await this.s.value.stat(o),
        p = {
          name: m.basename(o),
          isFile: (f.type & cs.File) !== 0,
          isDirectory: (f.type & cs.Directory) !== 0,
          isSymbolicLink: (f.type & cs.SymbolicLink) !== 0,
          mtime: f.mtime,
          ctime: f.ctime,
          size: f.size,
          readonly:
            !!((f.permissions ?? 0) & ia.Readonly) ||
            !this.s.value.isWritableFileSystem(o.scheme),
          locked: !!((f.permissions ?? 0) & ia.Locked),
          etag: hK({ mtime: f.mtime, size: f.size }),
          children: void 0,
        }
      return this.D(`exit saveNotebook(versionId: ${s}, ${o.toString()})`), p
    }
    async $searchInNotebooks(t, e, s, r, a) {
      const o = this.y.get(t)?.serializer
      if (!o) return { limitHit: !1, results: [] }
      const c = new _V()
      await (async (f, p, v) => {
        await Promise.all(
          f.map(
            async (b) =>
              await Promise.all(
                b.filenamePatterns.map((k) => {
                  const E = {
                    _reason: v._reason,
                    folderQueries: v.folderQueries,
                    includePattern: v.includePattern,
                    excludePattern: v.excludePattern,
                    maxResults: v.maxResults,
                    type: 1,
                    filePattern: k,
                  }
                  return this.t
                    .doInternalFileSearchWithCustomCallback(E, p, (P) => {
                      P.forEach((C) => {
                        c.has(C) ||
                          r.some((D) =>
                            b.isFromSettings && !D.isFromSettings
                              ? !1
                              : D.filenamePatterns.some((V) => XUt(V, C)),
                          ) ||
                          c.add(C)
                      })
                    })
                    .catch((P) => {
                      if (P.code === "ENOENT")
                        return (
                          console.warn(
                            "Could not find notebook search results, ignoring notebook results.",
                          ),
                          { limitHit: !1, messages: [] }
                        )
                      throw P
                    })
                }),
              ),
          ),
        )
      })(s, a, e)
      const u = new oi()
      let d = !1
      const m = Array.from(c).map(async (f) => {
        const p = []
        try {
          if (a.isCancellationRequested) return
          if (
            e.maxResults &&
            [...u.values()].reduce((E, P) => E + P.cellResults.length, 0) >
              e.maxResults
          ) {
            d = !0
            return
          }
          const v = [],
            b = this.g.get(f)
          if (b)
            b.apiNotebook
              .getCells()
              .forEach((P) =>
                v.push({
                  input: P.document.getText(),
                  outputs: P.outputs.flatMap((C) =>
                    C.items.map((R) => R.data.toString()),
                  ),
                }),
              )
          else {
            const E = await this.s.value.readFile(f),
              P = Q.fromString(E.toString()),
              C = await o.deserializeNotebook(P.buffer, a)
            if (a.isCancellationRequested) return
            da.from(C).cells.forEach((D) =>
              v.push({
                input: D.source,
                outputs: D.outputs.flatMap((V) =>
                  V.items.map((tt) => tt.valueBytes.toString()),
                ),
              }),
            )
          }
          if (a.isCancellationRequested) return
          v.forEach((E, P) => {
            const C = e.contentPattern.pattern,
              R = new HUt(E.input, void 0, E.outputs),
              D = R.findInInputs(C),
              V = R.findInOutputs(C),
              tt = V.flatMap((Z) => lct(Z.matches, Z.textBuffer)).map(
                (Z, M) => ((Z.webviewIndex = M), Z),
              )
            if (D.length > 0 || V.length > 0) {
              const Z = {
                index: P,
                contentResults: lct(D, R.inputTextBuffer),
                webviewResults: tt,
              }
              p.push(Z)
            }
          })
          const k = { resource: f, cellResults: p }
          u.set(f, k)
          return
        } catch {
          return
        }
      })
      return await Promise.all(m), { limitHit: d, results: [...u.values()] }
    }
    async z(t, e) {
      const s = await this.s.value.stat(t)
      if (
        typeof e?.mtime == "number" &&
        typeof e.etag == "string" &&
        e.etag !== o0t &&
        typeof s.mtime == "number" &&
        typeof s.size == "number" &&
        e.mtime < s.mtime &&
        e.etag !== hK({ mtime: e.mtime, size: s.size })
      )
        throw new n2(g(2767, null), 3, e)
    }
    A(t) {
      return t.scheme === G.file ? t.fsPath : t.toString()
    }
    B(t, e, s) {
      if (this.h.has(e)) throw new Error(`editor with id ALREADY EXSIST: ${e}`)
      const r = new lj(
        e,
        this.d,
        t,
        s.visibleRanges.map(Or.to),
        s.selections.map(Or.to),
        typeof s.viewColumn == "number" ? ii.to(s.viewColumn) : void 0,
        s.viewType,
      )
      this.h.set(e, r)
    }
    $acceptDocumentAndEditorsDelta(t) {
      if (t.value.removedDocuments)
        for (const s of t.value.removedDocuments) {
          const r = S.revive(s),
            a = this.g.get(r)
          a &&
            (a.dispose(),
            this.g.delete(r),
            this.q.$acceptDocumentsAndEditorsDelta({
              removedDocuments: a.apiNotebook
                .getCells()
                .map((o) => o.document.uri),
            }),
            this.n.fire(a.apiNotebook))
          for (const o of this.h.values())
            o.notebookData.uri.toString() === r.toString() &&
              this.h.delete(o.id)
        }
      if (t.value.addedDocuments) {
        const s = []
        for (const r of t.value.addedDocuments) {
          const a = S.revive(r.uri)
          if (this.g.has(a)) throw new Error(`adding EXISTING notebook ${a} `)
          const o = new JUt(this.c, this.q, this.r, a, r)
          s.push(...r.cells.map((c) => cj.asModelAddData(c))),
            this.g.get(a)?.dispose(),
            this.g.set(a, o),
            this.q.$acceptDocumentsAndEditorsDelta({ addedDocuments: s }),
            this.m.fire(o.apiNotebook)
        }
      }
      if (t.value.addedEditors)
        for (const s of t.value.addedEditors) {
          if (this.h.has(s.id)) return
          const r = S.revive(s.documentUri),
            a = this.g.get(r)
          a && this.B(a, s.id, s)
        }
      const e = []
      if (t.value.removedEditors)
        for (const s of t.value.removedEditors) {
          const r = this.h.get(s)
          r &&
            (this.h.delete(s),
            this.k?.id === r.id && (this.k = void 0),
            e.push(r))
        }
      if (t.value.visibleEditors) {
        this.l = t.value.visibleEditors
          .map((r) => this.h.get(r))
          .filter((r) => !!r)
        const s = new Set()
        this.l.forEach((r) => s.add(r.id))
        for (const r of this.h.values()) {
          const a = s.has(r.id)
          r._acceptVisibility(a)
        }
        ;(this.l = [...this.h.values()].map((r) => r).filter((r) => r.visible)),
          this.o.fire(this.visibleNotebookEditors)
      }
      t.value.newActiveEditor === null
        ? (this.k = void 0)
        : t.value.newActiveEditor &&
          (this.h.get(t.value.newActiveEditor) ||
            console.error(
              `FAILED to find active notebook editor ${t.value.newActiveEditor}`,
            ),
          (this.k = this.h.get(t.value.newActiveEditor))),
        t.value.newActiveEditor !== void 0 && this.j.fire(this.k?.apiEditor)
    }
    static C(t) {
      const e = H.String.with("notebookType", "A notebook type"),
        s = new Tt(
          "vscode.executeDataToNotebook",
          "_executeDataToNotebook",
          "Invoke notebook serializer",
          [
            e,
            new H(
              "data",
              "Bytes to convert to data",
              (a) => a instanceof Uint8Array,
              (a) => Q.wrap(a),
            ),
          ],
          new yt("Notebook Data", (a) => da.to(a.value)),
        ),
        r = new Tt(
          "vscode.executeNotebookToData",
          "_executeNotebookToData",
          "Invoke notebook serializer",
          [
            e,
            new H(
              "NotebookData",
              "Notebook data to convert to bytes",
              (a) => !0,
              (a) => new gs(da.from(a)),
            ),
          ],
          new yt("Bytes", (a) => a.buffer),
        )
      t.registerApiCommand(s), t.registerApiCommand(r)
    }
    D(t) {
      this.u.trace(`[Extension Host Notebook] ${t}`)
    }
  },
  ZUt = class {
    constructor(i, t, e, s = { timeout: 1500, errors: 3 }) {
      ;(this.b = i),
        (this.c = t),
        (this.d = e),
        (this.f = s),
        (this.a = new Du())
    }
    dispose() {}
    getOnWillSaveNotebookDocumentEvent(i) {
      return (t, e, s) => {
        const r = function (o) {
          t.call(e, o)
        }
        return (r.extension = i), this.a.event(r, void 0, s)
      }
    }
    async $participateInSave(i, t, e) {
      const s = S.revive(i),
        r = this.c.getNotebookDocument(s)
      if (!r) throw new Error("Unable to resolve notebook document")
      const a = []
      if (
        (await this.a.fireAsync(
          { notebook: r.apiNotebook, reason: e8.to(t) },
          e,
          async (c, l) => {
            const u = Date.now(),
              d = await await Promise.resolve(c)
            Date.now() - u > this.f.timeout &&
              this.b.warn(
                "onWillSaveNotebookDocument-listener from extension",
                l.extension.identifier,
              ),
              !e.isCancellationRequested &&
                d &&
                (d instanceof mo
                  ? a.push(d)
                  : this.b.warn(
                      "onWillSaveNotebookDocument-listener from extension",
                      l.extension.identifier,
                      "ignored due to invalid data",
                    ))
          },
        ),
        e.isCancellationRequested)
      )
        return !1
      if (a.length === 0) return !0
      const o = { edits: [] }
      for (const c of a) {
        const { edits: l } = Oi.from(c)
        o.edits = o.edits.concat(l)
      }
      return this.d.$tryApplyWorkspaceEdit(new gs(o))
    }
  },
  tMt = class {
    constructor(i) {
      ;(this.c = i),
        (this.a = new J()),
        (this.onDidSaveNotebookDocument = this.a.event),
        (this.b = new J()),
        (this.onDidChangeNotebookDocument = this.b.event)
    }
    $acceptModelChanged(i, t, e, s) {
      const a = this.c
        .getNotebookDocument(S.revive(i))
        .acceptModelChanged(t.value, e, s)
      this.b.fire(a)
    }
    $acceptDirtyStateChanged(i, t) {
      this.c.getNotebookDocument(S.revive(i)).acceptDirty(t)
    }
    $acceptModelSaved(i) {
      const t = this.c.getNotebookDocument(S.revive(i))
      this.a.fire(t.apiNotebook)
    }
  },
  wj = class {
    constructor(t, e) {
      ;(this.c = t),
        (this.d = e),
        (this.a = new J()),
        (this.b = new J()),
        (this.onDidChangeNotebookEditorSelection = this.a.event),
        (this.onDidChangeNotebookEditorVisibleRanges = this.b.event)
    }
    $acceptEditorPropertiesChanged(t, e) {
      this.c.debug("ExtHostNotebook#$acceptEditorPropertiesChanged", t, e)
      const s = this.d.getEditorById(t)
      e.visibleRanges &&
        s._acceptVisibleRanges(e.visibleRanges.ranges.map(Or.to)),
        e.selections && s._acceptSelections(e.selections.selections.map(Or.to)),
        e.visibleRanges &&
          this.b.fire({
            notebookEditor: s.apiEditor,
            visibleRanges: s.apiEditor.visibleRanges,
          }),
        e.selections &&
          this.a.fire(
            Object.freeze({
              notebookEditor: s.apiEditor,
              selections: s.apiEditor.selections,
            }),
          )
    }
    $acceptEditorViewColumns(t) {
      for (const e in t) this.d.getEditorById(e)._acceptViewColumn(ii.to(t[e]))
    }
  }
wj = __decorate([__param(0, Rt)], wj)
var zl
;(function (i) {
  ;(i[(i.Output = 1)] = "Output"),
    (i[(i.OutputItems = 2)] = "OutputItems"),
    (i[(i.ExecutionState = 3)] = "ExecutionState")
})(zl || (zl = {}))
var YKt = X("INotebookExecutionService"),
  eMt = 100,
  fct
;(function (i) {
  ;(i[(i.Disconnected = 1)] = "Disconnected"),
    (i[(i.Connected = 2)] = "Connected"),
    (i[(i.Initializing = 3)] = "Initializing")
})(fct || (fct = {}))
var QKt = X("INotebookKernelService"),
  XKt = X("INotebookKernelHistoryService"),
  yj = class {
    constructor(t, e, s, r, a) {
      ;(this.m = e),
        (this.n = s),
        (this.o = r),
        (this.q = a),
        (this.b = new oi()),
        (this.c = new oi()),
        (this.f = new Map()),
        (this.g = 0),
        (this.h = new Map()),
        (this.i = 0),
        (this.j = new Map()),
        (this.k = 0),
        (this.l = new J()),
        (this.onDidChangeNotebookCellExecutionState = this.l.event),
        (this.r = 0),
        (this.s = {}),
        (this.a = t.getProxy(K.MainThreadNotebookKernels))
      const o = new Tt(
          "notebook.selectKernel",
          "_notebook.selectKernel",
          "Trigger kernel picker for specified notebook editor widget",
          [
            new H(
              "options",
              "Select kernel options",
              (l) => !0,
              (l) => {
                if (l && "notebookEditor" in l && "id" in l) {
                  const u = this.n.getIdByEditor(l.notebookEditor)
                  return {
                    id: l.id,
                    extension: l.extension,
                    notebookEditorId: u,
                  }
                } else if (l && "notebookEditor" in l) {
                  const u = this.n.getIdByEditor(l.notebookEditor)
                  if (u === void 0)
                    throw new Error(
                      `Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${l.notebookEditor.notebook.uri.toString()}`,
                    )
                  return { notebookEditorId: u }
                }
                return l
              },
            ),
          ],
          yt.Void,
        ),
        c = new Tt(
          "vscode.executeNotebookVariableProvider",
          "_executeNotebookVariableProvider",
          "Execute notebook variable provider",
          [H.Uri],
          new yt("A promise that resolves to an array of variables", (l, u) =>
            l.map((d) => ({
              variable: {
                name: d.name,
                value: d.value,
                expression: d.expression,
                type: d.type,
                language: d.language,
              },
              hasNamedChildren: d.hasNamedChildren,
              indexedChildrenCount: d.indexedChildrenCount,
            })),
          ),
        )
      this.o.registerApiCommand(o), this.o.registerApiCommand(c)
    }
    createNotebookController(t, e, s, r, a, o) {
      for (const D of this.j.values())
        if (D.controller.id === e && ae.equals(t.identifier, D.extensionId))
          throw new Error(`notebook controller with id '${e}' ALREADY exist`)
      const c = this.k++,
        l = this
      this.q.trace(
        `NotebookController[${c}], CREATED by ${t.identifier.value}, ${e}`,
      )
      const u = () =>
        console.warn(
          `NO execute handler from notebook controller '${p.id}' of extension: '${t.identifier}'`,
        )
      let d = !1
      const m = new J(),
        f = new J(),
        p = {
          id: E3(t.identifier, e),
          notebookType: s,
          extensionId: t.identifier,
          extensionLocation: t.extensionLocation,
          label: r || t.identifier.value,
          preloads: o ? o.map(a8.from) : [],
        }
      let v = a ?? u,
        b,
        k
      this.a.$addKernel(c, p).catch((D) => {
        console.log(D), (d = !0)
      })
      let E = 0
      const P = () => {
          if (d) return
          const D = ++E
          Promise.resolve().then(() => {
            D === E && this.a.$updateKernel(c, p)
          })
        },
        C = new oi(),
        R = {
          get id() {
            return e
          },
          get notebookType() {
            return p.notebookType
          },
          onDidChangeSelectedNotebooks: m.event,
          get label() {
            return p.label
          },
          set label(D) {
            ;(p.label = D ?? t.displayName ?? t.name), P()
          },
          get detail() {
            return p.detail ?? ""
          },
          set detail(D) {
            ;(p.detail = D), P()
          },
          get description() {
            return p.description ?? ""
          },
          set description(D) {
            ;(p.description = D), P()
          },
          get supportedLanguages() {
            return p.supportedLanguages
          },
          set supportedLanguages(D) {
            ;(p.supportedLanguages = D), P()
          },
          get supportsExecutionOrder() {
            return p.supportsExecutionOrder ?? !1
          },
          set supportsExecutionOrder(D) {
            ;(p.supportsExecutionOrder = D), P()
          },
          get rendererScripts() {
            return p.preloads ? p.preloads.map(a8.to) : []
          },
          get executeHandler() {
            return v
          },
          set executeHandler(D) {
            v = D ?? u
          },
          get interruptHandler() {
            return b
          },
          set interruptHandler(D) {
            ;(b = D), (p.supportsInterrupt = !!D), P()
          },
          set variableProvider(D) {
            _(t, "notebookVariableProvider"),
              (k = D),
              (p.hasVariableProvider = !!D),
              D?.onDidChangeVariables((V) => l.a.$variablesUpdated(V.uri)),
              P()
          },
          get variableProvider() {
            return k
          },
          createNotebookCellExecution(D) {
            if (d) throw new Error("notebook controller is DISPOSED")
            if (!C.has(D.notebook.uri))
              throw (
                (l.q.trace(
                  `NotebookController[${c}] NOT associated to notebook, associated to THESE notebooks:`,
                  Array.from(C.keys()).map((V) => V.toString()),
                ),
                new Error(
                  `notebook controller is NOT associated to notebook: ${D.notebook.uri.toString()}`,
                ))
              )
            return l._createNotebookCellExecution(D, E3(t.identifier, this.id))
          },
          createNotebookExecution(D) {
            if ((_(t, "notebookExecution"), d))
              throw new Error("notebook controller is DISPOSED")
            if (!C.has(D.uri))
              throw (
                (l.q.trace(
                  `NotebookController[${c}] NOT associated to notebook, associated to THESE notebooks:`,
                  Array.from(C.keys()).map((V) => V.toString()),
                ),
                new Error(
                  `notebook controller is NOT associated to notebook: ${D.uri.toString()}`,
                ))
              )
            return l._createNotebookExecution(D, E3(t.identifier, this.id))
          },
          dispose: () => {
            d ||
              (this.q.trace(`NotebookController[${c}], DISPOSED`),
              (d = !0),
              this.j.delete(c),
              m.dispose(),
              f.dispose(),
              this.a.$removeKernel(c))
          },
          updateNotebookAffinity(D, V) {
            V === PO.Hidden && _(t, "notebookControllerAffinityHidden"),
              l.a.$updateNotebookPriority(c, D.uri, V)
          },
          onDidReceiveMessage: f.event,
          postMessage(D, V) {
            return (
              _(t, "notebookMessaging"),
              l.a.$postMessage(c, V && l.n.getIdByEditor(V), D)
            )
          },
          asWebviewUri(D) {
            return _(t, "notebookMessaging"), Tm(D, l.m.remote)
          },
        }
      return (
        this.j.set(c, {
          extensionId: t.identifier,
          controller: R,
          onDidReceiveMessage: f,
          onDidChangeSelection: m,
          associatedNotebooks: C,
        }),
        R
      )
    }
    getIdByController(t) {
      for (const [e, s] of this.j)
        if (s.controller === t) return E3(s.extensionId, t.id)
      return null
    }
    createNotebookControllerDetectionTask(t, e) {
      const s = this.g++,
        r = this
      this.q.trace(
        `NotebookControllerDetectionTask[${s}], CREATED by ${t.identifier.value}`,
      ),
        this.a.$addKernelDetectionTask(s, e)
      const a = {
        dispose: () => {
          this.f.delete(s), r.a.$removeKernelDetectionTask(s)
        },
      }
      return this.f.set(s, a), a
    }
    registerKernelSourceActionProvider(t, e, s) {
      const r = this.i++,
        a =
          typeof s.onDidChangeNotebookKernelSourceActions == "function"
            ? r
            : void 0,
        o = this
      this.h.set(r, s),
        this.q.trace(
          `NotebookKernelSourceActionProvider[${r}], CREATED by ${t.identifier.value}`,
        ),
        this.a.$addKernelSourceActionProvider(r, r, e)
      let c
      return (
        a !== void 0 &&
          (c = s.onDidChangeNotebookKernelSourceActions((l) =>
            this.a.$emitNotebookKernelSourceActionsChangeEvent(a),
          )),
        {
          dispose: () => {
            this.h.delete(r),
              o.a.$removeKernelSourceActionProvider(r, r),
              c?.dispose()
          },
        }
      )
    }
    async $provideKernelSourceActions(t, e) {
      const s = this.h.get(t)
      if (s) {
        const r = new gt()
        return ((await s.provideNotebookKernelSourceActions(e)) ?? []).map(
          (o) => XU.from(o, this.o.converter, r),
        )
      }
      return []
    }
    $acceptNotebookAssociation(t, e, s) {
      const r = this.j.get(t)
      if (r) {
        const a = this.n.getNotebookDocument(S.revive(e))
        s
          ? r.associatedNotebooks.set(a.uri, !0)
          : r.associatedNotebooks.delete(a.uri),
          this.q.trace(
            `NotebookController[${t}] ASSOCIATE notebook`,
            a.uri.toString(),
            s,
          ),
          r.onDidChangeSelection.fire({ selected: s, notebook: a.apiNotebook })
      }
    }
    async $executeCells(t, e, s) {
      const r = this.j.get(t)
      if (!r) return
      const a = this.n.getNotebookDocument(S.revive(e)),
        o = []
      for (const c of s) {
        const l = a.getCell(c)
        l && o.push(l.apiCell)
      }
      try {
        this.q.trace(
          `NotebookController[${t}] EXECUTE cells`,
          a.uri.toString(),
          o.length,
        ),
          await r.controller.executeHandler.call(
            r.controller,
            o,
            a.apiNotebook,
            r.controller,
          )
      } catch (c) {
        this.q.error(`NotebookController[${t}] execute cells FAILED`, c),
          console.error(c)
      }
    }
    async $cancelCells(t, e, s) {
      const r = this.j.get(t)
      if (!r) return
      const a = this.n.getNotebookDocument(S.revive(e))
      if (r.controller.interruptHandler)
        await r.controller.interruptHandler.call(r.controller, a.apiNotebook)
      else
        for (const o of s) {
          const c = a.getCell(o)
          c && this.b.get(c.uri)?.cancel()
        }
      if (r.controller.interruptHandler) {
        const o = this.c.get(a.uri)
        this.c.delete(a.uri),
          s.length &&
            Array.isArray(o) &&
            o.length &&
            o.forEach((c) => c.dispose())
      }
    }
    async $provideVariables(t, e, s, r, a, o, c) {
      const l = this.j.get(t)
      if (!l) return
      const u = this.n.getNotebookDocument(S.revive(s)),
        d = l.controller.variableProvider
      if (!d) return
      let m
      if (r !== void 0) {
        if (((m = this.s[r]), !m)) return
      } else this.s = {}
      const f = a === "named" ? Zh.Named : Zh.Indexed,
        p = d.provideVariables(u.apiNotebook, m, f, o, c)
      let v = 0
      for await (const b of p) {
        if (c.isCancellationRequested) return
        const k = {
          id: this.r++,
          name: b.variable.name,
          value: b.variable.value,
          type: b.variable.type,
          interfaces: b.variable.interfaces,
          language: b.variable.language,
          expression: b.variable.expression,
          hasNamedChildren: b.hasNamedChildren,
          indexedChildrenCount: b.indexedChildrenCount,
          extensionId: l.extensionId.value,
        }
        if (
          ((this.s[k.id] = b.variable),
          this.a.$receiveVariable(e, k),
          v++ >= eMt)
        )
          return
      }
    }
    $acceptKernelMessageFromRenderer(t, e, s) {
      const r = this.j.get(t)
      if (!r) return
      const a = this.n.getEditorById(e)
      r.onDidReceiveMessage.fire(
        Object.freeze({ editor: a.apiEditor, message: s }),
      )
    }
    $cellExecutionChanged(t, e, s) {
      const a = this.n.getNotebookDocument(S.revive(t)).getCell(e)
      if (a) {
        const o = s ? YU.to(s) : cl.Idle
        o !== void 0 && this.l.fire({ cell: a.apiCell, state: o })
      }
    }
    _createNotebookCellExecution(t, e) {
      if (t.index < 0)
        throw new Error(
          "CANNOT execute cell that has been REMOVED from notebook",
        )
      const r = this.n.getNotebookDocument(t.notebook.uri).getCellFromApiCell(t)
      if (!r) throw new Error("invalid cell")
      if (this.b.has(r.uri)) throw new Error(`duplicate execution for ${r.uri}`)
      const a = new iMt(e, r, this.a)
      this.b.set(r.uri, a)
      const o = a.onDidChangeState(() => {
        a.state === yr.Resolved &&
          (a.dispose(), o.dispose(), this.b.delete(r.uri))
      })
      return a.asApiObject()
    }
    _createNotebookExecution(t, e) {
      const s = this.n.getNotebookDocument(t.uri),
        r = t.getCells().find((c) => {
          const l = s.getCellFromApiCell(c)
          return l && this.b.has(l.uri)
        })
      if (r) throw new Error(`duplicate cell execution for ${r.document.uri}`)
      if (this.c.has(s.uri))
        throw new Error(`duplicate notebook execution for ${s.uri}`)
      const a = new rMt(e, s, this.a),
        o = a.onDidChangeState(() => {
          a.state === Rn.Resolved &&
            (a.dispose(), o.dispose(), this.c.delete(s.uri))
        })
      return this.c.set(s.uri, [a, o]), a.asApiObject()
    }
  }
yj = __decorate([__param(4, Rt)], yj)
var yr
;(function (i) {
  ;(i[(i.Init = 0)] = "Init"),
    (i[(i.Started = 1)] = "Started"),
    (i[(i.Resolved = 2)] = "Resolved")
})(yr || (yr = {}))
var iMt = class Jut extends at {
  static {
    this.a = 0
  }
  get state() {
    return this.f
  }
  constructor(t, e, s) {
    super(),
      (this.m = e),
      (this.n = s),
      (this.b = Jut.a++),
      (this.c = new J()),
      (this.onDidChangeState = this.c.event),
      (this.f = yr.Init),
      (this.g = this.D(new fe())),
      (this.h = new nMt(10, (r) => this.r(r))),
      (this.j = e.internalMetadata.executionOrder),
      this.n.$createExecution(this.b, t, this.m.notebook.uri, this.m.handle)
  }
  cancel() {
    this.g.cancel()
  }
  async q(t) {
    await this.h.addItem(t)
  }
  async r(t) {
    const e = Array.isArray(t) ? t : [t]
    return this.n.$updateExecution(this.b, new gs(e))
  }
  s() {
    if (this.f === yr.Init)
      throw new Error("Must call start before modifying cell output")
    if (this.f === yr.Resolved)
      throw new Error("Cannot modify cell output after calling resolve")
  }
  t(t) {
    let e = this.m
    if ((t && (e = this.m.notebook.getCellFromApiCell(t)), !e))
      throw new Error("INVALID cell")
    return e.handle
  }
  w(t) {
    return t.map((e) => {
      const s = SO.ensureUniqueMimeTypes(e.items, !0)
      return s === e.items
        ? ma.from(e)
        : ma.from({ items: s, id: e.id, metadata: e.metadata })
    })
  }
  async y(t, e, s) {
    const r = this.t(e),
      a = this.w(Ir(t))
    return this.q({ editType: zl.Output, cellHandle: r, append: s, outputs: a })
  }
  async z(t, e, s) {
    return (
      (t = SO.ensureUniqueMimeTypes(Ir(t), !0)),
      this.q({
        editType: zl.OutputItems,
        items: t.map(Tl.from),
        outputId: e.id,
        append: s,
      })
    )
  }
  asApiObject() {
    const t = this
    return Object.freeze({
      get token() {
        return t.g.token
      },
      get cell() {
        return t.m.apiCell
      },
      get executionOrder() {
        return t.j
      },
      set executionOrder(s) {
        ;(t.j = s), t.r([{ editType: zl.ExecutionState, executionOrder: t.j }])
      },
      start(s) {
        if (t.f === yr.Resolved || t.f === yr.Started)
          throw new Error("Cannot call start again")
        ;(t.f = yr.Started),
          t.c.fire(),
          t.r({ editType: zl.ExecutionState, runStartTime: s })
      },
      end(s, r, a) {
        if (t.f === yr.Resolved) throw new Error("Cannot call resolve twice")
        ;(t.f = yr.Resolved), t.c.fire(), t.h.flush()
        const o = sMt(a)
        t.n.$completeExecution(
          t.b,
          new gs({ runEndTime: r, lastRunSuccess: s, error: o }),
        )
      },
      clearOutput(s) {
        return t.s(), t.y([], s, !1)
      },
      appendOutput(s, r) {
        return t.s(), t.y(s, r, !0)
      },
      replaceOutput(s, r) {
        return t.s(), t.y(s, r, !1)
      },
      appendOutputItems(s, r) {
        return t.s(), t.z(s, r, !0)
      },
      replaceOutputItems(s, r) {
        return t.s(), t.z(s, r, !1)
      },
    })
  }
}
function sMt(i) {
  const t = (r) =>
      r
        ? {
            startLineNumber: r.start.line,
            startColumn: r.start.character,
            endLineNumber: r.end.line,
            endColumn: r.end.character,
          }
        : void 0,
    e = (r) => ({ uri: r.uri, position: r.position, label: r.label })
  return i
    ? {
        name: i.name,
        message: i.message,
        stack: i.stack instanceof Array ? i.stack.map((r) => e(r)) : i.stack,
        location: t(i.location),
        uri: i.uri,
      }
    : void 0
}
var Rn
;(function (i) {
  ;(i[(i.Init = 0)] = "Init"),
    (i[(i.Started = 1)] = "Started"),
    (i[(i.Resolved = 2)] = "Resolved")
})(Rn || (Rn = {}))
var rMt = class Lut extends at {
    static {
      this.a = 0
    }
    get state() {
      return this.f
    }
    constructor(t, e, s) {
      super(),
        (this.h = e),
        (this.j = s),
        (this.b = Lut.a++),
        (this.c = new J()),
        (this.onDidChangeState = this.c.event),
        (this.f = Rn.Init),
        (this.g = this.D(new fe())),
        this.j.$createNotebookExecution(this.b, t, this.h.uri)
    }
    cancel() {
      this.g.cancel()
    }
    asApiObject() {
      return Object.freeze({
        start: () => {
          if (this.f === Rn.Resolved || this.f === Rn.Started)
            throw new Error("Cannot call start again")
          ;(this.f = Rn.Started),
            this.c.fire(),
            this.j.$beginNotebookExecution(this.b)
        },
        end: () => {
          if (this.f === Rn.Resolved)
            throw new Error("Cannot call resolve twice")
          ;(this.f = Rn.Resolved),
            this.c.fire(),
            this.j.$completeNotebookExecution(this.b)
        },
      })
    }
  },
  nMt = class {
    constructor(i, t) {
      ;(this.f = i), (this.g = t), (this.a = []), (this.b = Date.now())
    }
    addItem(i) {
      return (
        this.a.push(i),
        this.c ||
          ((this.c = new Yn()),
          (this.b = Date.now()),
          Fi(this.f).then(() => this.flush())),
        Date.now() - this.b > this.f ? this.flush() : this.c.p
      )
    }
    flush() {
      if (this.a.length === 0 || !this.c) return Promise.resolve()
      const i = this.c
      this.c = void 0
      const t = this.a
      return (this.a = []), this.g(t).finally(() => i.complete())
    }
  }
function E3(i, t) {
  return `${i.value}/${t}`
}
var aMt = class {
    constructor(i, t) {
      ;(this.c = t),
        (this.a = new Map()),
        (this.b = i.getProxy(K.MainThreadNotebookRenderers))
    }
    $postRendererMessage(i, t, e) {
      const s = this.c.getEditorById(i)
      this.a.get(t)?.fire({ editor: s.apiEditor, message: e })
    }
    createRendererMessaging(i, t) {
      if (!i.contributes?.notebookRenderer?.some((s) => s.id === t))
        throw new Error(
          `Extensions may only call createRendererMessaging() for renderers they contribute (got ${t})`,
        )
      return {
        onDidReceiveMessage: (s, r, a) => this.d(t).event(s, r, a),
        postMessage: (s, r) => {
          lj.apiEditorsToExtHost.has(s) && ([s, r] = [r, s])
          const a = r && lj.apiEditorsToExtHost.get(r)
          return this.b.$postMessage(a?.id, t, s)
        },
      }
    }
    d(i) {
      let t = this.a.get(i)
      return (
        t ||
        ((t = new J({
          onDidRemoveLastListener: () => {
            t?.dispose(), this.a.delete(i)
          },
        })),
        this.a.set(i, t),
        t)
      )
    }
  },
  oMt = class {
    constructor(i) {
      ;(this.b = new Map()),
        (this.a = i.getProxy(K.MainThreadProfileContentHandlers))
    }
    registerProfileContentHandler(i, t, e) {
      if ((_(i, "profileContentHandlers"), this.b.has(t)))
        throw new Error(`Handler with id '${t}' already registered`)
      return (
        this.b.set(t, e),
        this.a.$registerProfileContentHandler(
          t,
          e.name,
          e.description,
          i.identifier.value,
        ),
        et(() => {
          this.b.delete(t), this.a.$unregisterProfileContentHandler(t)
        })
      )
    }
    async $saveProfile(i, t, e, s) {
      const r = this.b.get(i)
      if (!r) throw new Error(`Unknown handler with id: ${i}`)
      return r.saveProfile(t, e, s)
    }
    async $readProfile(i, t, e) {
      const s = this.b.get(i)
      if (!s) throw new Error(`Unknown handler with id: ${i}`)
      return s.readProfile(_t(t) ? t : S.revive(t), e)
    }
  },
  cMt = class {
    constructor(i) {
      ;(this.b = 0), (this.c = new Map()), (this.a = i)
    }
    async withProgress(i, t, e) {
      const s = this.b++,
        { title: r, location: a, cancellable: o } = t,
        c = { label: i.displayName || i.name, id: i.identifier.value }
      return (
        this.a
          .$startProgress(
            s,
            { location: GU.from(a), title: r, source: c, cancellable: o },
            i.isUnderDevelopment ? void 0 : i.identifier.value,
          )
          .catch(l7),
        this.d(s, e, !!o)
      )
    }
    d(i, t, e) {
      let s
      e && ((s = new fe()), this.c.set(i, s))
      const r = (o) => {
        this.a.$progressEnd(o), this.c.delete(o), s?.dispose()
      }
      let a
      try {
        a = t(new pct(this.a, i), e && s ? s.token : ce.None)
      } catch (o) {
        throw (r(i), o)
      }
      return (
        a.then(
          (o) => r(i),
          (o) => r(i),
        ),
        a
      )
    }
    $acceptProgressCanceled(i) {
      const t = this.c.get(i)
      t && (t.cancel(), this.c.delete(i))
    }
  }
function lMt(i, t) {
  return (
    (i.message = t.message),
    typeof t.increment == "number" &&
      (typeof i.increment == "number"
        ? (i.increment += t.increment)
        : (i.increment = t.increment)),
    i
  )
}
var pct = class extends dH {
  constructor(i, t) {
    super((e) => this.throttledReport(e)), (this.c = i), (this.d = t)
  }
  throttledReport(i) {
    this.c.$progressReport(this.d, i)
  }
}
__decorate(
  [
    Dvt(
      100,
      (i, t) => lMt(i, t),
      () => Object.create(null),
    ),
  ],
  pct.prototype,
  "throttledReport",
  null,
)
var uMt = class Rut {
  static {
    this.a = 0
  }
  constructor(t, e) {
    ;(this.d = e),
      (this.c = new Map()),
      (this.b = t.getProxy(K.MainThreadQuickDiff))
  }
  $provideOriginalResource(t, e, s) {
    const r = S.revive(e),
      a = this.c.get(t)
    return a
      ? Ci(() => a.provideOriginalResource(r, s)).then((o) => o || null)
      : Promise.resolve(null)
  }
  registerQuickDiffProvider(t, e, s, r) {
    const a = Rut.a++
    return (
      this.c.set(a, e),
      this.b.$registerQuickDiffProvider(
        a,
        dl.from(t, this.d),
        s,
        r,
        e.visible ?? !0,
      ),
      {
        dispose: () => {
          this.b.$unregisterQuickDiffProvider(a), this.c.delete(a)
        },
      }
    )
  }
}
function hMt(i, t, e) {
  const s = i.getProxy(K.MainThreadQuickOpen)
  class r {
    constructor(p, v) {
      ;(this.e = new Map()), (this.f = 0), (this.a = p), (this.b = v)
    }
    showQuickPick(p, v, b, k = ce.None) {
      this.c = void 0
      const E = Promise.resolve(v),
        P = ++this.f,
        C = s.$show(
          P,
          {
            title: b?.title,
            placeHolder: b?.placeHolder,
            matchOnDescription: b?.matchOnDescription,
            matchOnDetail: b?.matchOnDetail,
            ignoreFocusLost: b?.ignoreFocusOut,
            canPickMany: b?.canPickMany,
          },
          k,
        ),
        R = {},
        D = C.then(() => R)
      return Promise.race([D, E])
        .then((V) => {
          if (V === R) return
          const tt = hi(p, "quickPickItemTooltip")
          return E.then((Z) => {
            const M = []
            for (let rt = 0; rt < Z.length; rt++) {
              const Jt = Z[rt]
              if (typeof Jt == "string") M.push({ label: Jt, handle: rt })
              else if (Jt.kind === Kh.Separator)
                M.push({ type: "separator", label: Jt.label })
              else {
                Jt.tooltip &&
                  !tt &&
                  console.warn(
                    `Extension '${p.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${p.identifier.value}`,
                  )
                const ct = Jt.iconPath ? u(Jt.iconPath) : void 0
                M.push({
                  label: Jt.label,
                  iconPath: ct?.iconPath,
                  iconClass: ct?.iconClass,
                  description: Jt.description,
                  detail: Jt.detail,
                  picked: Jt.picked,
                  alwaysShow: Jt.alwaysShow,
                  tooltip: tt ? Dt.fromStrict(Jt.tooltip) : void 0,
                  handle: rt,
                })
              }
            }
            return (
              b &&
                typeof b.onDidSelectItem == "function" &&
                (this.c = (rt) => {
                  b.onDidSelectItem(Z[rt])
                }),
              s.$setItems(P, M),
              C.then((rt) => {
                if (typeof rt == "number") return Z[rt]
                if (Array.isArray(rt)) return rt.map((Jt) => Z[Jt])
              })
            )
          })
        })
        .then(void 0, (V) => {
          if (!Ms(V)) return s.$setError(P, V), Promise.reject(V)
        })
    }
    $onItemSelected(p) {
      this.c?.(p)
    }
    showInput(p, v = ce.None) {
      return (
        (this.d = p?.validateInput),
        s.$input(p, typeof this.d == "function", v).then(void 0, (b) => {
          if (!Ms(b)) return Promise.reject(b)
        })
      )
    }
    async $validateInput(p) {
      if (!this.d) return
      const v = await this.d(p)
      if (!v || typeof v == "string") return v
      let b
      switch (v.severity) {
        case ol.Info:
          b = Le.Info
          break
        case ol.Warning:
          b = Le.Warning
          break
        case ol.Error:
          b = Le.Error
          break
        default:
          b = v.message ? Le.Error : Le.Ignore
          break
      }
      return { content: v.message, severity: b }
    }
    async showWorkspaceFolderPick(p, v = ce.None) {
      const b = await this.b.executeCommand("_workbench.pickWorkspaceFolder", [
        p,
      ])
      if (!b) return
      const k = await this.a.getWorkspaceFolders2()
      if (k) return k.find((E) => E.uri.toString() === b.uri.toString())
    }
    createQuickPick(p) {
      const v = new d(p, () => this.e.delete(v._id))
      return this.e.set(v._id, v), v
    }
    createInputBox(p) {
      const v = new m(p, () => this.e.delete(v._id))
      return this.e.set(v._id, v), v
    }
    $onDidChangeValue(p, v) {
      this.e.get(p)?._fireDidChangeValue(v)
    }
    $onDidAccept(p) {
      this.e.get(p)?._fireDidAccept()
    }
    $onDidChangeActive(p, v) {
      const b = this.e.get(p)
      b instanceof d && b._fireDidChangeActive(v)
    }
    $onDidChangeSelection(p, v) {
      const b = this.e.get(p)
      b instanceof d && b._fireDidChangeSelection(v)
    }
    $onDidTriggerButton(p, v) {
      this.e.get(p)?._fireDidTriggerButton(v)
    }
    $onDidTriggerItemButton(p, v, b) {
      const k = this.e.get(p)
      k instanceof d && k._fireDidTriggerItemButton(v, b)
    }
    $onDidHide(p) {
      this.e.get(p)?._fireDidHide()
    }
  }
  class a {
    static {
      this.a = 1
    }
    constructor(p, v) {
      ;(this.y = p),
        (this.z = v),
        (this._id = d.a++),
        (this.e = !1),
        (this.f = !1),
        (this.g = !0),
        (this.j = !1),
        (this.k = !0),
        (this.l = ""),
        (this.m = void 0),
        (this.o = []),
        (this.p = new Map()),
        (this.q = new J()),
        (this.r = new J()),
        (this.s = new J()),
        (this.t = new J()),
        (this.v = { id: this._id }),
        (this.w = !1),
        (this.x = [this.s, this.t, this.q, this.r]),
        (this.onDidChangeValue = this.r.event),
        (this.onDidAccept = this.q.event),
        (this.onDidTriggerButton = this.s.event),
        (this.onDidHide = this.t.event)
    }
    get title() {
      return this.b
    }
    set title(p) {
      ;(this.b = p), this.A({ title: p })
    }
    get step() {
      return this.c
    }
    set step(p) {
      ;(this.c = p), this.A({ step: p })
    }
    get totalSteps() {
      return this.d
    }
    set totalSteps(p) {
      ;(this.d = p), this.A({ totalSteps: p })
    }
    get enabled() {
      return this.g
    }
    set enabled(p) {
      ;(this.g = p), this.A({ enabled: p })
    }
    get busy() {
      return this.j
    }
    set busy(p) {
      ;(this.j = p), this.A({ busy: p })
    }
    get ignoreFocusOut() {
      return this.k
    }
    set ignoreFocusOut(p) {
      ;(this.k = p), this.A({ ignoreFocusOut: p })
    }
    get value() {
      return this.l
    }
    set value(p) {
      ;(this.l = p), this.A({ value: p })
    }
    get valueSelection() {
      return this.m
    }
    set valueSelection(p) {
      ;(this.m = p), this.A({ valueSelection: p })
    }
    get placeholder() {
      return this.n
    }
    set placeholder(p) {
      ;(this.n = p), this.A({ placeholder: p })
    }
    get buttons() {
      return this.o
    }
    set buttons(p) {
      const v = hi(this.y, "quickInputButtonLocation")
      !v &&
        p.some((b) => b.location) &&
        console.warn(
          `Extension '${this.y.identifier.value}' uses a button location which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this.y.identifier.value}`,
        ),
        (this.o = p.slice()),
        this.p.clear(),
        p.forEach((b, k) => {
          const E = b === Xh.Back ? -1 : k
          this.p.set(E, b)
        }),
        this.A({
          buttons: p.map((b, k) => ({
            ...u(b.iconPath),
            tooltip: b.tooltip,
            handle: b === Xh.Back ? -1 : k,
            location: v ? b.location : void 0,
          })),
        })
    }
    show() {
      ;(this.e = !0), (this.f = !0), this.A({ visible: !0 })
    }
    hide() {
      ;(this.e = !1), this.A({ visible: !1 })
    }
    _fireDidAccept() {
      this.q.fire()
    }
    _fireDidChangeValue(p) {
      ;(this.l = p), this.r.fire(p)
    }
    _fireDidTriggerButton(p) {
      const v = this.p.get(p)
      v && this.s.fire(v)
    }
    _fireDidHide() {
      this.f && ((this.f = this.e), this.t.fire())
    }
    dispose() {
      this.w ||
        ((this.w = !0),
        this._fireDidHide(),
        (this.x = Hs(this.x)),
        this.u && (clearTimeout(this.u), (this.u = void 0)),
        this.z(),
        s.$dispose(this._id))
    }
    A(p) {
      if (!this.w) {
        for (const v of Object.keys(p)) {
          const b = p[v]
          this.v[v] = b === void 0 ? null : b
        }
        "visible" in this.v
          ? (this.u && (clearTimeout(this.u), (this.u = void 0)), this.B())
          : this.e &&
            !this.u &&
            (this.u = setTimeout(() => {
              ;(this.u = void 0), this.B()
            }, 0))
      }
    }
    B() {
      s.$createOrUpdate(this.v), (this.v = { id: this._id })
    }
  }
  function o(f) {
    if (f instanceof Ji) return { id: f.id }
    const p = l(f),
      v = c(f)
    return {
      dark: typeof p == "string" ? S.file(p) : p,
      light: typeof v == "string" ? S.file(v) : v,
    }
  }
  function c(f) {
    return typeof f == "object" && "light" in f ? f.light : f
  }
  function l(f) {
    return typeof f == "object" && "dark" in f ? f.dark : f
  }
  function u(f) {
    const p = o(f)
    let v, b
    return (
      "id" in p ? (b = gi.asClassName(p)) : (v = p),
      { iconPath: v, iconClass: b }
    )
  }
  class d extends a {
    constructor(p, v) {
      super(p, v),
        (this.C = []),
        (this.D = new Map()),
        (this.E = new Map()),
        (this.F = !1),
        (this.G = !0),
        (this.H = !0),
        (this.I = !0),
        (this.J = !1),
        (this.K = []),
        (this.L = new J()),
        (this.M = []),
        (this.N = new J()),
        (this.O = new J()),
        (this.onDidChangeActive = this.L.event),
        (this.onDidChangeSelection = this.N.event),
        (this.onDidTriggerItemButton = this.O.event),
        this.x.push(this.L, this.N, this.O),
        this.A({ type: "quickPick" })
    }
    get items() {
      return this.C
    }
    set items(p) {
      ;(this.C = p.slice()),
        this.D.clear(),
        this.E.clear(),
        p.forEach((k, E) => {
          this.D.set(E, k), this.E.set(k, E)
        })
      const v = hi(this.y, "quickPickItemTooltip"),
        b = []
      for (let k = 0; k < p.length; k++) {
        const E = p[k]
        if (E.kind === Kh.Separator)
          b.push({ type: "separator", label: E.label })
        else {
          E.tooltip &&
            !v &&
            console.warn(
              `Extension '${this.y.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this.y.identifier.value}`,
            )
          const P = E.iconPath ? u(E.iconPath) : void 0
          b.push({
            handle: k,
            label: E.label,
            iconPath: P?.iconPath,
            iconClass: P?.iconClass,
            description: E.description,
            detail: E.detail,
            picked: E.picked,
            alwaysShow: E.alwaysShow,
            tooltip: v ? Dt.fromStrict(E.tooltip) : void 0,
            buttons: E.buttons?.map((C, R) => ({
              ...u(C.iconPath),
              tooltip: C.tooltip,
              handle: R,
            })),
          })
        }
      }
      this.A({ items: b })
    }
    get canSelectMany() {
      return this.F
    }
    set canSelectMany(p) {
      ;(this.F = p), this.A({ canSelectMany: p })
    }
    get matchOnDescription() {
      return this.G
    }
    set matchOnDescription(p) {
      ;(this.G = p), this.A({ matchOnDescription: p })
    }
    get matchOnDetail() {
      return this.H
    }
    set matchOnDetail(p) {
      ;(this.H = p), this.A({ matchOnDetail: p })
    }
    get sortByLabel() {
      return this.I
    }
    set sortByLabel(p) {
      ;(this.I = p), this.A({ sortByLabel: p })
    }
    get keepScrollPosition() {
      return this.J
    }
    set keepScrollPosition(p) {
      ;(this.J = p), this.A({ keepScrollPosition: p })
    }
    get activeItems() {
      return this.K
    }
    set activeItems(p) {
      ;(this.K = p.filter((v) => this.E.has(v))),
        this.A({ activeItems: this.K.map((v) => this.E.get(v)) })
    }
    get selectedItems() {
      return this.M
    }
    set selectedItems(p) {
      ;(this.M = p.filter((v) => this.E.has(v))),
        this.A({ selectedItems: this.M.map((v) => this.E.get(v)) })
    }
    _fireDidChangeActive(p) {
      const v = Ue(p.map((b) => this.D.get(b)))
      ;(this.K = v), this.L.fire(v)
    }
    _fireDidChangeSelection(p) {
      const v = Ue(p.map((b) => this.D.get(b)))
      ;(this.M = v), this.N.fire(v)
    }
    _fireDidTriggerItemButton(p, v) {
      const b = this.D.get(p)
      if (!b || !b.buttons || !b.buttons.length) return
      const k = b.buttons[v]
      k && this.O.fire({ button: k, item: b })
    }
  }
  class m extends a {
    constructor(p, v) {
      super(p, v), (this.C = !1), this.A({ type: "inputBox" })
    }
    get password() {
      return this.C
    }
    set password(p) {
      ;(this.C = p), this.A({ password: p })
    }
    get prompt() {
      return this.D
    }
    set prompt(p) {
      ;(this.D = p), this.A({ prompt: p })
    }
    get validationMessage() {
      return this.E
    }
    set validationMessage(p) {
      ;(this.E = p),
        p
          ? typeof p == "string"
            ? this.A({ validationMessage: p, severity: Le.Error })
            : this.A({
                validationMessage: p.message,
                severity: p.severity ?? Le.Error,
              })
          : this.A({ validationMessage: void 0, severity: Le.Ignore })
    }
  }
  return new r(t, e)
}
var bj
function gct(i) {
  return i instanceof S
}
function dMt(i, t) {
  return i.scheme === G.file && t.scheme === G.file && De
    ? i.toString() === t.toString()
    : i.toString().toLowerCase() === t.toString().toLowerCase()
}
function Tj(i) {
  if (i)
    return typeof i.iconPath == "string"
      ? S.file(i.iconPath)
      : S.isUri(i.iconPath) || gi.isThemeIcon(i.iconPath)
        ? i.iconPath
        : void 0
}
function Yl(i) {
  if (i) {
    if (S.isUri(i)) return i
    if (gi.isThemeIcon(i)) return i
    {
      const t = i
      return { light: t.light, dark: t.dark }
    }
  } else return
}
function mMt(i) {
  const t = i.references?.map((e) => ({ ...e, icon: Yl(e.icon) }))
  return { ...i, references: t }
}
function kj(i) {
  return i ? { ...i, icon: Yl(i.icon) } : void 0
}
function Sj(i, t) {
  if (!i.iconPath && !t.iconPath) return 0
  if (i.iconPath) {
    if (!t.iconPath) return 1
  } else return -1
  const e =
      typeof i.iconPath == "string"
        ? i.iconPath
        : S.isUri(i.iconPath)
          ? i.iconPath.fsPath
          : i.iconPath.id,
    s =
      typeof t.iconPath == "string"
        ? t.iconPath
        : S.isUri(t.iconPath)
          ? t.iconPath.fsPath
          : t.iconPath.id
  return LB(e, s)
}
function fMt(i, t) {
  let e = 0
  if (i.strikeThrough !== t.strikeThrough) return i.strikeThrough ? 1 : -1
  if (i.faded !== t.faded) return i.faded ? 1 : -1
  if (i.tooltip !== t.tooltip)
    return (i.tooltip || "").localeCompare(t.tooltip || "")
  if (((e = Sj(i, t)), e !== 0)) return e
  if (i.light && t.light) e = Sj(i.light, t.light)
  else {
    if (i.light) return 1
    if (t.light) return -1
  }
  if (e !== 0) return e
  if (i.dark && t.dark) e = Sj(i.dark, t.dark)
  else {
    if (i.dark) return 1
    if (t.dark) return -1
  }
  return e
}
function pMt(i, t) {
  if (i.command !== t.command) return i.command < t.command ? -1 : 1
  if (i.title !== t.title) return i.title < t.title ? -1 : 1
  if (i.tooltip !== t.tooltip) {
    if (i.tooltip !== void 0 && t.tooltip !== void 0)
      return i.tooltip < t.tooltip ? -1 : 1
    if (i.tooltip !== void 0) return 1
    if (t.tooltip !== void 0) return -1
  }
  if (i.arguments === t.arguments) return 0
  if (i.arguments)
    if (t.arguments) {
      if (i.arguments.length !== t.arguments.length)
        return i.arguments.length - t.arguments.length
    } else return 1
  else return -1
  for (let e = 0; e < i.arguments.length; e++) {
    const s = i.arguments[e],
      r = t.arguments[e]
    if (s !== r && !(gct(s) && gct(r) && dMt(s, r))) return s < r ? -1 : 1
  }
  return 0
}
function vct(i, t) {
  let e = LB(i.resourceUri.fsPath, t.resourceUri.fsPath, !0)
  if (e !== 0) return e
  if (i.command && t.command) e = pMt(i.command, t.command)
  else {
    if (i.command) return 1
    if (t.command) return -1
  }
  if (e !== 0) return e
  if (i.decorations && t.decorations) e = fMt(i.decorations, t.decorations)
  else {
    if (i.decorations) return 1
    if (t.decorations) return -1
  }
  if (e !== 0) return e
  if (i.multiFileDiffEditorModifiedUri && t.multiFileDiffEditorModifiedUri)
    e = LB(
      i.multiFileDiffEditorModifiedUri.fsPath,
      t.multiFileDiffEditorModifiedUri.fsPath,
      !0,
    )
  else {
    if (i.multiFileDiffEditorModifiedUri) return 1
    if (t.multiFileDiffEditorModifiedUri) return -1
  }
  if (e !== 0) return e
  if (i.multiDiffEditorOriginalUri && t.multiDiffEditorOriginalUri)
    e = LB(
      i.multiDiffEditorOriginalUri.fsPath,
      t.multiDiffEditorOriginalUri.fsPath,
      !0,
    )
  else {
    if (i.multiDiffEditorOriginalUri) return 1
    if (t.multiDiffEditorOriginalUri) return -1
  }
  return e
}
function gMt(i, t) {
  for (let e = 0; e < i.length; e++) if (i[e] !== t[e]) return !1
  return !0
}
function vMt(i, t) {
  return (
    i.command === t.command &&
    i.title === t.title &&
    i.tooltip === t.tooltip &&
    (i.arguments && t.arguments
      ? gMt(i.arguments, t.arguments)
      : i.arguments === t.arguments)
  )
}
function wMt(i, t) {
  return Er(i, t, vMt)
}
var yMt = class {
    #t
    #e
    get value() {
      return this.d
    }
    set value(i) {
      ;(i = i ?? ""), this.#t.$setInputBoxValue(this.m, i), this.o(i)
    }
    get onDidChange() {
      return this.f.event
    }
    get placeholder() {
      return this.g
    }
    set placeholder(i) {
      this.#t.$setInputBoxPlaceholder(this.m, i), (this.g = i)
    }
    get validateInput() {
      return _(this.l, "scmValidation"), this.h
    }
    set validateInput(i) {
      if ((_(this.l, "scmValidation"), i && typeof i != "function"))
        throw new Error(
          `[${this.l.identifier.value}]: Invalid SCM input box validation function`,
        )
      ;(this.h = i), this.#t.$setValidationProviderIsEnabled(this.m, !!i)
    }
    get enabled() {
      return this.j
    }
    set enabled(i) {
      ;(i = !!i),
        this.j !== i &&
          ((this.j = i), this.#t.$setInputBoxEnablement(this.m, i))
    }
    get visible() {
      return this.k
    }
    set visible(i) {
      ;(i = !!i),
        this.k !== i &&
          ((this.k = i), this.#t.$setInputBoxVisibility(this.m, i))
    }
    get document() {
      return _(this.l, "scmTextDocument"), this.#e.getDocument(this.n)
    }
    constructor(i, t, e, s, r) {
      ;(this.l = i),
        (this.m = s),
        (this.n = r),
        (this.d = ""),
        (this.f = new J()),
        (this.g = ""),
        (this.j = !0),
        (this.k = !0),
        (this.#e = t),
        (this.#t = e)
    }
    showValidationMessage(i, t) {
      _(this.l, "scmValidation"), this.#t.$showValidationMessage(this.m, i, t)
    }
    $onInputBoxValueChange(i) {
      this.o(i)
    }
    o(i) {
      ;(this.d = i), this.f.fire(i)
    }
  },
  bMt = class Dut {
    static {
      this.d = 0
    }
    get disposed() {
      return this.m
    }
    get id() {
      return this.v
    }
    get label() {
      return this.w
    }
    set label(t) {
      ;(this.w = t), this.s.$updateGroupLabel(this.u, this.handle, t)
    }
    get hideWhenEmpty() {
      return this.q
    }
    set hideWhenEmpty(t) {
      ;(this.q = t), this.s.$updateGroup(this.u, this.handle, this.features)
    }
    get features() {
      return { hideWhenEmpty: this.hideWhenEmpty }
    }
    get resourceStates() {
      return [...this.g]
    }
    set resourceStates(t) {
      ;(this.g = [...t]), this.l.fire()
    }
    constructor(t, e, s, r, a, o, c) {
      ;(this.s = t),
        (this.t = e),
        (this.u = s),
        (this.v = r),
        (this.w = a),
        (this.multiDiffEditorEnableViewChanges = o),
        (this.x = c),
        (this.f = 0),
        (this.g = []),
        (this.h = new Map()),
        (this.j = new Map()),
        (this.k = new Map()),
        (this.l = new J()),
        (this.onDidUpdateResourceStates = this.l.event),
        (this.m = !1),
        (this.n = new J()),
        (this.onDidDispose = this.n.event),
        (this.o = []),
        (this.p = []),
        (this.q = void 0),
        (this.handle = Dut.d++)
    }
    getResourceState(t) {
      return this.h.get(t)
    }
    $executeResourceCommand(t, e) {
      const s = this.j.get(t)
      return s
        ? Ci(() => this.t.executeCommand(s.command, ...(s.arguments || []), e))
        : Promise.resolve(void 0)
    }
    _takeResourceStateSnapshot() {
      const t = [...this.g].sort(vct),
        s = JV(this.p, t, vct).map((o) => {
          const c = o.toInsert.map((l) => {
            const u = this.f++
            this.h.set(u, l)
            const d = l.resourceUri
            let m
            if (l.command)
              if (
                l.command.command === "vscode.open" ||
                l.command.command === "vscode.diff" ||
                l.command.command === "vscode.changes"
              ) {
                const Z = new gt()
                ;(m = this.t.converter.toInternal(l.command, Z)),
                  this.k.set(u, Z)
              } else this.j.set(u, l.command)
            const f = hi(this.x, "scmMultiDiffEditor"),
              p = f ? l.multiDiffEditorOriginalUri : void 0,
              v = f ? l.multiFileDiffEditorModifiedUri : void 0,
              b = Tj(l.decorations),
              k = (l.decorations && Tj(l.decorations.light)) || b,
              E = (l.decorations && Tj(l.decorations.dark)) || b,
              P = [k, E],
              C = (l.decorations && l.decorations.tooltip) || "",
              R = l.decorations && !!l.decorations.strikeThrough,
              D = l.decorations && !!l.decorations.faded,
              V = l.contextValue || ""
            return { rawResource: [u, d, P, C, R, D, V, m, p, v], handle: u }
          })
          return { start: o.start, deleteCount: o.deleteCount, toInsert: c }
        }),
        r = s.map(({ start: o, deleteCount: c, toInsert: l }) => [
          o,
          c,
          l.map((u) => u.rawResource),
        ]),
        a = s.reverse()
      for (const { start: o, deleteCount: c, toInsert: l } of a) {
        const u = l.map((m) => m.handle),
          d = this.o.splice(o, c, ...u)
        for (const m of d)
          this.h.delete(m),
            this.j.delete(m),
            this.k.get(m)?.dispose(),
            this.k.delete(m)
      }
      return (this.p = t), r
    }
    dispose() {
      ;(this.m = !0), this.n.fire()
    }
  },
  Ej = class Fut {
    static {
      this.d = 0
    }
    #t
    get id() {
      return this.A
    }
    get label() {
      return this.B
    }
    get rootUri() {
      return this.C
    }
    get inputBox() {
      return this.g
    }
    get count() {
      return this.h
    }
    set count(t) {
      this.h !== t &&
        ((this.h = t), this.#t.$updateSourceControl(this.x, { count: t }))
    }
    get remotes() {
      return this.j
    }
    set remotes(t) {
      ;(this.j = t), this.#t.$updateSourceControl(this.x, { remotes: t })
    }
    get quickDiffProvider() {
      return this.k
    }
    set quickDiffProvider(t) {
      this.k = t
      let e
      hi(this.y, "quickDiffProvider") && (e = t?.label),
        this.#t.$updateSourceControl(this.x, {
          hasQuickDiffProvider: !!t,
          quickDiffLabel: e,
        })
    }
    get historyProvider() {
      return _(this.y, "scmHistoryProvider"), this.l
    }
    set historyProvider(t) {
      _(this.y, "scmHistoryProvider"),
        (this.l = t),
        (this.m.value = new gt()),
        this.#t.$updateSourceControl(this.x, { hasHistoryProvider: !!t }),
        t &&
          (this.m.value.add(
            t.onDidChangeCurrentHistoryItemRefs(() => {
              const e = kj(t?.currentHistoryItemRef),
                s = kj(t?.currentHistoryItemRemoteRef),
                r = kj(t?.currentHistoryItemBaseRef)
              this.#t.$onDidChangeHistoryProviderCurrentHistoryItemRefs(
                this.x,
                e,
                s,
                r,
              )
            }),
          ),
          this.m.value.add(
            t.onDidChangeHistoryItemRefs((e) => {
              if (
                e.added.length === 0 &&
                e.modified.length === 0 &&
                e.removed.length === 0
              )
                return
              const s = e.added.map((o) => ({ ...o, icon: Yl(o.icon) })),
                r = e.modified.map((o) => ({ ...o, icon: Yl(o.icon) })),
                a = e.removed.map((o) => ({ ...o, icon: Yl(o.icon) }))
              this.#t.$onDidChangeHistoryProviderHistoryItemRefs(this.x, {
                added: s,
                modified: r,
                removed: a,
                silent: e.silent,
              })
            }),
          ))
    }
    get commitTemplate() {
      return this.n
    }
    set commitTemplate(t) {
      t !== this.n &&
        ((this.n = t),
        this.#t.$updateSourceControl(this.x, { commitTemplate: t }))
    }
    get acceptInputCommand() {
      return this.p
    }
    set acceptInputCommand(t) {
      ;(this.o.value = new gt()), (this.p = t)
      const e = this.z.converter.toInternal(t, this.o.value)
      this.#t.$updateSourceControl(this.x, { acceptInputCommand: e })
    }
    get actionButton() {
      return _(this.y, "scmActionButton"), this.s
    }
    set actionButton(t) {
      if ((_(this.y, "scmActionButton"), u2(this.s, t))) return
      ;(this.s = t), (this.q.value = new gt())
      const e =
        t !== void 0
          ? {
              command: {
                ...this.z.converter.toInternal(t.command, this.q.value),
                shortTitle: t.command.shortTitle,
              },
              secondaryCommands: t.secondaryCommands?.map((s) =>
                s.map((r) => this.z.converter.toInternal(r, this.q.value)),
              ),
              enabled: t.enabled,
            }
          : void 0
      this.#t.$updateSourceControl(this.x, { actionButton: e ?? null })
    }
    get statusBarCommands() {
      return this.u
    }
    set statusBarCommands(t) {
      if (this.u && t && wMt(this.u, t)) return
      ;(this.t.value = new gt()), (this.u = t)
      const e = (t || []).map((s) =>
        this.z.converter.toInternal(s, this.t.value),
      )
      this.#t.$updateSourceControl(this.x, { statusBarCommands: e })
    }
    get selected() {
      return this.v
    }
    constructor(t, e, s, r, a, o, c) {
      ;(this.y = t),
        (this.z = r),
        (this.A = a),
        (this.B = o),
        (this.C = c),
        (this.f = new Map()),
        (this.h = void 0),
        (this.j = void 0),
        (this.k = void 0),
        (this.m = new zr()),
        (this.n = void 0),
        (this.o = new zr()),
        (this.p = void 0),
        (this.q = new zr()),
        (this.t = new zr()),
        (this.u = void 0),
        (this.v = !1),
        (this.w = new J()),
        (this.onDidChangeSelection = this.w.event),
        (this.x = Fut.d++),
        (this.D = new Map()),
        (this.E = new Set()),
        (this.#t = s)
      const l = S.from({
        scheme: G.vscodeSourceControl,
        path: `${a}/scm${this.x}/input`,
        query: c ? `rootUri=${encodeURIComponent(c.toString())}` : void 0,
      })
      ;(this.g = new yMt(t, e, this.#t, this.x, l)),
        this.#t.$registerSourceControl(this.x, a, o, c, l)
    }
    createResourceGroup(t, e, s) {
      const r =
          hi(this.y, "scmMultiDiffEditor") &&
          s?.multiDiffEditorEnableViewChanges === !0,
        a = new bMt(this.#t, this.z, this.x, t, e, r, this.y),
        o = Qt.once(a.onDidDispose)(() => this.D.delete(a))
      return this.D.set(a, o), this.eventuallyAddResourceGroups(), a
    }
    eventuallyAddResourceGroups() {
      const t = [],
        e = []
      for (const [s, r] of this.D) {
        r.dispose()
        const a = s.onDidUpdateResourceStates(() => {
          this.E.add(s), this.eventuallyUpdateResourceStates()
        })
        Qt.once(s.onDidDispose)(() => {
          this.E.delete(s),
            a.dispose(),
            this.f.delete(s.handle),
            this.#t.$unregisterGroup(this.x, s.handle)
        }),
          t.push([
            s.handle,
            s.id,
            s.label,
            s.features,
            s.multiDiffEditorEnableViewChanges,
          ])
        const o = s._takeResourceStateSnapshot()
        o.length > 0 && e.push([s.handle, o]), this.f.set(s.handle, s)
      }
      this.#t.$registerGroups(this.x, t, e), this.D.clear()
    }
    eventuallyUpdateResourceStates() {
      const t = []
      this.E.forEach((e) => {
        const s = e._takeResourceStateSnapshot()
        s.length !== 0 && t.push([e.handle, s])
      }),
        t.length > 0 && this.#t.$spliceResourceStates(this.x, t),
        this.E.clear()
    }
    getResourceGroup(t) {
      return this.f.get(t)
    }
    setSelectionState(t) {
      ;(this.v = t), this.w.fire(t)
    }
    dispose() {
      this.o.dispose(),
        this.q.dispose(),
        this.t.dispose(),
        this.f.forEach((t) => t.dispose()),
        this.#t.$unregisterSourceControl(this.x)
    }
  }
__decorate([z_(100)], Ej.prototype, "eventuallyAddResourceGroups", null),
  __decorate([z_(100)], Ej.prototype, "eventuallyUpdateResourceStates", null)
var Ij = class {
  static {
    bj = this
  }
  static {
    this.d = 0
  }
  get onDidChangeActiveProvider() {
    return this.l.event
  }
  constructor(t, e, s, r) {
    ;(this.n = e),
      (this.o = s),
      (this.p = r),
      (this.h = new Map()),
      (this.j = new hn()),
      (this.k = void 0),
      (this.l = new J()),
      (this.f = t.getProxy(K.MainThreadSCM)),
      (this.g = t.getProxy(K.MainThreadTelemetry)),
      e.registerArgumentProcessor({
        processArgument: (a) => {
          if (a && a.$mid === 3) {
            const o = this.h.get(a.sourceControlHandle)
            if (!o) return a
            const c = o.getResourceGroup(a.groupHandle)
            return c ? c.getResourceState(a.handle) : a
          } else if (a && a.$mid === 4) {
            const o = this.h.get(a.sourceControlHandle)
            return o ? o.getResourceGroup(a.groupHandle) : a
          } else if (a && a.$mid === 5) {
            const o = this.h.get(a.handle)
            return o || a
          }
          return a
        },
      })
  }
  registerGitContextProvider(t) {
    return (
      (this.k = t),
      this.f.$registerGitContextProvider(),
      et(() => {
        this.f.$unregisterGitContextProvider(), (this.k = void 0)
      })
    )
  }
  gitStatusWasRun(t) {
    this.f.$gitStatusWasRun(t)
  }
  async $getFullCommit(t) {
    return this.k && (await this.k.getFullCommit(t))
  }
  async $searchAllCommits(t) {
    return this.k && (await this.k.getCommits(t))
  }
  async $searchPRs(t) {
    return this.k && (await this.k.getPullRequests(t))
  }
  async $getFullPR(t) {
    return this.k && (await this.k.getFullPullRequest(t))
  }
  async $getCurrentDiff() {
    return this.k && (await this.k.getCurrentDiff())
  }
  async $getDiffToMain(t) {
    return this.k && (await this.k.getBranchDiff(t))
  }
  async $getDiffRaw() {
    return this.k && (await this.k.getDiffRaw())
  }
  async $getGitRoot(t) {
    return this.k && (await this.k.getGitRoot(t))
  }
  async $getLastCommit() {
    return this.k && (await this.k.getLastCommit())
  }
  async $getLastCommits(t, e) {
    const s = this.k && (await this.k.getLastCommits(t, e))
    return s === void 0 ? [] : s
  }
  async $getFilenamesInCommit(t) {
    return (this.k && (await this.k.getFilenamesInCommit(t))) || []
  }
  async $getGitLineBlame(t, e, s) {
    return this.k && this.k.getGitLineBlame(t, e, s)
  }
  async $getGitFileBlame(t, e) {
    return this.k && this.k.getGitFileBlame(t, e)
  }
  async $getGitUpstreamURL() {
    return this.k && (await this.k.getGitUpstreamURL())
  }
  async $getCommitRawByCommitHash(t, e) {
    return this.k && (await this.k.getCommitRawByCommitHash(t, e))
  }
  async $getFileContentAtRef(t, e, s) {
    return this.k && (await this.k.getFileContentAtRef(t, e, s))
  }
  async $createWorktree(t) {
    return this.k && (await this.k.createWorktree(t))
  }
  async $syncWorktreeToBranch(t, e) {
    return this.k && (await this.k.syncWorktreeToBranch(t, e))
  }
  async $syncBranchToWorktree(t, e) {
    return this.k && (await this.k.syncBranchToWorktree(t, e))
  }
  async $resetWorktreeToDefaultBranch(t) {
    return this.k && (await this.k.resetWorktreeToDefaultBranch(t))
  }
  async $removeWorktree(t) {
    return this.k && (await this.k.removeWorktree(t))
  }
  async $listAllWorktrees() {
    return this.k && (await this.k.listAllWorktrees())
  }
  async $cleanupOldWorktrees() {
    return this.k && (await this.k.cleanupOldWorktrees())
  }
  async $getCurrentBranch() {
    return this.k && (await this.k.getCurrentBranch())
  }
  async $getDefaultBranch() {
    return this.k && (await this.k.getDefaultBranch())
  }
  async $getGitUser() {
    return this.k && (await this.k.getGitUser())
  }
  createSourceControl(t, e, s, r) {
    this.p.trace("ExtHostSCM#createSourceControl", t.identifier.value, e, s, r),
      this.g.$publicLog2("api/scm/createSourceControl", {
        extensionId: t.identifier.value,
      })
    const a = bj.d++,
      o = new Ej(t, this.o, this.f, this.n, e, s, r)
    this.h.set(a, o)
    const c = this.j.get(t.identifier) || []
    return c.push(o), this.j.set(t.identifier, c), o
  }
  getLastInputBox(t) {
    this.p.trace("ExtHostSCM#getLastInputBox", t.identifier.value)
    const e = this.j.get(t.identifier),
      s = e && e[e.length - 1]
    return s && s.inputBox
  }
  $provideOriginalResource(t, e, s) {
    const r = S.revive(e)
    this.p.trace("ExtHostSCM#$provideOriginalResource", t, r.toString())
    const a = this.h.get(t)
    return !a ||
      !a.quickDiffProvider ||
      !a.quickDiffProvider.provideOriginalResource
      ? Promise.resolve(null)
      : Ci(() => a.quickDiffProvider.provideOriginalResource(r, s)).then(
          (o) => o || null,
        )
  }
  $onInputBoxValueChange(t, e) {
    this.p.trace("ExtHostSCM#$onInputBoxValueChange", t)
    const s = this.h.get(t)
    return s && s.inputBox.$onInputBoxValueChange(e), Promise.resolve(void 0)
  }
  $executeResourceCommand(t, e, s, r) {
    this.p.trace("ExtHostSCM#$executeResourceCommand", t, e, s)
    const a = this.h.get(t)
    if (!a) return Promise.resolve(void 0)
    const o = a.getResourceGroup(e)
    return o ? o.$executeResourceCommand(s, r) : Promise.resolve(void 0)
  }
  $validateInput(t, e, s) {
    this.p.trace("ExtHostSCM#$validateInput", t)
    const r = this.h.get(t)
    return !r || !r.inputBox.validateInput
      ? Promise.resolve(void 0)
      : Ci(() => r.inputBox.validateInput(e, s)).then((a) => {
          if (!a) return Promise.resolve(void 0)
          const o = Dt.fromStrict(a.message)
          return o ? Promise.resolve([o, a.type]) : Promise.resolve(void 0)
        })
  }
  $setSelectedSourceControl(t) {
    return (
      this.p.trace("ExtHostSCM#$setSelectedSourceControl", t),
      t !== void 0 && this.h.get(t)?.setSelectionState(!0),
      this.m !== void 0 && this.h.get(this.m)?.setSelectionState(!1),
      (this.m = t),
      Promise.resolve(void 0)
    )
  }
  async $resolveHistoryItemRefsCommonAncestor(t, e, s) {
    try {
      return (
        (await this.h
          .get(t)
          ?.historyProvider?.resolveHistoryItemRefsCommonAncestor(e, s)) ??
        void 0
      )
    } catch (r) {
      this.p.error("ExtHostSCM#$resolveHistoryItemRefsCommonAncestor", r)
      return
    }
  }
  async $provideHistoryItemRefs(t, e, s) {
    try {
      return (
        (
          await this.h.get(t)?.historyProvider?.provideHistoryItemRefs(e, s)
        )?.map((o) => ({ ...o, icon: Yl(o.icon) })) ?? void 0
      )
    } catch (r) {
      this.p.error("ExtHostSCM#$provideHistoryItemRefs", r)
      return
    }
  }
  async $provideHistoryItems(t, e, s) {
    try {
      return (
        (await this.h.get(t)?.historyProvider?.provideHistoryItems(e, s))?.map(
          (o) => mMt(o),
        ) ?? void 0
      )
    } catch (r) {
      this.p.error("ExtHostSCM#$provideHistoryItems", r)
      return
    }
  }
  async $provideHistoryItemChanges(t, e, s, r) {
    try {
      return (
        (await this.h
          .get(t)
          ?.historyProvider?.provideHistoryItemChanges(e, s, r)) ?? void 0
      )
    } catch (a) {
      this.p.error("ExtHostSCM#$provideHistoryItemChanges", a)
      return
    }
  }
}
Ij = bj = __decorate([__param(3, Rt)], Ij)
var TMt = class Aut {
    static {
      this.a = 0
    }
    constructor(t, e) {
      ;(this.d = e),
        (this.c = new Map()),
        (this.b = t.getProxy(K.MainThreadShare))
    }
    async $provideShare(t, e, s) {
      return (
        (await this.c
          .get(t)
          ?.provideShare(
            {
              selection: U.to(e.selection),
              resourceUri: S.revive(e.resourceUri),
            },
            s,
          )) ?? void 0
      )
    }
    registerShareProvider(t, e) {
      const s = Aut.a++
      return (
        this.c.set(s, e),
        this.b.$registerShareProvider(
          s,
          dl.from(t, this.d),
          e.id,
          e.label,
          e.priority,
        ),
        {
          dispose: () => {
            this.b.$unregisterShareProvider(s), this.c.delete(s)
          },
        }
      )
    }
  },
  kMt = class _ut {
    static {
      this.a = 1
    }
    constructor(t) {
      ;(this.c = new Map()),
        (this.d = new Map()),
        (this.f = new Map()),
        (this.b = t.getProxy(K.MainThreadSpeech))
    }
    async $createSpeechToTextSession(t, e, s) {
      const r = this.c.get(t)
      if (!r) return
      const a = new gt(),
        o = new fe()
      this.d.set(e, o)
      const c = await r.provideSpeechToTextSession(
        o.token,
        s ? { language: s } : void 0,
      )
      c &&
        (a.add(
          c.onDidChange((l) => {
            o.token.isCancellationRequested ||
              this.b.$emitSpeechToTextEvent(e, l)
          }),
        ),
        a.add(o.token.onCancellationRequested(() => a.dispose())))
    }
    async $cancelSpeechToTextSession(t) {
      this.d.get(t)?.dispose(!0), this.d.delete(t)
    }
    async $createTextToSpeechSession(t, e, s) {
      const r = this.c.get(t)
      if (!r) return
      const a = new gt(),
        o = new fe()
      this.d.set(e, o)
      const c = await r.provideTextToSpeechSession(
        o.token,
        s ? { language: s } : void 0,
      )
      c &&
        (this.f.set(e, c),
        a.add(
          c.onDidChange((l) => {
            o.token.isCancellationRequested ||
              this.b.$emitTextToSpeechEvent(e, l)
          }),
        ),
        a.add(o.token.onCancellationRequested(() => a.dispose())))
    }
    async $synthesizeSpeech(t, e) {
      this.f.get(t)?.synthesize(e)
    }
    async $cancelTextToSpeechSession(t) {
      this.d.get(t)?.dispose(!0), this.d.delete(t), this.f.delete(t)
    }
    async $createKeywordRecognitionSession(t, e) {
      const s = this.c.get(t)
      if (!s) return
      const r = new gt(),
        a = new fe()
      this.d.set(e, a)
      const o = await s.provideKeywordRecognitionSession(a.token)
      o &&
        (r.add(
          o.onDidChange((c) => {
            a.token.isCancellationRequested ||
              this.b.$emitKeywordRecognitionEvent(e, c)
          }),
        ),
        r.add(a.token.onCancellationRequested(() => r.dispose())))
    }
    async $cancelKeywordRecognitionSession(t) {
      this.d.get(t)?.dispose(!0), this.d.delete(t)
    }
    registerProvider(t, e, s) {
      const r = _ut.a++
      return (
        this.c.set(r, s),
        this.b.$registerProvider(r, e, { extension: t, displayName: t.value }),
        et(() => {
          this.b.$unregisterProvider(r), this.c.delete(r)
        })
      )
    }
  },
  SMt = class e7 {
    static {
      this.a = 0
    }
    static {
      this.b = new Map([
        [
          "statusBarItem.errorBackground",
          new Mh("statusBarItem.errorForeground"),
        ],
        [
          "statusBarItem.warningBackground",
          new Mh("statusBarItem.warningForeground"),
        ],
      ])
    }
    #t
    #e
    constructor(t, e, s, r, a, o = oa.Left, c) {
      if (
        ((this.i = !1),
        (this.k = ""),
        (this.q = new gt()),
        (this.#t = t),
        (this.#e = e),
        a && r)
      ) {
        this.c = oTt(r.identifier, a)
        const l = s.get(this.c)
        l &&
          ((o = l.alignLeft ? oa.Left : oa.Right),
          (c = l.priority),
          (this.j = !0),
          (this.name = l.name),
          (this.text = l.text),
          (this.tooltip = l.tooltip),
          (this.command = l.command),
          (this.accessibilityInformation = l.accessibilityInformation))
      } else this.c = String(e7.a++)
      ;(this.e = r), (this.f = a), (this.g = o), (this.h = this.u(c))
    }
    u(t) {
      if (ps(t))
        return t === Number.POSITIVE_INFINITY
          ? Number.MAX_VALUE
          : t === Number.NEGATIVE_INFINITY
            ? -Number.MAX_VALUE
            : t
    }
    get id() {
      return this.f ?? this.e.identifier.value
    }
    get alignment() {
      return this.g
    }
    get priority() {
      return this.h
    }
    get text() {
      return this.k
    }
    get name() {
      return this.m
    }
    get tooltip() {
      return this.l
    }
    get color() {
      return this.n
    }
    get backgroundColor() {
      return this.o
    }
    get command() {
      return this.r?.fromApi
    }
    get accessibilityInformation() {
      return this.t
    }
    set text(t) {
      ;(this.k = t), this.v()
    }
    set name(t) {
      ;(this.m = t), this.v()
    }
    set tooltip(t) {
      ;(this.l = t), this.v()
    }
    set color(t) {
      ;(this.n = t), this.v()
    }
    set backgroundColor(t) {
      t && !e7.b.has(t.id) && (t = void 0), (this.o = t), this.v()
    }
    set command(t) {
      this.r?.fromApi !== t &&
        (this.p && this.q.add(this.p),
        (this.p = new gt()),
        typeof t == "string"
          ? (this.r = {
              fromApi: t,
              internal: this.#e.toInternal({ title: "", command: t }, this.p),
            })
          : t
            ? (this.r = { fromApi: t, internal: this.#e.toInternal(t, this.p) })
            : (this.r = void 0),
        this.v())
    }
    set accessibilityInformation(t) {
      ;(this.t = t), this.v()
    }
    show() {
      ;(this.j = !0), this.v()
    }
    hide() {
      clearTimeout(this.s), (this.j = !1), this.#t.$disposeEntry(this.c)
    }
    v() {
      this.i ||
        !this.j ||
        (clearTimeout(this.s),
        (this.s = setTimeout(() => {
          this.s = void 0
          let t
          this.e
            ? this.f
              ? (t = `${this.e.identifier.value}.${this.f}`)
              : (t = this.e.identifier.value)
            : (t = this.f)
          let e
          this.m
            ? (e = this.m)
            : (e = g(2768, null, this.e.displayName || this.e.name))
          let s = this.n
          this.o && (s = e7.b.get(this.o.id))
          const r = Dt.fromStrict(this.l)
          this.#t.$setEntry(
            this.c,
            t,
            this.e?.identifier.value,
            e,
            this.k,
            r,
            this.r?.internal,
            s,
            this.o,
            this.g === oa.Left,
            this.h,
            this.t,
          ),
            this.q.clear()
        }, 0)))
    }
    dispose() {
      this.hide(), (this.i = !0)
    }
  },
  EMt = class {
    constructor(i) {
      ;(this.b = []),
        (this.a = i.createStatusBarEntry(
          void 0,
          "status.extensionMessage",
          oa.Left,
          Number.MIN_VALUE,
        )),
        (this.a.name = g(2769, null))
    }
    dispose() {
      ;(this.b.length = 0), this.a.dispose()
    }
    setMessage(i) {
      const t = { message: i }
      return (
        this.b.unshift(t),
        this.c(),
        new Ht(() => {
          const e = this.b.indexOf(t)
          e >= 0 && (this.b.splice(e, 1), this.c())
        })
      )
    }
    c() {
      this.b.length > 0
        ? ((this.a.text = this.b[0].message), this.a.show())
        : this.a.hide()
    }
  },
  IMt = class {
    constructor(i, t) {
      ;(this.e = new Map()),
        (this.a = i.getProxy(K.MainThreadStatusBar)),
        (this.b = t),
        (this.c = new EMt(this))
    }
    $acceptStaticEntries(i) {
      for (const t of i) this.e.set(t.entryId, t)
    }
    createStatusBarEntry(i, t, e, s) {
      return new SMt(this.a, this.b, this.e, i, t, e, s)
    }
    setStatusBarMessage(i, t) {
      const e = this.c.setMessage(i)
      let s
      return (
        typeof t == "number"
          ? (s = setTimeout(() => e.dispose(), t))
          : typeof t < "u" &&
            t.then(
              () => e.dispose(),
              () => e.dispose(),
            ),
        new Ht(() => {
          e.dispose(), clearTimeout(s)
        })
      )
    }
  },
  PMt = class extends at {
    constructor(i, t) {
      super(),
        (this.n = t),
        (this.a = new J()),
        (this.b = new J()),
        (this.c = new J()),
        (this.f = new J()),
        (this.g = new J()),
        (this.h = new J()),
        (this.j = new J()),
        (this.onDidChangeTextEditorSelection = this.a.event),
        (this.onDidChangeTextEditorOptions = this.b.event),
        (this.onDidChangeTextEditorVisibleRanges = this.c.event),
        (this.onDidChangeTextEditorViewColumn = this.f.event),
        (this.onDidChangeTextEditorDiffInformation = this.g.event),
        (this.onDidChangeActiveTextEditor = this.h.event),
        (this.onDidChangeVisibleTextEditors = this.j.event),
        (this.m = i.getProxy(K.MainThreadTextEditors)),
        this.D(this.n.onDidChangeVisibleTextEditors((e) => this.j.fire(e))),
        this.D(this.n.onDidChangeActiveTextEditor((e) => this.h.fire(e)))
    }
    getActiveTextEditor() {
      return this.n.activeEditor()
    }
    getVisibleTextEditors(i) {
      const t = this.n.allEditors()
      return i ? t : t.map((e) => e.value)
    }
    async showTextDocument(i, t, e) {
      let s
      typeof t == "number"
        ? (s = { position: ii.from(t), preserveFocus: e })
        : typeof t == "object"
          ? (s = {
              position: ii.from(t.viewColumn),
              preserveFocus: t.preserveFocus,
              selection:
                typeof t.selection == "object" ? U.from(t.selection) : void 0,
              pinned: typeof t.preview == "boolean" ? !t.preview : void 0,
            })
          : (s = { preserveFocus: !1 })
      const r = await this.m.$tryShowTextDocument(i.uri, s),
        a = r && this.n.getEditor(r)
      if (a) return a.value
      throw r
        ? new Error(
            `Could NOT open editor for "${i.uri.toString()}" because another editor opened in the meantime.`,
          )
        : new Error(`Could NOT open editor for "${i.uri.toString()}".`)
    }
    createTextEditorDecorationType(i, t) {
      return new P$t(this.m, i, t).value
    }
    $acceptEditorPropertiesChanged(i, t) {
      const e = this.n.getEditor(i)
      if (!e) throw new Error("unknown text editor")
      if ((t.options && e._acceptOptions(t.options), t.selections)) {
        const s = t.selections.selections.map(or.to)
        e._acceptSelections(s)
      }
      if (t.visibleRanges) {
        const s = Ue(t.visibleRanges.map(U.to))
        e._acceptVisibleRanges(s)
      }
      if (
        (t.options &&
          this.b.fire({
            textEditor: e.value,
            options: {
              ...t.options,
              lineNumbers: vl.to(t.options.lineNumbers),
            },
          }),
        t.selections)
      ) {
        const s = zc.fromValue(t.selections.source),
          r = t.selections.selections.map(or.to)
        this.a.fire({ textEditor: e.value, selections: r, kind: s })
      }
      if (t.visibleRanges) {
        const s = Ue(t.visibleRanges.map(U.to))
        this.c.fire({ textEditor: e.value, visibleRanges: s })
      }
    }
    $acceptEditorPositionData(i) {
      for (const t in i) {
        const e = this.n.getEditor(t)
        if (!e) throw new Error("Unknown text editor")
        const s = ii.to(i[t])
        e.value.viewColumn !== s &&
          (e._acceptViewColumn(s),
          this.f.fire({ textEditor: e.value, viewColumn: s }))
      }
    }
    $acceptEditorDiffInformation(i, t) {
      const e = this.n.getEditor(i)
      if (!e) throw new Error("unknown text editor")
      if (!t) {
        e._acceptDiffInformation(void 0),
          this.g.fire({ textEditor: e.value, diffInformation: void 0 })
        return
      }
      const s = this,
        r = t.map((a) => {
          const o = S.revive(a.original),
            c = S.revive(a.modified),
            l = a.changes.map((u) => {
              const [d, m, f, p] = u
              let v
              return (
                d === m
                  ? (v = Yc.Addition)
                  : f === p
                    ? (v = Yc.Deletion)
                    : (v = Yc.Modification),
                {
                  original: { startLineNumber: d, endLineNumberExclusive: m },
                  modified: { startLineNumber: f, endLineNumberExclusive: p },
                  kind: v,
                }
              )
            })
          return Object.freeze({
            documentVersion: a.documentVersion,
            original: o,
            modified: c,
            changes: l,
            get isStale() {
              return s.n.getDocument(c)?.version !== a.documentVersion
            },
          })
        })
      e._acceptDiffInformation(r),
        this.g.fire({ textEditor: e.value, diffInformation: r })
    }
    getDiffInformation(i) {
      return Promise.resolve(this.m.$getDiffInformation(i))
    }
  },
  Pj = class {
    constructor(t) {
      ;(this.a = new TO(la.Dark)), (this.b = new J())
    }
    get activeColorTheme() {
      return this.a
    }
    $onColorThemeChange(t) {
      let e
      switch (t) {
        case "light":
          e = la.Light
          break
        case "hcDark":
          e = la.HighContrast
          break
        case "hcLight":
          e = la.HighContrastLight
          break
        default:
          e = la.Dark
      }
      ;(this.a = new TO(e)), this.b.fire(this.a)
    }
    get onDidChangeActiveColorTheme() {
      return this.b.event
    }
  }
Pj = __decorate([__param(0, Ot)], Pj)
var eZt = X("IExtHostTimeline"),
  $Mt = class {
    constructor(i, t) {
      ;(this.b = new Map()),
        (this.c = new Map()),
        (this.a = i.getProxy(K.MainThreadTimeline)),
        t.registerArgumentProcessor({
          processArgument: (e, s) => {
            if (e && e.$mid === 12)
              if (
                this.b.get(e.source) &&
                ae.equals(s, this.b.get(e.source)?.extension)
              ) {
                const r = e.uri === void 0 ? void 0 : S.revive(e.uri)
                return this.c.get(e.source)?.get(wct(r))?.get(e.handle)
              } else return
            return e
          },
        })
    }
    async $getTimeline(i, t, e, s) {
      return this.b.get(i)?.provider.provideTimeline(S.revive(t), e, s)
    }
    registerTimelineProvider(i, t, e, s) {
      const r = new gt(),
        a = this.d(t.id, s, r).bind(this)
      let o
      t.onDidChange &&
        (o = t.onDidChange(
          (l) =>
            this.a.$emitTimelineChangeEvent({
              uri: void 0,
              reset: !0,
              ...l,
              id: t.id,
            }),
          this,
        ))
      const c = this.c
      return this.f(
        {
          ...t,
          scheme: i,
          onDidChange: void 0,
          async provideTimeline(l, u, d) {
            u?.resetCache && (r.clear(), c.get(t.id)?.clear())
            const m = await t.provideTimeline(l, u, d)
            if (m == null) return
            const f = a(l, u)
            return { ...m, source: t.id, items: m.items.map(f) }
          },
          dispose() {
            for (const l of c.values()) l.get(t.id)?.clear()
            o?.dispose(), r.dispose()
          },
        },
        e,
      )
    }
    d(i, t, e) {
      return (s, r) => {
        let a
        if (r?.cacheResults) {
          let o = this.c.get(i)
          o === void 0 && ((o = new Map()), this.c.set(i, o))
          const c = wct(s)
          ;(a = o.get(c)), a === void 0 && ((a = new Map()), o.set(c, a))
        }
        return (o) => {
          const { iconPath: c, ...l } = o,
            u = `${i}|${o.id ?? o.timestamp}`
          a?.set(u, o)
          let d, m, f
          o.iconPath &&
            (c instanceof Ji
              ? (f = { id: c.id, color: c.color })
              : S.isUri(c)
                ? ((d = c), (m = c))
                : ({ light: d, dark: m } = c))
          let p
          return (
            ls.isMarkdownString(l.tooltip)
              ? (p = Dt.from(l.tooltip))
              : _t(l.tooltip)
                ? (p = l.tooltip)
                : ls.isMarkdownString(l.detail)
                  ? (console.warn(
                      "Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip",
                    ),
                    (p = Dt.from(l.detail)))
                  : _t(l.detail) &&
                    (console.warn(
                      "Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip",
                    ),
                    (p = l.detail)),
            {
              ...l,
              id: l.id ?? void 0,
              handle: u,
              source: i,
              command: o.command ? t.toInternal(o.command, e) : void 0,
              icon: d,
              iconDark: m,
              themeIcon: f,
              tooltip: p,
              accessibilityInformation: o.accessibilityInformation,
            }
          )
        }
      }
    }
    f(i, t) {
      if (this.b.get(i.id))
        throw new Error(`Timeline Provider ${i.id} already exists.`)
      return (
        this.a.$registerTimelineProvider({
          id: i.id,
          label: i.label,
          scheme: i.scheme,
        }),
        this.b.set(i.id, { provider: i, extension: t }),
        et(() => {
          for (const s of this.c.values()) s.get(i.id)?.clear()
          this.b.delete(i.id),
            this.a.$unregisterTimelineProvider(i.id),
            i.dispose()
        })
      )
    }
  }
function wct(i) {
  return i?.toString()
}
var xMt = { IconContribution: "base.contributions.icons" },
  yct
;(function (i) {
  function t(e, s) {
    let r = e.defaults
    for (; gi.isThemeIcon(r); ) {
      const a = Ql.getIcon(r.id)
      if (!a) return
      r = a.defaults
    }
    return r
  }
  i.getDefinition = t
})(yct || (yct = {}))
var bct
;(function (i) {
  function t(s) {
    return {
      weight: s.weight,
      style: s.style,
      src: s.src.map((r) => ({
        format: r.format,
        location: r.location.toString(),
      })),
    }
  }
  i.toJSONObject = t
  function e(s) {
    const r = (a) => (_t(a) ? a : void 0)
    if (
      s &&
      Array.isArray(s.src) &&
      s.src.every((a) => _t(a.format) && _t(a.location))
    )
      return {
        weight: r(s.weight),
        style: r(s.style),
        src: s.src.map((a) => ({
          format: a.format,
          location: S.parse(a.location),
        })),
      }
  }
  i.fromJSONObject = e
})(bct || (bct = {}))
var NMt = class {
    constructor() {
      ;(this.a = new J()),
        (this.onDidChange = this.a.event),
        (this.d = {
          definitions: {
            icons: {
              type: "object",
              properties: {
                fontId: { type: "string", description: g(2415, null) },
                fontCharacter: { type: "string", description: g(2416, null) },
              },
              additionalProperties: !1,
              defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }],
            },
          },
          type: "object",
          properties: {},
        }),
        (this.e = {
          type: "string",
          pattern: `^${gi.iconNameExpression}$`,
          enum: [],
          enumDescriptions: [],
        }),
        (this.b = {}),
        (this.f = {})
    }
    registerIcon(i, t, e, s) {
      const r = this.b[i]
      if (r) {
        if (e && !r.description) {
          ;(r.description = e),
            (this.d.properties[i].markdownDescription = `${e} $(${i})`)
          const c = this.e.enum.indexOf(i)
          c !== -1 && (this.e.enumDescriptions[c] = e), this.a.fire()
        }
        return r
      }
      const a = { id: i, description: e, defaults: t, deprecationMessage: s }
      this.b[i] = a
      const o = { $ref: "#/definitions/icons" }
      return (
        s && (o.deprecationMessage = s),
        e && (o.markdownDescription = `${e}: $(${i})`),
        (this.d.properties[i] = o),
        this.e.enum.push(i),
        this.e.enumDescriptions.push(e || ""),
        this.a.fire(),
        { id: i }
      )
    }
    deregisterIcon(i) {
      delete this.b[i], delete this.d.properties[i]
      const t = this.e.enum.indexOf(i)
      t !== -1 &&
        (this.e.enum.splice(t, 1), this.e.enumDescriptions.splice(t, 1)),
        this.a.fire()
    }
    getIcons() {
      return Object.keys(this.b).map((i) => this.b[i])
    }
    getIcon(i) {
      return this.b[i]
    }
    getIconSchema() {
      return this.d
    }
    getIconReferenceSchema() {
      return this.e
    }
    registerIconFont(i, t) {
      const e = this.f[i]
      return e || ((this.f[i] = t), this.a.fire(), t)
    }
    deregisterIconFont(i) {
      delete this.f[i]
    }
    getIconFont(i) {
      return this.f[i]
    }
    toString() {
      const i = (r, a) => r.id.localeCompare(a.id),
        t = (r) => {
          for (; gi.isThemeIcon(r.defaults); ) r = this.b[r.defaults.id]
          return `codicon codicon-${r ? r.id : ""}`
        },
        e = []
      e.push(
        "| preview     | identifier                        | default codicon ID                | description",
      ),
        e.push(
          "| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |",
        )
      const s = Object.keys(this.b).map((r) => this.b[r])
      for (const r of s.filter((a) => !!a.description).sort(i))
        e.push(
          `|<i class="${t(r)}"></i>|${r.id}|${gi.isThemeIcon(r.defaults) ? r.defaults.id : r.id}|${r.description || ""}|`,
        )
      e.push("| preview     | identifier                        "),
        e.push("| ----------- | --------------------------------- |")
      for (const r of s.filter((a) => !gi.isThemeIcon(a.defaults)).sort(i))
        e.push(`|<i class="${t(r)}"></i>|${r.id}|`)
      return e.join(`
`)
    }
  },
  Ql = new NMt()
Si.add(xMt.IconContribution, Ql)
function I3(i, t, e, s) {
  return Ql.registerIcon(i, t, e, s)
}
function CMt() {
  const i = uyt()
  for (const t in i) {
    const e = "\\" + i[t].toString(16)
    Ql.registerIcon(t, { fontCharacter: e })
  }
}
CMt()
var Tct = "vscode://schemas/icons",
  kct = Si.as(b6.JSONContribution)
kct.registerSchema(Tct, Ql.getIconSchema())
var Sct = new tn(() => kct.notifySchemaChanged(Tct), 200)
Ql.onDidChange(() => {
  Sct.isScheduled() || Sct.schedule()
})
var iZt = I3("widget-close", pt.close, g(2417, null)),
  sZt = I3("goto-previous-location", pt.arrowUp, g(2418, null)),
  rZt = I3("goto-next-location", pt.arrowDown, g(2419, null)),
  nZt = gi.modify(pt.sync, "spin"),
  aZt = gi.modify(pt.loading, "spin"),
  oZt = g(4314, null),
  cZt = I3("default-view-icon", pt.window, g(4315, null)),
  P3
;(function (i) {
  ;(i.ViewContainersRegistry = "workbench.registry.view.containers"),
    (i.ViewsRegistry = "workbench.registry.view")
})(P3 || (P3 = {}))
var Ect
;(function (i) {
  ;(i[(i.Sidebar = 0)] = "Sidebar"),
    (i[(i.Panel = 1)] = "Panel"),
    (i[(i.AuxiliaryBar = 2)] = "AuxiliaryBar")
})(Ect || (Ect = {}))
var JMt = class extends at {
  constructor() {
    super(...arguments),
      (this.c = this.D(new J())),
      (this.onDidRegister = this.c.event),
      (this.f = this.D(new J())),
      (this.onDidDeregister = this.f.event),
      (this.g = new Map()),
      (this.h = [])
  }
  get all() {
    return [...this.g.values()].flat()
  }
  registerViewContainer(i, t, e) {
    const s = this.get(i.id)
    if (s) return s
    const r = i
    return (
      (r.openCommandActionDescriptor = e?.doNotRegisterOpenCommand
        ? void 0
        : (r.openCommandActionDescriptor ?? { id: r.id })),
      Bht(this.g, t, []).push(r),
      e?.isDefault && this.h.push(r),
      this.c.fire({ viewContainer: r, viewContainerLocation: t }),
      r
    )
  }
  deregisterViewContainer(i) {
    for (const t of this.g.keys()) {
      const e = this.g.get(t),
        s = e?.indexOf(i)
      if (s !== -1) {
        e?.splice(s, 1),
          e.length === 0 && this.g.delete(t),
          this.f.fire({ viewContainer: i, viewContainerLocation: t })
        return
      }
    }
  }
  get(i) {
    return this.all.filter((t) => t.id === i)[0]
  }
  getViewContainers(i) {
    return [...(this.g.get(i) || [])]
  }
  getViewContainerLocation(i) {
    return [...this.g.keys()].filter(
      (t) => this.getViewContainers(t).filter((e) => e?.id === i.id).length > 0,
    )[0]
  }
  getDefaultViewContainer(i) {
    return this.h.find((t) => this.getViewContainerLocation(t) === i)
  }
}
Si.add(P3.ViewContainersRegistry, new JMt())
var $3
;(function (i) {
  ;(i.Open = "2_open"),
    (i.Debug = "4_debug"),
    (i.SCM = "5_scm"),
    (i.More = "9_more")
})($3 || ($3 = {}))
function LMt(i, t) {
  const e = i.group ?? $3.More,
    s = t.group ?? $3.More
  return e !== s ? e.localeCompare(s) : (i.order ?? 5) - (t.order ?? 5)
}
var RMt = class extends at {
  constructor() {
    super(...arguments),
      (this.c = this.D(new J())),
      (this.onViewsRegistered = this.c.event),
      (this.f = this.D(new J())),
      (this.onViewsDeregistered = this.f.event),
      (this.g = this.D(new J())),
      (this.onDidChangeContainer = this.g.event),
      (this.h = this.D(new J())),
      (this.onDidChangeViewWelcomeContent = this.h.event),
      (this.j = []),
      (this.m = new Map()),
      (this.n = new BV())
  }
  registerViews(i, t) {
    this.registerViews2([{ views: i, viewContainer: t }])
  }
  registerViews2(i) {
    i.forEach(({ views: t, viewContainer: e }) => this.q(t, e)), this.c.fire(i)
  }
  deregisterViews(i, t) {
    const e = this.r(i, t)
    e.length && this.f.fire({ views: e, viewContainer: t })
  }
  moveViews(i, t) {
    for (const e of this.m.keys())
      if (e !== t) {
        const s = this.r(i, e)
        s.length && (this.q(s, t), this.g.fire({ views: s, from: e, to: t }))
      }
  }
  getViews(i) {
    return this.m.get(i) || []
  }
  getView(i) {
    for (const t of this.j) {
      const e = (this.m.get(t) || []).filter((s) => s.id === i)[0]
      if (e) return e
    }
    return null
  }
  getViewContainer(i) {
    for (const t of this.j)
      if ((this.m.get(t) || []).filter((s) => s.id === i)[0]) return t
    return null
  }
  registerViewWelcomeContent(i, t) {
    return (
      this.n.add(i, t),
      this.h.fire(i),
      et(() => {
        this.n.delete(i, t), this.h.fire(i)
      })
    )
  }
  registerViewWelcomeContent2(i, t) {
    const e = new Map()
    for (const [s, r] of t)
      this.n.add(i, r),
        e.set(
          s,
          et(() => {
            this.n.delete(i, r), this.h.fire(i)
          }),
        )
    return this.h.fire(i), e
  }
  getViewWelcomeContent(i) {
    const t = []
    return this.n.forEach(i, (e) => t.push(e)), t.sort(LMt)
  }
  q(i, t) {
    let e = this.m.get(t)
    e || ((e = []), this.m.set(t, e), this.j.push(t))
    for (const s of i) {
      if (this.getView(s.id) !== null) throw new Error(g(4316, null, s.id))
      e.push(s)
    }
  }
  r(i, t) {
    const e = this.m.get(t)
    if (!e) return []
    const s = [],
      r = []
    for (const a of e) i.includes(a) ? s.push(a) : r.push(a)
    return (
      s.length &&
        (r.length
          ? this.m.set(t, r)
          : (this.m.delete(t), this.j.splice(this.j.indexOf(t), 1))),
      s
    )
  }
}
Si.add(P3.ViewsRegistry, new RMt())
var lZt = X("viewDescriptorService"),
  Ict
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"), (i[(i.Expand = 1)] = "Expand")
})(Ict || (Ict = {}))
var Pct
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Collapsed = 1)] = "Collapsed"),
    (i[(i.Expanded = 2)] = "Expanded")
})(Pct || (Pct = {}))
var Dn = class extends Error {
    constructor(i) {
      super(g(4317, null, i)), (this.name = "NoTreeViewError")
    }
    static is(i) {
      return !!i && i.name === "NoTreeViewError"
    }
  },
  DMt = class {
    constructor() {
      this.a = new Map()
    }
    removeDragOperationTransfer(i) {
      if (i && this.a.has(i)) {
        const t = this.a.get(i)
        return this.a.delete(i), t
      }
    }
    addDragOperationTransfer(i, t) {
      this.a.set(i, t)
    }
  }
function $ct(i, t) {
  if (_t(i)) return { label: i }
  if (i && typeof i == "object" && typeof i.label == "string") {
    let e
    return (
      Array.isArray(i.highlights) &&
        ((e = i.highlights.filter(
          (s) =>
            s.length === 2 &&
            typeof s[0] == "number" &&
            typeof s[1] == "number",
        )),
        (e = e.length ? e : void 0)),
      { label: i.label, highlights: e }
    )
  }
}
var FMt = class extends at {
    constructor(i, t, e) {
      super(),
        (this.f = i),
        (this.g = t),
        (this.h = e),
        (this.a = new Map()),
        (this.b = new DMt())
      function s(r) {
        return (
          r &&
          r.$treeViewId &&
          (r.$treeItemHandle || r.$selectedTreeItems || r.$focusedTreeItem)
        )
      }
      t.registerArgumentProcessor({
        processArgument: (r) =>
          s(r)
            ? this.q(r)
            : Array.isArray(r) && r.length > 0
              ? r.map((a) => (s(a) ? this.q(a) : a))
              : r,
      })
    }
    registerTreeDataProvider(i, t, e) {
      const s = this.createTreeView(i, { treeDataProvider: t }, e)
      return { dispose: () => s.dispose() }
    }
    createTreeView(i, t, e) {
      if (!t || !t.treeDataProvider)
        throw new Error("Options with treeDataProvider is mandatory")
      const s = t.dragAndDropController?.dropMimeTypes ?? [],
        r = t.dragAndDropController?.dragMimeTypes ?? [],
        a = !!t.dragAndDropController?.handleDrag,
        o = !!t.dragAndDropController?.handleDrop,
        c = this.m(i, t, e),
        l = {
          showCollapseAll: !!t.showCollapseAll,
          canSelectMany: !!t.canSelectMany,
          dropMimeTypes: s,
          dragMimeTypes: r,
          hasHandleDrag: a,
          hasHandleDrop: o,
          manuallyManageCheckboxes: !!t.manageCheckboxStateManually,
        },
        u = this.f.$registerTreeViewDataProvider(i, l),
        d = {
          get onDidCollapseElement() {
            return c.onDidCollapseElement
          },
          get onDidExpandElement() {
            return c.onDidExpandElement
          },
          get selection() {
            return c.selectedElements
          },
          get onDidChangeSelection() {
            return c.onDidChangeSelection
          },
          get activeItem() {
            return _(e, "treeViewActiveItem"), c.focusedElement
          },
          get onDidChangeActiveItem() {
            return _(e, "treeViewActiveItem"), c.onDidChangeActiveItem
          },
          get visible() {
            return c.visible
          },
          get onDidChangeVisibility() {
            return c.onDidChangeVisibility
          },
          get onDidChangeCheckboxState() {
            return c.onDidChangeCheckboxState
          },
          get message() {
            return c.message
          },
          set message(m) {
            to(m) && _(e, "treeViewMarkdownMessage"), (c.message = m)
          },
          get title() {
            return c.title
          },
          set title(m) {
            c.title = m
          },
          get description() {
            return c.description
          },
          set description(m) {
            c.description = m
          },
          get badge() {
            return c.badge
          },
          set badge(m) {
            m !== void 0 && Z2.isViewBadge(m)
              ? (c.badge = {
                  value: Math.floor(Math.abs(m.value)),
                  tooltip: m.tooltip,
                })
              : m === void 0 && (c.badge = void 0)
          },
          reveal: (m, f) => c.reveal(m, f),
          dispose: async () => {
            await u, this.a.delete(i), c.dispose()
          },
        }
      return this.D(d), d
    }
    async $getChildren(i, t) {
      const e = this.a.get(i)
      if (!e) return Promise.reject(new Dn(i))
      if (!t) {
        const r = await e.getChildren()
        return r ? [[0, ...r]] : void 0
      }
      const s = []
      for (let r = 0; r < t.length; r++) {
        const a = t[r],
          o = await e.getChildren(a)
        o && s.push([r, ...o])
      }
      return s
    }
    async $handleDrop(i, t, e, s, r, a, o, c) {
      const l = this.a.get(i)
      if (!l) return Promise.reject(new Dn(i))
      const u = pa.toDataTransfer(
        e,
        async (d) => (await this.f.$resolveDropFileData(i, t, d)).buffer,
      )
      return o === i && c && (await this.j(u, l, c, r, a)), l.onDrop(u, s, r)
    }
    async j(i, t, e, s, r) {
      const a = this.b.removeDragOperationTransfer(r)
      if (a)
        (await a)?.forEach((o, c) => {
          o && i.set(c, o)
        })
      else if (r && t.handleDrag) {
        const o = t.handleDrag(e, i, s)
        this.b.addDragOperationTransfer(r, o), await o
      }
      return i
    }
    async $handleDrag(i, t, e, s) {
      const r = this.a.get(i)
      if (!r) return Promise.reject(new Dn(i))
      const a = await this.j(new Uh(), r, t, s, e)
      if (!(!a || s.isCancellationRequested)) return pa.from(a)
    }
    async $hasResolve(i) {
      const t = this.a.get(i)
      if (!t) throw new Dn(i)
      return t.hasResolve
    }
    $resolve(i, t, e) {
      const s = this.a.get(i)
      if (!s) throw new Dn(i)
      return s.resolveTreeItem(t, e)
    }
    $setExpanded(i, t, e) {
      const s = this.a.get(i)
      if (!s) throw new Dn(i)
      s.setExpanded(t, e)
    }
    $setSelectionAndFocus(i, t, e) {
      const s = this.a.get(i)
      if (!s) throw new Dn(i)
      s.setSelectionAndFocus(t, e)
    }
    $setVisible(i, t) {
      const e = this.a.get(i)
      if (!e) {
        if (!t) return
        throw new Dn(i)
      }
      e.setVisible(t)
    }
    $changeCheckboxState(i, t) {
      const e = this.a.get(i)
      if (!e) throw new Dn(i)
      e.setCheckboxState(t)
    }
    m(i, t, e) {
      const s = this.D(new AMt(i, t, this.f, this.g.converter, this.h, e))
      return this.a.set(i, s), s
    }
    q(i) {
      const t = this.a.get(i.$treeViewId)
      return t && "$treeItemHandle" in i
        ? t.getExtensionElement(i.$treeItemHandle)
        : t && "$focusedTreeItem" in i && i.$focusedTreeItem
          ? t.focusedElement
          : null
    }
  },
  AMt = class EV extends at {
    static {
      this.a = "0"
    }
    static {
      this.b = "1"
    }
    get visible() {
      return this.q
    }
    get selectedElements() {
      return this.r
        .map((t) => this.getExtensionElement(t))
        .filter((t) => !Fe(t))
    }
    get focusedElement() {
      return this.s ? this.getExtensionElement(this.s) : void 0
    }
    constructor(t, e, s, r, a, o) {
      if (
        (super(),
        (this.I = t),
        (this.J = s),
        (this.L = r),
        (this.M = a),
        (this.N = o),
        (this.h = void 0),
        (this.j = new Map()),
        (this.m = new Map()),
        (this.q = !1),
        (this.r = []),
        (this.s = void 0),
        (this.t = this.D(new J())),
        (this.onDidExpandElement = this.t.event),
        (this.u = this.D(new J())),
        (this.onDidCollapseElement = this.u.event),
        (this.w = this.D(new J())),
        (this.onDidChangeSelection = this.w.event),
        (this.y = this.D(new J())),
        (this.onDidChangeActiveItem = this.y.event),
        (this.z = this.D(new J())),
        (this.onDidChangeVisibility = this.z.event),
        (this.C = this.D(new J())),
        (this.onDidChangeCheckboxState = this.C.event),
        (this.F = this.D(new J())),
        (this.G = Promise.resolve()),
        (this.H = Promise.resolve()),
        (this.O = ""),
        (this.P = ""),
        (this.Z = new fe()),
        o.contributes && o.contributes.views)
      )
        for (const d in o.contributes.views)
          for (const m of o.contributes.views[d])
            m.id === t && (this.P = m.name)
      ;(this.f = e.treeDataProvider),
        (this.g = e.dragAndDropController),
        this.f.onDidChangeTreeData &&
          this.D(
            this.f.onDidChangeTreeData((d) => {
              ;(Array.isArray(d) && d.length === 0) ||
                this.F.fire({ message: !1, element: d })
            }),
          )
      let c, l
      const u = Qt.debounce(
        this.F.event,
        (d, m) => (
          d || (d = { message: !1, elements: [] }),
          m.element !== !1 &&
            (c ||
              ((c = new Promise((f) => (l = f))),
              (this.G = this.G.then(() => c))),
            Array.isArray(m.element)
              ? d.elements.push(...m.element)
              : d.elements.push(m.element)),
          m.message && (d.message = !0),
          d
        ),
        200,
        !0,
      )
      this.D(
        u(({ message: d, elements: m }) => {
          m.length &&
            (this.H = this.H.then(() => {
              const f = l
              return (c = null), this.$(m).then(() => f())
            })),
            d && this.J.$setMessage(this.I, Dt.fromStrict(this.O) ?? "")
        }),
      )
    }
    async getChildren(t) {
      const e = t ? this.getExtensionElement(t) : void 0
      if (t && !e)
        return (
          this.M.error(`No tree item with id '${t}' found.`),
          Promise.resolve([])
        )
      let s = this.X(t)
      return s || (s = await this.Y(e)), s ? s.map((r) => r.item) : void 0
    }
    getExtensionElement(t) {
      return this.j.get(t)
    }
    reveal(t, e) {
      e = e || { select: !0, focus: !1 }
      const s = Fe(e.select) ? !0 : e.select,
        r = Fe(e.focus) ? !1 : e.focus,
        a = Fe(e.expand) ? !1 : e.expand
      return typeof this.f.getParent != "function"
        ? Promise.reject(
            new Error(
              "Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method",
            ),
          )
        : t
          ? this.G.then(() => this.S(t)).then(
              (o) =>
                this.W(t, o[o.length - 1]).then((c) =>
                  this.J.$reveal(
                    this.I,
                    { item: c.item, parentChain: o.map((l) => l.item) },
                    { select: s, focus: r, expand: a },
                  ),
                ),
              (o) => this.M.error(o),
            )
          : this.J.$reveal(this.I, void 0, { select: s, focus: r, expand: a })
    }
    get message() {
      return this.O
    }
    set message(t) {
      ;(this.O = t), this.F.fire({ message: !0, element: !1 })
    }
    get title() {
      return this.P
    }
    set title(t) {
      ;(this.P = t), this.J.$setTitle(this.I, t, this.Q)
    }
    get description() {
      return this.Q
    }
    set description(t) {
      ;(this.Q = t), this.J.$setTitle(this.I, this.P, t)
    }
    get badge() {
      return this.R
    }
    set badge(t) {
      ;(this.R?.value === t?.value && this.R?.tooltip === t?.tooltip) ||
        ((this.R = o8.from(t)), this.J.$setBadge(this.I, t))
    }
    setExpanded(t, e) {
      const s = this.getExtensionElement(t)
      s &&
        (e
          ? this.t.fire(Object.freeze({ element: s }))
          : this.u.fire(Object.freeze({ element: s })))
    }
    setSelectionAndFocus(t, e) {
      const s = !Er(this.r, t)
      this.r = t
      const r = this.s !== e
      ;(this.s = e),
        s && this.w.fire(Object.freeze({ selection: this.selectedElements })),
        r && this.y.fire(Object.freeze({ activeItem: this.focusedElement }))
    }
    setVisible(t) {
      t !== this.q &&
        ((this.q = t), this.z.fire(Object.freeze({ visible: this.q })))
    }
    async setCheckboxState(t) {
      const e = (
        await Promise.all(
          t.map(async (s) => {
            const r = this.getExtensionElement(s.treeItemHandle)
            return r
              ? {
                  extensionItem: r,
                  treeItem: await this.f.getTreeItem(r),
                  newState: s.newState ? _r.Checked : _r.Unchecked,
                }
              : Promise.resolve(void 0)
          }),
        )
      ).filter((s) => s !== void 0)
      e.forEach((s) => {
        s.treeItem.checkboxState = s.newState ? _r.Checked : _r.Unchecked
      }),
        this.C.fire({ items: e.map((s) => [s.extensionItem, s.newState]) })
    }
    async handleDrag(t, e, s) {
      const r = []
      for (const a of t) {
        const o = this.getExtensionElement(a)
        o && r.push(o)
      }
      if (!(!this.g?.handleDrag || r.length === 0))
        return await this.g.handleDrag(r, e, s), e
    }
    get hasHandleDrag() {
      return !!this.g?.handleDrag
    }
    async onDrop(t, e, s) {
      const r = e ? this.getExtensionElement(e) : void 0
      if (!((!r && e) || !this.g?.handleDrop))
        return Ci(() =>
          this.g?.handleDrop ? this.g.handleDrop(r, t, s) : void 0,
        )
    }
    get hasResolve() {
      return !!this.f.resolveTreeItem
    }
    async resolveTreeItem(t, e) {
      if (!this.f.resolveTreeItem) return
      const s = this.j.get(t)
      if (s) {
        const r = this.m.get(s)
        if (r) {
          const a =
            (await this.f.resolveTreeItem(r.extensionItem, s, e)) ??
            r.extensionItem
          return (
            this.hb(a),
            (r.item.tooltip = this.eb(a.tooltip)),
            (r.item.command = this.fb(r.disposableStore, a.command)),
            r.item
          )
        }
      }
    }
    S(t) {
      return this.U(t).then((e) =>
        e
          ? this.S(e).then((s) =>
              this.W(e, s[s.length - 1]).then((r) => (s.push(r), s)),
            )
          : Promise.resolve([]),
      )
    }
    U(t) {
      const e = this.m.get(t)
      return e
        ? Promise.resolve(e.parent ? this.j.get(e.parent.item.handle) : void 0)
        : Ci(() => this.f.getParent(t))
    }
    W(t, e) {
      const s = this.m.get(t)
      return s
        ? Promise.resolve(s)
        : Ci(() => this.f.getTreeItem(t))
            .then((r) => this.kb(t, r, e, !0))
            .then((r) =>
              this.getChildren(e ? e.item.handle : void 0).then(() => {
                const a = this.getExtensionElement(r)
                if (a) {
                  const o = this.m.get(a)
                  if (o) return Promise.resolve(o)
                }
                throw new Error(
                  `Cannot resolve tree item for element ${r} from extension ${this.N.identifier.value}`,
                )
              }),
            )
    }
    X(t) {
      if (t) {
        let e
        if (typeof t == "string") {
          const s = this.getExtensionElement(t)
          e = s ? this.m.get(s) : void 0
        } else e = t
        return (e && e.children) || void 0
      }
      return this.h
    }
    async Y(t) {
      this.rb(t)
      const e = new fe(this.Z.token)
      try {
        const s = t ? this.m.get(t) : void 0,
          r = await this.f.getChildren(t)
        if (e.token.isCancellationRequested) return
        const a = Ue(r || []),
          o = await Promise.all(Ue(a).map((l) => this.f.getTreeItem(l)))
        if (e.token.isCancellationRequested) return
        const c = o.map((l, u) => (l ? this.db(a[u], l, s) : null))
        return Ue(c)
      } finally {
        e.dispose()
      }
    }
    $(t) {
      if (t.some((s) => !s))
        return (
          this.Z.dispose(!0),
          (this.Z = new fe()),
          this.tb(),
          this.J.$refresh(this.I)
        )
      {
        const s = this.ab(t)
        if (s.length) return this.bb(s)
      }
      return Promise.resolve(void 0)
    }
    ab(t) {
      const e = new Set(),
        s = t.map((a) => this.m.get(a))
      for (const a of s)
        if (a && !e.has(a.item.handle)) {
          let o = a
          for (
            ;
            o &&
            o.parent &&
            s.findIndex(
              (c) =>
                o && o.parent && c && c.item.handle === o.parent.item.handle,
            ) === -1;

          ) {
            const c = this.j.get(o.parent.item.handle)
            o = c ? this.m.get(c) : void 0
          }
          o && !o.parent && e.add(a.item.handle)
        }
      const r = []
      return (
        e.forEach((a) => {
          const o = this.j.get(a)
          if (o) {
            const c = this.m.get(o)
            c && (!c.parent || !e.has(c.parent.item.handle)) && r.push(a)
          }
        }),
        r
      )
    }
    bb(t) {
      const e = {}
      return Promise.all(
        t.map((s) =>
          this.cb(s).then((r) => {
            r && (e[s] = r.item)
          }),
        ),
      ).then(() =>
        Object.keys(e).length ? this.J.$refresh(this.I, e) : void 0,
      )
    }
    cb(t) {
      const e = this.getExtensionElement(t)
      if (e) {
        const s = this.m.get(e)
        if (s)
          return (
            this.rb(e),
            Ci(() => this.f.getTreeItem(e)).then((r) => {
              if (r) {
                const a = this.ib(e, r, s.parent)
                return this.pb(e, a, s, s.parent), s.dispose(), a
              }
              return null
            })
          )
      }
      return Promise.resolve(null)
    }
    db(t, e, s) {
      const r = this.ib(t, e, s)
      if (e.id && this.j.has(r.item.handle))
        throw new Error(g(2772, null, e.id))
      return this.ob(t, r), this.qb(r, s), r
    }
    eb(t) {
      return ls.isMarkdownString(t) ? Dt.from(t) : t
    }
    fb(t, e) {
      return e ? { ...this.L.toInternal(e, t), originalId: e.command } : void 0
    }
    gb(t) {
      if (t.checkboxState === void 0) return
      let e, s, r
      return (
        typeof t.checkboxState == "number"
          ? (e = t.checkboxState)
          : ((e = t.checkboxState.state),
            (s = t.checkboxState.tooltip),
            (r = t.checkboxState.accessibilityInformation)),
        { isChecked: e === _r.Checked, tooltip: s, accessibilityInformation: r }
      )
    }
    hb(t) {
      if (!hO.isTreeItem(t, this.N))
        throw new Error(
          `Extension ${this.N.identifier.value} has provided an invalid tree item.`,
        )
    }
    ib(t, e, s) {
      this.hb(e)
      const r = this.D(new gt()),
        a = this.kb(t, e, s),
        o = this.lb(e)
      return {
        item: {
          handle: a,
          parentHandle: s ? s.item.handle : void 0,
          label: $ct(e.label, this.N),
          description: e.description,
          resourceUri: e.resourceUri,
          tooltip: this.eb(e.tooltip),
          command: this.fb(r, e.command),
          contextValue: e.contextValue,
          icon: o,
          iconDark: this.mb(e) || o,
          themeIcon: this.jb(e),
          collapsibleState: Fe(e.collapsibleState)
            ? bo.None
            : e.collapsibleState,
          accessibilityInformation: e.accessibilityInformation,
          checkbox: this.gb(e),
        },
        extensionItem: e,
        parent: s,
        children: void 0,
        disposableStore: r,
        dispose() {
          r.dispose()
        },
      }
    }
    jb(t) {
      return t.iconPath instanceof Ji ? t.iconPath : void 0
    }
    kb(t, { id: e, label: s, resourceUri: r }, a, o) {
      if (e) return `${EV.b}/${e}`
      const c = $ct(s, this.N),
        l = a ? a.item.handle : EV.a
      let u = c ? c.label : r ? xr(r) : ""
      u = u.indexOf("/") !== -1 ? u.replace("/", "//") : u
      const d = this.m.has(t) ? this.m.get(t).item.handle : void 0,
        m = this.X(a) || []
      let f,
        p = 0
      do {
        if (((f = `${l}/${p}:${u}`), o || !this.j.has(f) || d === f)) break
        p++
      } while (p <= m.length)
      return f
    }
    lb(t) {
      if (t.iconPath && !(t.iconPath instanceof Ji))
        return typeof t.iconPath == "string" || S.isUri(t.iconPath)
          ? this.nb(t.iconPath)
          : this.nb(t.iconPath.light)
    }
    mb(t) {
      if (t.iconPath && !(t.iconPath instanceof Ji) && t.iconPath.dark)
        return this.nb(t.iconPath.dark)
    }
    nb(t) {
      return S.isUri(t) ? t : S.file(t)
    }
    ob(t, e) {
      this.j.set(e.item.handle, t), this.m.set(t, e)
    }
    pb(t, e, s, r) {
      this.j.delete(e.item.handle),
        this.m.delete(t),
        e.item.handle !== s.item.handle && this.j.delete(s.item.handle),
        this.ob(t, e)
      const a = this.X(r) || [],
        o = a.filter((c) => c.item.handle === s.item.handle)[0]
      o && a.splice(a.indexOf(o), 1, e)
    }
    qb(t, e) {
      e
        ? (e.children || (e.children = []), e.children.push(t))
        : (this.h || (this.h = []), this.h.push(t))
    }
    rb(t) {
      if (t) {
        const e = this.m.get(t)
        if (e) {
          if (e.children)
            for (const s of e.children) {
              const r = this.j.get(s.item.handle)
              r && this.sb(r)
            }
          e.children = void 0
        }
      } else this.tb()
    }
    sb(t) {
      const e = this.m.get(t)
      if (e) {
        if (e.children)
          for (const s of e.children) {
            const r = this.j.get(s.item.handle)
            r && this.sb(r)
          }
        this.m.delete(t), this.j.delete(e.item.handle), e.dispose()
      }
    }
    tb() {
      ;(this.h = void 0),
        this.j.clear(),
        this.m.forEach((t) => t.dispose()),
        this.m.clear()
    }
    dispose() {
      super.dispose(), this.Z.dispose(), this.tb(), this.J.$disposeTree(this.I)
    }
  },
  _Mt = class Out {
    static {
      this.a = new Set([G.http, G.https])
    }
    constructor(t) {
      ;(this.c = new Map()), (this.b = t.getProxy(K.MainThreadUriOpeners))
    }
    registerExternalUriOpener(t, e, s, r) {
      if (this.c.has(e))
        throw new Error(`Opener with id '${e}' already registered`)
      const a = r.schemes.find((o) => !Out.a.has(o))
      if (a)
        throw new Error(
          `Scheme '${a}' is not supported. Only http and https are currently supported.`,
        )
      return (
        this.c.set(e, s),
        this.b.$registerUriOpener(e, r.schemes, t, r.label),
        et(() => {
          this.c.delete(e), this.b.$unregisterUriOpener(e)
        })
      )
    }
    async $canOpenUri(t, e, s) {
      const r = this.c.get(t)
      if (!r) throw new Error(`Unknown opener with id: ${t}`)
      const a = S.revive(e)
      return r.canOpenExternalUri(a, s)
    }
    async $openUri(t, e, s) {
      const r = this.c.get(t)
      if (!r) throw new Error(`Unknown opener id: '${t}'`)
      return r.openExternalUri(
        S.revive(e.resolvedUri),
        { sourceUri: S.revive(e.sourceUri) },
        s,
      )
    }
  },
  OMt = class But {
    static {
      this.a = 0
    }
    constructor(t) {
      ;(this.c = new no()),
        (this.d = new Map()),
        (this.b = t.getProxy(K.MainThreadUrls))
    }
    registerUriHandler(t, e) {
      const s = t.identifier
      if (this.c.has(s))
        throw new Error(
          `Protocol handler already registered for extension ${s}`,
        )
      const r = But.a++
      return (
        this.c.add(s),
        this.d.set(r, e),
        this.b.$registerUriHandler(r, s, t.displayName || t.name),
        et(() => {
          this.c.delete(s), this.d.delete(r), this.b.$unregisterUriHandler(r)
        })
      )
    }
    $handleExternalUri(t, e) {
      const s = this.d.get(t)
      if (!s) return Promise.resolve(void 0)
      try {
        s.handleUri(S.revive(e))
      } catch (r) {
        $e(r)
      }
      return Promise.resolve(void 0)
    }
    async createAppUri(t) {
      return S.revive(await this.b.$createAppUri(t))
    }
  },
  BMt = class extends at {
    #t
    #e
    #i
    #s
    #n
    #r
    #o
    #a
    #c
    #l
    #u
    #d
    #h
    constructor(i, t, e, s) {
      super(),
        (this.#a = void 0),
        (this.#c = !0),
        (this.#u = !1),
        (this.#d = this.D(new J())),
        (this.onDidDispose = this.#d.event),
        (this.#h = this.D(new J())),
        (this.onDidChangeViewState = this.#h.event),
        (this.#t = i),
        (this.#e = t),
        (this.#s = e),
        (this.#i = s.viewType),
        (this.#n = s.panelOptions),
        (this.#a = s.viewColumn),
        (this.#r = s.title),
        (this.#l = s.active)
    }
    dispose() {
      this.#u ||
        ((this.#u = !0),
        this.#d.fire(),
        this.#e.$disposeWebview(this.#t),
        this.#s.dispose(),
        super.dispose())
    }
    get webview() {
      return this.c(), this.#s
    }
    get viewType() {
      return this.c(), this.#i
    }
    get title() {
      return this.c(), this.#r
    }
    set title(i) {
      this.c(), this.#r !== i && ((this.#r = i), this.#e.$setTitle(this.#t, i))
    }
    get iconPath() {
      return this.c(), this.#o
    }
    set iconPath(i) {
      this.c(),
        this.#o !== i &&
          ((this.#o = i),
          this.#e.$setIconPath(this.#t, S.isUri(i) ? { light: i, dark: i } : i))
    }
    get options() {
      return this.#n
    }
    get viewColumn() {
      if ((this.c(), !(typeof this.#a == "number" && this.#a < 0)))
        return this.#a
    }
    get active() {
      return this.c(), this.#l
    }
    get visible() {
      return this.c(), this.#c
    }
    _updateViewState(i) {
      this.#u ||
        ((this.active !== i.active ||
          this.visible !== i.visible ||
          this.viewColumn !== i.viewColumn) &&
          ((this.#l = i.active),
          (this.#c = i.visible),
          (this.#a = i.viewColumn),
          this.#h.fire({ webviewPanel: this })))
    }
    reveal(i, t) {
      this.c(),
        this.#e.$reveal(this.#t, {
          viewColumn: typeof i > "u" ? void 0 : ii.from(i),
          preserveFocus: !!t,
        })
    }
    c() {
      if (this.#u) throw new Error("Webview is disposed")
    }
  },
  qMt = class qut extends at {
    static c() {
      return Ze()
    }
    constructor(t, e, s) {
      super(),
        (this.j = e),
        (this.m = s),
        (this.g = new Map()),
        (this.h = new Map()),
        (this.f = t.getProxy(K.MainThreadWebviewPanels))
    }
    dispose() {
      super.dispose(), this.g.forEach((t) => t.dispose()), this.g.clear()
    }
    createWebviewPanel(t, e, s, r, a = {}) {
      const o = typeof r == "object" ? r.viewColumn : r,
        c = {
          viewColumn: ii.from(o),
          preserveFocus: typeof r == "object" && !!r.preserveFocus,
        },
        l = Vl(t),
        u = qut.c()
      this.f.$createWebviewPanel(
        h3(t),
        u,
        e,
        {
          title: s,
          panelOptions: UMt(a),
          webviewOptions: $ot(t, this.m, a),
          serializeBuffersForPostMessage: l,
        },
        c,
      )
      const d = this.j.createNewWebview(u, a, t)
      return this.createNewWebviewPanel(u, e, s, o, a, d, !0)
    }
    $onDidChangeWebviewPanelViewStates(t) {
      const e = Object.keys(t)
      e.sort((s, r) => {
        const a = t[s],
          o = t[r]
        return a.active ? 1 : o.active ? -1 : +a.visible - +o.visible
      })
      for (const s of e) {
        const r = this.getWebviewPanel(s)
        if (!r) continue
        const a = t[s]
        r._updateViewState({
          active: a.active,
          visible: a.visible,
          viewColumn: ii.to(a.position),
        })
      }
    }
    async $onDidDisposeWebviewPanel(t) {
      this.getWebviewPanel(t)?.dispose(),
        this.g.delete(t),
        this.j.deleteWebview(t)
    }
    registerWebviewPanelSerializer(t, e, s) {
      if (this.h.has(e))
        throw new Error(`Serializer for '${e}' already registered`)
      return (
        this.h.set(e, { serializer: s, extension: t }),
        this.f.$registerSerializer(e, {
          serializeBuffersForPostMessage: Vl(t),
        }),
        new Ht(() => {
          this.h.delete(e), this.f.$unregisterSerializer(e)
        })
      )
    }
    async $deserializeWebviewPanel(t, e, s, r) {
      const a = this.h.get(e)
      if (!a) throw new Error(`No serializer found for '${e}'`)
      const { serializer: o, extension: c } = a,
        l = this.j.createNewWebview(t, s.webviewOptions, c),
        u = this.createNewWebviewPanel(
          t,
          e,
          s.title,
          r,
          s.panelOptions,
          l,
          s.active,
        )
      await o.deserializeWebviewPanel(u, s.state)
    }
    createNewWebviewPanel(t, e, s, r, a, o, c) {
      const l = new BMt(t, this.f, o, {
        viewType: e,
        title: s,
        viewColumn: r,
        panelOptions: a,
        active: c,
      })
      return this.g.set(t, l), l
    }
    getWebviewPanel(t) {
      return this.g.get(t)
    }
  }
function UMt(i) {
  return {
    enableFindWidget: i.enableFindWidget,
    retainContextWhenHidden: i.retainContextWhenHidden,
  }
}
var MMt = class extends at {
    #t
    #e
    #i
    #s
    #n
    #r
    #o
    #a
    #c
    constructor(i, t, e, s, r, a) {
      super(),
        (this.#n = !1),
        (this.#l = this.D(new J())),
        (this.onDidChangeVisibility = this.#l.event),
        (this.#u = this.D(new J())),
        (this.onDidDispose = this.#u.event),
        (this.#i = e),
        (this.#o = s),
        (this.#t = i),
        (this.#e = t),
        (this.#s = r),
        (this.#r = a)
    }
    dispose() {
      this.#n ||
        ((this.#n = !0), this.#u.fire(), this.#s.dispose(), super.dispose())
    }
    #l
    #u
    get title() {
      return this.a(), this.#o
    }
    set title(i) {
      this.a(),
        this.#o !== i &&
          ((this.#o = i), this.#e.$setWebviewViewTitle(this.#t, i))
    }
    get description() {
      return this.a(), this.#a
    }
    set description(i) {
      this.a(),
        this.#a !== i &&
          ((this.#a = i), this.#e.$setWebviewViewDescription(this.#t, i))
    }
    get visible() {
      return this.#r
    }
    get webview() {
      return this.#s
    }
    get viewType() {
      return this.#i
    }
    _setVisible(i) {
      i === this.#r || this.#n || ((this.#r = i), this.#l.fire())
    }
    get badge() {
      return this.a(), this.#c
    }
    set badge(i) {
      this.a(),
        !(i?.value === this.#c?.value && i?.tooltip === this.#c?.tooltip) &&
          ((this.#c = o8.from(i)), this.#e.$setWebviewViewBadge(this.#t, i))
    }
    show(i) {
      this.a(), this.#e.$show(this.#t, !!i)
    }
    a() {
      if (this.#n) throw new Error("Webview is disposed")
    }
  },
  HMt = class {
    constructor(i, t) {
      ;(this.d = t),
        (this.b = new Map()),
        (this.c = new Map()),
        (this.a = i.getProxy(K.MainThreadWebviewViews))
    }
    registerWebviewViewProvider(i, t, e, s) {
      if (this.b.has(t))
        throw new Error(`View provider for '${t}' already registered`)
      return (
        this.b.set(t, { provider: e, extension: i }),
        this.a.$registerWebviewViewProvider(h3(i), t, {
          retainContextWhenHidden: s?.retainContextWhenHidden,
          serializeBuffersForPostMessage: Vl(i),
        }),
        new Ht(() => {
          this.b.delete(t), this.a.$unregisterWebviewViewProvider(t)
        })
      )
    }
    async $resolveWebviewView(i, t, e, s, r) {
      const a = this.b.get(t)
      if (!a) throw new Error(`No view provider found for '${t}'`)
      const { provider: o, extension: c } = a,
        l = this.d.createNewWebview(i, {}, c),
        u = new MMt(i, this.a, t, e, l, !0)
      this.c.set(i, u), await o.resolveWebviewView(u, { state: s }, r)
    }
    async $onDidChangeWebviewViewVisibility(i, t) {
      this.e(i)._setVisible(t)
    }
    async $disposeWebviewView(i) {
      const t = this.e(i)
      this.c.delete(i), t.dispose(), this.d.deleteWebview(i)
    }
    e(i) {
      const t = this.c.get(i)
      if (!t) throw new Error("No webview found")
      return t
    }
  },
  uZt = new W("debugType", void 0, {
    type: "string",
    description: g(6138, null),
  }),
  hZt = new W("debugConfigurationType", void 0, {
    type: "string",
    description: g(6139, null),
  }),
  dZt = new W("debugState", "inactive", {
    type: "string",
    description: g(6140, null),
  }),
  mZt = new W("debugRecordingState", !1, {
    type: "string",
    description: g(6141, null),
  }),
  WMt = "debugUx",
  fZt = new W(WMt, "default", { type: "string", description: g(6142, null) }),
  pZt = new W("hasDebugged", !1, {
    type: "boolean",
    description: g(6143, null),
  }),
  gZt = new W("inDebugMode", !1, {
    type: "boolean",
    description: g(6144, null),
  }),
  vZt = new W("inDebugRepl", !1, {
    type: "boolean",
    description: g(6145, null),
  }),
  wZt = new W("breakpointWidgetVisible", !1, {
    type: "boolean",
    description: g(6146, null),
  }),
  yZt = new W("inBreakpointWidget", !1, {
    type: "boolean",
    description: g(6147, null),
  }),
  bZt = new W("breakpointsFocused", !0, {
    type: "boolean",
    description: g(6148, null),
  }),
  TZt = new W("watchExpressionsFocused", !0, {
    type: "boolean",
    description: g(6149, null),
  }),
  kZt = new W("watchExpressionsExist", !1, {
    type: "boolean",
    description: g(6150, null),
  }),
  SZt = new W("variablesFocused", !0, {
    type: "boolean",
    description: g(6151, null),
  }),
  EZt = new W("expressionSelected", !1, {
    type: "boolean",
    description: g(6152, null),
  }),
  IZt = new W("breakpointInputFocused", !1, {
    type: "boolean",
    description: g(6153, null),
  }),
  PZt = new W("callStackItemType", void 0, {
    type: "string",
    description: g(6154, null),
  }),
  $Zt = new W("callStackSessionIsAttach", !1, {
    type: "boolean",
    description: g(6155, null),
  }),
  xZt = new W("callStackItemStopped", !1, {
    type: "boolean",
    description: g(6156, null),
  }),
  NZt = new W("callStackSessionHasOneThread", !1, {
    type: "boolean",
    description: g(6157, null),
  }),
  CZt = new W("callStackFocused", !0, {
    type: "boolean",
    description: g(6158, null),
  }),
  JZt = new W("watchItemType", void 0, {
    type: "string",
    description: g(6159, null),
  }),
  LZt = new W("canViewMemory", void 0, {
    type: "boolean",
    description: g(6160, null),
  }),
  RZt = new W("breakpointItemType", void 0, {
    type: "string",
    description: g(6161, null),
  }),
  DZt = new W("breakpointItemBytes", void 0, {
    type: "boolean",
    description: g(6162, null),
  }),
  FZt = new W("breakpointHasModes", !1, {
    type: "boolean",
    description: g(6163, null),
  }),
  AZt = new W("breakpointSupportsCondition", !1, {
    type: "boolean",
    description: g(6164, null),
  }),
  _Zt = new W("loadedScriptsSupported", !1, {
    type: "boolean",
    description: g(6165, null),
  }),
  OZt = new W("loadedScriptsItemType", void 0, {
    type: "string",
    description: g(6166, null),
  }),
  BZt = new W("focusedSessionIsAttach", !1, {
    type: "boolean",
    description: g(6167, null),
  }),
  qZt = new W("focusedSessionIsNoDebug", !1, {
    type: "boolean",
    description: g(6168, null),
  }),
  UZt = new W("stepBackSupported", !1, {
    type: "boolean",
    description: g(6169, null),
  }),
  MZt = new W("restartFrameSupported", !1, {
    type: "boolean",
    description: g(6170, null),
  }),
  HZt = new W("stackFrameSupportsRestart", !1, {
    type: "boolean",
    description: g(6171, null),
  }),
  WZt = new W("jumpToCursorSupported", !1, {
    type: "boolean",
    description: g(6172, null),
  }),
  jZt = new W("stepIntoTargetsSupported", !1, {
    type: "boolean",
    description: g(6173, null),
  }),
  VZt = new W("breakpointsExist", !1, {
    type: "boolean",
    description: g(6174, null),
  }),
  GZt = new W("debuggersAvailable", !1, {
    type: "boolean",
    description: g(6175, null),
  }),
  zZt = new W("debugExtensionAvailable", !0, {
    type: "boolean",
    description: g(6176, null),
  }),
  YZt = new W("debugProtocolVariableMenuContext", void 0, {
    type: "string",
    description: g(6177, null),
  }),
  QZt = new W("debugSetVariableSupported", !1, {
    type: "boolean",
    description: g(6178, null),
  }),
  XZt = new W("debugSetDataBreakpointAddressSupported", !1, {
    type: "boolean",
    description: g(6179, null),
  }),
  KZt = new W("debugSetExpressionSupported", !1, {
    type: "boolean",
    description: g(6180, null),
  }),
  ZZt = new W("breakWhenValueChangesSupported", !1, {
    type: "boolean",
    description: g(6181, null),
  }),
  tte = new W("breakWhenValueIsAccessedSupported", !1, {
    type: "boolean",
    description: g(6182, null),
  }),
  ete = new W("breakWhenValueIsReadSupported", !1, {
    type: "boolean",
    description: g(6183, null),
  }),
  ite = new W("terminateDebuggeeSupported", !1, {
    type: "boolean",
    description: g(6184, null),
  }),
  ste = new W("suspendDebuggeeSupported", !1, {
    type: "boolean",
    description: g(6185, null),
  }),
  rte = new W("variableEvaluateNamePresent", !1, {
    type: "boolean",
    description: g(6186, null),
  }),
  nte = new W("variableIsReadonly", !1, {
    type: "boolean",
    description: g(6187, null),
  }),
  ate = new W("variableValue", !1, {
    type: "string",
    description: g(6188, null),
  }),
  ote = new W("variableType", !1, {
    type: "string",
    description: g(6189, null),
  }),
  cte = new W("variableInterfaces", !1, {
    type: "array",
    description: g(6190, null),
  }),
  lte = new W("variableName", !1, {
    type: "string",
    description: g(6191, null),
  }),
  ute = new W("variableLanguage", !1, {
    type: "string",
    description: g(6192, null),
  }),
  hte = new W("variableExtensionId", !1, {
    type: "string",
    description: g(6193, null),
  }),
  dte = new W("exceptionWidgetVisible", !1, {
    type: "boolean",
    description: g(6194, null),
  }),
  mte = new W("multiSessionRepl", !1, {
    type: "boolean",
    description: g(6195, null),
  }),
  fte = new W("multiSessionDebug", !1, {
    type: "boolean",
    description: g(6196, null),
  }),
  pte = new W("disassembleRequestSupported", !1, {
    type: "boolean",
    description: g(6197, null),
  }),
  gte = new W("disassemblyViewFocus", !1, {
    type: "boolean",
    description: g(6198, null),
  }),
  vte = new W("languageSupportsDisassembleRequest", !1, {
    type: "boolean",
    description: g(6199, null),
  }),
  wte = new W("focusedStackFrameHasInstructionReference", !1, {
    type: "boolean",
    description: g(6200, null),
  }),
  yte = {
    enum: ["neverOpen", "openOnSessionStart", "openOnFirstSessionStart"],
    default: "openOnFirstSessionStart",
    description: g(6202, null),
  },
  xct
;(function (i) {
  ;(i[(i.Inactive = 0)] = "Inactive"),
    (i[(i.Initializing = 1)] = "Initializing"),
    (i[(i.Stopped = 2)] = "Stopped"),
    (i[(i.Running = 3)] = "Running")
})(xct || (xct = {}))
var Nct
;(function (i) {
  ;(i[(i.Valid = 0)] = "Valid"),
    (i[(i.Unreadable = 1)] = "Unreadable"),
    (i[(i.Error = 2)] = "Error")
})(Nct || (Nct = {}))
var Cct
;(function (i) {
  ;(i[(i.Variable = 0)] = "Variable"), (i[(i.Address = 1)] = "Address")
})(Cct || (Cct = {}))
var x3
;(function (i) {
  ;(i[(i.Initial = 1)] = "Initial"), (i[(i.Dynamic = 2)] = "Dynamic")
})(x3 || (x3 = {}))
var Jct
;(function (i) {
  i.UnverifiedBreakpoints = "unverifiedBreakpoints"
})(Jct || (Jct = {}))
var bte = X("debugService"),
  Lct
;(function (i) {
  ;(i[(i.CONDITION = 0)] = "CONDITION"),
    (i[(i.HIT_COUNT = 1)] = "HIT_COUNT"),
    (i[(i.LOG_MESSAGE = 2)] = "LOG_MESSAGE"),
    (i[(i.TRIGGER_POINT = 3)] = "TRIGGER_POINT")
})(Lct || (Lct = {}))
var Rct
;(function (i) {
  ;(i[(i.Command = 0)] = "Command"), (i[(i.Tree = 1)] = "Tree")
})(Rct || (Rct = {}))
var Dct
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Collapsed = 1)] = "Collapsed"),
    (i[(i.Expanded = 2)] = "Expanded")
})(Dct || (Dct = {}))
var Fct
;(function (i) {
  ;(i.deserialize = (t) => t), (i.serialize = (t) => t)
})(Fct || (Fct = {}))
var Act
;(function (i) {
  ;(i.deserialize = (t) => ({
    id: t.id,
    name: t.name,
    iconPath: t.iconPath && {
      light: S.revive(t.iconPath.light),
      dark: S.revive(t.iconPath.dark),
    },
    iconClass: t.iconClass,
    visualization: t.visualization,
  })),
    (i.serialize = (t) => t)
})(Act || (Act = {}))
var jMt = class Uut {
  static {
    this.a = 0
  }
  constructor(t) {
    ;(this.c = new Map()), (this.b = t.getProxy(K.MainThreadCodeMapper))
  }
  async $mapCode(t, e, s) {
    const r = this.c.get(t)
    if (!r)
      throw new Error(
        `Received request to map code for unknown provider handle ${t}`,
      )
    const a = {
        textEdit: (l, u) => {
          ;(u = Array.isArray(u) ? u : [u]),
            this.b.$handleProgress(e.requestId, {
              uri: l,
              edits: u.map(si.from),
            })
        },
      },
      o = {
        codeBlocks: e.codeBlocks.map((l) => ({
          code: l.code,
          resource: S.revive(l.resource),
          markdownBeforeBlock: l.markdownBeforeBlock,
        })),
        conversation: e.conversation.map((l) =>
          l.type === "request"
            ? { type: "request", message: l.message }
            : {
                type: "response",
                message: l.message,
                result: l.result ? ga.to(l.result) : void 0,
                references: l.references?.map(yl.to),
              },
        ),
      }
    return (await r.provideMappedEdits(o, a, s)) ?? null
  }
  registerMappedEditsProvider(t, e) {
    const s = Uut.a++
    return (
      this.b.$registerCodeMapperProvider(s),
      this.c.set(s, e),
      { dispose: () => this.b.$unregisterCodeMapperProvider(s) }
    )
  }
}
function VMt(i) {
  const t = i.get(ti),
    e = i.get(Nc),
    s = i.get(im),
    r = i.get($n),
    a = i.get(dr),
    o = i.get(dB),
    c = i.get(Ds),
    l = i.get(ah),
    u = i.get(Ot),
    d = i.get(tH),
    m = i.get(iH),
    f = i.get($c),
    p = i.get(Rt),
    v = i.get(uB),
    b = i.get(um),
    k = i.get(trt),
    E = i.get(SH),
    P = i.get(Bl),
    C = i.get(PH),
    R = i.get(mH),
    D = i.get(pH),
    V = i.get(ert)
  u.set(lt.ExtHostFileSystemInfo, e),
    u.set(lt.ExtHostLogLevelServiceShape, f),
    u.set(lt.ExtHostWorkspace, a),
    u.set(lt.ExtHostConfiguration, c),
    u.set(lt.ExtHostExtensionService, r),
    u.set(lt.ExtHostStorage, d),
    u.set(lt.ExtHostTunnelService, v),
    u.set(lt.ExtHostWindow, k),
    u.set(lt.ExtHostSecretState, E),
    u.set(lt.ExtHostTelemetry, o),
    u.set(lt.ExtHostEditorTabs, P),
    u.set(lt.ExtHostManagedSockets, C),
    u.set(lt.ExtHostAuthentication, R),
    u.set(lt.ExtHostChatProvider, D)
  const tt = u.set(lt.ExtHostDecorations, i.get(kst)),
    Z = u.set(lt.ExtHostDocumentsAndEditors, i.get(Fo)),
    M = u.set(lt.ExtHostCommands, i.get(mr)),
    rt = u.set(lt.ExtHostTerminalService, i.get(Pn)),
    Jt = u.set(lt.ExtHostTerminalShellIntegration, i.get(rW)),
    ct = u.set(lt.ExtHostDebugService, i.get(KH)),
    me = u.set(lt.ExtHostSearch, i.get(eW)),
    j = u.set(lt.ExtHostTask, i.get(YH)),
    z = u.set(lt.ExtHostOutputService, i.get(Tst)),
    ot = u.set(lt.ExtHostLocalization, i.get(IH)),
    it = u.set(lt.ExtHostUrls, new OMt(u)),
    nt = u.set(lt.ExtHostDocuments, new sUt(u, Z)),
    $t = u.set(lt.ExtHostDocumentContentProviders, new eUt(u, Z, p)),
    Bt = u.set(
      lt.ExtHostDocumentSaveParticipant,
      new iUt(p, nt, u.getProxy(K.MainThreadBulkEdits)),
    ),
    xt = u.set(lt.ExtHostNotebook, new KUt(u, M, Z, nt, s, me, p)),
    oe = u.set(lt.ExtHostNotebookDocuments, new tMt(xt)),
    mi = u.set(lt.ExtHostNotebookEditors, new wj(p, xt)),
    Ce = u.set(lt.ExtHostNotebookKernels, new yj(u, t, xt, M, p)),
    wi = u.set(lt.ExtHostNotebookRenderers, new aMt(u, xt)),
    Ri = u.set(
      lt.ExtHostNotebookDocumentSaveParticipant,
      new ZUt(p, xt, u.getProxy(K.MainThreadBulkEdits)),
    ),
    ye = u.set(lt.ExtHostEditors, new PMt(u, Z)),
    Vr = u.set(
      lt.ExtHostTreeViews,
      new FMt(u.getProxy(K.MainThreadTreeViews), M, p),
    ),
    ec = u.set(
      lt.ExtHostEditorInsets,
      new l9t(u.getProxy(K.MainThreadEditorInsets), ye, t.remote),
    ),
    Fa = u.set(lt.ExtHostDiagnostics, new QW(u, p, e, Z)),
    Is = u.set(lt.ExtHostLanguages, new NUt(u, nt, M.converter, l)),
    Ct = u.set(lt.ExtHostLanguageFeatures, new PUt(u, l, nt, M, Fa, p, b, o)),
    te = u.set(lt.ExtHostCodeMapper, new jMt(u)),
    n_ = u.set(lt.ExtHostFileSystem, new hUt(u, Ct)),
    is = u.set(lt.ExtHostFileSystemEventService, new TUt(u, p, Z)),
    qi = u.set(lt.ExtHostQuickOpen, hMt(u, a, M)),
    Gr = u.set(lt.ExtHostSCM, new Ij(u, M, nt, p)),
    ic = u.set(lt.ExtHostQuickDiff, new uMt(u, l)),
    Eu = u.set(lt.ExtHostShare, new TMt(u, l)),
    a_ = u.set(lt.ExtHostComments, u9t(u, M, nt)),
    sc = u.set(lt.ExtHostProgress, new cMt(u.getProxy(K.MainThreadProgress))),
    Iu = u.set(lt.ExtHostLabelService, new SUt(u)),
    Aa = u.set(lt.ExtHostTheming, new Pj(u)),
    bt = u.set(lt.ExtHostCursor, new F2t(u, V, p)),
    _a = u.set(lt.ExtHostTimeline, new $Mt(u, M)),
    Pe = u.set(lt.ExtHostWebviews, new W2t(u, t.remote, a, p, b)),
    fi = u.set(lt.ExtHostWebviewPanels, new qMt(u, Pe, a)),
    s7 = u.set(lt.ExtHostCustomEditors, new Q2t(u, nt, m, Pe, fi)),
    r7 = u.set(lt.ExtHostWebviewViews, new HMt(u, Pe)),
    Us = u.set(lt.ExtHostTesting, i.get(gm)),
    Pu = u.set(lt.ExtHostUriOpeners, new _Mt(u)),
    N = u.set(lt.ExtHostProfileContentHandlers, new oMt(u))
  u.set(lt.ExtHostInteractive, new kUt(u, xt, Z, M, p))
  const A = u.set(lt.ExtHostChatAgents2, new e9t(u, p, M, nt, D)),
    q = u.set(lt.ExtHostChatVariables, new r9t(u)),
    mt = u.set(lt.ExtHostLanguageModelTools, new xUt(u)),
    It = u.set(lt.ExtHostAiRelatedInformation, new GNt(u)),
    ai = u.set(lt.ExtHostAiEmbeddingVector, new nUt(u)),
    Zt = u.set(lt.ExtHostStatusBar, new IMt(u, M.converter)),
    Di = u.set(lt.ExtHostSpeech, new kMt(u)),
    Te = u.set(lt.ExtHostEmbeddings, new rUt(u)),
    yi = Object.values(lt)
  u.assertRegistered(yi)
  const Ps = new IW(u, Z),
    Be = new a9t(u),
    Qe = new aj(u, p),
    Ni = new tUt(u)
  return (
    KNt.register(M),
    function ($, Et, At) {
      function Y(y) {
        return (T, x, ft) => {
          const ee = y((qe) => {
            try {
              T.call(x, qe)
            } catch ($u) {
              l7(
                new Error(
                  `[ExtensionListenerError] Extension '${$.identifier.value}' FAILED to handle event: ${$u.toString()}`,
                  { cause: $u },
                ),
              ),
                o.onExtensionError($.identifier, $u)
            }
          })
          return ft?.push(ee), ee
        }
      }
      const kt = (function () {
        let y = !$.isUnderDevelopment
        function T() {
          y ||
            (p.info(
              `Extension '${$.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`,
            ),
            (y = !0))
        }
        return function x(ft) {
          if (Array.isArray(ft)) ft.forEach(x)
          else if (typeof ft == "string") T()
          else {
            const ee = ft
            typeof ee.scheme > "u" && T(),
              typeof ee.exclusive == "boolean" &&
                _($, "documentFiltersExclusive")
          }
          return ft
        }
      })()
      function Xe(y, T, ...x) {
        return _($, y), T(...x)
      }
      const $s = {
        get onDidChangeCursorCreds() {
          return bt.onDidChangeCursorCreds
        },
        get productCommit() {
          return t.commit
        },
        get rendererPerformanceTimeOrigin() {
          return t.rendererPerformanceTimeOrigin
        },
        get onDidChangePrivacyMode() {
          return bt.onDidChangePrivacyMode
        },
        get onDidChangeCursorAuthToken() {
          return bt.onDidChangeCursorAuthToken
        },
        get onDidRequestRepoIndex() {
          return bt.onDidRequestRepoIndex
        },
        get onDidRequestRepoInterrupt() {
          return bt.onDidRequestRepoInterrupt
        },
        get onDidChangeFileSyncClientEnabled() {
          return bt.onDidChangeFileSyncClientEnabled
        },
        get onDidChangeCppEnabled() {
          return bt.onDidChangeCppEnabled
        },
        get onDidChangeCppConfig() {
          return bt.onDidChangeCppConfig
        },
        get onDidChangeMembershipType() {
          return bt.onDidChangeMembershipType
        },
        triggerRefreshCursorAuthToken: () => bt.triggerRefreshCursorAuthToken(),
        onDidChangeIndexingStatus: () => bt.onDidChangeIndexingStatus(),
        getCppSessionId: () => bt.getCppSessionId(),
        getCppTelemEnabled: () => bt.getCppTelemEnabled(),
        getCursorCreds: () => bt.getCursorCreds(),
        getPrivacyMode: () => bt.getPrivacyMode(),
        isFileSyncClientEnabled: () => bt.isFileSyncClientEnabled(),
        cppEnabled: () => bt.cppEnabled(),
        cppConfig: () => bt.cppConfig(),
        membershipType: () => bt.membershipType(),
        preferredEmbeddingModel: () => bt.preferredEmbeddingModel(),
        shouldIndexNewRepos: () => bt.shouldIndex(),
        getCursorAuthToken: () => bt.getCursorAuthToken(),
        updateUploadProgress(y, T, x = !1) {
          return bt.updateUploadProgress(y, T, x)
        },
        showWebCmdKInputBox(y) {
          return bt.showWebCmdKInputBox(y)
        },
        processAiReaderMessage(y) {
          return bt.processAiReaderMessage(y)
        },
        registerIndexProvider(y) {
          return bt.registerIndexProvider(y)
        },
        registerExtHostEventLogger(y) {
          return bt.registerExtHostEventLogger(y)
        },
        registerRequesterProvider(y) {
          return bt.registerRequesterProvider(y)
        },
        registerShadowClientProvider(y) {
          return bt.registerShadowClientProvider(y)
        },
        registerShadowServerProvider(y) {
          return bt.registerShadowServerProvider(y)
        },
        registerMetricsProvider(y) {
          return bt.registerMetricsProvider(y)
        },
        registerDiffingProvider(y) {
          return bt.registerDiffingProvider(y)
        },
        registerEverythingProvider(y) {
          return bt.registerEverythingProvider(y)
        },
        registerEverythingProviderAllLocal(y) {
          return bt.registerEverythingProviderAllLocal(y)
        },
        registerEditHistoryProvider(y) {
          return bt.registerEditHistoryProvider(y)
        },
        registerLspSubgraphProvider(y) {
          return bt.registerLspSubgraphProvider(y)
        },
        registerConnectTransportProvider: (y) =>
          bt.registerConnectTransportProvider(y),
        getAllRequestHeadersExceptAccessToken: (y) => {
          VNt({
            req: y.req,
            machineId: bt.getMachineId() ?? o_.machineId,
            macMachineId: bt.getMacMachineId() ?? o_.macMachineId,
            base64Fn: (T) => Yu(Q.wrap(T), !1, !0),
            cursorVersion: t.version,
            privacyMode: bt.getPrivacyMode(),
            sessionId: bt.getCppSessionId(),
            backupRequestId: y.requestId,
            clientKey: y.clientKey,
          })
          try {
            y.req.header.has(rY) || y.req.header.set(rY, cY())
          } catch {}
        },
        publicLogCapture(y) {
          bt.publicLogCapture(y)
        },
        getSemanticSearchResultsFromServer: (y) =>
          bt.getSemanticSearchResultsFromServer(y),
        shouldIgnoreUri: (y) => bt.$shouldIgnoreUri(y),
        adminBlocklistPath: () =>
          bt.$adminBlocklistPath().then((y) => y.fsPath),
      }
      for (const y of Object.keys($s)) {
        const T = y
        let x = Object.getOwnPropertyDescriptor($s, T)
        if (x?.get) {
          let ft = x.get
          Object.defineProperty($s, T, {
            get: () => Xe("cursor", ft.bind($s)),
            enumerable: !0,
            configurable: !0,
          })
        } else if (typeof $s[T] == "function") {
          let ft = $s[T]
          if (typeof ft == "function") {
            const ee = ft
            Object.defineProperty($s, T, {
              value: (...qe) => Xe("cursor", ee.bind($s), ...qe),
              enumerable: !0,
              configurable: !0,
            })
          }
        }
      }
      const Sr = {
        addBreadcrumb: Wgt,
        captureException: jgt,
        getTraceparent: cY,
        runInSpan: aY,
        span: nY,
        withSpan: Hgt,
      }
      for (const y of Object.keys(Sr)) {
        const T = y,
          x = Sr[T]
        typeof x == "function" && (Sr[T] = (...ft) => Xe("cursor", x, ...ft))
      }
      const Oa = {
          getSession(y, T, x) {
            return (
              typeof x?.forceNewSession == "object" &&
                x.forceNewSession.learnMore &&
                _($, "authLearnMore"),
              R.getSession($, y, T, x)
            )
          },
          getAccounts(y) {
            return R.getAccounts(y)
          },
          async hasSession(y, T) {
            return (
              _($, "authSession"),
              !!(await R.getSession($, y, T, { silent: !0 }))
            )
          },
          get onDidChangeSessions() {
            return Y(R.getExtensionScopedSessionsEvent($.identifier.value))
          },
          registerAuthenticationProvider(y, T, x, ft) {
            return R.registerAuthenticationProvider(y, T, x, ft)
          },
        },
        Hut = {
          registerCommand(y, T, x) {
            return M.registerCommand(!0, y, T, x, void 0, $)
          },
          registerTextEditorCommand(y, T, x) {
            return M.registerCommand(
              !0,
              y,
              (...ft) => {
                const ee = ye.getActiveTextEditor()
                if (!ee) {
                  p.warn(
                    "Cannot execute " +
                      y +
                      " because there is no active text editor.",
                  )
                  return
                }
                return ee
                  .edit((qe) => {
                    T.apply(x, [ee, qe, ...ft])
                  })
                  .then(
                    (qe) => {
                      qe ||
                        p.warn("Edits from command " + y + " were not applied.")
                    },
                    (qe) => {
                      p.warn("An error occurred while running command " + y, qe)
                    },
                  )
              },
              void 0,
              void 0,
              $,
            )
          },
          registerDiffInformationCommand: (y, T, x) => (
            _($, "diffCommand"),
            M.registerCommand(
              !0,
              y,
              async (...ft) => {
                const ee = Z.activeEditor(!0)
                if (!ee) {
                  p.warn(
                    "Cannot execute " +
                      y +
                      " because there is no active text editor.",
                  )
                  return
                }
                const qe = await ye.getDiffInformation(ee.id)
                T.apply(x, [qe, ...ft])
              },
              void 0,
              void 0,
              $,
            )
          ),
          executeCommand(y, ...T) {
            return M.executeCommand(y, ...T)
          },
          getCommands(y = !1) {
            return M.getCommands(y)
          },
        },
        Wut = $.identifier.value === "ms-python.python",
        jut = $.identifier.value === "ms-python.vscode-pylance",
        o_ = {
          get machineId() {
            return t.telemetryInfo.machineId
          },
          get macMachineId() {
            return t.telemetryInfo.macMachineId
          },
          get sessionId() {
            return t.telemetryInfo.sessionId
          },
          get language() {
            return t.environment.appLanguage
          },
          get appName() {
            return jut || Wut ? "Visual Studio Code" : t.environment.appName
          },
          get appRoot() {
            return t.environment.appRoot?.fsPath ?? ""
          },
          get appHost() {
            return t.environment.appHost
          },
          get uriScheme() {
            return t.environment.appUriScheme
          },
          get clipboard() {
            return Be.value
          },
          get shell() {
            return rt.getDefaultShell(!1)
          },
          get onDidChangeShell() {
            return Y(rt.onDidChangeShell)
          },
          get isTelemetryEnabled() {
            return o.getTelemetryConfiguration()
          },
          get onDidChangeTelemetryEnabled() {
            return Y(o.onDidChangeTelemetryEnabled)
          },
          get telemetryConfiguration() {
            return _($, "telemetry"), o.getTelemetryDetails()
          },
          get onDidChangeTelemetryConfiguration() {
            return _($, "telemetry"), Y(o.onDidChangeTelemetryConfiguration)
          },
          get isNewAppInstall() {
            return Rit(t.telemetryInfo.firstSessionDate)
          },
          createTelemetryLogger(y, T) {
            return Lit.validateSender(y), o.instantiateLogger($, y, T)
          },
          openExternal(y, T) {
            return k.openUri(y, {
              allowTunneling: !!t.remote.authority,
              allowContributedOpeners: T?.allowContributedOpeners,
            })
          },
          async asExternalUri(y) {
            if (y.scheme === t.environment.appUriScheme)
              return it.createAppUri(y)
            try {
              return await k.asExternalUri(y, {
                allowTunneling: !!t.remote.authority,
              })
            } catch (T) {
              if (C7(y, G.http) || C7(y, G.https)) return y
              throw T
            }
          },
          get remoteName() {
            return m2(t.remote.authority)
          },
          get remoteAuthority() {
            return _($, "resolvers"), t.remote.authority
          },
          get uiKind() {
            return t.uiKind
          },
          get logLevel() {
            return p.getLevel()
          },
          get onDidChangeLogLevel() {
            return Y(p.onDidChangeLogLevel)
          },
          get appQuality() {
            return _($, "resolvers"), t.quality
          },
          get appCommit() {
            return _($, "resolvers"), t.commit
          },
        }
      t.environment.extensionTestsLocationURI || Object.freeze(o_)
      const Vut = {
          createTestController(y, T, x) {
            return Us.createTestController($, y, T, x)
          },
          createTestObserver() {
            return _($, "testObserver"), Us.createTestObserver()
          },
          runTests(y) {
            return _($, "testObserver"), Us.runTests(y)
          },
          registerTestFollowupProvider(y) {
            return _($, "testObserver"), Us.registerTestFollowupProvider(y)
          },
          get onDidChangeTestResults() {
            return _($, "testObserver"), Y(Us.onResultsChanged)
          },
          get testResults() {
            return _($, "testObserver"), Us.results
          },
        },
        c_ = t.remote.isRemote ? So.Workspace : So.UI,
        Gut = {
          getExtension(y, T) {
            if (K_.modifiedExtensionDependencies?.[y]) {
              const ft = K_.modifiedExtensionDependencies[y]
              y !== ft && (y = ft)
            }
            hi($, "extensionsAny") || (T = !1)
            const x = Et.mine.getExtensionDescription(y)
            if (x) return new om(r, $.identifier, x, c_, !1)
            if (T) {
              const ft = Et.all.getExtensionDescription(y)
              if (ft) return new om(r, $.identifier, ft, c_, !0)
            }
          },
          get all() {
            $.identifier.value
            const y = []
            for (const T of Et.mine.getAllExtensionDescriptions())
              y.push(new om(r, $.identifier, T, c_, !1))
            return y
          },
          get allAcrossExtensionHosts() {
            _($, "extensionsAny")
            const y = new no(
                Et.mine.getAllExtensionDescriptions().map((x) => x.identifier),
              ),
              T = []
            for (const x of Et.all.getAllExtensionDescriptions()) {
              const ft = !y.has(x.identifier)
              T.push(new om(r, $.identifier, x, c_, ft))
            }
            return T
          },
          get onDidChange() {
            return hi($, "extensionsAny")
              ? Y(Qt.any(Et.mine.onDidChange, Et.all.onDidChange))
              : Y(Et.mine.onDidChange)
          },
        },
        zut = {
          createDiagnosticCollection(y) {
            return Fa.createDiagnosticCollection($.identifier, y)
          },
          get onDidChangeDiagnostics() {
            return Y(Fa.onDidChangeDiagnostics)
          },
          getDiagnostics: (y) => Fa.getDiagnostics(y),
          getLanguages() {
            return Is.getLanguages()
          },
          setTextDocumentLanguage(y, T) {
            return Is.changeLanguage(y.uri, T)
          },
          match(y, T) {
            const x = zU.from(y)
            let ft
            return (
              qrt(x) &&
                (ft = xt.notebookDocuments.find((ee) =>
                  ee.apiNotebook.getCells().find((qe) => qe.document === T),
                )?.apiNotebook),
              Brt(x, T.uri, T.languageId, !0, ft?.uri, ft?.notebookType)
            )
          },
          registerCodeActionsProvider(y, T, x) {
            return Ct.registerCodeActionProvider($, kt(y), T, x)
          },
          registerDocumentPasteEditProvider(y, T, x) {
            return (
              _($, "documentPaste"),
              Ct.registerDocumentPasteEditProvider($, kt(y), T, x)
            )
          },
          registerCodeLensProvider(y, T) {
            return Ct.registerCodeLensProvider($, kt(y), T)
          },
          registerDefinitionProvider(y, T) {
            return Ct.registerDefinitionProvider($, kt(y), T)
          },
          registerDeclarationProvider(y, T) {
            return Ct.registerDeclarationProvider($, kt(y), T)
          },
          registerImplementationProvider(y, T) {
            return Ct.registerImplementationProvider($, kt(y), T)
          },
          registerTypeDefinitionProvider(y, T) {
            return Ct.registerTypeDefinitionProvider($, kt(y), T)
          },
          registerHoverProvider(y, T) {
            return Ct.registerHoverProvider($, kt(y), T, $.identifier)
          },
          registerEvaluatableExpressionProvider(y, T) {
            return Ct.registerEvaluatableExpressionProvider(
              $,
              kt(y),
              T,
              $.identifier,
            )
          },
          registerInlineValuesProvider(y, T) {
            return Ct.registerInlineValuesProvider($, kt(y), T, $.identifier)
          },
          registerDocumentHighlightProvider(y, T) {
            return Ct.registerDocumentHighlightProvider($, kt(y), T)
          },
          registerMultiDocumentHighlightProvider(y, T) {
            return Ct.registerMultiDocumentHighlightProvider($, kt(y), T)
          },
          registerLinkedEditingRangeProvider(y, T) {
            return Ct.registerLinkedEditingRangeProvider($, kt(y), T)
          },
          registerReferenceProvider(y, T) {
            return Ct.registerReferenceProvider($, kt(y), T)
          },
          registerRenameProvider(y, T) {
            return Ct.registerRenameProvider($, kt(y), T)
          },
          registerNewSymbolNamesProvider(y, T) {
            return (
              _($, "newSymbolNamesProvider"),
              Ct.registerNewSymbolNamesProvider($, kt(y), T)
            )
          },
          registerDocumentSymbolProvider(y, T, x) {
            return Ct.registerDocumentSymbolProvider($, kt(y), T, x)
          },
          registerWorkspaceSymbolProvider(y) {
            return Ct.registerWorkspaceSymbolProvider($, y)
          },
          registerDocumentFormattingEditProvider(y, T) {
            return Ct.registerDocumentFormattingEditProvider($, kt(y), T)
          },
          registerDocumentRangeFormattingEditProvider(y, T) {
            return Ct.registerDocumentRangeFormattingEditProvider($, kt(y), T)
          },
          registerOnTypeFormattingEditProvider(y, T, x, ...ft) {
            return Ct.registerOnTypeFormattingEditProvider(
              $,
              kt(y),
              T,
              [x].concat(ft),
            )
          },
          registerDocumentSemanticTokensProvider(y, T, x) {
            return Ct.registerDocumentSemanticTokensProvider($, kt(y), T, x)
          },
          registerDocumentRangeSemanticTokensProvider(y, T, x) {
            return Ct.registerDocumentRangeSemanticTokensProvider(
              $,
              kt(y),
              T,
              x,
            )
          },
          registerSignatureHelpProvider(y, T, x, ...ft) {
            return typeof x == "object"
              ? Ct.registerSignatureHelpProvider($, kt(y), T, x)
              : Ct.registerSignatureHelpProvider(
                  $,
                  kt(y),
                  T,
                  typeof x > "u" ? [] : [x, ...ft],
                )
          },
          registerCompletionItemProvider(y, T, ...x) {
            return Ct.registerCompletionItemProvider($, kt(y), T, x)
          },
          registerInlineCompletionItemProvider(y, T, x) {
            return (
              T.handleDidShowCompletionItem &&
                _($, "inlineCompletionsAdditions"),
              T.handleDidPartiallyAcceptCompletionItem &&
                _($, "inlineCompletionsAdditions"),
              x && _($, "inlineCompletionsAdditions"),
              Ct.registerInlineCompletionsProvider($, kt(y), T, x)
            )
          },
          registerInlineEditProvider(y, T) {
            return (
              _($, "inlineEdit"), Ct.registerInlineEditProvider($, kt(y), T)
            )
          },
          registerDocumentLinkProvider(y, T) {
            return Ct.registerDocumentLinkProvider($, kt(y), T)
          },
          registerColorProvider(y, T) {
            return Ct.registerColorProvider($, kt(y), T)
          },
          registerFoldingRangeProvider(y, T) {
            return Ct.registerFoldingRangeProvider($, kt(y), T)
          },
          registerSelectionRangeProvider(y, T) {
            return Ct.registerSelectionRangeProvider($, y, T)
          },
          registerCallHierarchyProvider(y, T) {
            return Ct.registerCallHierarchyProvider($, y, T)
          },
          registerTypeHierarchyProvider(y, T) {
            return Ct.registerTypeHierarchyProvider($, y, T)
          },
          setLanguageConfiguration: (y, T) =>
            Ct.setLanguageConfiguration($, y, T),
          getTokenInformationAtPosition(y, T) {
            return _($, "tokenInformation"), Is.tokenAtPosition(y, T)
          },
          registerInlayHintsProvider(y, T) {
            return Ct.registerInlayHintsProvider($, y, T)
          },
          createLanguageStatusItem(y, T) {
            return Is.createLanguageStatusItem($, y, T)
          },
          registerDocumentDropEditProvider(y, T, x) {
            return Ct.registerDocumentOnDropEditProvider(
              $,
              y,
              T,
              hi($, "documentPaste") ? x : void 0,
            )
          },
        },
        Yut = {
          get activeTextEditor() {
            return ye.getActiveTextEditor()
          },
          get visibleTextEditors() {
            return ye.getVisibleTextEditors()
          },
          get activeTerminal() {
            return rt.activeTerminal
          },
          get terminals() {
            return rt.terminals
          },
          async showTextDocument(y, T, x) {
            S.isUri(y) &&
              y.scheme === G.vscodeRemote &&
              !y.authority &&
              b.report(
                "workspace.showTextDocument",
                $,
                "A URI of 'vscode-remote' scheme requires an authority.",
              )
            const ft = await (S.isUri(y)
              ? Promise.resolve(IV.openTextDocument(y))
              : Promise.resolve(y))
            return ye.showTextDocument(ft, T, x)
          },
          createTextEditorDecorationType(y) {
            return ye.createTextEditorDecorationType($, y)
          },
          onDidChangeActiveTextEditor(y, T, x) {
            return Y(ye.onDidChangeActiveTextEditor)(y, T, x)
          },
          onDidChangeVisibleTextEditors(y, T, x) {
            return Y(ye.onDidChangeVisibleTextEditors)(y, T, x)
          },
          onDidChangeTextEditorSelection(y, T, x) {
            return Y(ye.onDidChangeTextEditorSelection)(y, T, x)
          },
          onDidChangeTextEditorOptions(y, T, x) {
            return Y(ye.onDidChangeTextEditorOptions)(y, T, x)
          },
          onDidChangeTextEditorVisibleRanges(y, T, x) {
            return Y(ye.onDidChangeTextEditorVisibleRanges)(y, T, x)
          },
          onDidChangeTextEditorViewColumn(y, T, x) {
            return Y(ye.onDidChangeTextEditorViewColumn)(y, T, x)
          },
          onDidChangeTextEditorDiffInformation(y, T, x) {
            return (
              _($, "textEditorDiffInformation"),
              Y(ye.onDidChangeTextEditorDiffInformation)(y, T, x)
            )
          },
          onDidCloseTerminal(y, T, x) {
            return Y(rt.onDidCloseTerminal)(y, T, x)
          },
          onDidOpenTerminal(y, T, x) {
            return Y(rt.onDidOpenTerminal)(y, T, x)
          },
          onDidChangeActiveTerminal(y, T, x) {
            return Y(rt.onDidChangeActiveTerminal)(y, T, x)
          },
          onDidChangeTerminalDimensions(y, T, x) {
            return (
              _($, "terminalDimensions"),
              Y(rt.onDidChangeTerminalDimensions)(y, T, x)
            )
          },
          onDidChangeTerminalState(y, T, x) {
            return Y(rt.onDidChangeTerminalState)(y, T, x)
          },
          onDidWriteTerminalData(y, T, x) {
            return (
              _($, "terminalDataWriteEvent"),
              Y(rt.onDidWriteTerminalData)(y, T, x)
            )
          },
          onDidExecuteTerminalCommand(y, T, x) {
            return (
              _($, "terminalExecuteCommandEvent"),
              Y(rt.onDidExecuteTerminalCommand)(y, T, x)
            )
          },
          onDidChangeTerminalShellIntegration(y, T, x) {
            return Y(Jt.onDidChangeTerminalShellIntegration)(y, T, x)
          },
          onDidStartTerminalShellExecution(y, T, x) {
            return Y(Jt.onDidStartTerminalShellExecution)(y, T, x)
          },
          onDidEndTerminalShellExecution(y, T, x) {
            return Y(Jt.onDidEndTerminalShellExecution)(y, T, x)
          },
          get state() {
            return k.getState()
          },
          onDidChangeWindowState(y, T, x) {
            return Y(k.onDidChangeWindowState)(y, T, x)
          },
          showInformationMessage(y, ...T) {
            return Qe.showMessage($, Le.Info, y, T[0], T.slice(1))
          },
          showWarningMessage(y, ...T) {
            return Qe.showMessage($, Le.Warning, y, T[0], T.slice(1))
          },
          showErrorMessage(y, ...T) {
            return Qe.showMessage($, Le.Error, y, T[0], T.slice(1))
          },
          showQuickPick(y, T, x) {
            return qi.showQuickPick($, y, T, x)
          },
          showWorkspaceFolderPick(y) {
            return qi.showWorkspaceFolderPick(y)
          },
          showInputBox(y, T) {
            return qi.showInput(y, T)
          },
          showOpenDialog(y) {
            return Ni.showOpenDialog($, y)
          },
          showSaveDialog(y) {
            return Ni.showSaveDialog(y)
          },
          createStatusBarItem(y, T, x) {
            let ft, ee, qe
            return (
              typeof y == "string"
                ? ((ft = y), (ee = T), (qe = x))
                : ((ee = y), (qe = T)),
              Zt.createStatusBarEntry($, ft, ee, qe)
            )
          },
          setStatusBarMessage(y, T) {
            return Zt.setStatusBarMessage(y, T)
          },
          withScmProgress(y) {
            return (
              b.report(
                "window.withScmProgress",
                $,
                "Use 'withProgress' instead.",
              ),
              sc.withProgress($, { location: yo.SourceControl }, (T, x) =>
                y({ report(ft) {} }),
              )
            )
          },
          withProgress(y, T) {
            return sc.withProgress($, y, T)
          },
          createOutputChannel(y, T) {
            return z.createOutputChannel(y, T, $)
          },
          createWebviewPanel(y, T, x, ft) {
            return fi.createWebviewPanel($, y, T, x, ft)
          },
          createWebviewTextEditorInset(y, T, x, ft) {
            return (
              _($, "editorInsets"), ec.createWebviewEditorInset(y, T, x, ft, $)
            )
          },
          createTerminal(y, T, x) {
            return typeof y == "object"
              ? "pty" in y
                ? rt.createExtensionTerminal(y)
                : rt.createTerminalFromOptions(y)
              : rt.createTerminal(y, T, x)
          },
          registerTerminalLinkProvider(y) {
            return rt.registerLinkProvider(y)
          },
          registerTerminalProfileProvider(y, T) {
            return rt.registerProfileProvider($, y, T)
          },
          registerTerminalCompletionProvider(y, ...T) {
            return (
              _($, "terminalCompletionProvider"),
              rt.registerTerminalCompletionProvider($, y, ...T)
            )
          },
          registerTerminalQuickFixProvider(y, T) {
            return (
              _($, "terminalQuickFixProvider"),
              rt.registerTerminalQuickFixProvider(y, $.identifier.value, T)
            )
          },
          registerTreeDataProvider(y, T) {
            return Vr.registerTreeDataProvider(y, T, $)
          },
          createTreeView(y, T) {
            return Vr.createTreeView(y, T, $)
          },
          registerWebviewPanelSerializer: (y, T) =>
            fi.registerWebviewPanelSerializer($, y, T),
          registerCustomEditorProvider: (y, T, x = {}) =>
            s7.registerCustomEditorProvider($, y, T, x),
          registerFileDecorationProvider(y) {
            return tt.registerFileDecorationProvider(y, $)
          },
          registerUriHandler(y) {
            return it.registerUriHandler($, y)
          },
          createQuickPick() {
            return qi.createQuickPick($)
          },
          createInputBox() {
            return qi.createInputBox($)
          },
          get activeColorTheme() {
            return Aa.activeColorTheme
          },
          onDidChangeActiveColorTheme(y, T, x) {
            return Y(Aa.onDidChangeActiveColorTheme)(y, T, x)
          },
          registerWebviewViewProvider(y, T, x) {
            return r7.registerWebviewViewProvider($, y, T, x?.webviewOptions)
          },
          get activeNotebookEditor() {
            return xt.activeNotebookEditor
          },
          onDidChangeActiveNotebookEditor(y, T, x) {
            return Y(xt.onDidChangeActiveNotebookEditor)(y, T, x)
          },
          get visibleNotebookEditors() {
            return xt.visibleNotebookEditors
          },
          get onDidChangeVisibleNotebookEditors() {
            return Y(xt.onDidChangeVisibleNotebookEditors)
          },
          onDidChangeNotebookEditorSelection(y, T, x) {
            return Y(mi.onDidChangeNotebookEditorSelection)(y, T, x)
          },
          onDidChangeNotebookEditorVisibleRanges(y, T, x) {
            return Y(mi.onDidChangeNotebookEditorVisibleRanges)(y, T, x)
          },
          showNotebookDocument(y, T) {
            return xt.showNotebookDocument(y, T)
          },
          registerExternalUriOpener(y, T, x) {
            return (
              _($, "externalUriOpener"),
              Pu.registerExternalUriOpener($.identifier, y, T, x)
            )
          },
          registerProfileContentHandler(y, T) {
            return (
              _($, "profileContentHandlers"),
              N.registerProfileContentHandler($, y, T)
            )
          },
          registerQuickDiffProvider(y, T, x, ft) {
            return (
              _($, "quickDiffProvider"),
              ic.registerQuickDiffProvider(kt(y), T, x, ft)
            )
          },
          get tabGroups() {
            return P.tabGroups
          },
          registerShareProvider(y, T) {
            return _($, "shareProvider"), Eu.registerShareProvider(kt(y), T)
          },
          get nativeHandle() {
            return _($, "nativeWindowHandle"), k.nativeHandle
          },
        },
        IV = {
          get rootPath() {
            return (
              b.report(
                "workspace.rootPath",
                $,
                "Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath",
              ),
              a.getPath()
            )
          },
          set rootPath(y) {
            throw new Ba("rootPath")
          },
          getWorkspaceFolder(y) {
            return a.getWorkspaceFolder(y)
          },
          get workspaceFolders() {
            return a.getWorkspaceFolders()
          },
          get name() {
            return a.name
          },
          set name(y) {
            throw new Ba("name")
          },
          get workspaceFile() {
            return a.workspaceFile
          },
          set workspaceFile(y) {
            throw new Ba("workspaceFile")
          },
          updateWorkspaceFolders: (y, T, ...x) =>
            a.updateWorkspaceFolders($, y, T || 0, ...x),
          onDidChangeWorkspaceFolders: function (y, T, x) {
            return Y(a.onDidChangeWorkspace)(y, T, x)
          },
          asRelativePath: (y, T) => a.getRelativePath(y, T),
          findFiles: (y, T, x, ft) => a.findFiles(y, T, x, $.identifier, ft),
          findFiles2: (y, T, x) => (
            _($, "findFiles2"), a.findFiles2(y, T, $.identifier, x)
          ),
          findTextInFiles: (y, T, x, ft) => {
            _($, "findTextInFiles")
            let ee, qe
            return (
              typeof T == "object"
                ? ((ee = T), (qe = x))
                : ((ee = {}), (qe = T), (ft = x)),
              a.findTextInFiles(y, ee || {}, qe, $.identifier, ft)
            )
          },
          findTextInFiles2: (y, T, x) => (
            _($, "findTextInFiles2"),
            _($, "textSearchProvider2"),
            a.findTextInFiles2(y, T, $.identifier, x)
          ),
          save: (y) => a.save(y),
          saveAs: (y) => a.saveAs(y),
          saveAll: (y) => a.saveAll(y),
          applyEdit(y, T) {
            return Ps.applyWorkspaceEdit(y, $, T)
          },
          createFileSystemWatcher: (y, T, x, ft) => {
            let ee
            return (
              T && typeof T != "boolean"
                ? (_($, "createFileSystemWatcher"),
                  (ee = { ...T, correlate: !0 }))
                : (ee = {
                    ignoreCreateEvents: !!T,
                    ignoreChangeEvents: !!x,
                    ignoreDeleteEvents: !!ft,
                    correlate: !1,
                  }),
              is.createFileSystemWatcher(a, At, $, y, ee)
            )
          },
          get textDocuments() {
            return nt.getAllDocumentData().map((y) => y.document)
          },
          set textDocuments(y) {
            throw new Ba("textDocuments")
          },
          openTextDocument(y) {
            let T
            const x = y
            if (typeof y == "string") T = Promise.resolve(S.file(y))
            else if (S.isUri(y)) T = Promise.resolve(y)
            else if (!x || typeof x == "object") T = nt.createDocumentData(x)
            else throw new Error("illegal argument - uriOrFileNameOrOptions")
            return T.then(
              (ft) => (
                p.trace(`openTextDocument from ${$.identifier}`),
                ft.scheme === G.vscodeRemote &&
                  !ft.authority &&
                  b.report(
                    "workspace.openTextDocument",
                    $,
                    "A URI of 'vscode-remote' scheme requires an authority.",
                  ),
                nt.ensureDocumentData(ft).then((ee) => ee.document)
              ),
            )
          },
          onDidOpenTextDocument: (y, T, x) => Y(nt.onDidAddDocument)(y, T, x),
          onDidCloseTextDocument: (y, T, x) =>
            Y(nt.onDidRemoveDocument)(y, T, x),
          onDidChangeTextDocument: (y, T, x) =>
            Y(nt.onDidChangeDocument)(y, T, x),
          onDidSaveTextDocument: (y, T, x) => Y(nt.onDidSaveDocument)(y, T, x),
          onWillSaveTextDocument: (y, T, x) =>
            Y(Bt.getOnWillSaveTextDocumentEvent($))(y, T, x),
          get notebookDocuments() {
            return xt.notebookDocuments.map((y) => y.apiNotebook)
          },
          async openNotebookDocument(y, T) {
            let x
            if (S.isUri(y)) (x = y), await xt.openNotebookDocument(y)
            else if (typeof y == "string")
              x = S.revive(
                await xt.createNotebookDocument({ viewType: y, content: T }),
              )
            else throw new Error("Invalid arguments")
            return xt.getNotebookDocument(x).apiNotebook
          },
          onDidSaveNotebookDocument(y, T, x) {
            return Y(oe.onDidSaveNotebookDocument)(y, T, x)
          },
          onDidChangeNotebookDocument(y, T, x) {
            return Y(oe.onDidChangeNotebookDocument)(y, T, x)
          },
          onWillSaveNotebookDocument(y, T, x) {
            return Y(Ri.getOnWillSaveNotebookDocumentEvent($))(y, T, x)
          },
          get onDidOpenNotebookDocument() {
            return Y(xt.onDidOpenNotebookDocument)
          },
          get onDidCloseNotebookDocument() {
            return Y(xt.onDidCloseNotebookDocument)
          },
          registerNotebookSerializer(y, T, x, ft) {
            return xt.registerNotebookSerializer(
              $,
              y,
              T,
              x,
              hi($, "notebookLiveShare") ? ft : void 0,
            )
          },
          onDidChangeConfiguration: (y, T, x) =>
            Y(At.onDidChangeConfiguration)(y, T, x),
          getConfiguration(y, T) {
            return (
              (T = arguments.length === 1 ? void 0 : T),
              At.getConfiguration(y, T, $)
            )
          },
          registerTextDocumentContentProvider(y, T) {
            return $t.registerTextDocumentContentProvider(y, T)
          },
          registerTaskProvider: (y, T) => (
            b.report(
              "window.registerTaskProvider",
              $,
              "Use the corresponding function on the 'tasks' namespace instead",
            ),
            j.registerTaskProvider($, y, T)
          ),
          registerFileSystemProvider(y, T, x) {
            return qV(
              n_.registerFileSystemProvider($, y, T, x),
              s.addFileSystemProvider(y, T, x),
            )
          },
          get fs() {
            return s.value
          },
          registerFileSearchProvider: (y, T) => (
            _($, "fileSearchProvider"), me.registerFileSearchProviderOld(y, T)
          ),
          registerTextSearchProvider: (y, T) => (
            _($, "textSearchProvider"), me.registerTextSearchProviderOld(y, T)
          ),
          registerAITextSearchProvider: (y, T) => (
            _($, "aiTextSearchProvider"),
            _($, "textSearchProvider2"),
            me.registerAITextSearchProvider(y, T)
          ),
          registerFileSearchProvider2: (y, T) => (
            _($, "fileSearchProvider2"), me.registerFileSearchProvider(y, T)
          ),
          registerTextSearchProvider2: (y, T) => (
            _($, "textSearchProvider2"), me.registerTextSearchProvider(y, T)
          ),
          registerRemoteAuthorityResolver: (y, T) => (
            _($, "resolvers"), r.registerRemoteAuthorityResolver(y, T)
          ),
          registerResourceLabelFormatter: (y) => (
            _($, "resolvers"), Iu.$registerResourceLabelFormatter(y)
          ),
          getRemoteExecServer: (y) => (
            _($, "resolvers"), r.getRemoteExecServer(y)
          ),
          onDidCreateFiles: (y, T, x) => Y(is.onDidCreateFile)(y, T, x),
          onDidDeleteFiles: (y, T, x) => Y(is.onDidDeleteFile)(y, T, x),
          onDidRenameFiles: (y, T, x) => Y(is.onDidRenameFile)(y, T, x),
          onWillCreateFiles: (y, T, x) =>
            Y(is.getOnWillCreateFileEvent($))(y, T, x),
          onWillDeleteFiles: (y, T, x) =>
            Y(is.getOnWillDeleteFileEvent($))(y, T, x),
          onWillRenameFiles: (y, T, x) =>
            Y(is.getOnWillRenameFileEvent($))(y, T, x),
          openTunnel: (y) => (
            _($, "tunnels"),
            v.openTunnel($, y).then((T) => {
              if (!T) throw new Error("cannot open tunnel")
              return T
            })
          ),
          get tunnels() {
            return _($, "tunnels"), v.getTunnels()
          },
          onDidChangeTunnels: (y, T, x) => (
            _($, "tunnels"), Y(v.onDidChangeTunnels)(y, T, x)
          ),
          registerPortAttributesProvider: (y, T) => (
            _($, "portsAttributes"), v.registerPortsAttributesProvider(y, T)
          ),
          registerTunnelProvider: (y, T) => (
            _($, "tunnelFactory"), v.registerTunnelProvider(y, T)
          ),
          registerTimelineProvider: (y, T) => (
            _($, "timeline"),
            _a.registerTimelineProvider(y, T, $.identifier, M.converter)
          ),
          get isTrusted() {
            return a.trusted
          },
          requestWorkspaceTrust: (y) => (
            _($, "workspaceTrust"), a.requestWorkspaceTrust(y)
          ),
          onDidGrantWorkspaceTrust: (y, T, x) =>
            Y(a.onDidGrantWorkspaceTrust)(y, T, x),
          registerEditSessionIdentityProvider: (y, T) => (
            _($, "editSessionIdentityProvider"),
            a.registerEditSessionIdentityProvider(y, T)
          ),
          onWillCreateEditSessionIdentity: (y, T, x) => (
            _($, "editSessionIdentityProvider"),
            Y(a.getOnWillCreateEditSessionIdentityEvent($))(y, T, x)
          ),
          registerControlProvider: (y, T) => (
            _($, "control"), a.registerControlProvider(y, T)
          ),
          registerCanonicalUriProvider: (y, T) => (
            _($, "canonicalUriProvider"), a.registerCanonicalUriProvider(y, T)
          ),
          getCanonicalUri: (y, T, x) => (
            _($, "canonicalUriProvider"), a.provideCanonicalUri(y, T, x)
          ),
        },
        Qut = {
          get inputBox() {
            return (
              b.report(
                "scm.inputBox",
                $,
                "Use 'SourceControl.inputBox' instead",
              ),
              Gr.getLastInputBox($)
            )
          },
          createSourceControl(y, T, x) {
            return Gr.createSourceControl($, y, T, x)
          },
          registerGitContextProvider(y) {
            return _($, "cursor"), Gr.registerGitContextProvider(y)
          },
          gitStatusWasRun(y) {
            return _($, "cursorNoDeps"), Gr.gitStatusWasRun(y)
          },
        },
        Xut = {
          createCommentController(y, T) {
            return a_.createCommentController($, y, T)
          },
        },
        Kut = {
          get activeDebugSession() {
            return ct.activeDebugSession
          },
          get activeDebugConsole() {
            return ct.activeDebugConsole
          },
          get breakpoints() {
            return ct.breakpoints
          },
          get activeStackItem() {
            return ct.activeStackItem
          },
          registerDebugVisualizationProvider(y, T) {
            return (
              _($, "debugVisualization"),
              ct.registerDebugVisualizationProvider($, y, T)
            )
          },
          registerDebugVisualizationTreeProvider(y, T) {
            return (
              _($, "debugVisualization"),
              ct.registerDebugVisualizationTree($, y, T)
            )
          },
          onDidStartDebugSession(y, T, x) {
            return Y(ct.onDidStartDebugSession)(y, T, x)
          },
          onDidTerminateDebugSession(y, T, x) {
            return Y(ct.onDidTerminateDebugSession)(y, T, x)
          },
          onDidChangeActiveDebugSession(y, T, x) {
            return Y(ct.onDidChangeActiveDebugSession)(y, T, x)
          },
          onDidReceiveDebugSessionCustomEvent(y, T, x) {
            return Y(ct.onDidReceiveDebugSessionCustomEvent)(y, T, x)
          },
          onDidChangeBreakpoints(y, T, x) {
            return Y(ct.onDidChangeBreakpoints)(y, T, x)
          },
          onDidChangeActiveStackItem(y, T, x) {
            return Y(ct.onDidChangeActiveStackItem)(y, T, x)
          },
          registerDebugConfigurationProvider(y, T, x) {
            return ct.registerDebugConfigurationProvider(y, T, x || x3.Initial)
          },
          registerDebugAdapterDescriptorFactory(y, T) {
            return ct.registerDebugAdapterDescriptorFactory($, y, T)
          },
          registerDebugAdapterTrackerFactory(y, T) {
            return ct.registerDebugAdapterTrackerFactory(y, T)
          },
          startDebugging(y, T, x) {
            return !x || (typeof x == "object" && "configuration" in x)
              ? ct.startDebugging(y, T, { parentSession: x })
              : ct.startDebugging(y, T, x || {})
          },
          stopDebugging(y) {
            return ct.stopDebugging(y)
          },
          addBreakpoints(y) {
            return ct.addBreakpoints(y)
          },
          removeBreakpoints(y) {
            return ct.removeBreakpoints(y)
          },
          asDebugSourceUri(y, T) {
            return ct.asDebugSourceUri(y, T)
          },
        },
        Zut = {
          registerTaskProvider: (y, T) => j.registerTaskProvider($, y, T),
          fetchTasks: (y) => j.fetchTasks(y),
          executeTask: (y) => j.executeTask($, y),
          get taskExecutions() {
            return j.taskExecutions
          },
          onDidStartTask: (y, T, x) => Y(j.onDidStartTask)(y, T, x),
          onDidEndTask: (y, T, x) => Y(j.onDidEndTask)(y, T, x),
          onDidStartTaskProcess: (y, T, x) =>
            Y(j.onDidStartTaskProcess)(y, T, x),
          onDidEndTaskProcess: (y, T, x) => Y(j.onDidEndTaskProcess)(y, T, x),
        },
        tht = {
          createNotebookController(y, T, x, ft, ee) {
            return Ce.createNotebookController(
              $,
              y,
              T,
              x,
              ft,
              hi($, "notebookMessaging") ? ee : void 0,
            )
          },
          registerNotebookCellStatusBarItemProvider: (y, T) =>
            xt.registerNotebookCellStatusBarItemProvider($, y, T),
          createRendererMessaging(y) {
            return wi.createRendererMessaging($, y)
          },
          createNotebookControllerDetectionTask(y) {
            return (
              _($, "notebookKernelSource"),
              Ce.createNotebookControllerDetectionTask($, y)
            )
          },
          registerKernelSourceActionProvider(y, T) {
            return (
              _($, "notebookKernelSource"),
              Ce.registerKernelSourceActionProvider($, y, T)
            )
          },
          onDidChangeNotebookCellExecutionState(y, T, x) {
            return (
              _($, "notebookCellExecutionState"),
              Y(Ce.onDidChangeNotebookCellExecutionState)(y, T, x)
            )
          },
        },
        eht = {
          t(...y) {
            if (typeof y[0] == "string") {
              const T = y.shift(),
                x = !y || typeof y[0] != "object" ? y : y[0]
              return ot.getMessage($.identifier.value, { message: T, args: x })
            }
            return ot.getMessage($.identifier.value, y[0])
          },
          get bundle() {
            return ot.getBundle($.identifier.value)
          },
          get uri() {
            return ot.getBundleUri($.identifier.value)
          },
        },
        iht = {
          transferActiveChat(y) {
            return _($, "interactive"), A.transferActiveChat(y)
          },
        },
        sht = {
          getRelatedInformation(y, T) {
            return (
              _($, "aiRelatedInformation"), It.getRelatedInformation($, y, T)
            )
          },
          registerRelatedInformationProvider(y, T) {
            return (
              _($, "aiRelatedInformation"),
              It.registerRelatedInformationProvider($, y, T)
            )
          },
          registerEmbeddingVectorProvider(y, T) {
            return (
              _($, "aiRelatedInformation"),
              ai.registerEmbeddingVectorProvider($, y, T)
            )
          },
        },
        rht = {
          registerChatResponseProvider(y, T, x) {
            return _($, "chatProvider"), D.registerLanguageModel($, y, T, x)
          },
          registerChatVariableResolver(y, T, x, ft, ee, qe, $u, oht) {
            return (
              _($, "chatVariableResolver"),
              q.registerVariableResolver($, y, T, x, ft, ee, qe, $u, oht?.id)
            )
          },
          registerMappedEditsProvider(y, T) {
            return (
              _($, "mappedEditsProvider"),
              Ct.registerMappedEditsProvider($, y, T)
            )
          },
          registerMappedEditsProvider2(y) {
            return (
              _($, "mappedEditsProvider"), te.registerMappedEditsProvider($, y)
            )
          },
          createChatParticipant(y, T) {
            return A.createChatAgent($, y, T)
          },
          createDynamicChatParticipant(y, T, x) {
            return (
              _($, "chatParticipantPrivate"),
              A.createDynamicChatAgent($, y, T, x)
            )
          },
          registerChatParticipantDetectionProvider(y) {
            return (
              _($, "chatParticipantAdditions"),
              A.registerChatParticipantDetectionProvider($, y)
            )
          },
          registerRelatedFilesProvider(y, T) {
            return _($, "chatEditing"), A.registerRelatedFilesProvider($, y, T)
          },
        },
        nht = {
          selectChatModels: (y) => D.selectLanguageModels($, y ?? {}),
          onDidChangeChatModels: (y, T, x) => D.onDidChangeProviders(y, T, x),
          registerChatModelProvider: (y, T, x) => (
            _($, "chatProvider"), D.registerLanguageModel($, y, T, x)
          ),
          get embeddingModels() {
            return _($, "embeddings"), Te.embeddingsModels
          },
          onDidChangeEmbeddingModels: (y, T, x) => (
            _($, "embeddings"), Te.onDidChange(y, T, x)
          ),
          registerEmbeddingsProvider(y, T) {
            return _($, "embeddings"), Te.registerEmbeddingsProvider($, y, T)
          },
          async computeEmbeddings(y, T, x) {
            return _($, "embeddings"), Te.computeEmbeddings(y, T, x)
          },
          registerTool(y, T) {
            return mt.registerTool($, y, T)
          },
          invokeTool(y, T, x) {
            return mt.invokeTool(y, T, x)
          },
          get tools() {
            return mt.tools
          },
          fileIsIgnored(y, T) {
            return D.fileIsIgnored($, y, T)
          },
          registerIgnoredFileProvider(y) {
            return D.registerIgnoredFileProvider($, y)
          },
        },
        aht = {
          registerSpeechProvider(y, T) {
            return _($, "speech"), Di.registerProvider($.identifier, y, T)
          },
        }
      return {
        version: t.vscodeVersion,
        cursorVersion: t.version,
        ai: sht,
        authentication: Oa,
        commands: Hut,
        comments: Xut,
        chat: rht,
        debug: Kut,
        env: o_,
        extensions: Gut,
        interactive: iht,
        l10n: eht,
        languages: zut,
        lm: nht,
        notebooks: tht,
        scm: Qut,
        speech: aht,
        tasks: Zut,
        tests: Vut,
        tracing: Sr,
        window: Yut,
        workspace: IV,
        Breakpoint: il,
        TerminalOutputAnchor: D2,
        ChatResultFeedbackKind: ed,
        ChatVariableLevel: SU,
        ChatCompletionItem: xTt,
        CallHierarchyIncomingCall: ntt,
        CallHierarchyItem: _2,
        CallHierarchyOutgoingCall: att,
        CancellationError: bi,
        CancellationTokenSource: fe,
        CandidatePortSource: bq,
        CodeAction: tO,
        CodeActionKind: Ie,
        CodeActionTriggerKind: Fh,
        CodeLens: eO,
        Color: Xc,
        ColorInformation: oO,
        ColorPresentation: cO,
        ColorThemeKind: la,
        CommentMode: nU,
        CommentState: aU,
        CommentThreadCollapsibleState: Gh,
        CommentThreadState: zh,
        CommentThreadApplicability: Yh,
        CommentThreadFocus: Qh,
        CompletionItem: rO,
        CompletionItemKind: wt,
        CompletionItemTag: _h,
        CompletionList: Vc,
        CompletionTriggerKind: jc,
        ConfigurationTarget: tl,
        CustomExecution: K2,
        DebugAdapterExecutable: sl,
        DebugAdapterInlineImplementation: Wh,
        DebugAdapterNamedPipeServer: Hh,
        DebugAdapterServer: rl,
        DebugConfigurationProviderTriggerKind: x3,
        DebugConsoleMode: bO,
        DebugVisualization: TTt,
        DecorationRangeBehavior: vo,
        Diagnostic: Y6,
        DiagnosticRelatedInformation: Ch,
        DiagnosticSeverity: Ii,
        DiagnosticTag: po,
        Disposable: Ht,
        DocumentHighlight: K6,
        DocumentHighlightKind: Jh,
        MultiDocumentHighlight: Z6,
        DocumentLink: aO,
        DocumentSymbol: Dh,
        EndOfLine: nr,
        EnvironmentVariableMutatorType: Hc,
        EvaluatableExpression: pO,
        InlineValueText: gO,
        InlineValueVariableLookup: vO,
        InlineValueEvaluatableExpression: wO,
        InlineCompletionTriggerKind: jh,
        EventEmitter: J,
        ExtensionKind: So,
        ExtensionMode: ll,
        ExternalUriOpenerPriority: mU,
        FileChangeType: nl,
        FileDecoration: lU,
        FileDecoration2: lU,
        FileSystemError: ei,
        FileType: cs,
        FilePermission: ia,
        FoldingRange: rU,
        FoldingRangeKind: pn,
        FunctionBreakpoint: ko,
        InlineCompletionItem: H2,
        InlineCompletionList: W2,
        Hover: Q6,
        VerboseHover: X6,
        HoverVerbosityAction: A2,
        IndentAction: TW,
        Location: ys,
        MarkdownString: ls,
        OverviewRulerLane: wH,
        ParameterInformation: O2,
        PortAutoForwardAction: pU,
        Position: Ft,
        ProcessExecution: Kc,
        ProgressLocation: yo,
        QuickInputButtonLocation: cU,
        QuickInputButtons: Xh,
        Range: Nt,
        RelativePattern: el,
        Selection: fn,
        SelectionRange: Ah,
        SemanticTokens: al,
        SemanticTokensBuilder: bTt,
        SemanticTokensEdit: dtt,
        SemanticTokensEdits: yO,
        SemanticTokensLegend: oU,
        ShellExecution: wo,
        ShellQuoting: X2,
        SignatureHelp: q2,
        SignatureHelpTriggerKind: U2,
        SignatureInformation: B2,
        SnippetString: fo,
        SourceBreakpoint: To,
        StandardTokenType: ua,
        StatusBarAlignment: oa,
        SymbolInformation: Rh,
        SymbolKind: de,
        SymbolTag: Lh,
        Task: uO,
        TaskGroup: qh,
        TaskPanelKind: Q2,
        TaskRevealKind: Y2,
        TaskScope: ca,
        TerminalLink: cTt,
        TerminalQuickFixTerminalCommand: uTt,
        TerminalQuickFixOpener: lTt,
        TerminalLocation: G2,
        TerminalProfile: hTt,
        TerminalExitReason: V2,
        TerminalShellExecutionCommandLineConfidence: lO,
        TerminalCompletionItem: dTt,
        TerminalCompletionItemKind: z2,
        TerminalCompletionList: mTt,
        TextDocumentSaveReason: Gc,
        TextEdit: aa,
        SnippetTextEdit: F2,
        TextEditorCursorStyle: Xs,
        TextEditorChangeKind: Yc,
        TextEditorLineNumbersStyle: ar,
        TextEditorRevealType: nO,
        TextEditorSelectionChangeKind: zc,
        SyntaxTokenType: Qc,
        TextDocumentChangeReason: Bh,
        ThemeColor: Mh,
        ThemeIcon: Ji,
        TreeItem: hO,
        TreeItemCheckboxState: _r,
        TreeItemCollapsibleState: bo,
        TypeHierarchyItem: gU,
        UIKind: nm,
        Uri: S,
        ViewColumn: Oh,
        WorkspaceEdit: mo,
        DocumentPasteTriggerKind: eU,
        DocumentDropEdit: tU,
        DocumentDropOrPasteEditKind: Zc,
        DocumentPasteEdit: gTt,
        InlayHint: sO,
        InlayHintLabelPart: iO,
        InlayHintKind: M2,
        RemoteAuthorityResolverError: Mc,
        ResolvedAuthority: aTt,
        ManagedResolvedAuthority: G6,
        SourceControlInputBoxValidationType: j2,
        ExtensionRuntime: $O,
        TimelineItem: hU,
        NotebookRange: gn,
        NotebookCellKind: Eo,
        NotebookCellExecutionState: cl,
        NotebookCellData: kO,
        NotebookData: mtt,
        NotebookRendererScript: ptt,
        NotebookCellStatusBarAlignment: EO,
        NotebookEditorRevealType: IO,
        NotebookCellOutput: SO,
        NotebookCellOutputItem: ftt,
        CellErrorStackFrame: kTt,
        NotebookCellStatusBarItem: STt,
        NotebookControllerAffinity: uU,
        NotebookControllerAffinity2: PO,
        NotebookEdit: z6,
        NotebookKernelSourceAction: ETt,
        NotebookVariablesRequestKind: Zh,
        PortAttributes: PTt,
        LinkedEditingRanges: ITt,
        TestResultState: dU,
        TestRunRequest: xO,
        TestMessage: NO,
        TestMessageStackFrame: $Tt,
        TestTag: td,
        TestRunProfileKind: ul,
        TextSearchCompleteMessageType: S8,
        DataTransfer: Uh,
        DataTransferItem: dO,
        TestCoverageCount: CO,
        FileCoverage: LO,
        StatementCoverage: vtt,
        BranchCoverage: wtt,
        DeclarationCoverage: ytt,
        WorkspaceTrustState: fU,
        LanguageStatusSeverity: Wc,
        QuickPickItemKind: Kh,
        InputBoxValidationSeverity: ol,
        TabInputText: vU,
        TabInputTextDiff: RO,
        TabInputTextMerge: btt,
        TabInputCustom: wU,
        TabInputNotebook: yU,
        TabInputNotebookDiff: bU,
        TabInputWebview: Ttt,
        TabInputTerminal: ktt,
        TabInputInteractiveWindow: Stt,
        TabInputChat: Ett,
        TabInputTextMultiDiff: Itt,
        TelemetryTrustedValue: XM,
        LogLevel: vt,
        EditSessionIdentityMatch: SW,
        InteractiveSessionVoteDirection: TU,
        ChatCopyKind: kU,
        ChatEditingSessionActionOutcome: Io,
        InteractiveEditorResponseFeedbackKind: EU,
        cursor: $s,
        UploadType: kW,
        DebugStackFrame: utt,
        DebugThread: htt,
        RelatedInformationType: NU,
        SpeechToTextStatus: CU,
        TextToSpeechStatus: JU,
        PartialAcceptTriggerKind: go,
        KeywordRecognitionStatus: LU,
        ChatResponseMarkdownPart: DO,
        ChatResponseFileTreePart: AO,
        ChatResponseAnchorPart: rd,
        ChatResponseProgressPart: nd,
        ChatResponseProgressPart2: _O,
        ChatResponseReferencePart: vn,
        ChatResponseReferencePart2: vn,
        ChatResponseCodeCitationPart: qO,
        ChatResponseCodeblockUriPart: BO,
        ChatResponseWarningPart: ad,
        ChatResponseTextEditPart: od,
        ChatResponseMarkdownWithVulnerabilitiesPart: id,
        ChatResponseCommandButtonPart: OO,
        ChatResponseDetectedParticipantPart: sd,
        ChatResponseConfirmationPart: FO,
        ChatResponseMovePart: UO,
        ChatResponseReferencePartStatusKind: IU,
        ChatRequestTurn: Ptt,
        ChatResponseTurn: $tt,
        ChatLocation: bs,
        ChatRequestEditorData: xtt,
        ChatRequestNotebookData: Ntt,
        ChatReferenceBinaryData: Ctt,
        LanguageModelChatMessageRole: Js,
        LanguageModelChatMessage: Jtt,
        LanguageModelToolResultPart: PU,
        LanguageModelTextPart: Yi,
        LanguageModelToolCallPart: cd,
        LanguageModelError: wn,
        LanguageModelToolResult: $U,
        LanguageModelChatToolMode: xU,
        LanguageModelPromptTsxPart: hl,
        NewSymbolName: wTt,
        NewSymbolNameTag: sU,
        NewSymbolNameTriggerKind: Vh,
        InlineEdit: NTt,
        InlineEditTriggerKind: ld,
        ExcludeSettingOptions: kn,
        TextSearchContext2: k8,
        TextSearchMatch2: Tn,
        TextSearchCompleteMessageTypeNew: S8,
      }
    }
  )
}
var N3,
  $j = class {
    constructor(t, e, s, r, a, o, c) {
      ;(this.c = t),
        (this.d = e),
        (this.e = s),
        (this.f = r),
        (this.g = a),
        (this.h = o),
        (this.i = c),
        (this.a = new Map()),
        (this.b = [])
    }
    async install() {
      this.j(), Ae("code/extHost/willWaitForConfig")
      const t = await this.f.getConfigProvider()
      Ae("code/extHost/didWaitForConfig")
      const e = await this.g.getExtensionPathIndex()
      this.register(new GMt(this.c, e, this.d, t, this.i)),
        this.register(this.e.createInstance(xj)),
        this.h.remote.isRemote &&
          this.register(
            this.e.createInstance(Nj, e, this.h.environment.appUriScheme),
          )
    }
    register(t) {
      if ("nodeModuleName" in t)
        if (Array.isArray(t.nodeModuleName))
          for (const e of t.nodeModuleName) this.a.set(e, t)
        else this.a.set(t.nodeModuleName, t)
      typeof t.alternativeModuleName == "function" &&
        this.b.push((e) => t.alternativeModuleName(e))
    }
  }
$j = __decorate(
  [
    __param(2, t6),
    __param(3, Ds),
    __param(4, $n),
    __param(5, ti),
    __param(6, Rt),
  ],
  $j,
)
var xj = class {
  static {
    N3 = this
  }
  static {
    this.a = new Map([
      ["vscode-ripgrep", "@vscode/ripgrep"],
      ["vscode-windows-registry", "@vscode/windows-registry"],
    ])
  }
  constructor(t) {
    if (t.environment.appRoot && N3.a.size) {
      const e = Vn(this.c(t.environment.appRoot.fsPath)),
        s = "[a-z0-9_.-]",
        r = `@${s}+\\/${s}+|${s}+`,
        a = "node_modules|node_modules\\.asar(?:\\.unpacked)?"
      this.b = new RegExp(`^(${e}/${a}\\/)(${r})(.*)$`, "i")
    }
  }
  alternativeModuleName(t) {
    if (!this.b) return
    const e = this.b.exec(this.c(t))
    if (!e) return
    const [, s, r, a] = e,
      o = N3.a.get(r)
    if (o !== void 0)
      return (
        console.warn(
          `${r} as been renamed to ${o}, please update your imports`,
        ),
        s + o + a
      )
  }
  c(t) {
    return t.replace(/\\/g, "/")
  }
}
xj = N3 = __decorate([__param(0, ti)], xj)
var GMt = class {
    constructor(i, t, e, s, r) {
      ;(this.c = i),
        (this.d = t),
        (this.e = e),
        (this.f = s),
        (this.g = r),
        (this.nodeModuleName = "vscode"),
        (this.a = new hn())
    }
    load(i, t) {
      const e = this.d.findSubstr(t)
      if (e) {
        let s = this.a.get(e.identifier)
        return (
          s || ((s = this.c(e, this.e, this.f)), this.a.set(e.identifier, s)), s
        )
      }
      if (!this.b) {
        let s = ""
        this.d.forEach(
          (r, a) =>
            (s += `	${a} -> ${r.identifier.value}
`),
        ),
          this.g
            .warn(`Could not identify extension for 'vscode' require call from ${t}. These are the extension path mappings: 
${s}`),
          (this.b = this.c(lPt, this.e, this.f))
      }
      return this.b
    }
  },
  Nj = class {
    constructor(t, e, s) {
      ;(this.e = t),
        (this.f = e),
        (this.nodeModuleName = ["open", "opn"]),
        (this.d = s.getProxy(K.MainThreadTelemetry))
      const r = s.getProxy(K.MainThreadWindow)
      this.c = (a, o) => {
        const c = S.parse(a)
        return o
          ? this.g(a, o)
          : c.scheme === "http" || c.scheme === "https"
            ? r.$openUri(c, a, { allowTunneling: !0 })
            : c.scheme === "mailto" || c.scheme === this.f
              ? r.$openUri(c, a, {})
              : this.g(a, o)
      }
    }
    load(t, e, s) {
      const r = this.e.findSubstr(e)
      return (
        r && ((this.a = r.identifier.value), this.h()), (this.b = s(t)), this.c
      )
    }
    g(t, e) {
      return this.i(), this.b(t, e)
    }
    h() {
      this.a && this.d.$publicLog2("shimming.open", { extension: this.a })
    }
    i() {
      this.a &&
        this.d.$publicLog2("shimming.open.call.noForward", {
          extension: this.a,
        })
    }
  }
Nj = __decorate([__param(2, Ot)], Nj)
import {
  LogLevel as jo,
  createHttpPatch as _ct,
  createProxyResolver as zMt,
  createTlsPatch as YMt,
  createNetPatch as QMt,
  loadSystemCertificates as XMt,
} from "@vscode/proxy-agent"
import { createRequire as KMt } from "node:module"
import { parse as Oct } from "url"
import { spawn as ZMt } from "child_process"
import { userInfo as tHt } from "os"
import * as eHt from "os"
var Bct = /^\d+$/,
  iHt = /^Microsoft.PowerShell_.*/,
  sHt = /^Microsoft.PowerShellPreview_.*/,
  qct
;(function (i) {
  ;(i[(i.x64 = 0)] = "x64"), (i[(i.x86 = 1)] = "x86"), (i[(i.ARM = 2)] = "ARM")
})(qct || (qct = {}))
var jf
switch (process.arch) {
  case "ia32":
    jf = 1
    break
  case "arm":
  case "arm64":
    jf = 2
    break
  default:
    jf = 0
    break
}
var Xl
process.env.PROCESSOR_ARCHITEW6432
  ? (Xl = process.env.PROCESSOR_ARCHITEW6432 === "ARM64" ? 2 : 0)
  : process.env.PROCESSOR_ARCHITECTURE === "ARM64"
    ? (Xl = 2)
    : process.env.PROCESSOR_ARCHITECTURE === "X86"
      ? (Xl = 1)
      : (Xl = 0)
var C3 = class {
  constructor(i, t, e) {
    ;(this.exePath = i), (this.displayName = t), (this.a = e)
  }
  async exists() {
    return (
      this.a === void 0 && (this.a = await Mi.existsFile(this.exePath)), this.a
    )
  }
}
function rHt({ useAlternateBitness: i = !1 } = {}) {
  return i
    ? jf === 0
      ? process.env["ProgramFiles(x86)"] || null
      : (Xl === 0 && process.env.ProgramW6432) || null
    : process.env.ProgramFiles || null
}
async function J3({ useAlternateBitness: i = !1, findPreview: t = !1 } = {}) {
  const e = rHt({ useAlternateBitness: i })
  if (!e) return null
  const s = se(e, "PowerShell")
  if (!(await Mi.existsDirectory(s))) return null
  let r = -1,
    a = null
  for (const l of await re.readdir(s)) {
    let u = -1
    if (t) {
      const m = l.indexOf("-")
      if (m < 0) continue
      const f = l.substring(0, m)
      if (!Bct.test(f) || l.substring(m + 1) !== "preview") continue
      u = parseInt(f, 10)
    } else {
      if (!Bct.test(l)) continue
      u = parseInt(l, 10)
    }
    if (u <= r) continue
    const d = se(s, l, "pwsh.exe")
    ;(await Mi.existsFile(d)) && ((a = d), (r = u))
  }
  if (!a) return null
  const o = e.includes("x86") ? " (x86)" : "",
    c = t ? " Preview" : ""
  return new C3(a, `PowerShell${c}${o}`, !0)
}
async function Uct({ findPreview: i } = {}) {
  if (!process.env.LOCALAPPDATA) return null
  const t = se(process.env.LOCALAPPDATA, "Microsoft", "WindowsApps")
  if (!(await Mi.existsDirectory(t))) return null
  const { pwshMsixDirRegex: e, pwshMsixName: s } = i
    ? { pwshMsixDirRegex: sHt, pwshMsixName: "PowerShell Preview (Store)" }
    : { pwshMsixDirRegex: iHt, pwshMsixName: "PowerShell (Store)" }
  for (const r of await re.readdir(t))
    if (e.test(r)) {
      const a = se(t, r, "pwsh.exe")
      return new C3(a, s)
    }
  return null
}
function nHt() {
  const i = se(eHt.homedir(), ".dotnet", "tools", "pwsh.exe")
  return new C3(i, ".NET Core PowerShell Global Tool")
}
function aHt() {
  const i = se(
    process.env.windir,
    jf === 1 && Xl !== 1 ? "SysNative" : "System32",
    "WindowsPowerShell",
    "v1.0",
    "powershell.exe",
  )
  return new C3(i, "Windows PowerShell", !0)
}
async function* oHt() {
  let i = await J3()
  i && (yield i),
    (i = await J3({ useAlternateBitness: !0 })),
    i && (yield i),
    (i = await Uct()),
    i && (yield i),
    (i = nHt()),
    i && (yield i),
    (i = await J3({ findPreview: !0 })),
    i && (yield i),
    (i = await Uct({ findPreview: !0 })),
    i && (yield i),
    (i = await J3({ useAlternateBitness: !0, findPreview: !0 })),
    i && (yield i),
    (i = aHt()),
    i && (yield i)
}
async function* cHt() {
  for await (const i of oHt()) (await i.exists()) && (yield i)
}
async function lHt() {
  for await (const i of cHt()) return i
  return null
}
async function uHt(i, t) {
  return i === 1 ? (ie ? dHt() : nrt(t)) : hHt(i, t)
}
var Cj = null
function hHt(i, t) {
  if ((De && i === 2) || (Ke && i === 3)) return "/bin/bash"
  if (!Cj) {
    let e
    if (ie) e = "/bin/bash"
    else {
      if (((e = t.SHELL), !e))
        try {
          e = tHt().shell
        } catch {}
      e || (e = "sh"), e === "/bin/false" && (e = "/bin/bash")
    }
    Cj = e
  }
  return Cj
}
var Jj = null
async function dHt() {
  return Jj || (Jj = (await lHt()).exePath), Jj
}
import "assert"
var Jte = $V(xV(), 1),
  Lte = { o: g(1756, null), e: g(1757, null), t: g(1758, null) },
  Rte = {
    tunnel: {
      type: "subcommand",
      description:
        "Make the current machine accessible from vscode.dev or other machines through a secure tunnel",
      options: {
        "cli-data-dir": {
          type: "string",
          args: "dir",
          description: g(1759, null),
        },
        "disable-telemetry": { type: "boolean" },
        "telemetry-level": { type: "string" },
        user: {
          type: "subcommand",
          options: {
            login: {
              type: "subcommand",
              options: {
                provider: { type: "string" },
                "access-token": { type: "string" },
              },
            },
          },
        },
      },
    },
    "serve-web": {
      type: "subcommand",
      description: "Run a server that displays the editor UI in browsers.",
      options: {
        "cli-data-dir": {
          type: "string",
          args: "dir",
          description: g(1760, null),
        },
        "disable-telemetry": { type: "boolean" },
        "telemetry-level": { type: "string" },
      },
    },
    diff: {
      type: "boolean",
      cat: "o",
      alias: "d",
      args: ["file", "file"],
      description: g(1761, null),
    },
    merge: {
      type: "boolean",
      cat: "o",
      alias: "m",
      args: ["path1", "path2", "base", "result"],
      description: g(1762, null),
    },
    add: {
      type: "boolean",
      cat: "o",
      alias: "a",
      args: "folder",
      description: g(1763, null),
    },
    goto: {
      type: "boolean",
      cat: "o",
      alias: "g",
      args: "file:line[:character]",
      description: g(1764, null),
    },
    "new-window": {
      type: "boolean",
      cat: "o",
      alias: "n",
      description: g(1765, null),
    },
    "reuse-window": {
      type: "boolean",
      cat: "o",
      alias: "r",
      description: g(1766, null),
    },
    wait: { type: "boolean", cat: "o", alias: "w", description: g(1767, null) },
    waitMarkerFilePath: { type: "string" },
    locale: {
      type: "string",
      cat: "o",
      args: "locale",
      description: g(1768, null),
    },
    "user-data-dir": {
      type: "string",
      cat: "o",
      args: "dir",
      description: g(1769, null),
    },
    profile: {
      type: "string",
      cat: "o",
      args: "profileName",
      description: g(1770, null),
    },
    help: { type: "boolean", cat: "o", alias: "h", description: g(1771, null) },
    "extensions-dir": {
      type: "string",
      deprecates: ["extensionHomePath"],
      cat: "e",
      args: "dir",
      description: g(1772, null),
    },
    "extensions-download-dir": { type: "string" },
    "builtin-extensions-dir": { type: "string" },
    "list-extensions": {
      type: "boolean",
      cat: "e",
      description: g(1773, null),
    },
    "show-versions": { type: "boolean", cat: "e", description: g(1774, null) },
    category: {
      type: "string",
      allowEmptyValue: !0,
      cat: "e",
      description: g(1775, null),
      args: "category",
    },
    "install-extension": {
      type: "string[]",
      cat: "e",
      args: "ext-id | path",
      description: g(1776, null),
    },
    "pre-release": { type: "boolean", cat: "e", description: g(1777, null) },
    "uninstall-extension": {
      type: "string[]",
      cat: "e",
      args: "ext-id",
      description: g(1778, null),
    },
    "update-extensions": {
      type: "boolean",
      cat: "e",
      description: g(1779, null),
    },
    "enable-proposed-api": {
      type: "string[]",
      allowEmptyValue: !0,
      cat: "e",
      args: "ext-id",
      description: g(1780, null),
    },
    version: {
      type: "boolean",
      cat: "t",
      alias: "v",
      description: g(1781, null),
    },
    verbose: {
      type: "boolean",
      cat: "t",
      global: !0,
      description: g(1782, null),
    },
    log: {
      type: "string[]",
      cat: "t",
      args: "level",
      global: !0,
      description: g(1783, null),
    },
    status: {
      type: "boolean",
      alias: "s",
      cat: "t",
      description: g(1784, null),
    },
    "prof-startup": { type: "boolean", cat: "t", description: g(1785, null) },
    "prof-append-timers": { type: "string" },
    "prof-duration-markers": { type: "string[]" },
    "prof-duration-markers-file": { type: "string" },
    "no-cached-data": { type: "boolean" },
    "prof-startup-prefix": { type: "string" },
    "prof-v8-extensions": { type: "boolean" },
    "disable-extensions": {
      type: "boolean",
      deprecates: ["disableExtensions"],
      cat: "t",
      description: g(1786, null),
    },
    "disable-extension": {
      type: "string[]",
      cat: "t",
      args: "ext-id",
      description: g(1787, null),
    },
    sync: {
      type: "string",
      cat: "t",
      description: g(1788, null),
      args: ["on | off"],
    },
    "inspect-extensions": {
      type: "string",
      allowEmptyValue: !0,
      deprecates: ["debugPluginHost"],
      args: "port",
      cat: "t",
      description: g(1789, null),
    },
    "inspect-brk-extensions": {
      type: "string",
      allowEmptyValue: !0,
      deprecates: ["debugBrkPluginHost"],
      args: "port",
      cat: "t",
      description: g(1790, null),
    },
    "disable-lcd-text": {
      type: "boolean",
      cat: "t",
      description: g(1791, null),
    },
    "disable-gpu": { type: "boolean", cat: "t", description: g(1792, null) },
    "disable-chromium-sandbox": {
      type: "boolean",
      cat: "t",
      description: g(1793, null),
    },
    sandbox: { type: "boolean" },
    telemetry: { type: "boolean", cat: "t", description: g(1794, null) },
    remote: { type: "string", allowEmptyValue: !0 },
    "folder-uri": { type: "string[]", cat: "o", args: "uri" },
    "file-uri": { type: "string[]", cat: "o", args: "uri" },
    "locate-extension": { type: "string[]" },
    extensionDevelopmentPath: { type: "string[]" },
    extensionDevelopmentKind: { type: "string[]" },
    extensionTestsPath: { type: "string" },
    extensionEnvironment: { type: "string" },
    debugId: { type: "string" },
    debugRenderer: { type: "boolean" },
    "inspect-ptyhost": { type: "string", allowEmptyValue: !0 },
    "inspect-brk-ptyhost": { type: "string", allowEmptyValue: !0 },
    "inspect-search": {
      type: "string",
      deprecates: ["debugSearch"],
      allowEmptyValue: !0,
    },
    "inspect-brk-search": {
      type: "string",
      deprecates: ["debugBrkSearch"],
      allowEmptyValue: !0,
    },
    "inspect-sharedprocess": { type: "string", allowEmptyValue: !0 },
    "inspect-brk-sharedprocess": { type: "string", allowEmptyValue: !0 },
    "export-default-configuration": { type: "string" },
    "install-source": { type: "string" },
    "enable-smoke-test-driver": { type: "boolean" },
    logExtensionHostCommunication: { type: "boolean" },
    "skip-release-notes": { type: "boolean" },
    "skip-welcome": { type: "boolean" },
    "skip-onboarding": { type: "boolean" },
    "override-cursor-auth-token": { type: "string" },
    "disable-telemetry": { type: "boolean" },
    "disable-updates": { type: "boolean" },
    "use-inmemory-secretstorage": {
      type: "boolean",
      deprecates: ["disable-keytar"],
    },
    "password-store": { type: "string" },
    "disable-workspace-trust": { type: "boolean" },
    "disable-crash-reporter": { type: "boolean" },
    "crash-reporter-directory": { type: "string" },
    "crash-reporter-id": { type: "string" },
    "skip-add-to-recently-opened": { type: "boolean" },
    "open-url": { type: "boolean" },
    "file-write": { type: "boolean" },
    "file-chmod": { type: "boolean" },
    "install-builtin-extension": { type: "string[]" },
    force: { type: "boolean" },
    "do-not-sync": { type: "boolean" },
    trace: { type: "boolean" },
    "trace-category-filter": { type: "string" },
    "trace-options": { type: "string" },
    "preserve-env": { type: "boolean" },
    "force-user-env": { type: "boolean" },
    "force-disable-user-env": { type: "boolean" },
    "open-devtools": { type: "boolean" },
    "shadow-window-for-workspace-id": { type: "string" },
    "disable-gpu-sandbox": { type: "boolean" },
    logsPath: { type: "string" },
    "__enable-file-policy": { type: "boolean" },
    editSessionId: { type: "string" },
    continueOn: { type: "string" },
    "locate-shell-integration-path": {
      type: "string",
      args: ["bash", "pwsh", "zsh", "fish"],
    },
    "enable-coi": { type: "boolean" },
    "no-proxy-server": { type: "boolean" },
    "no-sandbox": { type: "boolean", alias: "sandbox" },
    "proxy-server": { type: "string" },
    "proxy-bypass-list": { type: "string" },
    "proxy-pac-url": { type: "string" },
    "js-flags": { type: "string" },
    inspect: { type: "string", allowEmptyValue: !0 },
    "inspect-brk": { type: "string", allowEmptyValue: !0 },
    nolazy: { type: "boolean" },
    "force-device-scale-factor": { type: "string" },
    "force-renderer-accessibility": { type: "boolean" },
    "ignore-certificate-errors": { type: "boolean" },
    "allow-insecure-localhost": { type: "boolean" },
    "log-net-log": { type: "string" },
    vmodule: { type: "string" },
    _urls: { type: "string[]" },
    "disable-dev-shm-usage": { type: "boolean" },
    "profile-temp": { type: "boolean" },
    "ozone-platform": { type: "string" },
    "enable-tracing": { type: "string" },
    "trace-startup-format": { type: "string" },
    "trace-startup-file": { type: "string" },
    "trace-startup-duration": { type: "string" },
    _: { type: "string[]" },
  }
function Mct(i) {
  return i.VSCODE_CLI === "1"
}
var Lj = void 0
async function mHt(i, t, e, s) {
  return e["force-disable-user-env"]
    ? (t.trace("resolveShellEnv(): skipped (--force-disable-user-env)"), {})
    : ie
      ? (t.trace("resolveShellEnv(): skipped (Windows)"), {})
      : Mct(s) && !e["force-user-env"]
        ? (t.trace("resolveShellEnv(): skipped (VSCODE_CLI is set)"), {})
        : (Mct(s)
            ? t.trace("resolveShellEnv(): running (--force-user-env)")
            : t.trace("resolveShellEnv(): running (macOS/Linux)"),
          Lj ||
            (Lj = Qn.withAsyncBody(async (r, a) => {
              const o = new fe()
              let c = 1e4
              const l = i.getValue(
                "application.shellEnvironmentResolutionTimeout",
              )
              typeof l == "number" && (c = Vwt(l, 1, 120) * 1e3)
              const u = setTimeout(() => {
                o.dispose(!0), a(new Error(g(2122, null)))
              }, c)
              try {
                r(await fHt(t, o.token))
              } catch (d) {
                !Ms(d) && !o.token.isCancellationRequested
                  ? a(new Error(g(2123, null, Zs(d))))
                  : r({})
              } finally {
                clearTimeout(u), o.dispose()
              }
            })),
          Lj)
}
async function fHt(i, t) {
  const e = process.env.ELECTRON_RUN_AS_NODE
  i.trace("getUnixShellEnvironment#runAsNode", e)
  const s = process.env.ELECTRON_NO_ATTACH_CONSOLE
  i.trace("getUnixShellEnvironment#noAttach", s)
  const r = Ze().replace(/-/g, "").substr(0, 12),
    a = new RegExp(r + "({.*})" + r),
    o = {
      ...process.env,
      ELECTRON_RUN_AS_NODE: "1",
      ELECTRON_NO_ATTACH_CONSOLE: "1",
      VSCODE_RESOLVING_ENVIRONMENT: "1",
    }
  i.trace("getUnixShellEnvironment#env", o)
  const c = await uHt(w7, o)
  return (
    i.trace("getUnixShellEnvironment#shell", c),
    new Promise((l, u) => {
      if (t.isCancellationRequested) return u(new bi())
      const d = ke(c)
      let m, f
      const p = ""
      ;/^pwsh(-preview)?$/.test(d)
        ? ((m = `& '${process.execPath}' ${p} -p '''${r}'' + JSON.stringify(process.env) + ''${r}'''`),
          (f = ["-Login", "-Command"]))
        : d === "nu"
          ? ((m = `^'${process.execPath}' ${p} -p '"${r}" + JSON.stringify(process.env) + "${r}"'`),
            (f = ["-i", "-l", "-c"]))
          : d === "xonsh"
            ? ((m = `import os, json; print("${r}", json.dumps(dict(os.environ)), "${r}")`),
              (f = ["-i", "-l", "-c"]))
            : ((m = `'${process.execPath}' ${p} -p '"${r}" + JSON.stringify(process.env) + "${r}"'`),
              d === "tcsh" || d === "csh"
                ? (f = ["-ic"])
                : (f = ["-i", "-l", "-c"])),
        i.trace("getUnixShellEnvironment#spawn", JSON.stringify(f), m)
      const v = ZMt(c, [...f, m], {
        detached: !0,
        stdio: ["ignore", "pipe", "pipe"],
        env: o,
      })
      t.onCancellationRequested(() => (v.kill(), u(new bi()))),
        v.on("error", (E) => {
          i.error("getUnixShellEnvironment#errorChildProcess", Zs(E)), u(E)
        })
      const b = []
      v.stdout.on("data", (E) => b.push(E))
      const k = []
      v.stderr.on("data", (E) => k.push(E)),
        v.on("close", (E, P) => {
          const C = Buffer.concat(b).toString("utf8")
          i.trace("getUnixShellEnvironment#raw", C)
          const R = Buffer.concat(k).toString("utf8")
          if (
            (R.trim() && i.trace("getUnixShellEnvironment#stderr", R), E || P)
          )
            return u(new Error(g(2124, null, E, P)))
          const D = a.exec(C),
            V = D ? D[1] : "{}"
          try {
            const tt = JSON.parse(V)
            e ? (tt.ELECTRON_RUN_AS_NODE = e) : delete tt.ELECTRON_RUN_AS_NODE,
              s
                ? (tt.ELECTRON_NO_ATTACH_CONSOLE = s)
                : delete tt.ELECTRON_NO_ATTACH_CONSOLE,
              delete tt.VSCODE_RESOLVING_ENVIRONMENT,
              delete tt.XDG_RUNTIME_DIR,
              i.trace("getUnixShellEnvironment#result", tt),
              l(tt)
          } catch (tt) {
            i.error("getUnixShellEnvironment#errorCaught", Zs(tt)), u(tt)
          }
        })
    })
  )
}
import { parse as Hct } from "url"
function pHt(i, t) {
  return i.protocol === "http:"
    ? t.HTTP_PROXY || t.http_proxy || null
    : (i.protocol === "https:" &&
        (t.HTTPS_PROXY || t.https_proxy || t.HTTP_PROXY || t.http_proxy)) ||
        null
}
async function gHt(i, t, e = {}) {
  const s = Hct(i),
    r = e.proxyUrl || pHt(s, t)
  if (!r) return null
  const a = Hct(r)
  if (!/^https?:$/.test(a.protocol || "")) return null
  const o = {
    host: a.hostname || "",
    port: (a.port ? +a.port : 0) || (a.protocol === "https" ? 443 : 80),
    auth: a.auth,
    rejectUnauthorized: PG(e.strictSSL) ? e.strictSSL : !0,
  }
  if (s.protocol === "http:") {
    const { default: c } = await import("http-proxy-agent")
    return new c.HttpProxyAgent(r, o)
  } else {
    const { default: c } = await import("https-proxy-agent")
    return new c.HttpsProxyAgent(r, o)
  }
}
import { createGunzip as vHt } from "zlib"
var Wct = class extends sbt {
  constructor(t, e, s) {
    super(s),
      (this.m = t),
      (this.n = e),
      this.q(),
      this.D(
        t.onDidChangeConfiguration((r) => {
          r.affectsConfiguration("http") && this.q()
        }),
      )
  }
  q() {
    const t = this.m.getValue("http")
    ;(this.f = t?.proxy),
      (this.g = !!t?.proxyStrictSSL),
      (this.h = t?.proxyAuthorization)
  }
  async request(t, e) {
    const { f: s, g: r } = this
    let a
    try {
      a = await mHt(this.m, this.b, this.n.args, process.env)
    } catch (l) {
      this.j ||
        ((this.j = !0),
        this.b.error("resolving shell environment failed", CV(l)))
    }
    const o = { ...process.env, ...a },
      c = t.agent
        ? t.agent
        : await gHt(t.url || "", o, { proxyUrl: s, strictSSL: r })
    return (
      (t.agent = c),
      (t.strictSSL = r),
      this.h &&
        (t.headers = { ...(t.headers || {}), "Proxy-Authorization": this.h }),
      this.c(t, () => Rj(t, e))
    )
  }
  async resolveProxy(t) {}
  async lookupAuthorization(t) {}
  async lookupKerberosAuthorization(t) {
    try {
      const e = this.m.getValue("http.proxyKerberosServicePrincipal")
      return (
        "Negotiate " +
        (await jct(t, e, this.b, "RequestService#lookupKerberosAuthorization"))
      )
    } catch (e) {
      this.b.debug(
        "RequestService#lookupKerberosAuthorization Kerberos authentication failed",
        e,
      )
      return
    }
  }
  async loadCertificates() {
    return (await import("@vscode/proxy-agent")).loadSystemCertificates({
      log: this.b,
    })
  }
}
Wct = __decorate([__param(0, dn), __param(1, cbt), __param(2, Rt)], Wct)
async function jct(i, t, e, s) {
  const r = await import("kerberos"),
    a = r.default || r,
    o = new URL(i),
    c =
      t ||
      (process.platform === "win32"
        ? `HTTP/${o.hostname}`
        : `HTTP@${o.hostname}`)
  return (
    e.debug(`${s} Kerberos authentication lookup`, `proxyURL:${o}`, `spn:${c}`),
    (await a.initializeClient(c)).step("")
  )
}
async function wHt(i) {
  return (
    Oct(i.url).protocol === "https:"
      ? await import("https")
      : await import("http")
  ).request
}
async function Rj(i, t) {
  return Qn.withAsyncBody(async (e, s) => {
    const r = Oct(i.url),
      a = i.getRawRequest ? i.getRawRequest(i) : await wHt(i),
      o = {
        hostname: r.hostname,
        port: r.port ? parseInt(r.port) : r.protocol === "https:" ? 443 : 80,
        protocol: r.protocol,
        path: r.path,
        method: i.type || "GET",
        headers: i.headers,
        agent: i.agent,
        rejectUnauthorized: PG(i.strictSSL) ? i.strictSSL : !0,
      }
    i.user && i.password && (o.auth = i.user + ":" + i.password)
    const c = a(o, (l) => {
      const u = ps(i.followRedirects) ? i.followRedirects : 3
      if (
        l.statusCode &&
        l.statusCode >= 300 &&
        l.statusCode < 400 &&
        u > 0 &&
        l.headers.location
      )
        l.statusCode === 303
          ? Rj(
              {
                ...i,
                url: l.headers.location,
                type: "GET",
                followRedirects: u - 1,
              },
              t,
            ).then(e, s)
          : Rj(
              { ...i, url: l.headers.location, followRedirects: u - 1 },
              t,
            ).then(e, s)
      else {
        let d = l
        !i.isChromiumNetwork &&
          l.headers["content-encoding"] === "gzip" &&
          (d = l.pipe(vHt())),
          e({ res: l, stream: cvt(d) })
      }
    })
    c.on("error", s),
      i.timeout && c.setTimeout(i.timeout),
      i.isChromiumNetwork && c.removeHeader("Content-Length"),
      i.data && typeof i.data == "string" && c.write(i.data),
      c.end(),
      t.onCancellationRequested(() => {
        c.abort(), s(new bi())
      })
  })
}
import * as L3 from "@vscode/proxy-agent"
var Kl = KMt(import.meta.url),
  Vct = Kl("http"),
  R3 = Kl("https"),
  Gct = Kl("tls"),
  zct = Kl("net"),
  Yct = !1,
  Qct = !1
function yHt(i, t, e, s, r, a, o) {
  const c = a.environment.useHostProxy,
    l = typeof c == "boolean" ? c : !a.remote.isRemote,
    u = {
      resolveProxy: (v) => i.resolveProxy(v),
      lookupProxyAuthorization: PHt.bind(
        void 0,
        i,
        s,
        r,
        t,
        {},
        {},
        a.remote.isRemote,
        l,
      ),
      getProxyURL: () => t.getConfiguration("http").get("proxy"),
      getProxySupport: () =>
        t.getConfiguration("http").get("proxySupport") || "off",
      getNoProxyConfig: () => t.getConfiguration("http").get("noProxy") || [],
      isAdditionalFetchSupportEnabled: () =>
        t.getConfiguration("http").get("fetchAdditionalSupport", !0),
      addCertificatesV1: () => SHt(t),
      addCertificatesV2: () => EHt(t),
      log: s,
      getLogLevel: () => {
        const v = s.getLevel()
        switch (v) {
          case vt.Trace:
            return jo.Trace
          case vt.Debug:
            return jo.Debug
          case vt.Info:
            return jo.Info
          case vt.Warning:
            return jo.Warning
          case vt.Error:
            return jo.Error
          case vt.Off:
            return jo.Off
          default:
            return b(v)
        }
        function b(k) {
          return s.error("Unknown log level", k), jo.Debug
        }
      },
      proxyResolveTelemetry: () => {},
      useHostProxy: l,
      loadAdditionalCertificates: async () => {
        const v = []
        if ((a.remote.isRemote && v.push(XMt({ log: s })), l)) {
          s.trace(
            "ProxyResolver#loadAdditionalCertificates: Loading certificates from main process",
          )
          const b = i.loadCertificates()
          b.then((k) =>
            s.trace(
              "ProxyResolver#loadAdditionalCertificates: Loaded certificates from main process",
              k.length,
            ),
          ),
            v.push(b)
        }
        return (
          a.environment.extensionTestsLocationURI &&
            R3.globalAgent.testCertificates?.length &&
            (s.trace(
              "ProxyResolver#loadAdditionalCertificates: Loading test certificates",
            ),
            v.push(Promise.resolve(R3.globalAgent.testCertificates))),
          (await Promise.all(v)).flat()
        )
      },
      env: process.env,
    },
    { resolveProxyWithRequest: d, resolveProxyURL: m } = zMt(u),
    f = L3.default || L3
  ;(f.resolveProxyURL = m), THt(u, t, r, a, m, o)
  const p = kHt(u, d)
  return IHt(e, p)
}
var bHt = [
  "content-length",
  "host",
  "trailer",
  "te",
  "upgrade",
  "cookie2",
  "keep-alive",
  "transfer-encoding",
  "set-cookie",
]
function THt(i, t, e, s, r, a) {
  if (!globalThis.__vscodeOriginalFetch) {
    const o = globalThis.fetch
    globalThis.__vscodeOriginalFetch = o
    const c = L3.createFetchPatch(i, o, r)
    globalThis.__vscodePatchedFetch = c
    let l = !1
    s.remote.isRemote ||
      ((l = t.getConfiguration("http").get("electronFetch", Qct)),
      a.add(
        t.onDidChangeConfiguration((u) => {
          u.affectsConfiguration("http.electronFetch") &&
            (l = t.getConfiguration("http").get("electronFetch", Qct))
        }),
      )),
      (globalThis.fetch = async function (d, m) {
        function f(D) {
          return m && D in m
            ? m[D]
            : typeof d == "object" && "cache" in d
              ? d[D]
              : void 0
        }
        const p =
            typeof d == "string" ? d : "cache" in d ? d.url : d.toString(),
          v = p.startsWith("data:")
        v && Zl(e, "data")
        const b = p.startsWith("blob:")
        b && Zl(e, "blob")
        const k = f("redirect") === "manual"
        k && Zl(e, "manualRedirect")
        const E = f("integrity")
        if ((E && Zl(e, "integrity"), !l || v || b || k || E)) {
          const D = await c(d, m)
          return Xct(e, D, p), D
        }
        if (m?.headers) {
          const D = new Headers(m.headers)
          for (const V of bHt) D.delete(V)
          m = { ...m, headers: D }
        }
        const P = d instanceof URL ? d.toString() : d,
          R = await Kl("electron").net.fetch(P, m)
        return Xct(e, R, p), R
      })
  }
}
function Xct(i, t, e) {
  const s = t.url
  Object.defineProperty(t, "url", {
    get() {
      return Zl(i, "url"), s || e
    },
  })
  const r = t.type
  Object.defineProperty(t, "type", {
    get() {
      return Zl(i, "typeProperty"), r !== "default" ? r : "basic"
    },
  })
}
var Kct = {
    url: 0,
    typeProperty: 0,
    data: 0,
    blob: 0,
    integrity: 0,
    manualRedirect: 0,
  },
  D3
function Zl(i, t) {
  Kct[t]++ ||
    (D3 && clearTimeout(D3),
    (D3 = setTimeout(() => {
      i.$publicLog2("fetchFeatureUse", Kct)
    }, 1e4)),
    D3.unref())
}
function kHt(i, t) {
  function e(s, r) {
    const a = s.default || s
    return (a.__vscodeOriginal = Object.assign({}, a)), Object.assign(a, r)
  }
  return {
    http: e(Vct, _ct(i, Vct, t)),
    https: e(R3, _ct(i, R3, t)),
    net: e(zct, QMt(i, zct)),
    tls: e(Gct, YMt(i, Gct)),
  }
}
function SHt(i) {
  const t = i.getConfiguration("http")
  return (
    !t.get("experimental.systemCertificatesV2", Yct) &&
    !!t.get("systemCertificates")
  )
}
function EHt(i) {
  const t = i.getConfiguration("http")
  return (
    !!t.get("experimental.systemCertificatesV2", Yct) &&
    !!t.get("systemCertificates")
  )
}
var Zct = new Map()
function IHt(i, t) {
  return i.getExtensionPathIndex().then((e) => {
    const s = Kl("module"),
      r = s._load
    s._load = function (o, c, l) {
      if (o === "net") return t.net
      if (o === "tls") return t.tls
      if (o !== "http" && o !== "https" && o !== "undici")
        return r.apply(this, arguments)
      const u = e.findSubstr(S.file(c.filename))
      let d = Zct.get(u)
      if ((d || Zct.set(u, (d = {})), !d[o]))
        if (o === "undici") {
          const m = r.apply(this, arguments)
          L3.patchUndici(m), (d[o] = m)
        } else {
          const m = t[o]
          d[o] = { ...m }
        }
      return d[o]
    }
  })
}
async function PHt(i, t, e, s, r, a, o, c, l, u, d) {
  const m = r[l]
  u && (r[l] = u),
    t.trace(
      "ProxyResolver#lookupProxyAuthorization callback",
      `proxyURL:${l}`,
      `proxyAuthenticate:${u}`,
      `proxyAuthenticateCache:${m}`,
    )
  const f = u || m,
    p = Array.isArray(f) ? f : typeof f == "string" ? [f] : []
  if (
    ($Ht(e, p, o),
    p.some((b) => /^(Negotiate|Kerberos)( |$)/i.test(b)) &&
      !d.kerberosRequested)
  ) {
    d.kerberosRequested = !0
    try {
      const b = s.getConfiguration("http").get("proxyKerberosServicePrincipal")
      return (
        "Negotiate " +
        (await jct(l, b, t, "ProxyResolver#lookupProxyAuthorization"))
      )
    } catch (b) {
      t.debug(
        "ProxyResolver#lookupProxyAuthorization Kerberos authentication failed",
        b,
      )
    }
    if (o && c) {
      t.debug(
        "ProxyResolver#lookupProxyAuthorization Kerberos authentication lookup on host",
        `proxyURL:${l}`,
      )
      const b = await i.lookupKerberosAuthorization(l)
      if (b) return "Negotiate " + b
    }
  }
  const v = p.find((b) => /^Basic( |$)/i.test(b))
  if (v)
    try {
      const b = a[l]
      if (b)
        if (d.basicAuthCacheUsed)
          t.debug(
            "ProxyResolver#lookupProxyAuthorization Basic authentication deleting cached credentials",
            `proxyURL:${l}`,
          ),
            delete a[l]
        else
          return (
            t.debug(
              "ProxyResolver#lookupProxyAuthorization Basic authentication using cached credentials",
              `proxyURL:${l}`,
            ),
            (d.basicAuthCacheUsed = !0),
            b
          )
      d.basicAuthAttempt = (d.basicAuthAttempt || 0) + 1
      const k = / realm="([^"]+)"/i.exec(v)?.[1]
      t.debug(
        "ProxyResolver#lookupProxyAuthorization Basic authentication lookup",
        `proxyURL:${l}`,
        `realm:${k}`,
      )
      const E = new URL(l),
        P = {
          scheme: "basic",
          host: E.hostname,
          port: Number(E.port),
          realm: k || "",
          isProxy: !0,
          attempt: d.basicAuthAttempt,
        },
        C = await i.lookupAuthorization(P)
      if (C) {
        t.debug(
          "ProxyResolver#lookupProxyAuthorization Basic authentication received credentials",
          `proxyURL:${l}`,
          `realm:${k}`,
        )
        const R =
          "Basic " +
          Buffer.from(`${C.username}:${C.password}`).toString("base64")
        return (a[l] = R), R
      } else
        t.debug(
          "ProxyResolver#lookupProxyAuthorization Basic authentication received no credentials",
          `proxyURL:${l}`,
          `realm:${k}`,
        )
    } catch (b) {
      t.error(
        "ProxyResolver#lookupProxyAuthorization Basic authentication failed",
        b,
      )
    }
}
var tlt = !1
function $Ht(i, t, e) {
  tlt ||
    !t.length ||
    ((tlt = !0),
    i.$publicLog2("proxyAuthenticationRequest", {
      authenticationType: t.map((s) => s.split(" ")[0]).join(","),
      extensionHostType: e ? "remote" : "local",
    }))
}
import { tmpdir as xHt } from "os"
var Dj = class extends at {
  constructor(t, e) {
    super()
    const s = t.getProxy(K.MainThreadDownloadService)
    e.registerCommand(!1, "_workbench.downloadResource", async (r) => {
      const a = S.file(se(xHt(), Ze()))
      return await s.$download(r, a), a
    })
  }
}
Dj = __decorate([__param(0, Ot), __param(1, mr)], Dj)
import * as NHt from "http"
import * as elt from "fs"
var CHt = class {
    constructor(i, t, e) {
      ;(this.b = i),
        (this.c = t),
        (this.f = e),
        (this.a = NHt.createServer((s, r) => this.h(s, r))),
        this.g().catch((s) => (t.error(s), ""))
    }
    get ipcHandlePath() {
      return this.f
    }
    async g() {
      try {
        this.a.listen(this.ipcHandlePath),
          this.a.on("error", (i) => this.c.error(i))
      } catch {
        this.c.error("Could not start open from terminal server.")
      }
      return this.f
    }
    h(i, t) {
      const e = (r, a) => {
          t.writeHead(r, { "content-type": "application/json" }),
            t.end(JSON.stringify(a || null), (o) => o && this.c.error(o))
        },
        s = []
      i.setEncoding("utf8"),
        i.on("data", (r) => s.push(r)),
        i.on("end", async () => {
          try {
            const r = JSON.parse(s.join(""))
            let a
            switch (r.type) {
              case "open":
                a = await this.i(r)
                break
              case "openExternal":
                a = await this.j(r)
                break
              case "status":
                a = await this.l(r)
                break
              case "extensionManagement":
                a = await this.k(r)
                break
              default:
                e(404, `Unknown message type: ${r.type}`)
                break
            }
            e(200, a)
          } catch (r) {
            const a = r instanceof Error ? r.message : JSON.stringify(r)
            e(500, a), this.c.error("Error while processing pipe request", r)
          }
        })
    }
    async i(i) {
      const {
          fileURIs: t,
          folderURIs: e,
          forceNewWindow: s,
          diffMode: r,
          mergeMode: a,
          addMode: o,
          forceReuseWindow: c,
          gotoLineMode: l,
          waitMarkerFilePath: u,
          remoteAuthority: d,
        } = i,
        m = []
      if (Array.isArray(e))
        for (const b of e)
          try {
            m.push({ folderUri: S.parse(b) })
          } catch {}
      if (Array.isArray(t))
        for (const b of t)
          try {
            tyt(b)
              ? m.push({ workspaceUri: S.parse(b) })
              : m.push({ fileUri: S.parse(b) })
          } catch {}
      const f = u ? S.file(u) : void 0,
        v = {
          forceNewWindow: s,
          diffMode: r,
          mergeMode: a,
          addMode: o,
          gotoLineMode: l,
          forceReuseWindow: c,
          preferNewWindow: !c && !f && !o,
          waitMarkerFileURI: f,
          remoteAuthority: d,
        }
      this.b.executeCommand("_remoteCLI.windowOpen", m, v)
    }
    async j(i) {
      for (const t of i.uris) {
        const e = S.parse(t),
          s = e.scheme === "file" ? e : t
        await this.b.executeCommand("_remoteCLI.openExternal", s)
      }
    }
    async k(i) {
      const t = (s) => s?.map((r) => (/\.vsix$/i.test(r) ? S.parse(r) : r)),
        e = {
          list: i.list,
          install: t(i.install),
          uninstall: t(i.uninstall),
          force: i.force,
        }
      return await this.b.executeCommand("_remoteCLI.manageExtensions", e)
    }
    async l(i) {
      return await this.b.executeCommand("_remoteCLI.getSystemStatus")
    }
    dispose() {
      this.a.close(),
        this.f &&
          process.platform !== "win32" &&
          elt.existsSync(this.f) &&
          elt.unlinkSync(this.f)
    }
  },
  Fj = class extends CHt {
    constructor(t, e) {
      super(t, e, e1t())
    }
  }
Fj = __decorate([__param(0, mr), __param(1, Rt)], Fj)
var Aj = class {
  constructor(t, e) {
    ;(this.a = t.getProxy(K.MainThreadConsole)),
      (this.b = e.consoleForward.includeStack),
      (this.c = e.consoleForward.logNative),
      this.d("info", "log"),
      this.d("log", "log"),
      this.d("warn", "warn"),
      this.d("debug", "debug"),
      this.d("error", "error")
  }
  d(t, e) {
    const s = this,
      r = console[t]
    Object.defineProperty(console, t, {
      set: () => {},
      get: () =>
        function () {
          s.e(t, e, r, arguments)
        },
    })
  }
  e(t, e, s, r) {
    this.a.$logExtensionHostMessage({
      type: "__$console",
      severity: e,
      arguments: LHt(r, this.b),
    }),
      this.c && this.f(t, s, r)
  }
}
Aj = __decorate([__param(0, Ot), __param(1, ti)], Aj)
var JHt = 1e5
function LHt(i, t) {
  const e = []
  if (i.length)
    for (let s = 0; s < i.length; s++) {
      let r = i[s]
      if (typeof r > "u") r = "undefined"
      else if (r instanceof Error) {
        const a = r
        a.stack ? (r = a.stack) : (r = a.toString())
      }
      e.push(r)
    }
  if (t) {
    const s = new Error().stack
    s &&
      e.push({
        __$stack: s
          .split(
            `
`,
          )
          .slice(3).join(`
`),
      })
  }
  try {
    const s = s1t(e)
    return s.length > JHt
      ? "Output omitted for a large object that exceeds the limits"
      : s
  } catch (s) {
    return `Output omitted for an object that cannot be inspected ('${s.toString()}')`
  }
}
var RHt = 1024 * 1024,
  _j = class extends Aj {
    constructor(t, e) {
      super(t, e),
        (this.g = !1),
        this.j("stderr", "error"),
        this.j("stdout", "log")
    }
    f(t, e, s) {
      const r = t === "error" || t === "warn" ? process.stderr : process.stdout
      ;(this.g = !0),
        r.write(`
START_NATIVE_LOG
`),
        e.apply(console, s),
        r.write(`
END_NATIVE_LOG
`),
        (this.g = !1)
    }
    j(t, e) {
      const s = process[t],
        r = s.write
      let a = ""
      Object.defineProperty(s, "write", {
        set: () => {},
        get: () => (o, c, l) => {
          if (!this.g) {
            a += o.toString(c)
            const u =
              a.length > RHt
                ? a.length
                : a.lastIndexOf(`
`)
            u !== -1 && (console[e](a.slice(0, u)), (a = a.slice(u + 1)))
          }
          r.call(s, o, c, l)
        },
      })
    }
  }
_j = __decorate([__param(0, Ot), __param(1, ti)], _j)
import { promises as Vo } from "fs"
async function DHt(i, t, e, s, r, a) {
  let o
  try {
    await FHt(i, t, e, s, r, a)
  } catch (c) {
    o = c
  } finally {
    o && r.errorTransformer && (o = r.errorTransformer(o)),
      typeof o < "u" && e.error(o),
      e.end()
  }
}
async function FHt(i, t, e, s, r, a) {
  Oj(a)
  const o = await i.open(t, { create: !1 })
  try {
    Oj(a)
    let c = 0,
      l = 0,
      u = r && typeof r.length == "number" ? r.length : void 0,
      d = Q.alloc(
        Math.min(r.bufferSize, typeof u == "number" ? u : r.bufferSize),
      ),
      m = r && typeof r.position == "number" ? r.position : 0,
      f = 0
    do
      (l = await i.read(o, m, d.buffer, f, d.byteLength - f)),
        (m += l),
        (f += l),
        (c += l),
        typeof u == "number" && (u -= l),
        f === d.byteLength &&
          (await e.write(s(d)),
          (d = Q.alloc(
            Math.min(r.bufferSize, typeof u == "number" ? u : r.bufferSize),
          )),
          (f = 0))
    while (l > 0 && (typeof u != "number" || u > 0) && Oj(a) && AHt(c, r))
    if (f > 0) {
      let p = f
      typeof u == "number" && (p = Math.min(f, u)), e.write(s(d.slice(0, p)))
    }
  } catch (c) {
    throw r0t(c)
  } finally {
    await i.close(o)
  }
}
function Oj(i) {
  if (i.isCancellationRequested) throw Nu()
  return !0
}
function AHt(i, t) {
  if (typeof t?.limits?.size == "number" && i > t.limits.size)
    throw ln(g(1955, null), dt.FileTooLarge)
  return !0
}
var _Ht = class extends at {
  constructor(i, t) {
    super(),
      (this.a = i),
      (this.b = t),
      (this.c = this.D(new J())),
      (this.onDidChangeFile = this.c.event),
      (this.g = this.D(new J())),
      (this.onDidWatchError = this.g.event),
      (this.j = []),
      (this.m = this.D(new J_(0))),
      (this.w = []),
      (this.y = this.D(new J_(0)))
  }
  watch(i, t) {
    return t.recursive || this.b?.watcher?.forceUniversal
      ? this.n(i, t)
      : this.z(i, t)
  }
  n(i, t) {
    const e = this.q(i, t),
      s = LV(this.j, e)
    return (
      this.r(),
      et(() => {
        s(), this.r()
      })
    )
  }
  q(i, t) {
    const e = {
      path: this.L(i),
      excludes: t.excludes,
      includes: t.includes,
      recursive: t.recursive,
      filter: t.filter,
      correlationId: t.correlationId,
    }
    if (dUt(e)) {
      const s = this.b?.watcher?.recursive?.usePolling
      s === !0
        ? (e.pollingInterval =
            this.b?.watcher?.recursive?.pollingInterval ?? 5e3)
        : Array.isArray(s) &&
          s.includes(e.path) &&
          (e.pollingInterval =
            this.b?.watcher?.recursive?.pollingInterval ?? 5e3)
    }
    return e
  }
  r() {
    this.m.trigger(() => this.s()).catch((i) => $e(i))
  }
  s() {
    return (
      this.h ||
        ((this.h = this.D(
          this.t(
            (i) => this.c.fire(Fot(i)),
            (i) => this.H(i),
            this.a.getLevel() === vt.Trace,
          ),
        )),
        this.D(
          this.a.onDidChangeLogLevel(() => {
            this.h?.setVerboseLogging(this.a.getLevel() === vt.Trace)
          }),
        )),
      this.h.watch(this.j)
    )
  }
  z(i, t) {
    const e = {
        path: this.L(i),
        excludes: t.excludes,
        includes: t.includes,
        recursive: !1,
        filter: t.filter,
        correlationId: t.correlationId,
      },
      s = LV(this.w, e)
    return (
      this.C(),
      et(() => {
        s(), this.C()
      })
    )
  }
  C() {
    this.y.trigger(() => this.F()).catch((i) => $e(i))
  }
  F() {
    return (
      this.u ||
        ((this.u = this.D(
          this.G(
            (i) => this.c.fire(Fot(i)),
            (i) => this.H(i),
            this.a.getLevel() === vt.Trace,
          ),
        )),
        this.D(
          this.a.onDidChangeLogLevel(() => {
            this.u?.setVerboseLogging(this.a.getLevel() === vt.Trace)
          }),
        )),
      this.u.watch(this.w)
    )
  }
  H(i) {
    i.type === "error" && this.g.fire(i.message), this.I(i)
  }
  I(i) {
    this.a[i.type](i.message)
  }
  J(i) {
    return Xr(i.fsPath)
  }
  L(i) {
    const t = this.J(i)
    return cmt(t)
  }
}
import { fork as OHt } from "child_process"
function BHt(i) {
  const t = i
  return t && typeof t.type == "string" && typeof t.severity == "string"
}
function qHt(i) {
  const t = []
  let e
  try {
    const s = JSON.parse(i.arguments),
      r = s[s.length - 1]
    r && r.__$stack && (s.pop(), (e = r.__$stack)), t.push(...s)
  } catch {
    t.push("Unable to log remote console arguments", i.arguments)
  }
  return { args: t, stack: e }
}
function UHt(i) {
  if (!i) return i
  const t = i.indexOf(`
`)
  return t === -1 ? i : i.substring(0, t)
}
function MHt(i, t) {
  const { args: e, stack: s } = qHt(i),
    r = typeof e[0] == "string" && e.length === 1
  let a = UHt(s)
  a && (a = `(${a.trim()})`)
  let o = []
  if (
    (typeof e[0] == "string"
      ? a && r
        ? (o = [`%c[${t}] %c${e[0]} %c${a}`, tu("blue"), tu(""), tu("grey")])
        : (o = [`%c[${t}] %c${e[0]}`, tu("blue"), tu(""), ...e.slice(1)])
      : (o = [`%c[${t}]%`, tu("blue"), ...e]),
    a && !r && o.push(a),
    typeof console[i.severity] != "function")
  )
    throw new Error("Unknown console method")
  console[i.severity].apply(console, o)
}
function tu(i) {
  return `color: ${i}`
}
var HHt = class {
    constructor(i, t) {
      ;(this.i = i),
        (this.j = t),
        (this.c = new Set()),
        (this.g = new Map()),
        (this.h = new J()),
        (this.onDidProcessExit = this.h.event)
      const e = t && t.timeout ? t.timeout : 6e4
      ;(this.b = new QG(e)), (this.d = null), (this.f = null)
    }
    getChannel(i) {
      const t = this
      return {
        call(e, s, r) {
          return t.k(i, e, s, r)
        },
        listen(e, s) {
          return t.l(i, e, s)
        },
      }
    }
    k(i, t, e, s = ce.None) {
      if (!this.b) return Promise.reject(new Error("disposed"))
      if (s.isCancellationRequested) return Promise.reject(Nu())
      this.b.cancel()
      const r = this.n(i),
        a = Zr((l) => r.call(t, e, l)),
        o = s.onCancellationRequested(() => a.cancel()),
        c = et(() => a.cancel())
      return (
        this.c.add(c),
        a.finally(() => {
          o.dispose(),
            this.c.delete(c),
            this.c.size === 0 && this.b && this.b.trigger(() => this.o())
        }),
        a
      )
    }
    l(i, t, e) {
      if (!this.b) return Qt.None
      this.b.cancel()
      let s
      const r = new J({
        onWillAddFirstListener: () => {
          ;(s = this.n(i).listen(t, e)(r.fire, r)), this.c.add(s)
        },
        onDidRemoveLastListener: () => {
          this.c.delete(s),
            s.dispose(),
            this.c.size === 0 && this.b && this.b.trigger(() => this.o())
        },
      })
      return r.event
    }
    get m() {
      if (!this.f) {
        const i = this.j && this.j.args ? this.j.args : [],
          t = Object.create(null)
        ;(t.env = {
          ...pe(process.env),
          VSCODE_PARENT_PID: String(process.pid),
        }),
          this.j && this.j.env && (t.env = { ...t.env, ...this.j.env }),
          this.j && this.j.freshExecArgv && (t.execArgv = []),
          this.j &&
            typeof this.j.debug == "number" &&
            (t.execArgv = ["--nolazy", "--inspect=" + this.j.debug]),
          this.j &&
            typeof this.j.debugBrk == "number" &&
            (t.execArgv = ["--nolazy", "--inspect-brk=" + this.j.debugBrk]),
          t.execArgv === void 0 &&
            (t.execArgv = process.execArgv
              .filter((d) => !/^--inspect(-brk)?=/.test(d))
              .filter((d) => !d.startsWith("--vscode-"))),
          Nxt(t.env),
          (this.d = OHt(this.i, i, t))
        const e = new J(),
          r = Qt.fromNodeEventEmitter(
            this.d,
            "message",
            (d) => d,
          )((d) => {
            if (BHt(d)) {
              MHt(d, `IPC Library: ${this.j.serverName}`)
              return
            }
            e.fire(Q.wrap(Buffer.from(d, "base64")))
          }),
          a = this.j.useQueue ? Cxt(this.d) : this.d,
          o = (d) =>
            this.d && this.d.connected && a.send(d.buffer.toString("base64")),
          c = e.event,
          l = { send: o, onMessage: c }
        this.f = new CY(l)
        const u = () => this.o()
        process.once("exit", u),
          this.d.on("error", (d) =>
            console.warn('IPC "' + this.j.serverName + '" errored with ' + d),
          ),
          this.d.on("exit", (d, m) => {
            process.removeListener("exit", u),
              r.dispose(),
              this.c.forEach((f) => Hs(f)),
              this.c.clear(),
              d !== 0 &&
                m !== "SIGTERM" &&
                console.warn(
                  'IPC "' +
                    this.j.serverName +
                    '" crashed with exit code ' +
                    d +
                    " and signal " +
                    m,
                ),
              this.b?.cancel(),
              this.o(),
              this.h.fire({ code: d, signal: m })
          })
      }
      return this.f
    }
    n(i) {
      let t = this.g.get(i)
      return t || ((t = this.m.getChannel(i)), this.g.set(i, t)), t
    }
    o() {
      this.f &&
        (this.d && (this.d.kill(), (this.d = null)),
        (this.f = null),
        this.g.clear())
    }
    dispose() {
      this.h.dispose(),
        this.b?.cancel(),
        (this.b = void 0),
        this.o(),
        this.c.clear()
    }
  },
  WHt = class extends fUt {
    constructor(i, t, e) {
      super(i, t, e), this.r()
    }
    q(i) {
      const t = i.add(
        new HHt(UG.asFileUri("bootstrap-fork").fsPath, {
          serverName: "File Watcher",
          args: ["--type=fileWatcher"],
          env: {
            VSCODE_ESM_ENTRYPOINT: "vs/platform/files/node/watcher/watcherMain",
            VSCODE_PIPE_LOGGING: "true",
            VSCODE_VERBOSE_LOGGING: "true",
          },
        }),
      )
      return (
        i.add(
          t.onDidProcessExit(({ code: e, signal: s }) =>
            this.s(`terminated by itself with code ${e}, signal: ${s} (ETERM)`),
          ),
        ),
        pq.toService(Uvt(t.getChannel("watcher")))
      )
    }
  }
import { watchFile as jHt, unwatchFile as VHt } from "fs"
var GHt = class extends at {
  constructor() {
    super(),
      (this.a = this.D(new J())),
      (this.onDidChangeFile = this.a.event),
      (this.b = this.D(new J())),
      (this.onDidLogMessage = this.b.event),
      (this.c = this.D(new J())),
      (this.f = this.c.event),
      (this.g = new Map()),
      (this.h = new Map()),
      (this.j = this.D(new f_())),
      (this.m = new Set()),
      (this.n = this.D(new J_(this.w()))),
      (this.q = 5007),
      (this.r = new Yn()),
      (this.R = !1),
      this.D(
        this.f((i) =>
          this.y({
            id: this.t(i),
            correlationId: this.s(i) ? i.correlationId : void 0,
            path: i.path,
          }),
        ),
      )
  }
  s(i) {
    return Rot(i)
  }
  t(i) {
    return this.s(i) ? i.correlationId : nn(i)
  }
  async watch(i) {
    this.r.isSettled || this.r.complete(), (this.r = new Yn())
    try {
      this.g.clear(), this.h.clear()
      for (const t of i)
        this.s(t) ? this.g.set(t.correlationId, t) : this.h.set(this.t(t), t)
      for (const [t] of this.j)
        !this.h.has(t) &&
          !this.g.has(t) &&
          (this.j.deleteAndDispose(t), this.m.delete(t))
      return await this.u(!1)
    } finally {
      this.r.complete()
    }
  }
  u(i) {
    const t = []
    for (const [e, s] of [...this.h, ...this.g]) this.j.has(e) || t.push(s)
    return this.n.trigger(() => this.N(t), i ? this.w() : 0).catch((e) => $e(e))
  }
  w() {
    return 800
  }
  isSuspended(i) {
    const t = this.t(i)
    return this.m.has(t) ? "polling" : this.j.has(t)
  }
  async y(i) {
    if (this.j.has(i.id)) return
    const t = new gt()
    this.j.set(i.id, t),
      await this.r.p,
      !t.isDisposed && (this.C(i, t), this.u(!0))
  }
  z(i) {
    this.j.deleteAndDispose(i.id), this.m.delete(i.id), this.u(!1)
  }
  C(i, t) {
    this.F(i, t)
      ? (this.P(`reusing an existing recursive watcher to monitor ${i.path}`),
        this.m.delete(i.id))
      : (this.G(i, t), this.m.add(i.id))
  }
  F(i, t) {
    const e = this.O?.subscribe(i.path, (s, r) => {
      t.isDisposed || (s ? this.C(i, t) : r?.type === 1 && this.H(i))
    })
    return e ? (t.add(e), !0) : !1
  }
  G(i, t) {
    let e = !1
    const s = (r, a) => {
      if (t.isDisposed) return
      const o = this.I(r),
        c = this.I(a),
        l = e
      ;(e = o), !o && (c || l) && this.H(i)
    }
    this.P(
      `starting fs.watchFile() on ${i.path} (correlationId: ${i.correlationId})`,
    )
    try {
      jHt(i.path, { persistent: !1, interval: this.q }, s)
    } catch (r) {
      this.Q(
        `fs.watchFile() failed with error ${r} on path ${i.path} (correlationId: ${i.correlationId})`,
      )
    }
    t.add(
      et(() => {
        this.P(
          `stopping fs.watchFile() on ${i.path} (correlationId: ${i.correlationId})`,
        )
        try {
          VHt(i.path, s)
        } catch (r) {
          this.Q(
            `fs.unwatchFile() failed with error ${r} on path ${i.path} (correlationId: ${i.correlationId})`,
          )
        }
      }),
    )
  }
  H(i) {
    this.P(
      `detected ${i.path} exists again, resuming watcher (correlationId: ${i.correlationId})`,
    )
    const t = { resource: S.file(i.path), type: 1, cId: i.correlationId }
    this.a.fire([t]), this.J(t, i), this.z(i)
  }
  I(i) {
    return i.ctimeMs === 0 && i.ino === 0
  }
  async stop() {
    this.j.clearAndDisposeAll(), this.m.clear()
  }
  J(i, t) {
    if (this.R) {
      const e = ` >> normalized ${i.type === 1 ? "[ADDED]" : i.type === 2 ? "[DELETED]" : "[CHANGED]"} ${i.resource.fsPath}`
      this.L(e, t)
    }
  }
  L(i, t) {
    this.R &&
      this.P(
        `${i}${typeof t.correlationId == "number" ? ` <${t.correlationId}> ` : ""}`,
      )
  }
  M(i) {
    return `${i.path} (excludes: ${i.excludes.length > 0 ? i.excludes : "<none>"}, includes: ${i.includes && i.includes.length > 0 ? JSON.stringify(i.includes) : "<all>"}, filter: ${wUt(i.filter)}, correlationId: ${typeof i.correlationId == "number" ? i.correlationId : "<none>"})`
  }
  async setVerboseLogging(i) {
    this.R = i
  }
}
import { watch as zHt, promises as YHt } from "fs"
var QHt = class i7 extends at {
    static {
      this.a = 100
    }
    static {
      this.b = 75
    }
    get isReusingRecursiveWatcher() {
      return this.n
    }
    get failed() {
      return this.q
    }
    constructor(t, e, s, r, a, o) {
      super(),
        (this.r = t),
        (this.s = e),
        (this.t = s),
        (this.u = r),
        (this.w = a),
        (this.y = o),
        (this.c = this.D(
          new _mt(
            { maxWorkChunkSize: 100, throttleDelay: 200, maxBufferedWork: 1e4 },
            (c) => this.t(c),
          ),
        )),
        (this.f = this.D(new Amt((c) => this.M(c), i7.b))),
        (this.g = _ot(this.r.path, this.r.excludes)),
        (this.h = this.r.includes ? _ot(this.r.path, this.r.includes) : void 0),
        (this.j = Rot(this.r) ? this.r.filter : void 0),
        (this.m = new fe()),
        (this.ready = this.z()),
        (this.n = !1),
        (this.q = !1)
    }
    async z() {
      try {
        const t = await this.F(this.r)
        if (this.m.token.isCancellationRequested) return
        const e = await YHt.stat(t)
        if (this.m.token.isCancellationRequested) return
        this.D(await this.G(t, e.isDirectory()))
      } catch (t) {
        t.code !== "ENOENT"
          ? this.O(t)
          : this.Q(
              `ignoring a path for watching who's stat info failed to resolve: ${this.r.path} (error: ${t})`,
            ),
          this.C()
      }
    }
    C() {
      ;(this.q = !0), this.u?.()
    }
    async F(t) {
      let e = t.path
      try {
        ;(e = await re.realpath(t.path)),
          t.path === e && (e = (await dq(t.path, this.m.token)) ?? t.path),
          t.path !== e &&
            this.Q(
              `correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${t.path}, real: ${e})`,
            )
      } catch {}
      return e
    }
    async G(t, e) {
      const s = new gt()
      return (
        this.H(t, e, s)
          ? (this.Q(`reusing an existing recursive watcher for ${this.r.path}`),
            (this.n = !0))
          : ((this.n = !1), await this.I(t, e, s)),
        s
      )
    }
    H(t, e, s) {
      if (e) return !1
      const r = S.file(this.r.path),
        a = this.s?.subscribe(this.r.path, async (o, c) => {
          if (!s.isDisposed)
            if (o) {
              const l = await this.G(t, e)
              s.isDisposed ? l.dispose() : s.add(l)
            } else
              c &&
                (typeof c.cId == "number" ||
                  typeof this.r.correlationId == "number") &&
                this.L(
                  { resource: r, type: c.type, cId: this.r.correlationId },
                  !0,
                )
        })
      return a ? (s.add(a), !0) : !1
    }
    async I(t, e, s) {
      if (Ke && ja(t, "/Volumes/", !0)) {
        this.O(
          `Refusing to watch ${t} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`,
        )
        return
      }
      const r = new fe(this.m.token)
      s.add(et(() => r.dispose(!0)))
      const a = new gt()
      s.add(a)
      try {
        const o = S.file(this.r.path),
          c = ke(t),
          l = zHt(t)
        a.add(
          et(() => {
            l.removeAllListeners(), l.close()
          }),
        ),
          this.Q(`Started watching: '${t}'`)
        const u = new Set()
        if (e)
          try {
            for (const m of await re.readdir(t)) u.add(m)
          } catch (m) {
            this.O(m)
          }
        if (r.token.isCancellationRequested) return
        const d = new Map()
        a.add(
          et(() => {
            for (const [, m] of d) m.dispose()
            d.clear()
          }),
        ),
          l.on("error", (m, f) => {
            r.token.isCancellationRequested ||
              (this.O(
                `Failed to watch ${t} for changes using fs.watch() (${m}, ${f})`,
              ),
              this.C())
          }),
          l.on("change", (m, f) => {
            if (r.token.isCancellationRequested) return
            this.y && this.R(`[raw] ["${m}"] ${f}`)
            let p = ""
            if (
              (f && ((p = f.toString()), Ke && (p = V_(p))),
              !(!p || (m !== "change" && m !== "rename")))
            )
              if (e)
                if (m === "rename") {
                  d.get(p)?.dispose()
                  const v = setTimeout(async () => {
                    if ((d.delete(p), p === c && !(await re.exists(t)))) {
                      this.J(o)
                      return
                    }
                    if (r.token.isCancellationRequested) return
                    const b = await this.N(se(t, p))
                    if (r.token.isCancellationRequested) return
                    let k
                    b
                      ? u.has(p)
                        ? (k = 0)
                        : ((k = 1), u.add(p))
                      : (u.delete(p), (k = 2)),
                      this.L({
                        resource: He(o, p),
                        type: k,
                        cId: this.r.correlationId,
                      })
                  }, i7.a)
                  d.set(
                    p,
                    et(() => clearTimeout(v)),
                  )
                } else {
                  let v
                  u.has(p) ? (v = 0) : ((v = 1), u.add(p)),
                    this.L({
                      resource: He(o, p),
                      type: v,
                      cId: this.r.correlationId,
                    })
                }
              else if (m === "rename" || p !== c) {
                const v = setTimeout(async () => {
                  const b = await re.exists(t)
                  r.token.isCancellationRequested ||
                    (b
                      ? (this.L(
                          { resource: o, type: 0, cId: this.r.correlationId },
                          !0,
                        ),
                        a.add(await this.G(t, !1)))
                      : this.J(o))
                }, i7.a)
                a.clear(), a.add(et(() => clearTimeout(v)))
              } else
                this.L({ resource: o, type: 0, cId: this.r.correlationId }, !0)
          })
      } catch (o) {
        r.token.isCancellationRequested ||
          this.O(
            `Failed to watch ${t} for changes using fs.watch() (${o.toString()})`,
          ),
          this.C()
      }
    }
    J(t) {
      this.P("Watcher shutdown because watched path got deleted"),
        this.L({ resource: t, type: 2, cId: this.r.correlationId }, !0),
        this.f.flush(),
        this.C()
    }
    L(t, e = !1) {
      this.m.token.isCancellationRequested ||
        (this.y &&
          this.R(
            `${t.type === 1 ? "[ADDED]" : t.type === 2 ? "[DELETED]" : "[CHANGED]"} ${t.resource.fsPath}`,
          ),
        !e && this.g.some((s) => s(t.resource.fsPath))
          ? this.y && this.R(` >> ignored (excluded) ${t.resource.fsPath}`)
          : !e &&
              this.h &&
              this.h.length > 0 &&
              !this.h.some((s) => s(t.resource.fsPath))
            ? this.y &&
              this.R(` >> ignored (not included) ${t.resource.fsPath}`)
            : this.f.work(t))
    }
    M(t) {
      const e = pUt(t),
        s = []
      for (const a of e) {
        if (vUt(a, this.j)) {
          this.y && this.R(` >> ignored (filtered) ${a.resource.fsPath}`)
          continue
        }
        s.push(a)
      }
      if (s.length === 0) return
      if (this.y)
        for (const a of s)
          this.R(
            ` >> normalized ${a.type === 1 ? "[ADDED]" : a.type === 2 ? "[DELETED]" : "[CHANGED]"} ${a.resource.fsPath}`,
          )
      this.c.work(s)
        ? this.c.pending > 0 &&
          this.Q(
            `started throttling events due to large amount of file change events at once (pending: ${this.c.pending}, most recent change: ${s[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,
          )
        : this.P(
            `started ignoring events due to too many file change events at once (incoming: ${s.length}, most recent change: ${s[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,
          )
    }
    async N(t) {
      if (De) return re.exists(t)
      try {
        const e = ke(t)
        return (await re.readdir(Ui(t))).some((r) => r === e)
      } catch (e) {
        return this.Q(e), !1
      }
    }
    setVerboseLogging(t) {
      this.y = t
    }
    O(t) {
      this.m.token.isCancellationRequested ||
        this.w?.({ type: "error", message: `[File Watcher (node.js)] ${t}` })
    }
    P(t) {
      this.m.token.isCancellationRequested ||
        this.w?.({ type: "warn", message: `[File Watcher (node.js)] ${t}` })
    }
    Q(t) {
      !this.m.token.isCancellationRequested &&
        this.y &&
        this.w?.({ type: "trace", message: `[File Watcher (node.js)] ${t}` })
    }
    R(t) {
      !this.m.token.isCancellationRequested &&
        this.y &&
        this.Q(
          `${t}${typeof this.r.correlationId == "number" ? ` <${this.r.correlationId}> ` : ""}`,
        )
    }
    dispose() {
      this.m.dispose(!0), super.dispose()
    }
  },
  XHt = class extends GHt {
    constructor(i) {
      super(),
        (this.O = i),
        (this.onDidError = Qt.None),
        (this.watchers = new Set())
    }
    async N(i) {
      i = this.Z(i)
      const t = [],
        e = new Set(Array.from(this.watchers))
      for (const s of i) {
        const r = this.W(s)
        r &&
        mZ(r.request.excludes, s.excludes) &&
        mZ(r.request.includes, s.includes)
          ? e.delete(r)
          : t.push(s)
      }
      t.length &&
        this.P(
          `Request to start watching: ${t.map((s) => this.M(s)).join(",")}`,
        ),
        e.size &&
          this.P(
            `Request to stop watching: ${Array.from(e)
              .map((s) => this.M(s.request))
              .join(",")}`,
          )
      for (const s of e) this.Y(s)
      for (const s of t) this.X(s)
    }
    W(i) {
      for (const t of this.watchers)
        if (
          typeof i.correlationId == "number" ||
          typeof t.request.correlationId == "number"
        ) {
          if (t.request.correlationId === i.correlationId) return t
        } else if ($7(t.request.path, i.path, !De)) return t
    }
    X(i) {
      const t = new QHt(
          i,
          this.O,
          (s) => this.a.fire(s),
          () => this.c.fire(i),
          (s) => this.b.fire(s),
          this.R,
        ),
        e = { request: i, instance: t }
      this.watchers.add(e)
    }
    async stop() {
      await super.stop()
      for (const i of this.watchers) this.Y(i)
    }
    Y(i) {
      this.P("stopping file watcher", i),
        this.watchers.delete(i),
        i.instance.dispose()
    }
    Z(i) {
      const t = new Map()
      for (const e of i) {
        const s = De ? e.path : e.path.toLowerCase()
        let r = t.get(e.correlationId)
        r || ((r = new Map()), t.set(e.correlationId, r)),
          r.has(s) &&
            this.P(
              `ignoring a request for watching who's path is already watched: ${this.M(e)}`,
            ),
          r.set(s, e)
      }
      return Array.from(t.values())
        .map((e) => Array.from(e.values()))
        .flat()
    }
    async setVerboseLogging(i) {
      super.setVerboseLogging(i)
      for (const t of this.watchers) t.instance.setVerboseLogging(i)
    }
    P(i, t) {
      this.R && this.b.fire({ type: "trace", message: this.bb(i, t) })
    }
    Q(i) {
      this.b.fire({ type: "warn", message: this.bb(i) })
    }
    bb(i, t) {
      return t
        ? `[File Watcher (node.js)] ${i} (${this.M(t.request)})`
        : `[File Watcher (node.js)] ${i}`
    }
  },
  KHt = class extends mUt {
    constructor(i, t, e) {
      super(i, t, e), this.r()
    }
    q(i) {
      return i.add(new XHt(void 0))
    }
  },
  ZHt = class r_ extends _Ht {
    static {
      this.M = !1
    }
    constructor(t, e) {
      super(t, e),
        (this.onDidChangeCapabilities = Qt.None),
        (this.Q = new oi((s) => J7.getComparisonKey(s))),
        (this.Y = new Map()),
        (this.Z = new Map()),
        (this.$ = new Map())
    }
    get capabilities() {
      return this.N || ((this.N = 253982), De && (this.N |= 1024)), this.N
    }
    async stat(t) {
      try {
        const { stat: e, symbolicLink: s } = await Mi.stat(this.J(t))
        return {
          type: this.P(e, s),
          ctime: e.birthtime.getTime(),
          mtime: e.mtime.getTime(),
          size: e.size,
          permissions: e.mode & 128 ? void 0 : ia.Locked,
        }
      } catch (e) {
        throw this.ib(e)
      }
    }
    async O(t) {
      try {
        return await this.stat(t)
      } catch {
        return
      }
    }
    async readdir(t) {
      try {
        const e = await re.readdir(this.J(t), { withFileTypes: !0 }),
          s = []
        return (
          await Promise.all(
            e.map(async (r) => {
              try {
                let a
                r.isSymbolicLink()
                  ? (a = (await this.stat(He(t, r.name))).type)
                  : (a = this.P(r)),
                  s.push([r.name, a])
              } catch (a) {
                this.a.trace(a)
              }
            }),
          ),
          s
        )
      } catch (e) {
        throw this.ib(e)
      }
    }
    P(t, e) {
      let s
      return (
        e?.dangling
          ? (s = cs.Unknown)
          : t.isFile()
            ? (s = cs.File)
            : t.isDirectory()
              ? (s = cs.Directory)
              : (s = cs.Unknown),
        e && (s |= cs.SymbolicLink),
        s
      )
    }
    async R(t) {
      const e = this.J(t)
      this.S(
        `[Disk FileSystemProvider]: createResourceLock() - request to acquire resource lock (${e})`,
      )
      let s
      for (; (s = this.Q.get(t)); )
        this.S(
          `[Disk FileSystemProvider]: createResourceLock() - waiting for resource lock to be released (${e})`,
        ),
          await s.wait()
      const r = new Ns()
      return (
        this.Q.set(t, r),
        this.S(
          `[Disk FileSystemProvider]: createResourceLock() - new resource lock created (${e})`,
        ),
        et(() => {
          this.S(
            `[Disk FileSystemProvider]: createResourceLock() - resource lock dispose() (${e})`,
          ),
            this.Q.get(t) === r &&
              (this.S(
                `[Disk FileSystemProvider]: createResourceLock() - resource lock removed from resource-lock map (${e})`,
              ),
              this.Q.delete(t)),
            this.S(
              `[Disk FileSystemProvider]: createResourceLock() - resource lock barrier open() (${e})`,
            ),
            r.open()
        })
      )
    }
    async readFile(t, e) {
      let s
      try {
        e?.atomic &&
          (this.S(
            `[Disk FileSystemProvider]: atomic read operation started (${this.J(t)})`,
          ),
          (s = await this.R(t)))
        const r = this.J(t)
        return await Vo.readFile(r)
      } catch (r) {
        throw this.ib(r)
      } finally {
        s?.dispose()
      }
    }
    S(t) {
      r_.M && this.a.trace(t)
    }
    readFileStream(t, e, s) {
      const r = lY((a) => Q.concat(a.map((o) => Q.wrap(o))).buffer)
      return (
        DHt(this, t, r, (a) => a.buffer, { ...e, bufferSize: 256 * 1024 }, s), r
      )
    }
    async writeFile(t, e, s) {
      return s?.atomic !== !1 && s?.atomic?.postfix && (await this.U(t))
        ? this.W(t, He(C_(t), `${xr(t)}${s.atomic.postfix}`), e, s)
        : this.X(t, e, s)
    }
    async U(t) {
      try {
        const e = this.J(t),
          { symbolicLink: s } = await Mi.stat(e)
        if (s) return !1
      } catch {}
      return !0
    }
    async W(t, e, s, r) {
      const a = new gt()
      try {
        a.add(await this.R(t)),
          a.add(await this.R(e)),
          await this.X(e, s, r, !0)
        try {
          await this.rename(e, t, { overwrite: !0 })
        } catch (o) {
          try {
            await this.delete(e, { recursive: !1, useTrash: !1, atomic: !1 })
          } catch {}
          throw o
        }
      } finally {
        a.dispose()
      }
    }
    async X(t, e, s, r) {
      let a
      try {
        const o = this.J(t)
        if (!s.create || !s.overwrite) {
          if (await re.exists(o)) {
            if (!s.overwrite) throw ln(g(1958, null), dt.FileExists)
          } else if (!s.create) throw ln(g(1959, null), dt.FileNotFound)
        }
        ;(a = await this.open(t, { create: !0, unlock: s.unlock }, r)),
          await this.write(a, 0, e, 0, e.byteLength)
      } catch (o) {
        throw await this.jb(t, o)
      } finally {
        typeof a == "number" && (await this.close(a))
      }
    }
    static {
      this.ab = !0
    }
    static configureFlushOnWrite(t) {
      r_.ab = t
    }
    async open(t, e, s) {
      const r = this.J(t)
      let a
      Rc(e) && !s && (a = await this.R(t))
      let o
      try {
        if (Rc(e) && e.unlock)
          try {
            const { stat: c } = await Mi.stat(r)
            c.mode & 128 || (await Vo.chmod(r, c.mode | 128))
          } catch (c) {
            c.code !== "ENOENT" && this.a.trace(c)
          }
        if (ie && Rc(e))
          try {
            ;(o = await re.open(r, "r+")), await re.ftruncate(o, 0)
          } catch (c) {
            if (
              (c.code !== "ENOENT" && this.a.trace(c), typeof o == "number")
            ) {
              try {
                await re.close(o)
              } catch (l) {
                this.a.trace(l)
              }
              o = void 0
            }
          }
        typeof o != "number" && (o = await re.open(r, Rc(e) ? "w" : "r"))
      } catch (c) {
        throw (a?.dispose(), Rc(e) ? await this.jb(t, c) : this.ib(c))
      }
      if ((this.Y.set(o, 0), Rc(e) && this.$.set(o, t), a)) {
        const c = this.Z.get(o)
        this.S(
          `[Disk FileSystemProvider]: open() - storing lock for handle ${o} (${r})`,
        ),
          this.Z.set(o, a),
          c &&
            (this.S(
              `[Disk FileSystemProvider]: open() - disposing a previous lock that was still stored on same handle ${o} (${r})`,
            ),
            c.dispose())
      }
      return o
    }
    async close(t) {
      const e = this.Z.get(t)
      try {
        if ((this.Y.delete(t), this.$.delete(t) && r_.ab))
          try {
            await re.fdatasync(t)
          } catch (s) {
            r_.configureFlushOnWrite(!1), this.a.error(s)
          }
        return await re.close(t)
      } catch (s) {
        throw this.ib(s)
      } finally {
        e &&
          (this.Z.get(t) === e &&
            (this.S(
              `[Disk FileSystemProvider]: close() - resource lock removed from handle-lock map ${t}`,
            ),
            this.Z.delete(t)),
          this.S(
            `[Disk FileSystemProvider]: close() - disposing lock for handle ${t}`,
          ),
          e.dispose())
      }
    }
    async read(t, e, s, r, a) {
      const o = this.bb(t, e)
      let c = null
      try {
        c = (await re.read(t, s, r, a, o)).bytesRead
      } catch (l) {
        throw this.ib(l)
      } finally {
        this.cb(t, o, c)
      }
      return c
    }
    bb(t, e) {
      return e === this.Y.get(t) ? null : e
    }
    cb(t, e, s) {
      const r = this.Y.get(t)
      typeof r == "number" &&
        (typeof e == "number" ||
          (typeof s == "number" ? this.Y.set(t, r + s) : this.Y.delete(t)))
    }
    async write(t, e, s, r, a) {
      return qmt(() => this.db(t, e, s, r, a), 100, 3)
    }
    async db(t, e, s, r, a) {
      const o = this.bb(t, e)
      let c = null
      try {
        c = (await re.write(t, s, r, a, o)).bytesWritten
      } catch (l) {
        throw await this.jb(this.$.get(t), l)
      } finally {
        this.cb(t, o, c)
      }
      return c
    }
    async mkdir(t) {
      try {
        await Vo.mkdir(this.J(t))
      } catch (e) {
        throw this.ib(e)
      }
    }
    async delete(t, e) {
      try {
        const s = this.J(t)
        if (e.recursive) {
          let r
          e?.atomic !== !1 &&
            e.atomic.postfix &&
            (r = se(Ui(s), `${ke(s)}${e.atomic.postfix}`)),
            await re.rm(s, za.MOVE, r)
        } else
          try {
            await Vo.unlink(s)
          } catch (r) {
            if (r.code === "EPERM" || r.code === "EISDIR") {
              let a = !1
              try {
                const { stat: o, symbolicLink: c } = await Mi.stat(s)
                a = o.isDirectory() && !c
              } catch {}
              if (a) await Vo.rmdir(s)
              else throw r
            } else throw r
          }
      } catch (s) {
        throw this.ib(s)
      }
    }
    async rename(t, e, s) {
      const r = this.J(t),
        a = this.J(e)
      if (r !== a)
        try {
          await this.eb(t, e, "move", s.overwrite), await re.rename(r, a)
        } catch (o) {
          throw (
            ((o.code === "EINVAL" ||
              o.code === "EBUSY" ||
              o.code === "ENAMETOOLONG") &&
              (o = new Error(g(1960, null, ke(r), ke(Ui(a)), o.toString()))),
            this.ib(o))
          )
        }
    }
    async copy(t, e, s) {
      const r = this.J(t),
        a = this.J(e)
      if (r !== a)
        try {
          await this.eb(t, e, "copy", s.overwrite),
            await re.copy(r, a, { preserveSymlinks: !0 })
        } catch (o) {
          throw (
            ((o.code === "EINVAL" ||
              o.code === "EBUSY" ||
              o.code === "ENAMETOOLONG") &&
              (o = new Error(g(1961, null, ke(r), ke(Ui(a)), o.toString()))),
            this.ib(o))
          )
        }
    }
    async eb(t, e, s, r) {
      const a = this.J(t),
        o = this.J(e)
      let c = !1
      if ((!!(this.capabilities & 1024) || (c = $7(a, o, !0)), c)) {
        if (s === "copy") throw ln(g(1962, null), dt.FileExists)
        if (s === "move") return
      }
      const u = await this.O(t)
      if (!u) throw ln(g(1963, null), dt.FileNotFound)
      const d = await this.O(e)
      if (d) {
        if (!r) throw ln(g(1964, null), dt.FileExists)
        ;(u.type & cs.File && d.type & cs.File) ||
          (await this.delete(e, { recursive: !0, useTrash: !1, atomic: !1 }))
      }
    }
    async cloneFile(t, e) {
      return this.fb(t, e, !1)
    }
    async fb(t, e, s) {
      const r = this.J(t),
        a = this.J(e),
        o = !!(this.capabilities & 1024)
      if ($7(r, a, !o)) return
      const c = new gt()
      try {
        c.add(await this.R(t)),
          c.add(await this.R(e)),
          s && (await Vo.mkdir(Ui(a), { recursive: !0 })),
          await Vo.copyFile(r, a)
      } catch (l) {
        if (l.code === "ENOENT" && !s) return this.fb(t, e, !0)
        throw this.ib(l)
      } finally {
        c.dispose()
      }
    }
    t(t, e, s) {
      return new WHt(
        (r) => t(r),
        (r) => e(r),
        s,
      )
    }
    G(t, e, s) {
      return new KHt(
        (r) => t(r),
        (r) => e(r),
        s,
      )
    }
    ib(t) {
      if (t instanceof f6) return t
      let e = t,
        s
      switch (t.code) {
        case "ENOENT":
          s = dt.FileNotFound
          break
        case "EISDIR":
          s = dt.FileIsADirectory
          break
        case "ENOTDIR":
          s = dt.FileNotADirectory
          break
        case "EEXIST":
          s = dt.FileExists
          break
        case "EPERM":
        case "EACCES":
          s = dt.NoPermissions
          break
        case "ERR_UNC_HOST_NOT_ALLOWED":
          ;(e = `${t.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`),
            (s = dt.Unknown)
          break
        default:
          s = dt.Unknown
      }
      return ln(e, s)
    }
    async jb(t, e) {
      let s = this.ib(e)
      if (t && s.code === dt.NoPermissions)
        try {
          const { stat: r } = await Mi.stat(this.J(t))
          r.mode & 128 || (s = ln(e, dt.FileWriteLocked))
        } catch (r) {
          this.a.trace(r)
        }
      return s
    }
  },
  Bj = class {
    constructor(t, e) {
      t.addFileSystemProvider(G.file, new tWt(e), { isCaseSensitive: De })
    }
  }
Bj = __decorate([__param(0, im), __param(1, Rt)], Bj)
var tWt = class {
  constructor(i) {
    ;(this.b = i), (this.a = new ZHt(this.b))
  }
  async stat(i) {
    const t = await this.a.stat(i)
    return {
      type: t.type,
      ctime: t.ctime,
      mtime: t.mtime,
      size: t.size,
      permissions: t.permissions === ia.Readonly ? 1 : void 0,
    }
  }
  readDirectory(i) {
    return this.a.readdir(i)
  }
  createDirectory(i) {
    return this.a.mkdir(i)
  }
  readFile(i) {
    return this.a.readFile(i)
  }
  writeFile(i, t, e) {
    return this.a.writeFile(i, t, { ...e, unlock: !1, atomic: !1 })
  }
  delete(i, t) {
    return this.a.delete(i, { ...t, useTrash: !1, atomic: !1 })
  }
  rename(i, t, e) {
    return this.a.rename(i, t, e)
  }
  copy(i, t, e) {
    return this.a.copy(i, t, e)
  }
  get onDidChangeFile() {
    throw new Error("Method not implemented.")
  }
  watch(i, t) {
    throw new Error("Method not implemented.")
  }
}
import { createRequire as eWt } from "node:module"
var ilt = eWt(import.meta.url),
  iWt = class extends $j {
    j() {
      const i = this,
        t = ilt("module"),
        e = t._load
      t._load = function (c, l, u) {
        return (
          (c = a(c)),
          i.a.has(c)
            ? i.a
                .get(c)
                .load(c, S.file(Rvt(l.filename)), (d) =>
                  e.apply(this, [d, l, u]),
                )
            : e.apply(this, arguments)
        )
      }
      const s = t._resolveLookupPaths
      t._resolveLookupPaths = (o, c) => s.call(this, a(o), c)
      const r = t._resolveFilename
      t._resolveFilename = function (c, l, u, d) {
        return (
          c === "vsda" &&
            Array.isArray(d?.paths) &&
            d.paths.length === 0 &&
            (d.paths = t._nodeModulePaths(import.meta.dirname)),
          r.call(this, c, l, u, d)
        )
      }
      const a = (o) => {
        for (const c of i.b) {
          const l = c(o)
          if (l) {
            o = l
            break
          }
        }
        return o
      }
    }
  },
  sWt = class extends NH {
    constructor() {
      super(...arguments), (this.extensionRuntime = $O.Node)
    }
    async wb() {
      this.h.createInstance(_j)
      const i = this.h.invokeFunction(VMt)
      if (
        (this.h.createInstance(Dj),
        this.f.remote.isRemote && this.f.remote.authority)
      ) {
        const s = this.h.createInstance(Fj)
        process.env.VSCODE_IPC_HOOK_CLI = s.ipcHandlePath
      }
      this.h.createInstance(Bj),
        await this.h
          .createInstance(iWt, i, { mine: this.J, all: this.L })
          .install(),
        Ae("code/extHost/didInitAPI")
      const e = await this.m.getConfigProvider()
      await yHt(this.j, e, this, this.q, this.y, this.f, this.B),
        Ae("code/extHost/didInitProxyResolver")
    }
    xb(i) {
      return i.main
    }
    async yb(i, t, e) {
      if (t.scheme !== G.file)
        throw new Error(`Cannot load URI: '${t}', must be of file-scheme`)
      let s = null
      e.codeLoadingStart(),
        this.q.trace(`ExtensionService#loadCommonJSModule ${t.toString(!0)}`),
        this.q.flush()
      const r = i?.identifier.value
      i && (await this.u.initializeLocalizedMessages(i))
      try {
        r && Ae(`code/extHost/willLoadExtensionCode/${r}`), (s = ilt(t.fsPath))
      } finally {
        r && Ae(`code/extHost/didLoadExtensionCode/${r}`), e.codeLoadingStop()
      }
      return s
    }
    async $setRemoteEnvironment(i) {
      if (this.f.remote.isRemote)
        for (const t in i) {
          const e = i[t]
          e === null ? delete process.env[t] : (process.env[t] = e)
        }
    }
  }
import * as Vf from "fs"
import { exec as slt } from "child_process"
var rWt = (i, t, e) => {
    const s = new Uint8Array(16)
    for (let o = 0; o < 16; o++) s[o] = Math.round(Math.random() * 256)
    const r = Yu(Q.wrap(s))
    return (
      [
        `GET ws://localhost${i}?${t}&skipWebSocketFrames=true HTTP/1.1`,
        "Connection: Upgrade",
        "Upgrade: websocket",
        `Sec-WebSocket-Key: ${r}`,
      ].join(`\r
`) +
      `\r
\r
`
    )
  },
  rlt = Q.fromString(`\r
\r
`)
async function nWt(i, t, e, s, r) {
  i.write(Q.fromString(rWt(t, e, s)))
  const a = new gt()
  try {
    return await new Promise((o, c) => {
      let l
      a.add(
        i.onData((u) => {
          l ? (l = Q.concat([l, u], l.byteLength + u.byteLength)) : (l = u)
          const d = l.indexOf(rlt)
          if (d === -1) return
          o(i), i.pauseData()
          const m = l.slice(d + rlt.byteLength)
          m.byteLength && r.onData.fire(m)
        }),
      ),
        a.add(i.onClose((u) => c(u ?? new Error("socket closed")))),
        a.add(i.onEnd(() => c(new Error("socket ended"))))
    })
  } catch (o) {
    throw (i.dispose(), o)
  } finally {
    a.dispose()
  }
}
var aWt = class extends at {
    constructor(i, t) {
      super(),
        (this.g = i),
        (this.a = this.D(new Fu())),
        (this.onData = (...e) => (
          this.a.isPaused && queueMicrotask(() => this.a.resume()),
          this.a.event(...e)
        )),
        (this.b = this.D(new J())),
        (this.onDidDispose = this.b.event),
        (this.f = !1),
        this.D(t.onData),
        this.D(t.onData.event((e) => this.a.fire(e))),
        (this.onClose = this.D(t.onClose).event),
        (this.onEnd = this.D(t.onEnd).event)
    }
    pauseData() {
      this.a.pause()
    }
    drain() {
      return Promise.resolve()
    }
    end() {
      ;(this.f = !0), this.h()
    }
    traceSocketEvent(i, t) {
      Y_.traceSocketEvent(this, this.g, i, t)
    }
    dispose() {
      this.f || this.h(), this.b.fire(), super.dispose()
    }
  },
  oWt = "signService",
  Gf = X(oWt)
import * as cWt from "net"
import * as lWt from "os"
import * as uWt from "net"
var nlt = {
  1: !0,
  7: !0,
  9: !0,
  11: !0,
  13: !0,
  15: !0,
  17: !0,
  19: !0,
  20: !0,
  21: !0,
  22: !0,
  23: !0,
  25: !0,
  37: !0,
  42: !0,
  43: !0,
  53: !0,
  69: !0,
  77: !0,
  79: !0,
  87: !0,
  95: !0,
  101: !0,
  102: !0,
  103: !0,
  104: !0,
  109: !0,
  110: !0,
  111: !0,
  113: !0,
  115: !0,
  117: !0,
  119: !0,
  123: !0,
  135: !0,
  137: !0,
  139: !0,
  143: !0,
  161: !0,
  179: !0,
  389: !0,
  427: !0,
  465: !0,
  512: !0,
  513: !0,
  514: !0,
  515: !0,
  526: !0,
  530: !0,
  531: !0,
  532: !0,
  540: !0,
  548: !0,
  554: !0,
  556: !0,
  563: !0,
  587: !0,
  601: !0,
  636: !0,
  989: !0,
  990: !0,
  993: !0,
  995: !0,
  1719: !0,
  1720: !0,
  1723: !0,
  2049: !0,
  3659: !0,
  4045: !0,
  5060: !0,
  5061: !0,
  6e3: !0,
  6566: !0,
  6665: !0,
  6666: !0,
  6667: !0,
  6668: !0,
  6669: !0,
  6697: !0,
  10080: !0,
}
function hWt(i, t, e, s = "127.0.0.1") {
  let r = !1,
    a,
    o = 1
  const c = uWt.createServer({ pauseOnConnect: !0 })
  function l(u, d) {
    r ||
      ((r = !0), c.removeAllListeners(), c.close(), a && clearTimeout(a), d(u))
  }
  return new Promise((u) => {
    ;(a = setTimeout(() => {
      l(0, u)
    }, e)),
      c.on("listening", () => {
        l(i, u)
      }),
      c.on("error", (d) => {
        d && (d.code === "EADDRINUSE" || d.code === "EACCES") && o < t
          ? (i++, o++, c.listen(i, s))
          : l(0, u)
      }),
      c.on("close", () => {
        l(0, u)
      }),
      c.listen(i, s)
  })
}
var dWt = 30 * 1e3,
  alt
;(function (i) {
  ;(i[(i.Management = 1)] = "Management"),
    (i[(i.ExtensionHost = 2)] = "ExtensionHost"),
    (i[(i.Tunnel = 3)] = "Tunnel")
})(alt || (alt = {}))
function qj(i) {
  switch (i) {
    case 1:
      return "Management"
    case 2:
      return "ExtensionHost"
    case 3:
      return "Tunnel"
  }
}
function olt(i) {
  const t = new fe()
  return setTimeout(() => t.cancel(), i), t.token
}
function mWt(i, t) {
  if (i.isCancellationRequested || t.isCancellationRequested)
    return ce.Cancelled
  const e = new fe()
  return (
    i.onCancellationRequested(() => e.cancel()),
    t.onCancellationRequested(() => e.cancel()),
    e.token
  )
}
var Uj = class {
  get didTimeout() {
    return this.c === "timedout"
  }
  constructor(i) {
    ;(this.c = "pending"),
      (this.d = new gt()),
      ({ promise: this.promise, resolve: this.f, reject: this.g } = YG()),
      i.isCancellationRequested
        ? this.h()
        : this.d.add(i.onCancellationRequested(() => this.h()))
  }
  registerDisposable(i) {
    this.c === "pending" ? this.d.add(i) : i.dispose()
  }
  h() {
    this.c === "pending" &&
      (this.d.dispose(), (this.c = "timedout"), this.g(this.i()))
  }
  i() {
    const i = new Error("Time limit reached")
    return (i.code = "ETIMEDOUT"), (i.syscall = "connect"), i
  }
  resolve(i) {
    this.c === "pending" && (this.d.dispose(), (this.c = "resolved"), this.f(i))
  }
  reject(i) {
    this.c === "pending" && (this.d.dispose(), (this.c = "rejected"), this.g(i))
  }
}
function fWt(i, t) {
  const e = new Uj(t)
  return (
    e.registerDisposable(
      i.onControlMessage((s) => {
        const r = JSON.parse(s.toString()),
          a = EWt(r)
        a ? e.reject(a) : e.resolve(r)
      }),
    ),
    e.promise
  )
}
function pWt(i, t, e, s, r, a, o, c) {
  const l = new Uj(c),
    u = ss.create(!1)
  return (
    i.info(`Creating a socket (${o})...`),
    Ae(`code/willCreateSocket/${a}`),
    t.connect(e, s, r, o).then(
      (d) => {
        l.didTimeout
          ? (Ae(`code/didCreateSocketError/${a}`),
            i.info(
              `Creating a socket (${o}) finished after ${u.elapsed()} ms, but this is too late and has timed out already.`,
            ),
            d?.dispose())
          : (Ae(`code/didCreateSocketOK/${a}`),
            i.info(
              `Creating a socket (${o}) was successful after ${u.elapsed()} ms.`,
            ),
            l.resolve(d))
      },
      (d) => {
        Ae(`code/didCreateSocketError/${a}`),
          i.info(
            `Creating a socket (${o}) returned an error after ${u.elapsed()} ms.`,
          ),
          i.error(d),
          l.reject(d)
      },
    ),
    l.promise
  )
}
function Mj(i, t) {
  const e = new Uj(t)
  return (
    i.then(
      (s) => {
        e.didTimeout || e.resolve(s)
      },
      (s) => {
        e.didTimeout || e.reject(s)
      },
    ),
    e.promise
  )
}
async function gWt(i, t, e, s) {
  const r = dlt(i, t)
  i.logService.trace(`${r} 1/6. invoking socketFactory.connect().`)
  let a
  try {
    a = await pWt(
      i.logService,
      i.remoteSocketFactoryService,
      i.connectTo,
      BG.getServerRootPath(),
      `reconnectionToken=${i.reconnectionToken}&reconnection=${i.reconnectionProtocol ? "true" : "false"}`,
      qj(t),
      `renderer-${qj(t)}-${i.reconnectionToken}`,
      s,
    )
  } catch (d) {
    throw (
      (i.logService.error(
        `${r} socketFactory.connect() failed or timed out. Error:`,
      ),
      i.logService.error(d),
      d)
    )
  }
  i.logService.trace(`${r} 2/6. socketFactory.connect() was successful.`)
  let o, c
  i.reconnectionProtocol
    ? (i.reconnectionProtocol.beginAcceptReconnection(a, null),
      (o = i.reconnectionProtocol),
      (c = !1))
    : ((o = new vq({ socket: a })), (c = !0)),
    i.logService.trace(`${r} 3/6. sending AuthRequest control message.`)
  const l = await Mj(i.signService.createNewMessage(Ze()), s),
    u = {
      type: "auth",
      auth: i.connectionToken || "00000000000000000000",
      data: l.data,
    }
  o.sendControl(Q.fromString(JSON.stringify(u)))
  try {
    const d = await fWt(o, mWt(s, olt(1e4)))
    if (d.type !== "sign" || typeof d.data != "string") {
      const v = new Error("Unexpected handshake message")
      throw ((v.code = "VSCODE_CONNECTION_ERROR"), v)
    }
    if (
      (i.logService.trace(`${r} 4/6. received SignRequest control message.`),
      !(await Mj(i.signService.validate(l, d.signedData), s)))
    ) {
      const v = new Error("Refused to connect to unsupported server")
      throw ((v.code = "VSCODE_CONNECTION_ERROR"), v)
    }
    const f = await Mj(i.signService.sign(d.data), s),
      p = {
        type: "connectionType",
        commit: i.commit,
        signedData: f,
        desiredConnectionType: t,
      }
    return (
      e && (p.args = e),
      i.logService.trace(
        `${r} 5/6. sending ConnectionTypeRequest control message.`,
      ),
      o.sendControl(Q.fromString(JSON.stringify(p))),
      { protocol: o, ownsProtocol: c }
    )
  } catch (d) {
    throw (
      (d &&
        d.code === "ETIMEDOUT" &&
        (i.logService.error(`${r} the handshake timed out. Error:`),
        i.logService.error(d)),
      d &&
        d.code === "VSCODE_CONNECTION_ERROR" &&
        (i.logService.error(
          `${r} received error control message when negotiating connection. Error:`,
        ),
        i.logService.error(d)),
      c && hlt(o),
      d)
    )
  }
}
async function vWt(i, t, e) {
  const s = Date.now(),
    r = dlt(i, 3),
    { protocol: a } = await gWt(i, 3, t, e)
  return (
    i.logService.trace(
      `${r} 6/6. handshake finished, connection is up and running after ${$Wt(s)}!`,
    ),
    a
  )
}
async function clt(i, t, e) {
  const { connectTo: s, connectionToken: r } =
    await i.addressProvider.getAddress()
  return {
    commit: i.commit,
    quality: i.quality,
    connectTo: s,
    connectionToken: r,
    reconnectionToken: t,
    reconnectionProtocol: e,
    remoteSocketFactoryService: i.remoteSocketFactoryService,
    signService: i.signService,
    logService: i.logService,
  }
}
async function wWt(i, t, e) {
  const s = await clt(i, Ze(), null)
  return await vWt(s, { host: t, port: e }, ce.None)
}
function yWt(i) {
  return Zr(
    (t) =>
      new Promise((e, s) => {
        const r = setTimeout(e, i * 1e3)
        t.onCancellationRequested(() => {
          clearTimeout(r), e()
        })
      }),
  )
}
var llt
;(function (i) {
  ;(i[(i.ConnectionLost = 0)] = "ConnectionLost"),
    (i[(i.ReconnectionWait = 1)] = "ReconnectionWait"),
    (i[(i.ReconnectionRunning = 2)] = "ReconnectionRunning"),
    (i[(i.ReconnectionPermanentFailure = 3)] = "ReconnectionPermanentFailure"),
    (i[(i.ConnectionGain = 4)] = "ConnectionGain")
})(llt || (llt = {}))
var bWt = class {
    constructor(i, t) {
      ;(this.reconnectionToken = i),
        (this.millisSinceLastIncomingData = t),
        (this.type = 0)
    }
  },
  TWt = class {
    constructor(i, t, e, s) {
      ;(this.reconnectionToken = i),
        (this.millisSinceLastIncomingData = t),
        (this.durationSeconds = e),
        (this.c = s),
        (this.type = 1)
    }
    skipWait() {
      this.c.cancel()
    }
  },
  kWt = class {
    constructor(i, t, e) {
      ;(this.reconnectionToken = i),
        (this.millisSinceLastIncomingData = t),
        (this.attempt = e),
        (this.type = 2)
    }
  },
  ult = class {
    constructor(i, t, e) {
      ;(this.reconnectionToken = i),
        (this.millisSinceLastIncomingData = t),
        (this.attempt = e),
        (this.type = 4)
    }
  },
  SWt = class {
    constructor(i, t, e, s) {
      ;(this.reconnectionToken = i),
        (this.millisSinceLastIncomingData = t),
        (this.attempt = e),
        (this.handled = s),
        (this.type = 3)
    }
  },
  Yte = class Bn extends at {
    static triggerPermanentFailure(t, e, s) {
      ;(this._permanentFailure = !0),
        (this.f = t),
        (this.g = e),
        (this.h = s),
        this.j.forEach((r) => r.C(this.f, this.g, this.h))
    }
    static debugTriggerReconnection() {
      this.j.forEach((t) => t.w())
    }
    static debugPauseSocketWriting() {
      this.j.forEach((t) => t.F())
    }
    static {
      this._permanentFailure = !1
    }
    static {
      this.f = 0
    }
    static {
      this.g = 0
    }
    static {
      this.h = !1
    }
    static {
      this.j = []
    }
    get n() {
      return this.c || Bn._permanentFailure
    }
    constructor(t, e, s, r, a) {
      super(),
        (this.s = t),
        (this.t = e),
        (this.reconnectionToken = s),
        (this.protocol = r),
        (this.u = a),
        (this.m = this.D(new J())),
        (this.onDidStateChange = this.m.event),
        (this.c = !1),
        (this.q = !1),
        (this.r = !1),
        this.m.fire(new ult(this.reconnectionToken, 0, 0)),
        this.D(
          r.onSocketClose((o) => {
            const c = F3(this.s, this.reconnectionToken, !0)
            o
              ? o.type === 0
                ? (this.t.logService.info(
                    `${c} received socket close event (hadError: ${o.hadError}).`,
                  ),
                  o.error && this.t.logService.error(o.error))
                : (this.t.logService.info(
                    `${c} received socket close event (wasClean: ${o.wasClean}, code: ${o.code}, reason: ${o.reason}).`,
                  ),
                  o.event && this.t.logService.error(o.event))
              : this.t.logService.info(`${c} received socket close event.`),
              this.w()
          }),
        ),
        this.D(
          r.onSocketTimeout((o) => {
            const c = F3(this.s, this.reconnectionToken, !0)
            this.t.logService.info(
              `${c} received socket timeout event (unacknowledgedMsgCount: ${o.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${o.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${o.timeSinceLastReceivedSomeData}).`,
            ),
              this.w()
          }),
        ),
        Bn.j.push(this),
        this.D(
          et(() => {
            const o = Bn.j.indexOf(this)
            o >= 0 && Bn.j.splice(o, 1)
          }),
        ),
        this.n && this.C(Bn.f, Bn.g, Bn.h)
    }
    dispose() {
      super.dispose(), (this.r = !0)
    }
    async w() {
      if (!this.q)
        try {
          ;(this.q = !0), await this.y()
        } finally {
          this.q = !1
        }
    }
    async y() {
      if (this.n || this.r) return
      const t = F3(this.s, this.reconnectionToken, !0)
      this.t.logService.info(
        `${t} starting reconnecting loop. You can get more information with the trace log level.`,
      ),
        this.m.fire(
          new bWt(
            this.reconnectionToken,
            this.protocol.getMillisSinceLastIncomingData(),
          ),
        )
      const e = [0, 5, 5, 10, 10, 10, 10, 10, 30]
      let s = -1
      do {
        s++
        const r = s < e.length ? e[s] : e[e.length - 1]
        try {
          if (r > 0) {
            const o = yWt(r)
            this.m.fire(
              new TWt(
                this.reconnectionToken,
                this.protocol.getMillisSinceLastIncomingData(),
                r,
                o,
              ),
            ),
              this.t.logService.info(
                `${t} waiting for ${r} seconds before reconnecting...`,
              )
            try {
              await o
            } catch {}
          }
          if (this.n) {
            this.t.logService.error(
              `${t} permanent failure occurred while running the reconnecting loop.`,
            )
            break
          }
          this.m.fire(
            new kWt(
              this.reconnectionToken,
              this.protocol.getMillisSinceLastIncomingData(),
              s + 1,
            ),
          ),
            this.t.logService.info(`${t} resolving connection...`)
          const a = await clt(this.t, this.reconnectionToken, this.protocol)
          this.t.logService.info(`${t} connecting to ${a.connectTo}...`),
            await this.G(a, olt(dWt)),
            this.t.logService.info(`${t} reconnected!`),
            this.m.fire(
              new ult(
                this.reconnectionToken,
                this.protocol.getMillisSinceLastIncomingData(),
                s + 1,
              ),
            )
          break
        } catch (a) {
          if (a.code === "VSCODE_CONNECTION_ERROR") {
            this.t.logService.error(
              `${t} A permanent error occurred in the reconnecting loop! Will give up now! Error:`,
            ),
              this.t.logService.error(a),
              this.z(this.protocol.getMillisSinceLastIncomingData(), s + 1, !1)
            break
          }
          if (s > 360) {
            this.t.logService.error(
              `${t} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time has expired! Will give up now! Error:`,
            ),
              this.t.logService.error(a),
              this.z(this.protocol.getMillisSinceLastIncomingData(), s + 1, !1)
            break
          }
          if (P2.isTemporarilyNotAvailable(a)) {
            this.t.logService.info(
              `${t} A temporarily not available error occurred while trying to reconnect, will try again...`,
            ),
              this.t.logService.trace(a)
            continue
          }
          if (
            (a.code === "ETIMEDOUT" ||
              a.code === "ENETUNREACH" ||
              a.code === "ECONNREFUSED" ||
              a.code === "ECONNRESET") &&
            a.syscall === "connect"
          ) {
            this.t.logService.info(
              `${t} A network error occurred while trying to reconnect, will try again...`,
            ),
              this.t.logService.trace(a)
            continue
          }
          if (Ms(a)) {
            this.t.logService.info(
              `${t} A promise cancelation error occurred while trying to reconnect, will try again...`,
            ),
              this.t.logService.trace(a)
            continue
          }
          if (a instanceof P2) {
            this.t.logService.error(
              `${t} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`,
            ),
              this.t.logService.error(a),
              this.z(
                this.protocol.getMillisSinceLastIncomingData(),
                s + 1,
                P2.isHandled(a),
              )
            break
          }
          this.t.logService.error(
            `${t} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`,
          ),
            this.t.logService.error(a),
            this.z(this.protocol.getMillisSinceLastIncomingData(), s + 1, !1)
          break
        }
      } while (!this.n && !this.r)
    }
    z(t, e, s) {
      this.u ? Bn.triggerPermanentFailure(t, e, s) : this.C(t, e, s)
    }
    C(t, e, s) {
      this.m.fire(new SWt(this.reconnectionToken, t, e, s)), hlt(this.protocol)
    }
    F() {
      this.protocol.pauseSocketWriting()
    }
  }
function hlt(i) {
  try {
    i.acceptDisconnect()
    const t = i.getSocket()
    i.dispose(), t.dispose()
  } catch (t) {
    $e(t)
  }
}
function EWt(i) {
  if (i && i.type === "error") {
    const t = new Error(`Connection error: ${i.reason}`)
    return (t.code = "VSCODE_CONNECTION_ERROR"), t
  }
  return null
}
function IWt(i, t) {
  for (; i.length < t; ) i += " "
  return i
}
function PWt(i, t) {
  return `[remote-connection][${IWt(qj(i), 13)}][${t.substr(0, 5)}\u2026]`
}
function F3(i, t, e) {
  return `${PWt(i, t)}[${e ? "reconnect" : "initial"}]`
}
function dlt(i, t) {
  return `${F3(t, i.reconnectionToken, !!i.reconnectionProtocol)}[${i.connectTo}]`
}
function $Wt(i) {
  return `${Date.now() - i} ms`
}
var Hj = X("remoteSocketFactoryService")
async function xWt(i, t, e, s, r) {
  let a
  for (
    let o = 3;
    o &&
    (a?.dispose(),
    (a = await new mlt(i, t, e, s, r).waitForReady()),
    !((r && nlt[r]) || !nlt[a.tunnelLocalPort]));
    o--
  );
  return a
}
var mlt = class extends at {
    constructor(i, t, e, s, r) {
      super(),
        (this.m = t),
        (this.n = r),
        (this.privacy = Ur.Private),
        (this.j = new Map()),
        (this.a = i),
        (this.b = cWt.createServer()),
        (this.c = new Ns()),
        (this.f = () => this.c.open()),
        this.b.on("listening", this.f),
        (this.g = (a) => this.q(a)),
        this.b.on("connection", this.g),
        (this.h = () => {}),
        this.b.on("error", this.h),
        (this.tunnelRemotePort = s),
        (this.tunnelRemoteHost = e)
    }
    async dispose() {
      super.dispose(),
        this.b.removeListener("listening", this.f),
        this.b.removeListener("connection", this.g),
        this.b.removeListener("error", this.h),
        this.b.close(),
        Array.from(this.j.values()).forEach((t) => {
          t()
        })
    }
    async waitForReady() {
      const i = this.n ?? this.tunnelRemotePort,
        t = In(this.m) ? "0.0.0.0" : "127.0.0.1"
      let e = await hWt(i, 2, 1e3, t),
        s = null
      return (
        this.b.listen(e, this.m),
        await this.c.wait(),
        (s = this.b.address()),
        s ||
          ((e = 0),
          this.b.listen(e, this.m),
          await this.c.wait(),
          (s = this.b.address())),
        (this.tunnelLocalPort = s.port),
        (this.localAddress = `${this.tunnelRemoteHost === "127.0.0.1" ? "127.0.0.1" : "localhost"}:${s.port}`),
        this
      )
    }
    async q(i) {
      i.pause()
      const t =
          Ro(this.tunnelRemoteHost) || In(this.tunnelRemoteHost)
            ? "localhost"
            : this.tunnelRemoteHost,
        e = await wWt(this.a, t, this.tunnelRemotePort),
        s = e.getSocket(),
        r = e.readEntireBuffer()
      e.dispose(),
        r.byteLength > 0 && i.write(r.buffer),
        i.on("end", () => {
          i.localAddress && this.j.delete(i.localAddress), s.end()
        }),
        i.on("close", () => s.end()),
        i.on("error", () => {
          i.localAddress && this.j.delete(i.localAddress),
            s instanceof Ku ? s.socket.destroy() : s.end()
        }),
        s instanceof Ku ? this.s(i, s) : this.r(i, s),
        i.localAddress &&
          this.j.set(i.localAddress, () => {
            i.end(), s.end()
          })
    }
    r(i, t) {
      t.onClose(() => i.destroy()),
        t.onEnd(() => i.end()),
        t.onData((e) => i.write(e.buffer)),
        i.on("data", (e) => t.write(Q.wrap(e))),
        i.resume()
    }
    s(i, t) {
      const e = t.socket
      e.on("end", () => i.end()),
        e.on("close", () => i.end()),
        e.on("error", () => {
          i.destroy()
        }),
        e.pipe(i),
        i.pipe(e)
    }
  },
  Wj = class extends rH {
    constructor(t, e, s, r, a) {
      super(e, a), (this.H = t), (this.I = s), (this.J = r)
    }
    isPortPrivileged(t) {
      return vPt(t, this.s, w7, lWt.release())
    }
    F(t, e, s, r, a, o, c, l) {
      const u = this.C(e, s)
      if (u) return ++u.refcount, u.value
      if (pPt(t)) return this.G(t, e, s, a, o, c, l)
      {
        this.q.trace(
          `ForwardedPorts: (TunnelService) Creating tunnel without provider ${e}:${s} on local port ${a}.`,
        )
        const d = {
            commit: this.J.commit,
            quality: this.J.quality,
            addressProvider: t,
            remoteSocketFactoryService: this.H,
            signService: this.I,
            logService: this.q,
            ipcLogger: null,
          },
          m = xWt(d, r, e, s, a)
        return (
          this.q.trace(
            "ForwardedPorts: (TunnelService) Tunnel created without provider.",
          ),
          this.y(e, s, m),
          m
        )
      }
    }
  }
Wj = __decorate(
  [
    __param(0, Hj),
    __param(1, Rt),
    __param(2, Gf),
    __param(3, w6),
    __param(4, dn),
  ],
  Wj,
)
var jj = class extends Wj {
  constructor(t, e, s, r, a) {
    super(t, e, s, r, a)
  }
}
jj = __decorate(
  [
    __param(0, Hj),
    __param(1, Rt),
    __param(2, Gf),
    __param(3, w6),
    __param(4, dn),
  ],
  jj,
)
var flt = class extends at {
  constructor(t, e, s, r, a) {
    super(),
      (this.b = t),
      (this.c = e),
      (this.f = s),
      (this.g = r),
      (this.h = a),
      (this.a = new Map())
  }
  async openTunnel(t, e, s, r, a, o, c, l, u) {
    if (
      (this.c.trace(
        `ForwardedPorts: (SharedTunnelService) openTunnel request for ${s}:${r} on local port ${o}.`,
      ),
      !this.a.has(t))
    ) {
      const d = new jj(this.b, this.c, this.g, this.f, this.h)
      this.D(d),
        this.a.set(t, d),
        d.onTunnelClosed(async () => {
          ;(await d.tunnels).length === 0 && (d.dispose(), this.a.delete(t))
        })
    }
    return this.a.get(t).openTunnel(e, s, r, a, o, c, l, u)
  }
}
flt = __decorate(
  [
    __param(0, Hj),
    __param(1, Rt),
    __param(2, w6),
    __param(3, Gf),
    __param(4, dn),
  ],
  flt,
)
var NWt = X("dialogService"),
  plt
;(function (i) {
  ;(i[(i.Confirmation = 1)] = "Confirmation"),
    (i[(i.Prompt = 2)] = "Prompt"),
    (i[(i.Input = 3)] = "Input")
})(plt || (plt = {}))
var Zte = X("fileDialogService"),
  glt
;(function (i) {
  ;(i[(i.SAVE = 0)] = "SAVE"),
    (i[(i.DONT_SAVE = 1)] = "DONT_SAVE"),
    (i[(i.CANCEL = 2)] = "CANCEL")
})(glt || (glt = {}))
var CWt = 10 * 1e3,
  A3 = "remote.tunnels.toRestore",
  Vj = "remote.tunnels.toRestoreExpiration",
  JWt = 1e3 * 60 * 60 * 24 * 14,
  vlt = "onTunnel",
  tee = new W("forwardedPortsViewEnabled", !1, g(13182, null)),
  LWt = new W("forwardedPortsViewOnlyEnabled", !1, g(13183, null))
function wlt(i) {
  const t = i.match(/^([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*:)?([0-9]+)$/)
  if (t)
    return {
      host: t[1]?.substring(0, t[1].length - 1) || "localhost",
      port: Number(t[2]),
    }
}
var zf
;(function (i) {
  ;(i.Other = "Other"), (i.User = "User"), (i.AutoForwardEnd = "AutoForwardEnd")
})(zf || (zf = {}))
var Fn
;(function (i) {
  ;(i[(i.User = 0)] = "User"),
    (i[(i.Auto = 1)] = "Auto"),
    (i[(i.Extension = 2)] = "Extension")
})(Fn || (Fn = {}))
var Gj = { source: Fn.User, description: g(13184, null) },
  eee = { source: Fn.Auto, description: g(13185, null) }
function ylt(i, t, e) {
  const s = i.get(hs(t, e))
  if (s) return s
  if (Ro(t))
    for (const r of sm) {
      const a = hs(r, e)
      if (i.has(a)) return i.get(a)
    }
  else if (In(t))
    for (const r of lB) {
      const a = hs(r, e)
      if (i.has(a)) return i.get(a)
    }
}
function ts(i, t, e) {
  const s = ylt(i, t, e)
  if (s) return s
  const r = In(t) ? "localhost" : Ro(t) ? "0.0.0.0" : void 0
  if (r) return ylt(i, r, e)
}
function hs(i, t) {
  return i + ":" + t
}
var La
;(function (i) {
  ;(i.Notify = "notify"),
    (i.OpenBrowser = "openBrowser"),
    (i.OpenBrowserOnce = "openBrowserOnce"),
    (i.OpenPreview = "openPreview"),
    (i.Silent = "silent"),
    (i.Ignore = "ignore")
})(La || (La = {}))
function RWt(i) {
  return (
    i &&
    "host" in i &&
    typeof i.host == "string" &&
    "port" in i &&
    typeof i.port == "number" &&
    (!("detail" in i) || typeof i.detail == "string") &&
    (!("pid" in i) || typeof i.pid == "string")
  )
}
var blt = class kr extends at {
    static {
      this.c = "remote.portsAttributes"
    }
    static {
      this.f = "remote.otherPortsAttributes"
    }
    static {
      this.g = /^(\d+)\-(\d+)$/
    }
    static {
      this.h = /^([a-z0-9\-]+):(\d{1,5})$/
    }
    constructor(t) {
      super(),
        (this.q = t),
        (this.j = []),
        (this.n = new J()),
        (this.onDidChangeAttributes = this.n.event),
        this.D(
          t.onDidChangeConfiguration((e) => {
            ;(e.affectsConfiguration(kr.c) || e.affectsConfiguration(kr.f)) &&
              this.r()
          }),
        ),
        this.r()
    }
    r() {
      ;(this.j = this.w()), this.n.fire()
    }
    getAttributes(t, e, s) {
      let r = this.u(t, e, s, this.j, 0)
      const a = {
        label: void 0,
        onAutoForward: void 0,
        elevateIfNeeded: void 0,
        requireLocalPort: void 0,
        protocol: void 0,
      }
      for (; r >= 0; ) {
        const o = this.j[r]
        o.key === t
          ? ((a.onAutoForward = o.onAutoForward ?? a.onAutoForward),
            (a.elevateIfNeeded =
              o.elevateIfNeeded !== void 0
                ? o.elevateIfNeeded
                : a.elevateIfNeeded),
            (a.label = o.label ?? a.label),
            (a.requireLocalPort = o.requireLocalPort),
            (a.protocol = o.protocol))
          : ((a.onAutoForward = a.onAutoForward ?? o.onAutoForward),
            (a.elevateIfNeeded =
              a.elevateIfNeeded !== void 0
                ? a.elevateIfNeeded
                : o.elevateIfNeeded),
            (a.label = a.label ?? o.label),
            (a.requireLocalPort =
              a.requireLocalPort !== void 0 ? a.requireLocalPort : void 0),
            (a.protocol = a.protocol ?? o.protocol)),
          (r = this.u(t, e, s, this.j, r + 1))
      }
      return a.onAutoForward !== void 0 ||
        a.elevateIfNeeded !== void 0 ||
        a.label !== void 0 ||
        a.requireLocalPort !== void 0 ||
        a.protocol !== void 0
        ? a
        : this.z()
    }
    s(t) {
      return t.start !== void 0 && t.end !== void 0
    }
    t(t) {
      return t.host !== void 0 && t.port !== void 0 && _t(t.host) && ps(t.port)
    }
    u(t, e, s, r, a) {
      if (a >= r.length) return -1
      const o = !Ro(e) && !In(e),
        l = r
          .slice(a)
          .findIndex((u) =>
            ps(u.key)
              ? o
                ? !1
                : u.key === t
              : this.s(u.key)
                ? o
                  ? !1
                  : t >= u.key.start && t <= u.key.end
                : this.t(u.key)
                  ? t === u.key.port && e === u.key.host
                  : s
                    ? u.key.test(s)
                    : !1,
          )
      return l >= 0 ? l + a : -1
    }
    w() {
      const t = this.q.getValue(kr.c)
      if (!t || !Je(t)) return []
      const e = []
      for (const r in t) {
        if (r === void 0) continue
        const a = t[r]
        let o
        if (Number(r)) o = Number(r)
        else if (_t(r))
          if (kr.g.test(r)) {
            const c = r.match(kr.g)
            o = { start: Number(c[1]), end: Number(c[2]) }
          } else if (kr.h.test(r)) {
            const c = r.match(kr.h)
            o = { host: c[1], port: Number(c[2]) }
          } else {
            let c
            try {
              c = RegExp(r)
            } catch {}
            c && (o = c)
          }
        o &&
          e.push({
            key: o,
            elevateIfNeeded: a.elevateIfNeeded,
            onAutoForward: a.onAutoForward,
            label: a.label,
            requireLocalPort: a.requireLocalPort,
            protocol: a.protocol,
          })
      }
      const s = this.q.getValue(kr.f)
      return (
        s &&
          (this.m = {
            elevateIfNeeded: s.elevateIfNeeded,
            label: s.label,
            onAutoForward: s.onAutoForward,
            requireLocalPort: s.requireLocalPort,
            protocol: s.protocol,
          }),
        this.y(e)
      )
    }
    y(t) {
      function e(s, r) {
        return ps(s.key)
          ? s.key
          : r.s(s.key)
            ? s.key.start
            : r.t(s.key)
              ? s.key.port
              : Number.MAX_VALUE
      }
      return t.sort((s, r) => e(s, this) - e(r, this))
    }
    z() {
      return this.m
    }
    static providedActionToAction(t) {
      switch (t) {
        case Pa.Notify:
          return La.Notify
        case Pa.OpenBrowser:
          return La.OpenBrowser
        case Pa.OpenBrowserOnce:
          return La.OpenBrowserOnce
        case Pa.OpenPreview:
          return La.OpenPreview
        case Pa.Silent:
          return La.Silent
        case Pa.Ignore:
          return La.Ignore
        default:
          return
      }
    }
    async addAttributes(t, e, s) {
      const a = this.q.inspect(kr.c).userRemoteValue
      let o
      !a || !Je(a) ? (o = {}) : (o = pe(a)), o[`${t}`] || (o[`${t}`] = {})
      for (const c in e) o[`${t}`][c] = e[c]
      return this.q.updateValue(kr.c, o, s)
    }
  },
  zj = class extends at {
    constructor(t, e, s, r, a, o, c, l, u, d) {
      super(),
        (this.H = t),
        (this.I = e),
        (this.J = s),
        (this.L = r),
        (this.M = a),
        (this.N = o),
        (this.O = c),
        (this.P = l),
        (this.Q = u),
        (this.R = d),
        (this.c = new Map()),
        (this.g = new J()),
        (this.onForwardPort = this.g.event),
        (this.h = new J()),
        (this.onClosePort = this.h.event),
        (this.j = new J()),
        (this.onPortName = this.j.event),
        (this.n = new J()),
        (this.onCandidatesChanged = this.n.event),
        (this.s = new J()),
        (this.onEnvironmentTunnelsSet = this.s.event),
        (this.t = !1),
        (this.u = void 0),
        (this.y = !1),
        (this.z = new J()),
        (this.C = new Map()),
        (this.F = new Map()),
        (this.G = []),
        (this.U = !1),
        (this.eb = new Date()),
        (this.configPortsAttributes = new blt(s)),
        (this.r = this.bb()),
        this.D(this.configPortsAttributes.onDidChangeAttributes(this.kb, this)),
        (this.forwarded = new Map()),
        (this.f = new Map()),
        this.H.tunnels.then(async (m) => {
          const f = await this.getAttributes(
            m.map((p) => ({
              port: p.tunnelRemotePort,
              host: p.tunnelRemoteHost,
            })),
          )
          for (const p of m)
            if (p.localAddress) {
              const v = hs(p.tunnelRemoteHost, p.tunnelRemotePort),
                b = ts(
                  this.m ?? new Map(),
                  p.tunnelRemoteHost,
                  p.tunnelRemotePort,
                )
              this.forwarded.set(v, {
                remotePort: p.tunnelRemotePort,
                remoteHost: p.tunnelRemoteHost,
                localAddress: p.localAddress,
                protocol: f?.get(p.tunnelRemotePort)?.protocol ?? Fs.Http,
                localUri: await this.Y(
                  p.localAddress,
                  f?.get(p.tunnelRemotePort),
                ),
                localPort: p.tunnelLocalPort,
                name: f?.get(p.tunnelRemotePort)?.label,
                runningProcess: b?.detail,
                hasRunningProcess: !!b,
                pid: b?.pid,
                privacy: p.privacy,
                source: Gj,
              }),
                this.f.set(v, p)
            }
        }),
        (this.detected = new Map()),
        this.D(
          this.H.onTunnelOpened(async (m) => {
            const f = hs(m.tunnelRemoteHost, m.tunnelRemotePort)
            if (
              !ts(this.forwarded, m.tunnelRemoteHost, m.tunnelRemotePort) &&
              !ts(this.detected, m.tunnelRemoteHost, m.tunnelRemotePort) &&
              !ts(this.c, m.tunnelRemoteHost, m.tunnelRemotePort) &&
              m.localAddress
            ) {
              const p = ts(
                  this.m ?? new Map(),
                  m.tunnelRemoteHost,
                  m.tunnelRemotePort,
                ),
                v = (
                  await this.getAttributes([
                    { port: m.tunnelRemotePort, host: m.tunnelRemoteHost },
                  ])
                )?.get(m.tunnelRemotePort)
              this.forwarded.set(f, {
                remoteHost: m.tunnelRemoteHost,
                remotePort: m.tunnelRemotePort,
                localAddress: m.localAddress,
                protocol: v?.protocol ?? Fs.Http,
                localUri: await this.Y(m.localAddress, v),
                localPort: m.tunnelLocalPort,
                name: v?.label,
                closeable: !0,
                runningProcess: p?.detail,
                hasRunningProcess: !!p,
                pid: p?.pid,
                privacy: m.privacy,
                source: Gj,
              })
            }
            await this.db(),
              this.W(!0),
              this.f.set(f, m),
              this.g.fire(this.forwarded.get(f))
          }),
        ),
        this.D(this.H.onTunnelClosed((m) => this.X(m, zf.Other))),
        this.W(!1)
    }
    S() {
      return this.Q.extensions.find((t) => t.activationEvents?.includes(vlt))
        ? (this.R.createKey(LWt.key, !0), !0)
        : !1
    }
    W(t) {
      if (
        this.U ||
        (t && (this.U = !0), this.L.remoteAuthority !== void 0 && !t) ||
        this.S()
      )
        return
      const s = this.D(
        this.Q.onDidRegisterExtensions(() => {
          this.S() && s.dispose()
        }),
      )
    }
    async X(t, e) {
      const s = hs(t.host, t.port)
      this.forwarded.has(s) &&
        (this.forwarded.delete(s), await this.db(), this.h.fire(t))
    }
    Y(t, e) {
      if (t.startsWith("http")) return S.parse(t)
      const s = e?.protocol ?? "http"
      return S.parse(`${s}://${t}`)
    }
    async Z(t) {
      const e = this.N.getWorkspace(),
        s = e.configuration
          ? nn(e.configuration.path)
          : e.folders.length > 0
            ? nn(e.folders[0].uri.path)
            : void 0
      if (s === void 0) {
        this.O.debug(
          "Could not get workspace hash for forwarded ports storage key.",
        )
        return
      }
      return `${t}.${this.L.remoteAuthority}.${s}`
    }
    async $() {
      return this.Z(A3)
    }
    async ab() {
      return this.Z(Vj)
    }
    async bb() {
      const t = this.I.get(A3, 1)
      if (t) return this.I.remove(A3, 1), await this.db(), t
      const e = await this.$()
      if (e) return this.I.get(e, 0)
    }
    async restoreForwarded() {
      if ((this.cb(), this.J.getValue("remote.restoreForwardedPorts"))) {
        const t = await this.r
        if (t && t !== this.w) {
          const e = JSON.parse(t) ?? []
          this.O.trace(
            `ForwardedPorts: (TunnelModel) restoring ports ${e.map((s) => s.remotePort).join(", ")}`,
          )
          for (const s of e) {
            const r = ts(this.detected, s.remoteHost, s.remotePort)
            ;(s.source.source !== Fn.Extension && !r) ||
            (s.source.source === Fn.Extension && r)
              ? await this.gb({
                  remote: { host: s.remoteHost, port: s.remotePort },
                  local: s.localPort,
                  name: s.name,
                  elevateIfNeeded: !0,
                  source: s.source,
                })
              : s.source.source === Fn.Extension &&
                !r &&
                this.C.set(hs(s.remoteHost, s.remotePort), s)
          }
        }
      }
      if (((this.y = !0), this.z.fire(), !this.u)) {
        const t = await this.$()
        ;(this.u = this.D(new gt())),
          this.u.add(
            this.I.onDidChangeValue(
              0,
              void 0,
              this.u,
            )(async (e) => {
              e.key === t &&
                ((this.r = Promise.resolve(this.I.get(t, 0))),
                await this.restoreForwarded())
            }),
          )
      }
    }
    cb() {
      const t = this.I.keys(0, 0).filter((e) => e.startsWith(Vj))
      for (const e of t) {
        const s = this.I.getNumber(e, 0)
        if (s && s < Date.now()) {
          this.r = Promise.resolve(void 0)
          const r = e.replace(Vj, A3)
          this.I.remove(e, 0), this.I.remove(r, 0)
        }
      }
    }
    async db() {
      if (this.J.getValue("remote.restoreForwardedPorts")) {
        const t = Array.from(this.forwarded.values()),
          e = t.map((o) => ({
            remoteHost: o.remoteHost,
            remotePort: o.remotePort,
            localPort: o.localPort,
            name: o.name,
            localAddress: o.localAddress,
            localUri: o.localUri,
            protocol: o.protocol,
            source: o.source,
          }))
        let s
        t.length > 0 && (s = JSON.stringify(e))
        const r = await this.$(),
          a = await this.ab()
        !s && r && a
          ? (this.I.remove(r, 0), this.I.remove(a, 0))
          : s !== this.w &&
            r &&
            a &&
            (this.I.store(r, s, 0, 0), this.I.store(a, Date.now() + JWt, 0, 0)),
          (this.w = s)
      }
    }
    async fb(t, e, s) {
      if (!t.tunnelLocalPort || !s?.requireLocalPort || t.tunnelLocalPort === e)
        return
      const r = new Date()
      if (this.eb.getTime() + CWt > r.getTime()) return
      this.eb = r
      const a = g(13186, null, e, t.tunnelRemotePort, t.tunnelLocalPort)
      return this.P.info(a)
    }
    async forward(t, e) {
      return (
        !this.y && this.L.remoteAuthority && (await Qt.toPromise(this.z.event)),
        this.gb(t, e)
      )
    }
    async gb(t, e) {
      await this.Q.activateByEvent(vlt)
      const s = ts(this.forwarded, t.remote.host, t.remote.port)
      e =
        e ??
        (e !== null
          ? (await this.getAttributes([t.remote]))?.get(t.remote.port)
          : void 0)
      const r = t.local !== void 0 ? t.local : t.remote.port
      let a
      if (s) return this.ib(s, t, e)
      {
        const o = this.L.remoteAuthority,
          c = o
            ? {
                getAddress: async () =>
                  (await this.M.resolveAuthority(o)).authority,
              }
            : void 0,
          l = hs(t.remote.host, t.remote.port)
        this.c.set(l, !0), (t = this.hb(l, t))
        const u = await this.H.openTunnel(
          c,
          t.remote.host,
          t.remote.port,
          void 0,
          r,
          t.elevateIfNeeded ? t.elevateIfNeeded : e?.elevateIfNeeded,
          t.privacy,
          e?.protocol,
        )
        if (typeof u == "string") a = u
        else if (u && u.localAddress) {
          const d = ts(this.m ?? new Map(), t.remote.host, t.remote.port),
            m = u.protocol
              ? u.protocol === Fs.Https
                ? Fs.Https
                : Fs.Http
              : (e?.protocol ?? Fs.Http),
            f = {
              remoteHost: u.tunnelRemoteHost,
              remotePort: u.tunnelRemotePort,
              localPort: u.tunnelLocalPort,
              name: e?.label ?? t.name,
              closeable: !0,
              localAddress: u.localAddress,
              protocol: m,
              localUri: await this.Y(u.localAddress, e),
              runningProcess: d?.detail,
              hasRunningProcess: !!d,
              pid: d?.pid,
              source: t.source ?? Gj,
              privacy: u.privacy,
            }
          return (
            this.forwarded.set(l, f),
            this.f.set(l, u),
            this.c.delete(l),
            await this.db(),
            await this.fb(u, r, e),
            this.g.fire(f),
            u
          )
        }
        this.c.delete(l)
      }
      return a
    }
    hb(t, e) {
      const s = this.C.has(t) ? this.C : this.F.has(t) ? this.F : void 0
      if (s) {
        const r = s.get(t)
        s.delete(t),
          r &&
            ((e.name = r.name ?? e.name),
            (e.local =
              ("local" in r
                ? r.local
                : "localPort" in r
                  ? r.localPort
                  : void 0) ?? e.local),
            (e.privacy = e.privacy))
      }
      return e
    }
    async ib(t, e, s) {
      const r = s?.label ?? e.name
      let a
      ;(function (c) {
        ;(c[(c.None = 0)] = "None"),
          (c[(c.Fire = 1)] = "Fire"),
          (c[(c.Reopen = 2)] = "Reopen")
      })(a || (a = {}))
      let o = a.None
      switch (
        (r !== t.name && ((t.name = r), (o = a.Fire)),
        (s?.protocol || t.protocol !== Fs.Http) &&
          s?.protocol !== t.protocol &&
          ((e.source = t.source), (o = a.Reopen)),
        e.privacy && t.privacy !== e.privacy && (o = a.Reopen),
        o)
      ) {
        case a.Fire: {
          this.g.fire()
          break
        }
        case a.Reopen:
          await this.close(t.remoteHost, t.remotePort, zf.User),
            await this.gb(e, s)
      }
      return ts(this.f, e.remote.host, e.remote.port)
    }
    async name(t, e, s) {
      const r = ts(this.forwarded, t, e),
        a = hs(t, e)
      if (r) {
        ;(r.name = s), await this.db(), this.j.fire({ host: t, port: e })
        return
      } else
        this.detected.has(a) &&
          ((this.detected.get(a).name = s), this.j.fire({ host: t, port: e }))
    }
    async close(t, e, s) {
      const r = hs(t, e),
        a = this.forwarded.get(r)
      return (
        s === zf.AutoForwardEnd &&
          a &&
          a.source.source === Fn.Auto &&
          this.F.set(r, {
            local: a.localPort,
            name: a.name,
            privacy: a.privacy,
          }),
        await this.H.closeTunnel(t, e),
        this.X({ host: t, port: e }, s)
      )
    }
    address(t, e) {
      const s = hs(t, e)
      return (this.forwarded.get(s) || this.detected.get(s))?.localAddress
    }
    get environmentTunnelsSet() {
      return this.t
    }
    addEnvironmentTunnels(t) {
      if (t)
        for (const e of t) {
          const s = ts(
              this.m ?? new Map(),
              e.remoteAddress.host,
              e.remoteAddress.port,
            ),
            r =
              typeof e.localAddress == "string"
                ? e.localAddress
                : hs(e.localAddress.host, e.localAddress.port)
          this.detected.set(hs(e.remoteAddress.host, e.remoteAddress.port), {
            remoteHost: e.remoteAddress.host,
            remotePort: e.remoteAddress.port,
            localAddress: r,
            protocol: Fs.Http,
            localUri: this.Y(r),
            closeable: !1,
            runningProcess: s?.detail,
            hasRunningProcess: !!s,
            pid: s?.pid,
            privacy: Ur.ConstantPrivate,
            source: { source: Fn.Extension, description: g(13187, null) },
          }),
            this.H.setEnvironmentTunnel(
              e.remoteAddress.host,
              e.remoteAddress.port,
              r,
              Ur.ConstantPrivate,
              Fs.Http,
            )
        }
      ;(this.t = !0), this.s.fire(), this.g.fire()
    }
    setCandidateFilter(t) {
      this.q = t
    }
    async setCandidates(t) {
      let e = t
      this.q && (e = await this.q(t))
      const s = this.jb(e)
      this.O.trace(
        `ForwardedPorts: (TunnelModel) removed candidates ${Array.from(
          s.values(),
        )
          .map((r) => r.port)
          .join(", ")}`,
      ),
        this.n.fire(s)
    }
    jb(t) {
      const e = this.m ?? new Map(),
        s = new Map()
      return (
        (this.m = s),
        t.forEach((r) => {
          const a = hs(r.host, r.port)
          s.set(a, {
            host: r.host,
            port: r.port,
            detail: r.detail,
            pid: r.pid,
          }),
            e.has(a) && e.delete(a)
          const o = ts(this.forwarded, r.host, r.port)
          o &&
            ((o.runningProcess = r.detail),
            (o.hasRunningProcess = !0),
            (o.pid = r.pid))
        }),
        e.forEach((r, a) => {
          const o = wlt(a)
          if (!o) return
          const c = ts(this.forwarded, o.host, o.port)
          c &&
            ((c.runningProcess = void 0),
            (c.hasRunningProcess = !1),
            (c.pid = void 0))
          const l = ts(this.detected, o.host, o.port)
          l &&
            ((l.runningProcess = void 0),
            (l.hasRunningProcess = !1),
            (l.pid = void 0))
        }),
        e
      )
    }
    get candidates() {
      return this.m ? Array.from(this.m.values()) : []
    }
    get candidatesOrUndefined() {
      return this.m ? this.candidates : void 0
    }
    async kb() {
      const t = Array.from(this.forwarded.values()),
        e = await this.getAttributes(
          t.map((s) => ({ port: s.remotePort, host: s.remoteHost })),
          !1,
        )
      if (e)
        for (const s of t) {
          const r = e.get(s.remotePort)
          ;(r?.protocol || s.protocol !== Fs.Http) &&
            r?.protocol !== s.protocol &&
            (await this.gb(
              {
                remote: { host: s.remoteHost, port: s.remotePort },
                local: s.localPort,
                name: s.name,
                source: s.source,
              },
              r,
            )),
            r &&
              r.label &&
              r.label !== s.name &&
              (await this.name(s.remoteHost, s.remotePort, r.label))
        }
    }
    async getAttributes(t, e = !0) {
      const s = new Map(),
        r = new Map()
      t.forEach((u) => {
        const d = ts(this.m ?? new Map(), sm[0], u.port) ?? u
        if (d) {
          s.set(u.port, d)
          const m = RWt(d) ? d.pid : void 0
          r.has(m) || r.set(m, []), r.get(m)?.push(u.port)
        }
      })
      const a = new Map()
      if (
        (t.forEach((u) => {
          const d = this.configPortsAttributes.getAttributes(
            u.port,
            u.host,
            s.get(u.port)?.detail,
          )
          d && a.set(u.port, d)
        }),
        this.G.length === 0 || !e)
      )
        return a.size > 0 ? a : void 0
      const o = await Promise.all(
          this.G.flatMap((u) =>
            Array.from(r.entries()).map((d) => {
              const m = d[1],
                f = s.get(m[0])
              return u.providePortAttributes(m, f?.pid, f?.detail, ce.None)
            }),
          ),
        ),
        c = new Map()
      if (
        (o.forEach((u) =>
          u.forEach((d) => {
            d && c.set(d.port, d)
          }),
        ),
        !a && !c)
      )
        return
      const l = new Map()
      return (
        t.forEach((u) => {
          const d = a.get(u.port),
            m = c.get(u.port)
          l.set(u.port, {
            elevateIfNeeded: d?.elevateIfNeeded,
            label: d?.label,
            onAutoForward:
              d?.onAutoForward ??
              blt.providedActionToAction(m?.autoForwardAction),
            requireLocalPort: d?.requireLocalPort,
            protocol: d?.protocol,
          })
        }),
        l
      )
    }
    addAttributesProvider(t) {
      this.G.push(t)
    }
  }
__decorate([z_(1e3)], zj.prototype, "db", null),
  (zj = __decorate(
    [
      __param(0, fPt),
      __param(1, XK),
      __param(2, dn),
      __param(3, lst),
      __param(4, sTt),
      __param(5, s6),
      __param(6, Rt),
      __param(7, NWt),
      __param(8, uPt),
      __param(9, qQ),
    ],
    zj,
  ))
function DWt(i) {
  const t = i.trim().split(`
`),
    e = []
  return (
    t.forEach((r) => {
      const a = /\/proc\/(\d+)\/fd\/\d+ -> socket:\[(\d+)\]/.exec(r)
      a &&
        a.length >= 3 &&
        e.push({ pid: parseInt(a[1], 10), socket: parseInt(a[2], 10) })
    }),
    e.reduce((r, a) => ((r[a.socket] = a), r), {})
  )
}
function FWt(...i) {
  const t = [].concat(...i.map(_Wt))
  return [
    ...new Map(
      t
        .filter((e) => e.st === "0A")
        .map((e) => {
          const s = e.local_address.split(":")
          return {
            socket: parseInt(e.inode, 10),
            ip: AWt(s[0]),
            port: parseInt(s[1], 16),
          }
        })
        .map((e) => [e.ip + ":" + e.port, e]),
    ).values(),
  ]
}
function AWt(i) {
  let t = ""
  if (i.length === 8)
    for (let e = i.length - 2; e >= 0; e -= 2)
      (t += parseInt(i.substr(e, 2), 16)), e !== 0 && (t += ".")
  else
    for (let e = 0; e < i.length; e += 8) {
      const s = i.substring(e, e + 8)
      let r = ""
      for (let a = 8; a >= 2; a -= 2)
        (r += s.substring(a - 2, a)),
          (a === 6 || a === 2) &&
            ((r = parseInt(r, 16).toString(16)),
            (t += `${r}`),
            (r = ""),
            e + a !== i.length - 6 && (t += ":"))
    }
  return t
}
function _Wt(i) {
  const t = i.trim().split(`
`),
    e = t
      .shift()
      .trim()
      .split(/\s+/)
      .filter((r) => r !== "rx_queue" && r !== "tm->when")
  return t.map((r) =>
    r
      .trim()
      .split(/\s+/)
      .reduce((a, o, c) => ((a[e[c] || c] = o), a), {}),
  )
}
function OWt(i) {
  return i.length > 500
    ? !1
    : !!i.match(/.*\.vscode-server-[a-zA-Z]+\/bin.*/) ||
        i.indexOf("out/server-main.js") !== -1 ||
        i.indexOf("_productName=VSCode") !== -1
}
function BWt(i) {
  const t = i.trim().split(`
`),
    e = []
  return (
    t.forEach((s) => {
      const r = /^\d+\s+\D+\s+root\s+(\d+)\s+(\d+).+\d+\:\d+\:\d+\s+(.+)$/.exec(
        s,
      )
      r &&
        r.length >= 4 &&
        e.push({ pid: parseInt(r[1], 10), ppid: parseInt(r[2]), cmd: r[3] })
    }),
    e
  )
}
async function qWt(i, t, e) {
  const s = e.reduce((a, o) => ((a[o.pid] = o), a), {}),
    r = []
  return (
    i.forEach(({ socket: a, ip: o, port: c }) => {
      const l = t[a] ? t[a].pid : void 0,
        u = l ? s[l]?.cmd : void 0
      l && u && !OWt(u) && r.push({ host: o, port: c, detail: u, pid: l })
    }),
    r
  )
}
function UWt(i, t, e) {
  const s = new Map(),
    r = BWt(t)
  for (const a of i) {
    const o = e.get(a.port)
    if (o) {
      s.set(a.port, o)
      continue
    }
    const c = r.find((l) => l.cmd.includes(`${a.port}`))
    if (c) {
      let l = c,
        u
      do (u = r.find((d) => d.ppid === l.pid)), u && (l = u)
      while (u)
      s.set(a.port, {
        host: a.ip,
        port: a.port,
        pid: l.pid,
        detail: l.cmd,
        ppid: l.ppid,
      })
    } else s.set(a.port, { host: a.ip, port: a.port, ppid: Number.MAX_VALUE })
  }
  return s
}
var Yj = class extends hB {
  constructor(t, e, s, r) {
    super(t, e, s),
      (this.C = e),
      (this.F = r),
      (this.w = void 0),
      (this.y = new Map()),
      (this.z = !1),
      De &&
        e.remote.isRemote &&
        e.remote.authority &&
        (this.a.$setRemoteTunnelService(process.pid), this.H())
  }
  async $registerCandidateFinder(t) {
    if (t && this.z) return
    this.z = t
    let e
    this.w && ((e = this.w), await this.a.$onFoundNewCandidates(this.w))
    const s = new zwt()
    let r = 0
    for (; this.z; ) {
      const a = new Date().getTime(),
        o = (await this.I()).filter((u) => Ro(u.host) || In(u.host))
      this.r.trace(
        `ForwardedPorts: (ExtHostTunnelService) found candidate ports ${o.map((u) => u.port).join(", ")}`,
      )
      const c = new Date().getTime() - a
      this.r.trace(
        `ForwardedPorts: (ExtHostTunnelService) candidate port scan took ${c} ms.`,
      ),
        r++ > 3 && s.update(c),
        (!e || JSON.stringify(e) !== JSON.stringify(o)) &&
          ((e = o), await this.a.$onFoundNewCandidates(e))
      const l = this.G(s.value)
      this.r.trace(
        `ForwardedPorts: (ExtHostTunnelService) next candidate port scan in ${l} ms.`,
      ),
        await new Promise((u) => setTimeout(() => u(), l))
    }
  }
  G(t) {
    return Math.max(t * 20, 2e3)
  }
  async H() {
    ;(this.w = await this.I()),
      this.r.trace(
        `ForwardedPorts: (ExtHostTunnelService) Initial candidates found: ${this.w.map((t) => t.port).join(", ")}`,
      )
  }
  async I() {
    let t = "",
      e = ""
    try {
      ;(t = await Vf.promises.readFile("/proc/net/tcp", "utf8")),
        (e = await Vf.promises.readFile("/proc/net/tcp6", "utf8"))
    } catch {}
    const s = FWt(t, e),
      r = await new Promise((f) => {
        slt("ls -l /proc/[0-9]*/fd/[0-9]* | grep socket:", (p, v, b) => {
          f(v)
        })
      }),
      a = DWt(r),
      o = await re.readdir("/proc"),
      c = []
    for (const f of o)
      try {
        const p = Number(f),
          v = He(S.file("/proc"), f)
        if ((await Vf.promises.stat(v.fsPath)).isDirectory() && !isNaN(p)) {
          const k = await Vf.promises.readlink(He(v, "cwd").fsPath),
            E = await Vf.promises.readFile(He(v, "cmdline").fsPath, "utf8")
          c.push({ pid: p, cwd: k, cmd: E })
        }
      } catch {}
    const l = [],
      u = s.filter((f) => {
        const p = a[f.socket]
        return p || l.push(f), p
      }),
      d = qWt(u, a, c)
    let m
    if (
      (this.r.trace(
        `ForwardedPorts: (ExtHostTunnelService) number of possible root ports ${l.length}`,
      ),
      l.length > 0)
    ) {
      const f = await new Promise((p) => {
        slt("ps -F -A -l | grep root", (v, b, k) => {
          p(b)
        })
      })
      ;(this.y = UWt(l, f, this.y)),
        (m = Array.from(this.y.values())),
        this.r.trace(
          `ForwardedPorts: (ExtHostTunnelService) heuristic ports ${m.map((p) => p.port).join(", ")}`,
        )
    }
    return d.then((f) => (m ? f.concat(m) : f))
  }
  u(t) {
    return async (e) => {
      const s = new mlt(
        {
          commit: this.C.commit,
          quality: this.C.quality,
          logService: this.r,
          ipcLogger: null,
          remoteSocketFactoryService: {
            _serviceBrand: void 0,
            async connect(a, o, c, l) {
              const u = await t.makeConnection()
              return MWt.connect(u, o, c, l)
            },
            register() {
              throw new Error("not implemented")
            },
          },
          addressProvider: {
            getAddress() {
              return Promise.resolve({
                connectTo: new ZZ(0),
                connectionToken: t.connectionToken,
              })
            },
          },
          signService: this.F,
        },
        "localhost",
        e.remoteAddress.host || "localhost",
        e.remoteAddress.port,
        e.localAddressPort,
      )
      await s.waitForReady()
      const r = new J()
      return {
        localAddress: wlt(s.localAddress) ?? s.localAddress,
        remoteAddress: { port: s.tunnelRemotePort, host: s.tunnelRemoteHost },
        onDidDispose: r.event,
        dispose: () => {
          s.dispose(), r.fire(), r.dispose()
        },
      }
    }
  }
}
Yj = __decorate(
  [__param(0, Ot), __param(1, ti), __param(2, Rt), __param(3, Gf)],
  Yj,
)
var MWt = class Mut extends aWt {
  static connect(t, e, s, r) {
    const a = new gt(),
      o = {
        onClose: a.add(new J()),
        onData: a.add(new J()),
        onEnd: a.add(new J()),
      }
    a.add(t.onDidReceiveMessage((l) => o.onData.fire(Q.wrap(l)))),
      a.add(t.onDidEnd(() => o.onEnd.fire())),
      a.add(
        t.onDidClose((l) =>
          o.onClose.fire({ type: 0, error: l, hadError: !!l }),
        ),
      )
    const c = new Mut(t, r, o)
    return c.D(a), nWt(c, e, s, r, o)
  }
  constructor(t, e, s) {
    super(e, s), (this.n = t)
  }
  write(t) {
    this.n.send(t.buffer)
  }
  h() {
    this.n.end()
  }
  async drain() {
    await this.n.drain?.()
  }
}
import * as Go from "fs"
var HWt = class extends sH {
  constructor() {
    super(...arguments), (this.i = null)
  }
  async g(i) {
    const t = await super.g(i)
    if (t.scheme !== G.file) return t
    if (this.b.skipWorkspaceStorageLock)
      return this.d.info(`Skipping acquiring lock for ${t.fsPath}.`), t
    const e = t.fsPath
    let s = 0
    do {
      let r
      s === 0
        ? (r = e)
        : (r = /[/\\]$/.test(e)
            ? `${e.substr(0, e.length - 1)}-${s}`
            : `${e}-${s}`),
        await WWt(r)
      const a = se(r, "vscode.lock"),
        o = await klt(this.d, a, !1)
      if (o)
        return (
          (this.i = o),
          process.on("exit", () => {
            o.dispose()
          }),
          S.file(r)
        )
      s++
    } while (s < 10)
    return t
  }
  onWillDeactivateAll() {
    this.i?.setWillRelease(6e3)
  }
}
async function WWt(i) {
  try {
    await Go.promises.stat(i)
    return
  } catch {}
  try {
    await Go.promises.mkdir(i, { recursive: !0 })
  } catch {}
}
var jWt = 1e3,
  Tlt = 10 * 60 * 1e3,
  VWt = class extends at {
    constructor(i, t) {
      super(),
        (this.b = i),
        (this.c = t),
        (this.a = this.D(new ZG())),
        this.a.cancelAndSet(async () => {
          const e = await Qj(i, t)
          ;(!e || e.pid !== process.pid) &&
            (i.info(`Lock '${t}': The lock was lost unexpectedly.`),
            this.a.cancel())
          try {
            await Go.promises.utimes(t, new Date(), new Date())
          } catch (s) {
            i.error(s), i.info(`Lock '${t}': Could not update mtime.`)
          }
        }, jWt)
    }
    dispose() {
      super.dispose()
      try {
        Go.unlinkSync(this.c)
      } catch {}
    }
    async setWillRelease(i) {
      this.b.info(
        `Lock '${this.c}': Marking the lockfile as scheduled to be released in ${i} ms.`,
      )
      try {
        const t = { pid: process.pid, willReleaseAt: Date.now() + i }
        await re.writeFile(this.c, JSON.stringify(t), { flag: "w" })
      } catch (t) {
        this.b.error(t)
      }
    }
  }
async function klt(i, t, e) {
  try {
    const r = { pid: process.pid, willReleaseAt: 0 }
    await re.writeFile(t, JSON.stringify(r), { flag: "wx" })
  } catch (r) {
    i.error(r)
  }
  const s = await Qj(i, t)
  return !s || s.pid !== process.pid
    ? e
      ? (i.info(`Lock '${t}': Could not acquire lock, giving up.`), null)
      : (i.info(
          `Lock '${t}': Could not acquire lock, checking if the file is stale.`,
        ),
        zWt(i, t))
    : (i.info(`Lock '${t}': Lock acquired.`), new VWt(i, t))
}
async function Qj(i, t) {
  let e
  try {
    e = await Go.promises.readFile(t)
  } catch (s) {
    return i.error(s), null
  }
  try {
    return JSON.parse(String(e))
  } catch (s) {
    return i.error(s), null
  }
}
async function Xj(i, t) {
  let e
  try {
    e = await Go.promises.stat(t)
  } catch (s) {
    return i.error(s), 0
  }
  return e.mtime.getTime()
}
function GWt(i) {
  try {
    return process.kill(i, 0), !0
  } catch {
    return !1
  }
}
async function zWt(i, t) {
  const e = await Qj(i, t)
  if (!e)
    return i.info(`Lock '${t}': Could not read pid of lock holder.`), Yf(i, t)
  if (e.willReleaseAt) {
    let c = e.willReleaseAt - Date.now()
    if (c < 5e3) {
      for (
        c > 0
          ? i.info(
              `Lock '${t}': The lockfile is scheduled to be released in ${c} ms.`,
            )
          : i.info(
              `Lock '${t}': The lockfile is scheduled to have been released.`,
            );
        c > 0;

      ) {
        if ((await Fi(Math.min(100, c)), (await Xj(i, t)) === 0))
          return Yf(i, t)
        c = e.willReleaseAt - Date.now()
      }
      return Yf(i, t)
    }
  }
  if (!GWt(e.pid))
    return i.info(`Lock '${t}': The pid ${e.pid} appears to be gone.`), Yf(i, t)
  const s = await Xj(i, t),
    r = Date.now() - s
  if (r <= Tlt)
    return (
      i.info(
        `Lock '${t}': The lock does not look stale, elapsed: ${r} ms, giving up.`,
      ),
      null
    )
  i.info(`Lock '${t}': The lock looks stale, waiting for 2s.`), await Fi(2e3)
  const a = await Xj(i, t),
    o = Date.now() - a
  return o <= Tlt
    ? (i.info(
        `Lock '${t}': The lock does not look stale, elapsed: ${o} ms, giving up.`,
      ),
      null)
    : (i.info(`Lock '${t}': The lock looks stale even after waiting for 2s.`),
      Yf(i, t))
}
async function Yf(i, t) {
  i.info(`Lock '${t}': Deleting a stale lock.`)
  try {
    await Go.promises.unlink(t)
  } catch {}
  return klt(i, t, !0)
}
var An
;(function (i) {
  ;(i[(i.Trace = 0)] = "Trace"),
    (i[(i.Debug = 1)] = "Debug"),
    (i[(i.Info = 2)] = "Info"),
    (i[(i.Warning = 3)] = "Warning"),
    (i[(i.Error = 4)] = "Error"),
    (i[(i.Critical = 5)] = "Critical"),
    (i[(i.Off = 6)] = "Off")
})(An || (An = {}))
async function YWt(i, t, e, s, r) {
  try {
    const a = await import("@vscode/spdlog")
    a.setFlushOn(An.Trace)
    const o = await a.createAsyncRotatingLogger(i, t, e, s)
    return (
      r ? o.clearFormatters() : o.setPattern("%Y-%m-%d %H:%M:%S.%e [%l] %v"), o
    )
  } catch (a) {
    console.error(a)
  }
  return null
}
function Slt(i, t, e) {
  switch (t) {
    case vt.Trace:
      i.trace(e)
      break
    case vt.Debug:
      i.debug(e)
      break
    case vt.Info:
      i.info(e)
      break
    case vt.Warning:
      i.warn(e)
      break
    case vt.Error:
      i.error(e)
      break
    case vt.Off:
      break
    default:
      throw new Error(`Invalid log level ${t}`)
  }
}
function Elt(i, t) {
  switch (t) {
    case vt.Trace:
      i.setLevel(An.Trace)
      break
    case vt.Debug:
      i.setLevel(An.Debug)
      break
    case vt.Info:
      i.setLevel(An.Info)
      break
    case vt.Warning:
      i.setLevel(An.Warning)
      break
    case vt.Error:
      i.setLevel(An.Error)
      break
    case vt.Off:
      i.setLevel(An.Off)
      break
    default:
      throw new Error(`Invalid log level ${t}`)
  }
}
var QWt = class extends Fq {
    constructor(i, t, e, s, r) {
      super(),
        (this.n = []),
        this.setLevel(r),
        (this.q = this.s(i, t, e, s)),
        this.D(
          this.onDidChangeLogLevel((a) => {
            this.r && Elt(this.r, a)
          }),
        )
    }
    async s(i, t, e, s) {
      const r = e ? 6 : 1,
        a = (30 / r) * dK.MB,
        o = await YWt(i, t, a, r, s)
      if (o) {
        ;(this.r = o), Elt(this.r, this.getLevel())
        for (const { level: c, message: l } of this.n) Slt(this.r, c, l)
        this.n = []
      }
    }
    m(i, t) {
      this.r
        ? Slt(this.r, i, t)
        : this.getLevel() <= i && this.n.push({ level: i, message: t })
    }
    flush() {
      this.r ? this.u() : this.q.then(() => this.u())
    }
    dispose() {
      this.r ? this.w() : this.q.then(() => this.w()), super.dispose()
    }
    u() {
      this.r && this.r.flush()
    }
    w() {
      this.r && (this.r.drop(), (this.r = void 0))
    }
  },
  XWt = class extends CB {
    q(i, t, e) {
      return i.scheme === G.file
        ? new QWt(
            e?.name || Ze(),
            i.fsPath,
            !e?.donotRotate,
            !!e?.donotUseFormatters,
            t,
          )
        : super.q(i, t, e)
    }
    registerLogger(i) {
      super.registerLogger(i), this.r.$registerLogger(i)
    }
    deregisterLogger(i) {
      super.deregisterLogger(i), this.r.$deregisterLogger(i)
    }
  }
import { homedir as KWt } from "os"
var ZWt = class extends PB {
    m() {
      return KWt()
    }
  },
  tjt = class extends at {
    constructor(i, t = []) {
      super(),
        (this.a = new Dwt([i, ...t])),
        this.D(i.onDidChangeLogLevel((e) => this.setLevel(e)))
    }
    get onDidChangeLogLevel() {
      return this.a.onDidChangeLogLevel
    }
    setLevel(i) {
      this.a.setLevel(i)
    }
    getLevel() {
      return this.a.getLevel()
    }
    trace(i, ...t) {
      this.a.trace(i, ...t)
    }
    debug(i, ...t) {
      this.a.debug(i, ...t)
    }
    info(i, ...t) {
      this.a.info(i, ...t)
    }
    warn(i, ...t) {
      this.a.warn(i, ...t)
    }
    error(i, ...t) {
      this.a.error(i, ...t)
    }
    flush() {
      this.a.flush()
    }
  },
  Kj = class extends tjt {
    constructor(t, e, s) {
      const r = s.remote.isRemote
          ? "remoteexthost"
          : t
            ? "workerexthost"
            : "exthost",
        a = s.remote.isRemote ? g(2763, null) : g(t ? 2764 : 2765, null)
      super(e.createLogger(r, { name: a }))
    }
  }
;(Kj = __decorate([__param(1, $c), __param(2, ti)], Kj)),
  Ut($n, sWt, 0),
  Ut($c, XWt, 1),
  Ut(Rt, new on(Kj, [!1], !0)),
  Ut(Gf, crt, 1),
  Ut(iH, HWt, 0),
  Ut(KH, mW, 0),
  Ut(eW, bW, 0),
  Ut(YH, cW, 0),
  Ut(Pn, oW, 0),
  Ut(uB, Yj, 0),
  Ut(ql, ZWt, 0)
import { createRequire as ejt } from "node:module"
var Ilt = ejt(import.meta.url)
;(function () {
  for (let t = 0; t < process.execArgv.length; t++)
    process.execArgv[t] === "--inspect-port=0" &&
      (process.execArgv.splice(t, 1), t--)
})()
var _3 = (0, zgt.default)(process.argv.slice(2), {
  boolean: ["transformURIs", "skipWorkspaceStorageLock"],
  string: ["useHostProxy"],
})
;(function () {
  const i = Ilt("module"),
    t = i._load
  i._load = function (e) {
    if (e === "natives")
      throw new Error(
        'Either the extension or an NPM dependency is using the [unsupported "natives" node module](https://go.microsoft.com/fwlink/?linkid=871887).',
      )
    return t.apply(this, arguments)
  }
})()
var O3 = process.exit.bind(process),
  ijt = process.on.bind(process)
function sjt(i) {
  ;(process.exit = function (t) {
    if (i) O3(t)
    else {
      const e = new Error(
        "An extension called process.exit() and this was prevented.",
      )
      console.warn(e.stack)
    }
  }),
    (process.crash = function () {
      const t = new Error(
        "An extension called process.crash() and this was prevented.",
      )
      console.warn(t.stack)
    }),
    (process.env.ELECTRON_RUN_AS_NODE = "1"),
    (process.on = function (t, e) {
      t === "uncaughtException" &&
        (e = function () {
          try {
            return e.call(void 0, arguments)
          } catch {}
        }),
        ijt(t, e)
    })
}
var Hr = function (i) {
  O3()
}
function rjt() {
  const i = p$t(process.env)
  if (i.type === 3)
    return new Promise((t, e) => {
      const s = (r) => {
        const a = r[0],
          o = new Xa()
        a.on("message", (c) => o.fire(Q.wrap(c.data))),
          a.on("close", () => {
            Hr("renderer closed the MessagePort")
          }),
          a.start(),
          t({ onMessage: o.event, send: (c) => a.postMessage(c.buffer) })
      }
      process.parentPort.on("message", (r) => s(r.ports))
    })
  if (i.type === 2)
    return new Promise((t, e) => {
      let s = null
      const r = setTimeout(() => {
          Hr("VSCODE_EXTHOST_IPC_SOCKET timeout")
        }, 6e4),
        a = 108e5,
        o = 3e5,
        c = new tz(() => Hr("renderer disconnected for too long (1)"), a),
        l = new tz(() => Hr("renderer disconnected for too long (2)"), o)
      process.on("message", (d, m) => {
        if (d && d.type === "VSCODE_EXTHOST_IPC_SOCKET") {
          m.setNoDelay(!0)
          const f = Q.wrap(Buffer.from(d.initialDataChunk, "base64"))
          let p
          if (d.skipWebSocketFrames) p = new Ku(m, "extHost-socket")
          else {
            const v = Q.wrap(Buffer.from(d.inflateBytes, "base64"))
            p = new Yvt(new Ku(m, "extHost-socket"), d.permessageDeflate, v, !1)
          }
          s
            ? (c.cancel(),
              l.cancel(),
              s.beginAcceptReconnection(p, f),
              s.endAcceptReconnection(),
              s.sendResume())
            : (clearTimeout(r),
              (s = new vq({ socket: p, initialChunk: f })),
              s.sendResume(),
              s.onDidDispose(() => Hr("renderer disconnected")),
              t(s),
              s.onSocketClose(() => {
                c.schedule()
              }))
        }
        if (d && d.type === "VSCODE_EXTHOST_IPC_REDUCE_GRACE_TIME") {
          if (l.isScheduled()) return
          c.isScheduled() && l.schedule()
        }
      })
      const u = { type: "VSCODE_EXTHOST_IPC_READY" }
      process.send?.(u)
    })
  {
    const t = i.pipeName
    return new Promise((e, s) => {
      const r = Ygt.createConnection(t, () => {
        r.removeListener("error", s)
        const a = new vq({ socket: new Ku(r, "extHost-renderer") })
        a.sendResume(), e(a)
      })
      r.once("error", s),
        r.on("close", () => {
          Hr("renderer closed the socket")
        })
    })
  }
}
async function njt() {
  const i = await rjt()
  return new (class {
    constructor() {
      ;(this.a = new Xa()),
        (this.onMessage = this.a.event),
        (this.b = !1),
        (this.d = i.onMessage((t) => {
          PPt(t, 2)
            ? ((this.b = !0),
              this.d.dispose(),
              Hr("received terminate message from renderer"))
            : this.a.fire(t)
        }))
    }
    send(t) {
      this.b || i.send(t)
    }
    async drain() {
      if (i.drain) return i.drain()
    }
  })()
}
function ajt(i) {
  return new Promise((t) => {
    const e = i.onMessage((s) => {
      e.dispose()
      const r = JSON.parse(s.toString()),
        a = r.commit,
        o = K_.commit
      if ((a && o && a !== o && O3(55), r.parentPid)) {
        let c = 0
        setInterval(function () {
          try {
            process.kill(r.parentPid, 0), (c = 0)
          } catch (u) {
            u && u.code === "EPERM"
              ? (c++,
                c >= 3 &&
                  Hr(
                    `parent process ${r.parentPid} does not exist anymore (3 x EPERM): ${u.message} (code: ${u.code}) (errno: ${u.errno})`,
                  ))
              : Hr(
                  `parent process ${r.parentPid} does not exist anymore: ${u.message} (code: ${u.code}) (errno: ${u.errno})`,
                )
          }
        }, 1e3)
        let l
        try {
          ;(l = Ilt("native-watchdog")), l.start(r.parentPid)
        } catch (u) {
          $e(u)
        }
      }
      i.send(Cit(0)), t({ protocol: i, initData: r })
    })
    i.send(Cit(1))
  })
}
async function ojt() {
  const i = []
  process.on("unhandledRejection", (c, l) => {
    i.push(l),
      setTimeout(() => {
        const u = i.indexOf(l)
        u >= 0 &&
          l.catch((d) => {
            i.splice(u, 1),
              Ms(d) ||
                (console.warn(
                  `rejected promise not handled within 1 second: ${d}`,
                ),
                d && d.stack && console.warn(`stack trace: ${d.stack}`),
                c && $e(c))
          })
      }, 1e3)
  }),
    process.on("rejectionHandled", (c) => {
      const l = i.indexOf(c)
      l >= 0 && i.splice(l, 1)
    }),
    process.on("uncaughtException", function (c) {
      Eht(c) || $e(c)
    }),
    Ae("code/extHost/willConnectToRenderer")
  const t = await njt()
  Ae("code/extHost/didConnectToRenderer")
  const e = await ajt(t)
  Ae("code/extHost/didWaitForInitData")
  const { initData: s } = e
  sjt(!!s.environment.extensionTestsLocationURI),
    (s.environment.useHostProxy =
      _3.useHostProxy !== void 0 ? _3.useHostProxy !== "false" : void 0),
    (s.environment.skipWorkspaceStorageLock = st(
      _3.skipWorkspaceStorageLock,
      !1,
    ))
  const r = new (class {
    constructor() {
      this.pid = process.pid
    }
    exit(l) {
      O3(l)
    }
    fsExists(l) {
      return re.exists(l)
    }
    fsRealpath(l) {
      return Lvt(l)
    }
  })()
  let a = null
  s.remote.authority && _3.transformURIs && (a = m$t(s.remote.authority))
  const o = new h$t(e.protocol, s, r, a)
  Hr = (c) => o.terminate(c)
}
ojt().catch((i) => console.log(i))

//# sourceMappingURL=https://cursor-sourcemaps.s3.amazonaws.com/sourcemaps/f5f18731406b73244e0558ee7716d77c8096d150/core/vs/workbench/api/node/extensionHostProcess.js.map

//# debugId=1d7f60fd-c040-547c-970e-c3471ba696a3
