{"line":18,"column":2}

-------------------------------[        currentFileContentsWithToFill        ]--------------------------------
interface User {
    id: number;
    name: string;
    age: number;
}
interface Admin { level: number; permission: string[] }

interface Post {title: string; content: string}

interface Comment {
    id: number;
    author: string;
}

type UserRole = User | Admin;
type Content = Post | Comment;
type Result<T> = T | Error;
type ID = string | number;
ty[ToFill]

class Response {
  data: any;
  status: number;

  constructor(data: any, status: number) {
    this.data = data;
    this.status = status;
  }
}

class DataProcessor {
  private items: string[] = [];

  addItem(item: string | null) {
    this.items.push(item);
  }

  getFirstItem(): string | undefined {
    return this.items[0];
  }

  getItems(): string[] {
    return this.items;
  }
}

function merge(a: string, b: string): string {
  return a + b;
}

function wrap(input: string): string[] {
  return [input]
}

class Cache {
  private store = new Map<string, string>();

  get(key: string): string | undefined {
    return this.store.get(key);
  }

  set(key: string, value: string) {
    this.store.set(key, value);
  }
}

function demo() {
  const userRes = new Response(new Error('Error'), 200);

  const processor = new DataProcessor();
  processor.addItem('Hello');

  const merged = merge<string>('Hello', 'World');
  const numbers = merge<number>(1, 2);

  const cache = new Cache();
  cache.set('user1', '123');
  cache.set('post1', '456');

  const wrapped = wrap('pending');
}



-------------------------------[               firstChunkValue               ]--------------------------------
type Result<T> = T | Error;
type ID = string | number;
type Maybe<T> = T | undefined;

-------------------------------[                   fullText                  ]--------------------------------
type Result<T> = T | Error;
type ID = string | number;
type Maybe<T> = T | undefined;
type Nullable<T> = T | null;
type Optional<T> = T | undefined;
type Readonly<T> = { readonly [P in keyof T]: T[P] };
type Mutable<T> = { -readonly [P in keyof T]: T[P] };
type DeepReadonly<T> = { readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P] };

